import { createStore, mapGetters, mapActions, useStore } from "vuex";
import { defineComponent, withDirectives, openBlock, createElementBlock, createElementVNode, normalizeStyle, Fragment, renderList, normalizeClass, withModifiers, toDisplayString, vShow, nextTick, resolveDirective, createCommentVNode, renderSlot, watch, ref as ref$1, onMounted, resolveComponent, createVNode, mergeProps, createBlock, resolveDynamicComponent, withCtx, pushScopeId, popScopeId, createTextVNode, watchEffect, onBeforeUnmount, onUnmounted, computed as computed$1, reactive as reactive$1, vModelRadio, vModelText, toRefs, getCurrentInstance, TransitionGroup, h as h$1, unref, withKeys, toRaw } from "vue";
import { ElNotification, ElUpload, ElRadioGroup, ElRadio, ElProgress, ElDropdown, ElDropdownItem, ElDropdownMenu, ElMessageBox, ElTabPane, ElTabs, ElSelect, ElOption, ElInputNumber, ElCheckbox, ElDialog, ElRadioButton } from "element-plus";
var mutations$1 = {
  loading(state, data) {
  },
  changeRoute(state, from) {
    state.routeFrom = from;
  },
  changeOnline(state, status) {
    state.online = status;
  },
  changeUser(state, name2) {
    state.user.name = name2;
    state.user = { ...state.user };
    localStorage.setItem("username", name2);
  },
  managerEdit(state, status) {
    state.tempEditing = status;
  },
  setImg(state, imgs) {
    state.imgs = imgs;
  },
  setImgIndex(state, index2) {
    state.imgIndex = index2;
  },
  setEditImgVisible(state, status) {
    state.editImgVisible = status;
  },
  setImageCutoutVisible(state, status) {
    state.imageCutoutVisible = status;
  },
  setImageCutoutResult(state, result) {
    state.imageCutoutResult = result;
  },
  setImageCutoutRaw(state, raw) {
    state.imageCutoutRaw = raw;
  },
  setState(state, { key, value }) {
    state[key] = value;
  }
};
var actions$1 = {
  hideLoading(props2, data) {
    setTimeout(() => {
      props2.commit("loading", false);
    }, 600);
  },
  setFonts(store, list) {
    store.state.fonts = list;
  }
};
const all$1 = {
  state: {
    loading: null,
    online: true,
    user: {
      name: localStorage.getItem("username")
    },
    scroll: true,
    manager: "",
    tempEditing: true,
    fonts: [],
    app: null,
    imgs: [],
    imgIndex: 0,
    editImgVisible: false,
    imageCutoutVisible: false,
    imageCutoutRaw: null,
    imageCutoutResult: null,
    templateVisible: false,
    templateMode: 1,
    templateId: null,
    templateDate: Date.now()
  },
  getters: {
    online: (state) => {
      console.log(state);
      return state.online;
    },
    user: (state) => {
      return state.user;
    },
    manager: (state) => {
      return state.manager;
    },
    tempEditing: (state) => {
      return state.tempEditing;
    },
    fonts: (state) => {
      return state.fonts;
    }
  },
  mutations: {
    ...mutations$1
  },
  actions: {
    ...actions$1
  }
};
var mutations = {
  updatePaddingTop(state, num) {
    state.dPaddingTop = num;
  },
  selectItem(state, { data, type }) {
    state.selectItem.data = data;
    state.selectItem.type = type;
  },
  resize(state, data) {
    const { width, height } = data;
    const target = state.dActiveElement;
    target.width = width;
    target.height = height;
  },
  setWidgetStyle(state, { uuid, key, value, pushHistory: pushHistory2 }) {
    const widget = state.dWidgets.find((item) => item.uuid === uuid);
    widget[key] = value;
  },
  setMouseEvent(state, e2) {
    state.activeMouseEvent = e2;
  },
  setDWidgets(state, e2) {
    state.dWidgets = e2;
  },
  setDPage(state, e2) {
    state.dPage = e2;
  },
  setShowMoveable(state, show) {
    state.showMoveable = show;
  },
  setShowRotatable(state, e2) {
    state.showRotatable = e2;
  },
  zoomScreenChange(state, e2) {
    state.zoomScreenChange = Math.random();
  },
  updateRect(state, e2) {
    state.updateRect = Math.random();
  },
  updateSelect(state, e2) {
    state.updateSelect = Math.random();
  },
  updateGuidelines(state, lines) {
    state.guidelines = { ...state.guidelines, ...lines };
  },
  setCropUuid(state, uuid) {
    state.dCropUuid = uuid;
  },
  setDraging(state, drag) {
    state.dDraging = drag;
  }
};
let customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = "";
    let i = size;
    while (i--) {
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
};
function pushHistory(store, msg) {
  console.log("history\u538B\u6808", "\u6765\u6E90: " + msg);
  const history = store.state.dHistory;
  const pageHistory = store.state.dPageHistory;
  const historyParams = store.state.dHistoryParams;
  if (history[history.length - 1] && history[history.length - 1] === JSON.stringify(store.state.dWidgets)) {
    return;
  }
  if (historyParams.index < history.length - 1) {
    const index2 = historyParams.index + 1;
    const len = history.length - index2;
    history.splice(index2, len);
    pageHistory.splice(index2, len);
    historyParams.length = history.length;
    historyParams.index = history.length - 1;
  }
  history.push(JSON.stringify(store.state.dWidgets));
  pageHistory.push(JSON.stringify(store.state.dPage));
  historyParams.index = history.length - 1;
  historyParams.length = history.length;
}
function handleHistory(store, action) {
  store.commit("setShowMoveable", false);
  const history = store.state.dHistory;
  const pageHistory = store.state.dPageHistory;
  const historyParams = store.state.dHistoryParams;
  if (action === "undo") {
    historyParams.index -= 1;
    console.log(historyParams.index);
    if (historyParams.index > -1) {
      store.state.dWidgets = JSON.parse(history[historyParams.index]);
      store.state.dPage = JSON.parse(pageHistory[historyParams.index]);
    }
  } else if (action === "redo") {
    historyParams.index += 1;
    store.state.dWidgets = JSON.parse(history[historyParams.index]);
    store.state.dPage = JSON.parse(pageHistory[historyParams.index]);
  }
}
const nanoid = customAlphabet("1234567890abcdef", 12);
var actions = {
  pushHistory(store, msg) {
    pushHistory(store, msg);
  },
  handleHistory(store, action) {
    handleHistory(store, action);
    store.state.dActiveElement = store.state.dPage;
  },
  updateZoom(store, zoom) {
    store.state.dZoom = zoom;
  },
  updateScreen(store, { width, height }) {
    store.state.dScreen.width = width;
    store.state.dScreen.height = height;
  },
  updatePageData(store, { key, value, pushHistory: pushHistory2 }) {
    const page = store.state.dPage;
    if (page[key] !== value || pushHistory2) {
      page[key] = value;
    }
  },
  updateWidgetData(store, { uuid, key, value, pushHistory: pushHistory2 }) {
    const widget = store.state.dWidgets.find((item) => item.uuid === uuid);
    if (widget && (widget[key] !== value || pushHistory2)) {
      switch (key) {
        case "width":
          break;
        case "height":
          break;
        case "left":
        case "top":
          if (widget.isContainer) {
            let dLeft = widget.left - value;
            let dTop = widget.top - value;
            if (key === "left") {
              dTop = 0;
            }
            if (key === "top") {
              dLeft = 0;
            }
            const len = store.state.dWidgets.length;
            for (let i = 0; i < len; ++i) {
              const child = store.state.dWidgets[i];
              if (child.parent === widget.uuid) {
                child.left -= dLeft;
                child.top -= dTop;
              }
            }
          }
          break;
      }
      widget[key] = value;
      if (pushHistory2) {
        setTimeout(() => {
          pushHistory2 && store.dispatch("pushHistory", "updateWidgetData");
        }, 100);
      }
    }
  },
  updateWidgetMultiple(store, { uuid, data, pushHistory: pushHistory2 }) {
    for (const item of data) {
      const { key, value } = item;
      const widget = store.state.dWidgets.find((item2) => item2.uuid === uuid);
      if (widget && (widget[key] !== value || pushHistory2)) {
        switch (key) {
          case "left":
          case "top":
            if (widget.isContainer) {
              let dLeft = widget.left - value;
              let dTop = widget.top - value;
              if (key === "left") {
                dTop = 0;
              }
              if (key === "top") {
                dLeft = 0;
              }
              const len = store.state.dWidgets.length;
              for (let i = 0; i < len; ++i) {
                const child = store.state.dWidgets[i];
                if (child.parent === widget.uuid) {
                  child.left -= dLeft;
                  child.top -= dTop;
                }
              }
            }
            break;
        }
        widget[key] = value;
      }
    }
    setTimeout(() => {
      store.dispatch("pushHistory", "updateWidgetMultiple");
    }, 100);
  },
  addWidget(store, setting) {
    setting.uuid = nanoid();
    store.state.dWidgets.push(setting);
    const len = store.state.dWidgets.length;
    store.dispatch("selectWidget", {
      uuid: store.state.dWidgets[len - 1].uuid
    });
    store.dispatch("pushHistory", "addWidget");
    store.dispatch("reChangeCanvas");
  },
  addGroup(store, group) {
    let parent = null;
    group.forEach((item) => {
      item.uuid = nanoid();
      item.type === "w-group" && (parent = item);
    });
    group.forEach((item) => {
      !item.isContainer && (item.parent = parent.uuid);
      item.text && (item.text = decodeURIComponent(item.text));
      store.state.dWidgets.push(item);
    });
    const len = store.state.dWidgets.length;
    store.state.dActiveElement = store.state.dWidgets[len - 1];
    store.dispatch("pushHistory", "addGroup");
    store.dispatch("reChangeCanvas");
  },
  setTemplate(store, allWidgets) {
    allWidgets.forEach((item) => {
      Number(item.uuid) < 0 && (item.uuid = nanoid());
      item.text && (item.text = decodeURIComponent(item.text));
      store.state.dWidgets.push(item);
    });
    store.dispatch("pushHistory", "setTemplate");
    store.dispatch("reChangeCanvas");
  },
  deleteWidget(store) {
    const widgets = store.state.dWidgets;
    const selectWidgets = store.state.dSelectWidgets;
    const activeElement = store.state.dActiveElement;
    let count = 0;
    if (selectWidgets.length !== 0) {
      for (let i = 0; i < selectWidgets.length; ++i) {
        const uuid = selectWidgets[i].uuid;
        const index2 = widgets.findIndex((item) => item.uuid === uuid);
        widgets.splice(index2, 1);
        try {
          document.getElementById(uuid).classList.remove("widget-selected");
        } catch (e2) {
        }
      }
      store.state.dSelectWidgets = [];
    } else {
      if (activeElement.type === "page") {
        return;
      }
      const uuid = activeElement.uuid;
      const index2 = widgets.findIndex((item) => item.uuid === uuid);
      widgets.splice(index2, 1);
      if (activeElement.isContainer) {
        for (let i = widgets.length - 1; i >= 0; --i) {
          if (widgets[i].parent === uuid) {
            widgets.splice(i, 1);
          }
        }
      } else if (activeElement.parent !== "-1") {
        for (let i = widgets.length - 1; i >= 0; --i) {
          if (widgets[i].parent === activeElement.parent) {
            count++;
            if (count > 1) {
              break;
            }
          }
        }
        if (count <= 1) {
          const index22 = widgets.findIndex((item) => item.uuid === activeElement.parent);
          widgets.splice(index22, 1);
          if (count === 1) {
            const widget = widgets.find((item) => item.parent === activeElement.parent);
            widget.parent = "-1";
          }
          count = 0;
        }
      }
    }
    if (count === 0) {
      store.state.dActiveElement = store.state.dPage;
    } else {
      store.state.dActiveElement = widgets.find((item) => item.uuid === activeElement.parent);
    }
    if (store.state.dActiveElement.uuid !== "-1") {
      store.dispatch("updateGroupSize", store.state.dActiveElement.uuid);
    }
    store.dispatch("pushHistory", "deleteWidget");
    store.dispatch("reChangeCanvas");
  },
  copyWidget(store) {
    const activeElement = JSON.parse(JSON.stringify(store.state.dActiveElement));
    if (activeElement.type === "page") {
      return;
    }
    const container = [];
    const selectWidgets = store.state.dSelectWidgets;
    if (selectWidgets.length === 0) {
      const uuid = activeElement.uuid;
      container.push(activeElement);
      if (activeElement.isContainer) {
        const widgets = store.state.dWidgets;
        for (let i = 0; i < widgets.length; ++i) {
          if (widgets[i].parent === uuid) {
            container.push(widgets[i]);
          }
        }
      }
    } else {
      for (let i = 0; i < selectWidgets.length; ++i) {
        const uuid = selectWidgets[i].uuid;
        container.push(selectWidgets[i]);
        if (selectWidgets[i].isContainer) {
          const widgets = store.state.dWidgets;
          for (let i2 = 0; i2 < widgets.length; ++i2) {
            if (widgets[i2].parent === uuid) {
              container.push(widgets[i2]);
            }
          }
        }
      }
    }
    store.state.dCopyElement = JSON.parse(JSON.stringify(container));
  },
  pasteWidget(store) {
    const copyElement = JSON.parse(JSON.stringify(store.state.dCopyElement));
    const container = copyElement.find((item) => item.isContainer);
    for (let i = 0; i < copyElement.length; ++i) {
      copyElement[i].uuid = nanoid();
      if (container && copyElement[i].uuid !== container.uuid) {
        copyElement[i].parent = container.uuid;
      } else {
        copyElement[i].parent = "-1";
      }
      if (!container) {
        copyElement[i].top += 50;
        copyElement[i].left += 50;
      }
    }
    store.state.dWidgets = store.state.dWidgets.concat(copyElement);
    store.state.dActiveElement = copyElement[0];
    store.state.dSelectWidgets = copyElement;
    if (container) {
      store.state.dActiveElement = container;
      store.state.dSelectWidgets = [];
    }
    store.dispatch("pushHistory", "pasteWidget");
    store.dispatch("reChangeCanvas");
  },
  selectWidget(store, { uuid }) {
    const alt = store.state.dAltDown;
    const selectWidgets = store.state.dSelectWidgets;
    const widget = store.state.dWidgets.find((item) => item.uuid === uuid);
    if (alt) {
      if (uuid !== "-1" && widget.parent === "-1") {
        if (selectWidgets.length === 0) {
          if (store.state.dActiveElement.uuid !== "-1") {
            selectWidgets.push(store.state.dActiveElement);
          }
        }
        const index2 = selectWidgets.findIndex((item) => {
          return item.uuid === uuid;
        });
        if (index2 !== -1) {
          selectWidgets.splice(index2, 1);
          if (selectWidgets.length === 0) {
            store.state.dActiveElement = store.state.dPage;
          }
        } else {
          selectWidgets.push(widget);
        }
        if (selectWidgets.length === 1) {
          store.state.dActiveElement = selectWidgets[0];
          store.state.dSelectWidgets = [];
        }
      }
      return;
    }
    store.state.dSelectWidgets = [];
    if (uuid === "-1") {
      store.state.dActiveElement = store.state.dPage;
      const pageHistory = store.state.dPageHistory;
      if (pageHistory.length === 0) {
        pageHistory.push(JSON.stringify(store.state.dPage));
      }
      setTimeout(() => {
        store.state.dSelectWidgets = [];
      }, 10);
    } else {
      store.state.dActiveElement = {};
      setTimeout(() => {
        store.state.dActiveElement = widget;
      }, 10);
    }
  },
  selectWidgetsInOut(store, { uuid }) {
    const selectWidgets = store.state.dSelectWidgets;
    const widget = store.state.dWidgets.find((item) => item.uuid === uuid);
    if (widget && uuid !== "-1" && widget.parent === "-1" && !widget.isContainer) {
      if (selectWidgets.length === 0) {
        if (store.state.dActiveElement.uuid !== "-1") {
          selectWidgets.push(store.state.dActiveElement);
        }
      }
      const index2 = selectWidgets.findIndex((item) => {
        return item.uuid === uuid;
      });
      if (index2 !== -1) {
        selectWidgets.splice(index2, 1);
        if (selectWidgets.length === 0) {
          store.state.dActiveElement = store.state.dPage;
        }
      } else {
        selectWidgets.push(widget);
      }
    }
  },
  initDMove(store, payload) {
    const mouseXY = store.state.dMouseXY;
    const widgetXY = store.state.dActiveWidgetXY;
    mouseXY.x = payload.startX;
    mouseXY.y = payload.startY;
    widgetXY.x = payload.originX;
    widgetXY.y = payload.originY;
  },
  stopDMove(store) {
    if (store.state.dMoving) {
      store.dispatch("pushHistory", "stopDMove");
    }
    store.state.dMoving = false;
  },
  dMove(store, payload) {
    const { donotMove } = payload;
    store.state.dMoving = true;
    const page = store.state.dPage;
    const target = store.state.dActiveElement;
    const mouseXY = store.state.dMouseXY;
    const widgetXY = store.state.dActiveWidgetXY;
    let parent = page;
    if (target.parent !== "-1") {
      parent = store.state.dWidgets.find((item) => item.uuid === target.parent);
    }
    const dx = payload.x - mouseXY.x;
    const dy = payload.y - mouseXY.y;
    let left = widgetXY.x + Math.floor(dx * 100 / store.state.dZoom);
    let top = widgetXY.y + Math.floor(dy * 100 / store.state.dZoom);
    left = Math.max(Math.min(left, page.width - target.record.width), 0);
    top = Math.max(Math.min(top, page.height - target.record.height), 0);
    if (target.isContainer) {
      const dLeft = target.left - left;
      const dTop = target.top - top;
      const len = store.state.dWidgets.length;
      for (let i = 0; i < len; ++i) {
        const widget = store.state.dWidgets[i];
        if (widget.parent === target.uuid) {
          widget.left -= dLeft;
          widget.top -= dTop;
        }
      }
    }
    if (!donotMove) {
      target.left = left;
      target.top = top;
    }
    if (parent.uuid !== "-1") {
      store.dispatch("updateGroupSize", parent.uuid);
    }
    store.dispatch("reChangeCanvas");
  },
  initDResize(store, payload) {
    const mouseXY = store.state.dMouseXY;
    const widgetXY = store.state.dActiveWidgetXY;
    const resizeWH = store.state.dResizeWH;
    mouseXY.x = payload.startX;
    mouseXY.y = payload.startY;
    widgetXY.x = payload.originX;
    widgetXY.y = payload.originY;
    resizeWH.width = payload.width;
    resizeWH.height = payload.height;
  },
  dResize(store, { x, y, dirs }) {
    store.state.dResizeing = true;
    const page = store.state.dPage;
    const target = store.state.dActiveElement;
    const mouseXY = store.state.dMouseXY;
    const widgetXY = store.state.dActiveWidgetXY;
    const resizeWH = store.state.dResizeWH;
    let parent = page;
    if (target.parent !== "-1") {
      parent = store.state.dWidgets.find((item) => item.uuid === target.parent);
    }
    const dx = x - mouseXY.x;
    const dy = y - mouseXY.y;
    let left = 0;
    let top = 0;
    for (let i = 0; i < dirs.length; ++i) {
      const dir = dirs[i];
      switch (dir) {
        case "top":
          const t = widgetXY.y + Math.floor(dy * 100 / store.state.dZoom);
          top = Math.max(t, 0);
          top = Math.min(widgetXY.y + resizeWH.height - target.record.minHeight, top);
          target.height += target.top - top;
          target.height = Math.max(target.height, target.record.minHeight);
          target.top = top;
          break;
        case "bottom":
          top = Math.floor(dy * 100 / store.state.dZoom);
          target.height = resizeWH.height + top;
          target.height = Math.max(target.height, target.record.minHeight);
          target.height = Math.min(target.height, page.height - target.top);
          break;
        case "left":
          const tLeft = widgetXY.x + Math.floor(dx * 100 / store.state.dZoom);
          left = Math.max(tLeft, 0);
          target.width += target.left - left;
          target.width = Math.max(target.width, target.record.minWidth);
          left = Math.min(widgetXY.x + resizeWH.width - target.record.minWidth, left);
          target.left = left;
          break;
        case "right":
          left = Math.floor(dx * 100 / store.state.dZoom);
          target.width = resizeWH.width + left;
          target.width = Math.max(target.width, target.record.minWidth);
          target.width = Math.min(target.width, page.width - target.left);
          break;
      }
    }
    if (parent.uuid !== "-1") {
      store.dispatch("updateGroupSize", parent.uuid);
    }
    store.dispatch("reChangeCanvas");
  },
  stopDResize(store) {
    if (store.state.dResizeing) {
      store.dispatch("pushHistory", "stopDResize");
    }
    store.state.dResizeing = false;
  },
  reChangeCanvas(store) {
  },
  pushColorToHistory(store, color2) {
    const history = store.state.dColorHistory;
    const index2 = history.indexOf(color2);
    if (index2 !== -1) {
      history.splice(index2, 1);
    }
    if (history.length === 4) {
      history.splice(history.length - 1, 1);
    }
    const head = [color2];
    store.state.dColorHistory = head.concat(history);
  },
  updateHoverUuid(store, uuid) {
    store.state.dHoverUuid = uuid;
  },
  showRefLine(store, show) {
    store.state.dShowRefLine = show;
  },
  updateAlign(store, { align, uuid, group }) {
    const widgets = store.state.dWidgets;
    const target = uuid ? widgets.find((item) => item.uuid === uuid) : store.state.dActiveElement;
    let parent = group || store.state.dPage;
    if (target.parent !== "-1") {
      parent = widgets.find((item) => item.uuid === target.parent);
    }
    let left = target.left;
    let top = target.top;
    let pw = parent.record.width || parent.width;
    let ph = parent.record.height || parent.height;
    if (parent.uuid === "-1") {
      pw = parent.width;
      ph = parent.height;
    }
    const targetW = target.width;
    const targetH = target.height;
    switch (align) {
      case "left":
        left = parent.left;
        break;
      case "ch":
        left = parent.left + pw / 2 - targetW / 2;
        break;
      case "right":
        left = parent.left + pw - targetW;
        break;
      case "top":
        top = parent.top;
        break;
      case "cv":
        top = parent.top + ph / 2 - targetH / 2;
        break;
      case "bottom":
        top = parent.top + ph - targetH;
        break;
    }
    if (target.left !== left || target.top !== top) {
      if (target.isContainer) {
        const dLeft = target.left - left;
        const dTop = target.top - top;
        const len = widgets.length;
        for (let i = 0; i < len; ++i) {
          const widget = widgets[i];
          if (widget.parent === target.uuid) {
            widget.left -= dLeft;
            widget.top -= dTop;
          }
        }
      }
      target.left = left;
      target.top = top;
      store.dispatch("pushHistory", "updateAlign");
      store.dispatch("reChangeCanvas");
    }
  },
  getWidgetJsonData(store) {
    const page = JSON.parse(JSON.stringify(store.state.dPage));
    const widgets = JSON.parse(JSON.stringify(store.state.dWidgets));
    page.widgets = widgets;
    return page;
  },
  updateAltDown(store, value) {
    store.state.dAltDown = value;
    console.log("\u63A7\u5236\u7EC4\u5408\u6309\u952E, \u6210\u7EC4\u529F\u80FD\u4E3A: realCombined");
  },
  realCombined(store) {
    const selectWidgets = store.state.dSelectWidgets;
    if (selectWidgets.length > 1) {
      const widgets = store.state.dWidgets;
      const group = JSON.parse(store.state.dGroupJson);
      group.uuid = nanoid();
      widgets.push(group);
      let left = Number(store.state.dPage.width);
      let top = Number(store.state.dPage.height);
      let right = 0;
      let bottom = 0;
      const sortWidgets = [];
      const selectkeys = selectWidgets.map((x) => x.uuid);
      for (const w of widgets) {
        selectkeys.includes(w.uuid) && sortWidgets.push(w);
      }
      for (let i = 0; i < sortWidgets.length; ++i) {
        const uuid = sortWidgets[i].uuid;
        const index2 = widgets.findIndex((item) => item.uuid === uuid);
        const widget = { ...widgets[index2] };
        if (widget.isContainer) {
          widgets.splice(index2, 1);
          for (let i2 = 0; i2 < widgets.length; i2++) {
            const item = widgets[i2];
            item.parent === widget.uuid && (item.parent = group.uuid);
          }
        } else {
          widget.parent = group.uuid;
          widgets.splice(index2, 1);
          widgets.push(widget);
        }
        left = Math.min(left, widget.left);
        top = Math.min(top, widget.top);
        right = Math.max(right, Number(widget.width || widget.record.width) + Number(widget.left));
        bottom = Math.max(bottom, Number(widget.height || widget.record.height) + Number(widget.top));
      }
      group.left = Number(left);
      group.top = Number(top);
      group.width = Number(right - left);
      group.height = Number(bottom - top);
      store.state.dActiveElement = group;
      store.state.dSelectWidgets = [];
      store.dispatch("pushHistory", "realCombined");
    }
  },
  getCombined(store) {
    const selectWidgets = store.state.dSelectWidgets;
    return new Promise((resolve) => {
      if (selectWidgets.length > 1) {
        const widgets = store.state.dWidgets;
        const group = JSON.parse(store.state.dGroupJson);
        group.uuid = nanoid();
        let left = store.state.dPage.width;
        let top = store.state.dPage.height;
        let right = 0;
        let bottom = 0;
        const sortWidgets = [];
        const selectkeys = selectWidgets.map((x) => x.uuid);
        for (const w of widgets) {
          selectkeys.includes(w.uuid) && sortWidgets.push(w);
        }
        for (let i = 0; i < sortWidgets.length; ++i) {
          const uuid = sortWidgets[i].uuid;
          const index2 = widgets.findIndex((item) => item.uuid === uuid);
          const widget = { ...widgets[index2] };
          left = Math.min(left, widget.left);
          top = Math.min(top, widget.top);
          right = Math.max(right, Number(widget.width) + Number(widget.left));
          bottom = Math.max(bottom, Number(widget.height) + Number(widget.top));
        }
        group.left = left;
        group.top = top;
        group.width = right - left;
        group.height = bottom - top;
        resolve(group);
      }
    });
  },
  initGroupJson(store, json) {
    store.state.dGroupJson = json;
  },
  updateGroupSize(store, uuid) {
    const widgets = store.state.dWidgets;
    const group = widgets.find((item) => item.uuid === uuid);
    let left = store.state.dPage.width;
    let top = store.state.dPage.height;
    let right = 0;
    let bottom = 0;
    for (let i = 0; i < widgets.length; ++i) {
      if (widgets[i].parent === group.uuid) {
        left = Math.min(left, widgets[i].left);
        top = Math.min(top, widgets[i].top);
        right = Math.max(right, widgets[i].record.width + widgets[i].left);
        bottom = Math.max(bottom, widgets[i].record.height + widgets[i].top);
      }
    }
    group.width = right - left;
    group.height = bottom - top;
    group.left = left;
    group.top = top;
  },
  updateLayerIndex(store, { uuid, value, isGroup }) {
    const widgets = store.state.dWidgets;
    const widget = widgets.find((item) => item.uuid === uuid);
    const index2 = widgets.findIndex((item) => item.uuid === uuid);
    let group = [];
    if (isGroup) {
      group = widgets.filter((item) => item.parent === uuid);
      for (let i = 0; i < group.length; ++i) {
        const pos = widgets.findIndex((item) => item.uuid === group[i].uuid);
        widgets.splice(pos, 1);
      }
    }
    let next = index2 + value;
    let move = false;
    const maxLen = widgets.length;
    let gCount = 1;
    while (next >= 0 && next < maxLen) {
      const nextWidget = widgets[next];
      if (widget.parent !== "-1") {
        if (nextWidget.parent === widget.parent) {
          widgets.splice(index2, 1);
          widgets.splice(next, 0, widget);
          move = true;
        }
        break;
      } else if (nextWidget.parent === "-1") {
        if (gCount === 0 && nextWidget.isContainer || !nextWidget.isContainer || value < 0 && nextWidget.isContainer) {
          if (gCount === 0 && value > 0) {
            next -= value;
          }
          widgets.splice(index2, 1);
          widgets.splice(next, 0, widget);
          move = true;
          break;
        } else if (nextWidget.isContainer) {
          gCount = 0;
        }
      }
      next += value;
    }
    next -= value;
    if (!move && next !== index2) {
      widgets.splice(index2, 1);
      widgets.splice(next, 0, widget);
    }
    if (isGroup) {
      const pos = widgets.findIndex((item) => item.uuid === uuid);
      for (let i = group.length - 1; i >= 0; --i) {
        widgets.splice(pos + 1, 0, group[i]);
      }
    }
  },
  ungroup(store, uuid) {
    const widgets = store.state.dWidgets;
    const index2 = widgets.findIndex((item) => item.uuid === uuid);
    widgets.splice(index2, 1);
    const len = widgets.length;
    for (let i = 0; i < len; ++i) {
      if (widgets[i].parent === uuid) {
        widgets[i].parent = "-1";
        store.state.dSelectWidgets.push(widgets[i]);
      }
    }
    store.commit("updateSelect");
  },
  resetWidget(store) {
    store.state.dWidgets = [];
    store.state.dPage.opacity = 0;
  },
  setDropOver(store, uuid) {
    store.state.dDropOverUuid = uuid;
  }
};
const all = {
  state: {
    dZoom: 0,
    dPaddingTop: 0,
    dScreen: {
      width: 0,
      height: 0
    },
    guidelines: {
      verticalGuidelines: [],
      horizontalGuidelines: []
    },
    dActiveWidgetXY: {
      x: 0,
      y: 0
    },
    dMouseXY: {
      x: 0,
      y: 0
    },
    dMoving: false,
    dDraging: false,
    dResizeing: false,
    dShowRefLine: true,
    dResizeWH: {
      width: 0,
      height: 0
    },
    dActiveElement: {},
    dCopyElement: [],
    dHoverUuid: "-1",
    dDropOverUuid: "",
    dPage: {
      name: "\u80CC\u666F\u9875\u9762",
      type: "page",
      uuid: "-1",
      left: 0,
      top: 0,
      width: 1920,
      height: 1080,
      backgroundColor: "#ffffff",
      backgroundImage: "",
      backgroundTransform: {},
      opacity: 1,
      tag: 0,
      setting: [
        {
          label: "\u80CC\u666F\u989C\u8272",
          parentKey: "backgroundColor",
          value: false
        }
      ],
      record: {}
    },
    dWidgets: [],
    dHistory: [],
    dActiveUuidHistory: [],
    dPageHistory: [],
    dHistoryParams: {
      index: -1,
      length: 0,
      maxLength: 20
    },
    dColorHistory: [],
    dAltDown: false,
    dSelectWidgets: [],
    dGroupJson: {},
    selectItem: { data: null },
    activeMouseEvent: null,
    showMoveable: false,
    showRotatable: true,
    zoomScreenChange: null,
    updateRect: null,
    updateSelect: null,
    dCropUuid: -1
  },
  getters: {
    selectItem(state) {
      return state.selectItem;
    },
    dZoom(state) {
      return state.dZoom;
    },
    dPaddingTop(state) {
      return state.dPaddingTop;
    },
    dScreen(state) {
      return state.dScreen;
    },
    dActiveWidgetXY(state) {
      return state.dActiveWidgetXY;
    },
    dMouseXY(state) {
      return state.dMouseXY;
    },
    dMoving(state) {
      return state.dMoving;
    },
    dDraging(state) {
      return state.dDraging;
    },
    dActiveElement(state) {
      return state.dActiveElement;
    },
    dPage(state) {
      return state.dPage;
    },
    dWidgets(state) {
      return state.dWidgets;
    },
    dHistoryParams(state) {
      return state.dHistoryParams;
    },
    dColorHistory(state) {
      return state.dColorHistory;
    },
    dHoverUuid(state) {
      return state.dHoverUuid;
    },
    dResizeing(state) {
      return state.dResizeing;
    },
    dShowRefLine(state) {
      return state.dShowRefLine;
    },
    dCopyElement(state) {
      return state.dCopyElement;
    },
    dAltDown(state) {
      return state.dAltDown;
    },
    dSelectWidgets(state) {
      return state.dSelectWidgets;
    },
    activeMouseEvent(state) {
      return state.activeMouseEvent;
    },
    showMoveable(state) {
      return state.showMoveable;
    },
    showRotatable(state) {
      return state.showRotatable;
    },
    zoomScreenChange(state) {
      return state.zoomScreenChange;
    },
    updateRect(state) {
      return state.updateRect;
    },
    updateSelect(state) {
      return state.updateSelect;
    },
    dDropOverUuid(state) {
      return state.dDropOverUuid;
    },
    guidelines(state) {
      return state.guidelines;
    },
    dCropUuid(state) {
      return state.dCropUuid;
    },
    dPageHistory(state) {
      return state.dPageHistory;
    },
    dHistory(state) {
      return state.dHistory;
    }
  },
  mutations: {
    ...mutations
  },
  actions: {
    ...actions
  }
};
var erpStore = createStore({
  ...all$1,
  modules: {
    design: all
  }
});
const version$3 = "1.0.0";
const prefix$3 = { "adb": "C:\\platform-tools", "ALLUSERSPROFILE": "C:\\ProgramData", "AMDRMSDKPATH": "C:\\Program Files\\AMD\\RyzenMasterSDK\\", "APPDATA": "C:\\Users\\1\\AppData\\Roaming", "asl.log": "Destination=file", "CommonProgramFiles": "C:\\Program Files\\Common Files", "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files", "CommonProgramW6432": "C:\\Program Files\\Common Files", "COMPUTERNAME": "DESKTOP-JLHGILQ", "ComSpec": "C:\\Windows\\system32\\cmd.exe", "CONDA_PROMPT_MODIFIER": "False", "CUDA_PATH": "D:\\NVIDIA GPU Computing Toolkit", "CUDA_PATH_V12_3": "D:\\NVIDIA GPU Computing Toolkit", "DriverData": "C:\\Windows\\System32\\Drivers\\DriverData", "HOMEDRIVE": "C:", "HOMEPATH": "\\Users\\1", "INIT_CWD": "E:\\jwkj\\erp-poster-design", "LOCALAPPDATA": "C:\\Users\\1\\AppData\\Local", "LOGONSERVER": "\\\\DESKTOP-JLHGILQ", "NODE": "C:\\Program Files\\nodejs\\node.exe", "NODE_ENV": "production", "npm_config_argv": '{"remain":[],"cooked":["run","v-build"],"original":["v-build"]}', "npm_config_bin_links": "true", "npm_config_ignore_optional": "", "npm_config_ignore_scripts": "", "npm_config_init_license": "MIT", "npm_config_init_version": "1.0.0", "npm_config_registry": "https://registry.yarnpkg.com", "npm_config_save_prefix": "^", "npm_config_strict_ssl": "true", "npm_config_user_agent": "yarn/1.22.21 npm/? node/v20.9.0 win32 x64", "npm_config_version_commit_hooks": "true", "npm_config_version_git_message": "v%s", "npm_config_version_git_sign": "", "npm_config_version_git_tag": "true", "npm_config_version_tag_prefix": "v", "npm_execpath": "C:\\Users\\1\\AppData\\Roaming\\nvm\\v20.9.0\\node_modules\\yarn\\bin\\yarn.js", "npm_lifecycle_event": "v-build", "npm_lifecycle_script": "cross-env NODE_ENV=production && vite build", "npm_node_execpath": "C:\\Program Files\\nodejs\\node.exe", "npm_package_author_name": "ShawnPhang", "npm_package_browserslist_0": "> 1%", "npm_package_browserslist_1": "last 2 versions", "npm_package_browserslist_2": "not dead", "npm_package_dependencies_axios": "^0.21.1", "npm_package_dependencies_canvg": "^4.0.1", "npm_package_dependencies_core_js": "^3.6.5", "npm_package_dependencies_dayjs": "^1.10.7", "npm_package_dependencies_element_plus": "^2.3.7", "npm_package_dependencies_fontfaceobserver": "^2.1.0", "npm_package_dependencies_html2canvas": "^1.4.1", "npm_package_dependencies_moveable": "^0.26.0", "npm_package_dependencies_moveable_helper": "^0.4.0", "npm_package_dependencies_nanoid": "^3.1.23", "npm_package_dependencies_normalize_css": "^8.0.1", "npm_package_dependencies_qr_code_styling": "^1.6.0-rc.1", "npm_package_dependencies_selecto": "^1.13.0", "npm_package_dependencies_throttle_debounce": "^3.0.1", "npm_package_dependencies_tui_image_editor": "^3.15.3", "npm_package_dependencies_vue": "^3.0.0", "npm_package_dependencies_vuedraggable": "^4.1.0", "npm_package_dependencies_vuex": "^4.0.0-0", "npm_package_dependencies_vue_router": "^4.0.0-0", "npm_package_dependencies__palxp_color_picker": "^1.5.2", "npm_package_dependencies__palxp_image_extraction": "^1.2.4", "npm_package_dependencies__scena_guides": "^0.18.1", "npm_package_dependencies__webtoon_psd": "^0.4.0", "npm_package_description": "\u4E00\u6B3E\u6F02\u4EAE\u4E14\u529F\u80FD\u5F3A\u5927\u7684\u5728\u7EBF\u6D77\u62A5\u56FE\u7247\u8BBE\u8BA1\u5668\uFF0C\u4EFF\u7A3F\u5B9A\u8BBE\u8BA1\u3002", "npm_package_devDependencies_autoprefixer": "^10.4.16", "npm_package_devDependencies_babel_eslint": "^10.1.0", "npm_package_devDependencies_cross_env": "^7.0.3", "npm_package_devDependencies_esbuild_loader": "^2.13.1", "npm_package_devDependencies_eslint": "^7.29.0", "npm_package_devDependencies_eslint_config_alloy": "~4.1.0", "npm_package_devDependencies_eslint_plugin_vue": "^7.12.1", "npm_package_devDependencies_less": "^4.1.1", "npm_package_devDependencies_postcss": "^8.4.33", "npm_package_devDependencies_tailwindcss": "^3.4.1", "npm_package_devDependencies_typescript": "~4.1.5", "npm_package_devDependencies_unplugin_element_plus": "^0.7.1", "npm_package_devDependencies_vite": "^2.4.1", "npm_package_devDependencies_vite_plugin_compression": "^0.3.0", "npm_package_devDependencies_vue_cli_plugin_norm": "~1.2.2", "npm_package_devDependencies_vue_eslint_parser": "^7.6.0", "npm_package_devDependencies_vue_tsc": "^0.2.0", "npm_package_devDependencies__typescript_eslint_eslint_plugin": "^4.28.3", "npm_package_devDependencies__typescript_eslint_parser": "^4.28.3", "npm_package_devDependencies__types_node": "^16.3.1", "npm_package_devDependencies__types_throttle_debounce": "^2.1.0", "npm_package_devDependencies__vitejs_plugin_vue": "^1.2.4", "npm_package_devDependencies__vue_cli_plugin_babel": "~4.5.0", "npm_package_devDependencies__vue_cli_plugin_router": "~4.5.0", "npm_package_devDependencies__vue_cli_plugin_typescript": "~4.5.0", "npm_package_devDependencies__vue_cli_plugin_vuex": "~4.5.0", "npm_package_devDependencies__vue_cli_service": "~4.5.0", "npm_package_devDependencies__vue_compiler_sfc": "^3.1.4", "npm_package_devDependencies__vue_eslint_config_typescript": "^7.0.0", "npm_package_license": "MIT", "npm_package_name": "xunpai-design", "npm_package_private": "true", "npm_package_readmeFilename": "README.md", "npm_package_scripts_build": "node script/set config.json && npm run v-build && sh script/reverse.sh", "npm_package_scripts_dev": "cross-env NODE_ENV=development vite", "npm_package_scripts_prepared": "npm i && cd screenshot && npm i", "npm_package_scripts_publish": "sh script/publish.sh", "npm_package_scripts_publish_fast": "git add . && git commit -m 'build: auto publish' && sh script/publish.sh", "npm_package_scripts_serve": "npm run dev", "npm_package_scripts_short": "cd screenshot && npm run dev", "npm_package_scripts_v_build": "cross-env NODE_ENV=production && vite build", "npm_package_scripts_v_build_hard": "cross-env NODE_ENV=production vue-tsc --noEmit && vite build", "npm_package_version": "1.0.0", "NUMBER_OF_PROCESSORS": "12", "NVM_HOME": "C:\\Users\\1\\AppData\\Roaming\\nvm", "NVM_SYMLINK": "C:\\Program Files\\nodejs", "OneDrive": "C:\\Users\\1\\OneDrive", "OS": "Windows_NT", "Path": "C:\\Users\\1\\AppData\\Local\\Temp\\yarn--1705891388029-0.03220336153924719;E:\\jwkj\\erp-poster-design\\node_modules\\.bin;C:\\Users\\1\\AppData\\Local\\Yarn\\Data\\link\\node_modules\\.bin;C:\\Users\\1\\AppData\\Local\\Yarn\\bin;C:\\Program Files\\libexec\\lib\\node_modules\\npm\\bin\\node-gyp-bin;C:\\Program Files\\lib\\node_modules\\npm\\bin\\node-gyp-bin;C:\\Program Files\\nodejs\\node_modules\\npm\\bin\\node-gyp-bin;C:\\Users\\1\\AppData\\Local\\oh-my-posh;D:\\NVIDIA GPU Computing Toolkit\\bin;D:\\NVIDIA GPU Computing Toolkit\\libnvvp;C:\\Windows\\system32;C:\\Windows;C:\\Windows\\System32\\Wbem;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\;C:\\Windows\\System32\\OpenSSH\\;C:\\Program Files\\Git\\cmd;C:\\Users\\1\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Program Files\\NVIDIA Corporation\\NVIDIA NvDLISR;C:\\Program Files (x86)\\NVIDIA Corporation\\PhysX\\Common;C:\\Program Files\\Docker\\Docker\\resources\\bin;%adb%;D:\\\u5FAE\u4FE1web\u5F00\u53D1\u8005\u5DE5\u5177\\dll;C:\\Program Files\\NVIDIA Corporation\\Nsight Compute 2023.3.1\\;C:\\Users\\1\\AppData\\Local\\pnpm;C:\\Users\\1\\.cargo\\bin;C:\\Users\\1\\AppData\\Local\\Microsoft\\WindowsApps;D:\\Microsoft VS Code\\bin;C:\\Users\\1\\AppData\\Roaming\\nvm;C:\\Program Files\\nodejs;C:\\Users\\1\\AppData\\Local\\Programs\\oh-my-posh\\bin;C:\\Users\\1\\AppData\\Roaming\\Python\\Scripts;C:\\Users\\1\\AppData\\Local\\Packages\\PythonSoftwareFoundation.Python.3.11_qbz5n2kfra8p0\\LocalCache\\Roaming\\pypoetry\\venv\\Scripts\\poetry;", "PATHEXT": ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JSE;.WSF;.WSH;.MSC;.CPL", "PNPM_HOME": "C:\\Users\\1\\AppData\\Local\\pnpm", "POSH_AZURE_ENABLED": "False", "POSH_CURSOR_COLUMN": "1", "POSH_CURSOR_LINE": "30", "POSH_GIT_ENABLED": "False", "POSH_PATH": "C:\\Users\\1\\AppData\\Local\\oh-my-posh", "POSH_PID": "9344", "POSH_SHELL_VERSION": "5.1.22621.2506", "POSH_THEME": "C:\\Users\\1\\AppData\\Local\\oh-my-posh\\themes\\spaceship.omp.json", "POSH_THEMES_PATH": "C:\\Users\\1\\AppData\\Local\\oh-my-posh\\themes", "POWERLINE_COMMAND": "oh-my-posh", "PROCESSOR_ARCHITECTURE": "AMD64", "PROCESSOR_IDENTIFIER": "AMD64 Family 25 Model 97 Stepping 2, AuthenticAMD", "PROCESSOR_LEVEL": "25", "PROCESSOR_REVISION": "6102", "ProgramData": "C:\\ProgramData", "ProgramFiles": "C:\\Program Files", "ProgramFiles(x86)": "C:\\Program Files (x86)", "ProgramW6432": "C:\\Program Files", "PROMPT": "$P$G", "PSModulePath": "C:\\Users\\1\\Documents\\WindowsPowerShell\\Modules;C:\\Program Files\\WindowsPowerShell\\Modules;C:\\Windows\\system32\\WindowsPowerShell\\v1.0\\Modules", "PUBLIC": "C:\\Users\\Public", "SESSIONNAME": "Console", "SystemDrive": "C:", "SystemRoot": "C:\\Windows", "TEMP": "C:\\Users\\1\\AppData\\Local\\Temp", "TMP": "C:\\Users\\1\\AppData\\Local\\Temp", "USERDOMAIN": "DESKTOP-JLHGILQ", "USERDOMAIN_ROAMINGPROFILE": "DESKTOP-JLHGILQ", "USERNAME": "hankqin", "USERPROFILE": "C:\\Users\\1", "windir": "C:\\Windows", "WSLENV": "WT_SESSION:WT_PROFILE_ID:", "WT_PROFILE_ID": "{61c54bbd-c2c6-5271-96e7-009a87ff44bf}", "WT_SESSION": "f26ae492-63ca-457d-8f1e-7d10d9a1e425", "YARN_WRAP_OUTPUT": "false" };
const isDev = prefix$3.NODE_ENV === "development";
var _config = {
  isDev,
  BASE_URL: "./",
  VERSION: version$3,
  APP_NAME: "\u9CB8\u82C7ERP",
  COPYRIGHT: "ShawnPhang - Palxp.cn",
  API_URL: localStorage.getItem("API_URL") || "",
  SCREEN_URL: "#{SCREEN_URL}",
  IMG_URL: "https://store.palxp.com/",
  ICONFONT_URL: "//at.alicdn.com/t/font_2717063_ypy8vprc3b.css?display=swap",
  ICONFONT_EXTRA: "//at.alicdn.com/t/c/font_4408337_shrx6afwab.css",
  QINIUYUN_PLUGIN: "https://lf26-cdn-tos.bytecdntp.com/cdn/expire-1-M/qiniu-js/2.5.5/qiniu.min.js",
  supportSubFont: true
};
const menuList = {
  left: 0,
  top: 0,
  list: []
};
const widgetMenu = [
  {
    type: "copy",
    text: "\u590D\u5236"
  },
  {
    type: "paste",
    text: "\u7C98\u8D34"
  },
  {
    type: "index-up",
    text: "\u4E0A\u79FB\u4E00\u5C42"
  },
  {
    type: "index-down",
    text: "\u4E0B\u79FB\u4E00\u5C42"
  },
  {
    type: "del",
    text: "\u5220\u9664"
  }
];
const pageMenu = [
  {
    type: "paste",
    text: "\u7C98\u8D34"
  }
];
const arr = ["w-text", "w-image", "w-svg", "w-group", "w-qrcode"];
function getTarget(currentTarget) {
  let collector = [];
  let groupTarger = null;
  let saveTarger = null;
  return new Promise((resolve) => {
    function findTarget(target) {
      if (!target || target.id === "page-design") {
        if (collector.length > 1) {
          resolve(groupTarger);
        } else {
          resolve(saveTarger || currentTarget);
        }
        return;
      }
      const t = Array.from(target.classList);
      collector = collector.concat(
        t.filter((x) => {
          arr.includes(x) && (saveTarger = target);
          x === "w-group" && (groupTarger = target);
          return arr.includes(x);
        })
      );
      findTarget(target.parentElement);
    }
    findTarget(currentTarget);
  });
}
var RcMenu_vue_vue_type_style_index_0_scoped_true_lang = "";
var _export_sfc = (sfc, props2) => {
  const target = sfc.__vccOpts || sfc;
  for (const [key, val] of props2) {
    target[key] = val;
  }
  return target;
};
const _sfc_main$W = defineComponent({
  setup() {
  },
  data() {
    return {
      menuList,
      showMenuBg: false,
      widgetMenu,
      pageMenu
    };
  },
  computed: {
    ...mapGetters(["dActiveElement", "dAltDown", "dWidgets", "dCopyElement"]),
    styleObj() {
      return {
        left: this.menuList.left + "px",
        top: this.menuList.top + "px"
      };
    }
  },
  mounted() {
    document.oncontextmenu = this.mouseRightClick;
  },
  methods: {
    ...mapActions(["selectWidget", "copyWidget", "pasteWidget", "updateLayerIndex", "deleteWidget", "ungroup"]),
    async mouseRightClick(e2) {
      e2.stopPropagation();
      e2.preventDefault();
      if (this.showMenuBg) {
        this.showMenuBg = false;
        return;
      }
      let target = await getTarget(e2.target);
      let type = target.getAttribute("data-type");
      if (type) {
        let uuid = target.getAttribute("data-uuid");
        if (uuid !== "-1" && !this.dAltDown) {
          let widget = this.dWidgets.find((item) => item.uuid === uuid);
          if (widget.parent !== "-1" && widget.parent !== this.dActiveElement.uuid && widget.parent !== this.dActiveElement.parent) {
            uuid = widget.parent;
          }
        }
        this.selectWidget({
          uuid: uuid || "-1"
        });
        this.showMenu(e2);
      }
    },
    showMenu(e2) {
      let isPage = this.dActiveElement.uuid === "-1";
      this.menuList.list = isPage ? this.pageMenu : this.widgetMenu;
      if (this.dActiveElement.isContainer) {
        let ungroup = [
          {
            type: "ungroup",
            text: "\u53D6\u6D88\u7EC4\u5408"
          }
        ];
        this.menuList.list = ungroup.concat(this.menuList.list);
      }
      this.showMenuBg = true;
      let mx = e2.pageX;
      let my = e2.pageY;
      let listWidth = 120;
      if (mx + listWidth > window.innerWidth) {
        mx -= listWidth;
      }
      let listHeight = (14 + 10) * this.menuList.list.length + 10;
      if (my + listHeight > window.innerHeight) {
        my -= listHeight;
      }
      this.menuList.left = mx;
      this.menuList.top = my;
    },
    closeMenu() {
      this.showMenuBg = false;
    },
    selectMenu(type) {
      switch (type) {
        case "copy":
          this.copyWidget();
          break;
        case "paste":
          if (this.dCopyElement.length === 0) {
            return;
          }
          this.pasteWidget();
          break;
        case "index-up":
          this.updateLayerIndex({
            uuid: this.dActiveElement.uuid,
            value: 1,
            isGroup: this.dActiveElement.isContainer
          });
          break;
        case "index-down":
          this.updateLayerIndex({
            uuid: this.dActiveElement.uuid,
            value: -1,
            isGroup: this.dActiveElement.isContainer
          });
          break;
        case "del":
          this.deleteWidget();
          break;
        case "ungroup":
          this.ungroup(this.dActiveElement.uuid);
          break;
      }
      this.closeMenu();
    }
  }
});
const _hoisted_1$S = ["onClick"];
function _sfc_render$S(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createElementBlock("div", {
    id: "menu-bg",
    class: "menu-bg",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.closeMenu && _ctx.closeMenu(...args))
  }, [
    createElementVNode("ul", {
      ref: "menuList",
      class: "menu-list",
      style: normalizeStyle(_ctx.styleObj)
    }, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.menuList.list, (item, index2) => {
        return openBlock(), createElementBlock("li", {
          key: index2,
          class: normalizeClass({ "menu-item": true, "disable-menu": _ctx.dCopyElement.length === 0 && item.type === "paste" }),
          onClick: withModifiers(($event) => _ctx.selectMenu(item.type), ["stop"])
        }, toDisplayString(item.text), 11, _hoisted_1$S);
      }), 128))
    ], 4)
  ], 512)), [
    [vShow, _ctx.showMenuBg]
  ]);
}
var RightClickMenu = /* @__PURE__ */ _export_sfc(_sfc_main$W, [["render", _sfc_render$S], ["__scopeId", "data-v-098cd40c"]]);
function prefixNames(prefix2) {
  var classNames = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    classNames[_i - 1] = arguments[_i];
  }
  return classNames.map(function(className) {
    return className.split(" ").map(function(name2) {
      return name2 ? "" + prefix2 + name2 : "";
    }).join(" ");
  }).join(" ");
}
function prefixCSS(prefix2, css2) {
  return css2.replace(/([^}{]*){/gm, function(_, selector) {
    return selector.replace(/\.([^{,\s\d.]+)/g, "." + prefix2 + "$1") + "{";
  });
}
function ref(target, name2) {
  return function(e2) {
    e2 && (target[name2] = e2);
  };
}
function refs(target, name2, i) {
  return function(e2) {
    e2 && (target[name2][i] = e2);
  };
}
function Properties(properties, action) {
  return function(component) {
    var prototype = component.prototype;
    properties.forEach(function(property) {
      action(prototype, property);
    });
  };
}
function withMethods(methods, duplicate) {
  if (duplicate === void 0) {
    duplicate = {};
  }
  return function(prototype, propertyName) {
    methods.forEach(function(name2) {
      var methodName = duplicate[name2] || name2;
      if (methodName in prototype) {
        return;
      }
      prototype[methodName] = function() {
        var _a2;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var result = (_a2 = this[propertyName])[name2].apply(_a2, args);
        if (result === this[propertyName]) {
          return this;
        } else {
          return result;
        }
      };
    });
  };
}
var PolyMap = /* @__PURE__ */ function() {
  function PolyMap2() {
    this.keys = [];
    this.values = [];
  }
  var __proto = PolyMap2.prototype;
  __proto.get = function(key) {
    return this.values[this.keys.indexOf(key)];
  };
  __proto.set = function(key, value) {
    var keys2 = this.keys;
    var values = this.values;
    var prevIndex = keys2.indexOf(key);
    var index2 = prevIndex === -1 ? keys2.length : prevIndex;
    keys2[index2] = key;
    values[index2] = value;
  };
  return PolyMap2;
}();
var HashMap = /* @__PURE__ */ function() {
  function HashMap2() {
    this.object = {};
  }
  var __proto = HashMap2.prototype;
  __proto.get = function(key) {
    return this.object[key];
  };
  __proto.set = function(key, value) {
    this.object[key] = value;
  };
  return HashMap2;
}();
var SUPPORT_MAP = typeof Map === "function";
var Link = /* @__PURE__ */ function() {
  function Link2() {
  }
  var __proto = Link2.prototype;
  __proto.connect = function(prevLink, nextLink) {
    this.prev = prevLink;
    this.next = nextLink;
    prevLink && (prevLink.next = this);
    nextLink && (nextLink.prev = this);
  };
  __proto.disconnect = function() {
    var prevLink = this.prev;
    var nextLink = this.next;
    prevLink && (prevLink.next = nextLink);
    nextLink && (nextLink.prev = prevLink);
  };
  __proto.getIndex = function() {
    var link = this;
    var index2 = -1;
    while (link) {
      link = link.prev;
      ++index2;
    }
    return index2;
  };
  return Link2;
}();
function orderChanged(changed, fixed2) {
  var fromLinks = [];
  var toLinks = [];
  changed.forEach(function(_a2) {
    var from = _a2[0], to = _a2[1];
    var link = new Link();
    fromLinks[from] = link;
    toLinks[to] = link;
  });
  fromLinks.forEach(function(link, i) {
    link.connect(fromLinks[i - 1]);
  });
  return changed.filter(function(_, i) {
    return !fixed2[i];
  }).map(function(_a2, i) {
    var from = _a2[0], to = _a2[1];
    if (from === to) {
      return [0, 0];
    }
    var fromLink = fromLinks[from];
    var toLink = toLinks[to - 1];
    var fromIndex = fromLink.getIndex();
    fromLink.disconnect();
    if (!toLink) {
      fromLink.connect(void 0, fromLinks[0]);
    } else {
      fromLink.connect(toLink, toLink.next);
    }
    var toIndex = fromLink.getIndex();
    return [fromIndex, toIndex];
  });
}
var Result = /* @__PURE__ */ function() {
  function Result2(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed2) {
    this.prevList = prevList;
    this.list = list;
    this.added = added;
    this.removed = removed;
    this.changed = changed;
    this.maintained = maintained;
    this.changedBeforeAdded = changedBeforeAdded;
    this.fixed = fixed2;
  }
  var __proto = Result2.prototype;
  Object.defineProperty(__proto, "ordered", {
    get: function() {
      if (!this.cacheOrdered) {
        this.caculateOrdered();
      }
      return this.cacheOrdered;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(__proto, "pureChanged", {
    get: function() {
      if (!this.cachePureChanged) {
        this.caculateOrdered();
      }
      return this.cachePureChanged;
    },
    enumerable: true,
    configurable: true
  });
  __proto.caculateOrdered = function() {
    var ordered = orderChanged(this.changedBeforeAdded, this.fixed);
    var changed = this.changed;
    var pureChanged = [];
    this.cacheOrdered = ordered.filter(function(_a2, i) {
      var from = _a2[0], to = _a2[1];
      var _b = changed[i], fromBefore = _b[0], toBefore = _b[1];
      if (from !== to) {
        pureChanged.push([fromBefore, toBefore]);
        return true;
      }
    });
    this.cachePureChanged = pureChanged;
  };
  return Result2;
}();
function diff$1(prevList, list, findKeyCallback2) {
  var mapClass = SUPPORT_MAP ? Map : findKeyCallback2 ? HashMap : PolyMap;
  var callback = findKeyCallback2 || function(e2) {
    return e2;
  };
  var added = [];
  var removed = [];
  var maintained = [];
  var prevKeys = prevList.map(callback);
  var keys2 = list.map(callback);
  var prevKeyMap = new mapClass();
  var keyMap = new mapClass();
  var changedBeforeAdded = [];
  var fixed2 = [];
  var removedMap = {};
  var changed = [];
  var addedCount = 0;
  var removedCount = 0;
  prevKeys.forEach(function(key, prevListIndex) {
    prevKeyMap.set(key, prevListIndex);
  });
  keys2.forEach(function(key, listIndex) {
    keyMap.set(key, listIndex);
  });
  prevKeys.forEach(function(key, prevListIndex) {
    var listIndex = keyMap.get(key);
    if (typeof listIndex === "undefined") {
      ++removedCount;
      removed.push(prevListIndex);
    } else {
      removedMap[listIndex] = removedCount;
    }
  });
  keys2.forEach(function(key, listIndex) {
    var prevListIndex = prevKeyMap.get(key);
    if (typeof prevListIndex === "undefined") {
      added.push(listIndex);
      ++addedCount;
    } else {
      maintained.push([prevListIndex, listIndex]);
      removedCount = removedMap[listIndex] || 0;
      changedBeforeAdded.push([prevListIndex - removedCount, listIndex - addedCount]);
      fixed2.push(listIndex === prevListIndex);
      if (prevListIndex !== listIndex) {
        changed.push([prevListIndex, listIndex]);
      }
    }
  });
  removed.reverse();
  return new Result(prevList, list, added, removed, changed, maintained, changedBeforeAdded, fixed2);
}
var ListDiffer = /* @__PURE__ */ function() {
  function ListDiffer2(list, findKeyCallback2) {
    if (list === void 0) {
      list = [];
    }
    this.findKeyCallback = findKeyCallback2;
    this.list = [].slice.call(list);
  }
  var __proto = ListDiffer2.prototype;
  __proto.update = function(list) {
    var newData = [].slice.call(list);
    var result = diff$1(this.list, newData, this.findKeyCallback);
    this.list = newData;
    return result;
  };
  return ListDiffer2;
}();
var RGB = "rgb";
var RGBA = "rgba";
var HSL = "hsl";
var HSLA = "hsla";
var COLOR_MODELS = [RGB, RGBA, HSL, HSLA];
var FUNCTION = "function";
var PROPERTY = "property";
var ARRAY = "array";
var OBJECT = "object";
var STRING = "string";
var NUMBER = "number";
var UNDEFINED = "undefined";
var IS_WINDOW = typeof window !== UNDEFINED;
var doc = typeof document !== UNDEFINED && document;
var prefixes = ["webkit", "ms", "moz", "o"];
var getCrossBrowserProperty = function(property) {
  if (!doc) {
    return "";
  }
  var styles = (doc.body || doc.documentElement).style;
  var length = prefixes.length;
  if (typeof styles[property] !== UNDEFINED) {
    return property;
  }
  for (var i = 0; i < length; ++i) {
    var name2 = "-" + prefixes[i] + "-" + property;
    if (typeof styles[name2] !== UNDEFINED) {
      return name2;
    }
  }
  return "";
};
var TRANSFORM = /* @__PURE__ */ getCrossBrowserProperty("transform");
var FILTER = /* @__PURE__ */ getCrossBrowserProperty("filter");
var ANIMATION = /* @__PURE__ */ getCrossBrowserProperty("animation");
var KEYFRAMES = /* @__PURE__ */ ANIMATION.replace("animation", "keyframes");
var OPEN_CLOSED_CHARACTERS = [{
  open: "(",
  close: ")"
}, {
  open: '"',
  close: '"'
}, {
  open: "'",
  close: "'"
}, {
  open: '\\"',
  close: '\\"'
}, {
  open: "\\'",
  close: "\\'"
}];
var TINY_NUM$1 = 1e-7;
var DEFAULT_UNIT_PRESETS = {
  "cm": function(pos) {
    return pos * 96 / 2.54;
  },
  "mm": function(pos) {
    return pos * 96 / 254;
  },
  "in": function(pos) {
    return pos * 96;
  },
  "pt": function(pos) {
    return pos * 96 / 72;
  },
  "pc": function(pos) {
    return pos * 96 / 6;
  },
  "%": function(pos, size) {
    return pos * size / 100;
  },
  "vw": function(pos, size) {
    if (size === void 0) {
      size = window.innerWidth;
    }
    return pos / 100 * size;
  },
  "vh": function(pos, size) {
    if (size === void 0) {
      size = window.innerHeight;
    }
    return pos / 100 * size;
  },
  "vmax": function(pos, size) {
    if (size === void 0) {
      size = Math.max(window.innerWidth, window.innerHeight);
    }
    return pos / 100 * size;
  },
  "vmin": function(pos, size) {
    if (size === void 0) {
      size = Math.min(window.innerWidth, window.innerHeight);
    }
    return pos / 100 * size;
  }
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __spreadArrays$6() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a2 = arguments[i], j2 = 0, jl = a2.length; j2 < jl; j2++, k++)
      r[k] = a2[j2];
  return r;
}
function dot$1(a1, a2, b1, b2) {
  return (a1 * b2 + a2 * b1) / (b1 + b2);
}
function isUndefined$2(value) {
  return typeof value === UNDEFINED;
}
function isObject$2(value) {
  return value && typeof value === OBJECT;
}
function isArray$1(value) {
  return Array.isArray(value);
}
function isString$2(value) {
  return typeof value === STRING;
}
function isNumber$1(value) {
  return typeof value === NUMBER;
}
function isFunction$2(value) {
  return typeof value === FUNCTION;
}
function isEqualSeparator(character, separator) {
  var isCharacterSpace = character === "" || character == " ";
  var isSeparatorSpace = separator === "" || separator == " ";
  return isSeparatorSpace && isCharacterSpace || character === separator;
}
function findOpen(openCharacter, texts, index2, length, openCloseCharacters) {
  var isIgnore = findIgnore(openCharacter, texts, index2);
  if (!isIgnore) {
    return findClose(openCharacter, texts, index2 + 1, length, openCloseCharacters);
  }
  return index2;
}
function findIgnore(character, texts, index2) {
  if (!character.ignore) {
    return null;
  }
  var otherText = texts.slice(Math.max(index2 - 3, 0), index2 + 3).join("");
  return new RegExp(character.ignore).exec(otherText);
}
function findClose(closeCharacter, texts, index2, length, openCloseCharacters) {
  var _loop_1 = function(i2) {
    var character = texts[i2].trim();
    if (character === closeCharacter.close && !findIgnore(closeCharacter, texts, i2)) {
      return {
        value: i2
      };
    }
    var nextIndex = i2;
    var openCharacter = find$2(openCloseCharacters, function(_a2) {
      var open = _a2.open;
      return open === character;
    });
    if (openCharacter) {
      nextIndex = findOpen(openCharacter, texts, i2, length, openCloseCharacters);
    }
    if (nextIndex === -1) {
      return out_i_1 = i2, "break";
    }
    i2 = nextIndex;
    out_i_1 = i2;
  };
  var out_i_1;
  for (var i = index2; i < length; ++i) {
    var state_1 = _loop_1(i);
    i = out_i_1;
    if (typeof state_1 === "object")
      return state_1.value;
    if (state_1 === "break")
      break;
  }
  return -1;
}
function splitText(text, splitOptions) {
  var _a2 = isString$2(splitOptions) ? {
    separator: splitOptions
  } : splitOptions, _b = _a2.separator, separator = _b === void 0 ? "," : _b, isSeparateFirst = _a2.isSeparateFirst, isSeparateOnlyOpenClose = _a2.isSeparateOnlyOpenClose, _c = _a2.isSeparateOpenClose, isSeparateOpenClose = _c === void 0 ? isSeparateOnlyOpenClose : _c, _d = _a2.openCloseCharacters, openCloseCharacters = _d === void 0 ? OPEN_CLOSED_CHARACTERS : _d;
  var openClosedText = openCloseCharacters.map(function(_a3) {
    var open = _a3.open, close = _a3.close;
    if (open === close) {
      return open;
    }
    return open + "|" + close;
  }).join("|");
  var regexText = "(\\s*" + separator + "\\s*|" + openClosedText + "|\\s+)";
  var regex2 = new RegExp(regexText, "g");
  var texts = text.split(regex2).filter(function(chr) {
    return chr && chr !== "undefined";
  });
  var length = texts.length;
  var values = [];
  var tempValues = [];
  function resetTemp() {
    if (tempValues.length) {
      values.push(tempValues.join(""));
      tempValues = [];
      return true;
    }
    return false;
  }
  var _loop_2 = function(i2) {
    var character = texts[i2].trim();
    var nextIndex = i2;
    var openCharacter = find$2(openCloseCharacters, function(_a3) {
      var open = _a3.open;
      return open === character;
    });
    var closeCharacter = find$2(openCloseCharacters, function(_a3) {
      var close = _a3.close;
      return close === character;
    });
    if (openCharacter) {
      nextIndex = findOpen(openCharacter, texts, i2, length, openCloseCharacters);
      if (nextIndex !== -1 && isSeparateOpenClose) {
        if (resetTemp() && isSeparateFirst) {
          return out_i_2 = i2, "break";
        }
        values.push(texts.slice(i2, nextIndex + 1).join(""));
        i2 = nextIndex;
        if (isSeparateFirst) {
          return out_i_2 = i2, "break";
        }
        return out_i_2 = i2, "continue";
      }
    } else if (closeCharacter && !findIgnore(closeCharacter, texts, i2)) {
      var nextOpenCloseCharacters = __spreadArrays$6(openCloseCharacters);
      nextOpenCloseCharacters.splice(openCloseCharacters.indexOf(closeCharacter), 1);
      return {
        value: splitText(text, {
          separator,
          isSeparateFirst,
          isSeparateOnlyOpenClose,
          isSeparateOpenClose,
          openCloseCharacters: nextOpenCloseCharacters
        })
      };
    } else if (isEqualSeparator(character, separator) && !isSeparateOnlyOpenClose) {
      resetTemp();
      if (isSeparateFirst) {
        return out_i_2 = i2, "break";
      }
      return out_i_2 = i2, "continue";
    }
    if (nextIndex === -1) {
      nextIndex = length - 1;
    }
    tempValues.push(texts.slice(i2, nextIndex + 1).join(""));
    i2 = nextIndex;
    out_i_2 = i2;
  };
  var out_i_2;
  for (var i = 0; i < length; ++i) {
    var state_2 = _loop_2(i);
    i = out_i_2;
    if (typeof state_2 === "object")
      return state_2.value;
    if (state_2 === "break")
      break;
  }
  if (tempValues.length) {
    values.push(tempValues.join(""));
  }
  return values;
}
function splitSpace(text) {
  return splitText(text, "");
}
function splitComma(text) {
  return splitText(text, ",");
}
function splitBracket(text) {
  var matches2 = /([^(]*)\(([\s\S]*)\)([\s\S]*)/g.exec(text);
  if (!matches2 || matches2.length < 4) {
    return {};
  } else {
    return {
      prefix: matches2[1],
      value: matches2[2],
      suffix: matches2[3]
    };
  }
}
function splitUnit(text) {
  var matches2 = /^([^\d|e|\-|\+]*)((?:\d|\.|-|e-|e\+)+)(\S*)$/g.exec(text);
  if (!matches2) {
    return {
      prefix: "",
      unit: "",
      value: NaN
    };
  }
  var prefix2 = matches2[1];
  var value = matches2[2];
  var unit = matches2[3];
  return {
    prefix: prefix2,
    unit,
    value: parseFloat(value)
  };
}
function camelize$1(str) {
  return str.replace(/[\s-_]+([^\s-_])/g, function(all3, letter) {
    return letter.toUpperCase();
  });
}
function decamelize(str, separator) {
  if (separator === void 0) {
    separator = "-";
  }
  return str.replace(/([a-z])([A-Z])/g, function(all3, letter, letter2) {
    return "" + letter + separator + letter2.toLowerCase();
  });
}
function toArray(value) {
  return [].slice.call(value);
}
function now() {
  return Date.now ? Date.now() : new Date().getTime();
}
function findIndex(arr2, callback, defaultIndex) {
  if (defaultIndex === void 0) {
    defaultIndex = -1;
  }
  var length = arr2.length;
  for (var i = 0; i < length; ++i) {
    if (callback(arr2[i], i, arr2)) {
      return i;
    }
  }
  return defaultIndex;
}
function find$2(arr2, callback, defalutValue) {
  var index2 = findIndex(arr2, callback);
  return index2 > -1 ? arr2[index2] : defalutValue;
}
var requestAnimationFrame$1 = /* @__PURE__ */ function() {
  var firstTime = now();
  var raf = IS_WINDOW && (window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame);
  return raf ? raf.bind(window) : function(callback) {
    var currTime = now();
    var id = setTimeout(function() {
      callback(currTime - firstTime);
    }, 1e3 / 60);
    return id;
  };
}();
var cancelAnimationFrame = /* @__PURE__ */ function() {
  var caf = IS_WINDOW && (window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.msCancelAnimationFrame);
  return caf ? caf.bind(window) : function(handle) {
    clearTimeout(handle);
  };
}();
function getKeys(obj) {
  return Object.keys(obj);
}
function sortOrders(keys2, orders) {
  if (orders === void 0) {
    orders = [];
  }
  keys2.sort(function(a2, b) {
    var index1 = orders.indexOf(a2);
    var index2 = orders.indexOf(b);
    if (index2 === -1 && index1 === -1) {
      return 0;
    }
    if (index1 === -1) {
      return 1;
    }
    if (index2 === -1) {
      return -1;
    }
    return index1 - index2;
  });
}
function convertUnitSize(pos, size) {
  var _a2 = splitUnit(pos), value = _a2.value, unit = _a2.unit;
  if (isObject$2(size)) {
    var sizeFunction = size[unit];
    if (sizeFunction) {
      if (isFunction$2(sizeFunction)) {
        return sizeFunction(value);
      } else if (DEFAULT_UNIT_PRESETS[unit]) {
        return DEFAULT_UNIT_PRESETS[unit](value, sizeFunction);
      }
    }
  } else if (unit === "%") {
    return value * size / 100;
  }
  if (DEFAULT_UNIT_PRESETS[unit]) {
    return DEFAULT_UNIT_PRESETS[unit](value);
  }
  return value;
}
function between(value, min, max2) {
  return Math.max(min, Math.min(value, max2));
}
function checkBoundSize(targetSize, compareSize, isMax, ratio) {
  if (ratio === void 0) {
    ratio = targetSize[0] / targetSize[1];
  }
  return [[throttle$3(compareSize[0], TINY_NUM$1), throttle$3(compareSize[0] / ratio, TINY_NUM$1)], [throttle$3(compareSize[1] * ratio, TINY_NUM$1), throttle$3(compareSize[1], TINY_NUM$1)]].filter(function(size) {
    return size.every(function(value, i) {
      var defaultSize = compareSize[i];
      var throttledSize = throttle$3(defaultSize, TINY_NUM$1);
      return isMax ? value <= defaultSize || value <= throttledSize : value >= defaultSize || value >= throttledSize;
    });
  })[0] || targetSize;
}
function calculateBoundSize(size, minSize, maxSize, keepRatio) {
  if (!keepRatio) {
    return size.map(function(value, i) {
      return between(value, minSize[i], maxSize[i]);
    });
  }
  var width = size[0], height = size[1];
  var ratio = keepRatio === true ? width / height : keepRatio;
  var _a2 = checkBoundSize(size, minSize, false, ratio), minWidth = _a2[0], minHeight = _a2[1];
  var _b = checkBoundSize(size, maxSize, true, ratio), maxWidth = _b[0], maxHeight = _b[1];
  if (width < minWidth || height < minHeight) {
    width = minWidth;
    height = minHeight;
  } else if (width > maxWidth || height > maxHeight) {
    width = maxWidth;
    height = maxHeight;
  }
  return [width, height];
}
function sum(nums) {
  var length = nums.length;
  var total = 0;
  for (var i = length - 1; i >= 0; --i) {
    total += nums[i];
  }
  return total;
}
function average(nums) {
  var length = nums.length;
  var total = 0;
  for (var i = length - 1; i >= 0; --i) {
    total += nums[i];
  }
  return length ? total / length : 0;
}
function getRad$1(pos1, pos2) {
  var distX = pos2[0] - pos1[0];
  var distY = pos2[1] - pos1[1];
  var rad = Math.atan2(distY, distX);
  return rad >= 0 ? rad : rad + Math.PI * 2;
}
function getCenterPoint(points) {
  return [0, 1].map(function(i) {
    return average(points.map(function(pos) {
      return pos[i];
    }));
  });
}
function getShapeDirection(points) {
  var center = getCenterPoint(points);
  var pos1Rad = getRad$1(center, points[0]);
  var pos2Rad = getRad$1(center, points[1]);
  return pos1Rad < pos2Rad && pos2Rad - pos1Rad < Math.PI || pos1Rad > pos2Rad && pos2Rad - pos1Rad < -Math.PI ? 1 : -1;
}
function getDist$2(a2, b) {
  return Math.sqrt(Math.pow((b ? b[0] : 0) - a2[0], 2) + Math.pow((b ? b[1] : 0) - a2[1], 2));
}
function throttle$3(num, unit) {
  if (!unit) {
    return num;
  }
  var reverseUnit = 1 / unit;
  return Math.round(num / unit) / reverseUnit;
}
function throttleArray(nums, unit) {
  nums.forEach(function(_, i) {
    nums[i] = throttle$3(nums[i], unit);
  });
  return nums;
}
function cutHex(hex) {
  return hex.replace("#", "");
}
function hexToRGBA(hex) {
  var h2 = cutHex(hex);
  var r = parseInt(h2.substring(0, 2), 16);
  var g = parseInt(h2.substring(2, 4), 16);
  var b = parseInt(h2.substring(4, 6), 16);
  var a2 = parseInt(h2.substring(6, 8), 16) / 255;
  if (isNaN(a2)) {
    a2 = 1;
  }
  return [r, g, b, a2];
}
function toFullHex(h2) {
  var r = h2.charAt(1);
  var g = h2.charAt(2);
  var b = h2.charAt(3);
  var a2 = h2.charAt(4);
  var arr2 = ["#", r, r, g, g, b, b, a2, a2];
  return arr2.join("");
}
function hslToRGBA(hsl2) {
  var _a2;
  var h2 = hsl2[0];
  var s = hsl2[1];
  var l = hsl2[2];
  if (h2 < 0) {
    h2 += Math.floor((Math.abs(h2) + 360) / 360) * 360;
  }
  h2 %= 360;
  var c = (1 - Math.abs(2 * l - 1)) * s;
  var x = c * (1 - Math.abs(h2 / 60 % 2 - 1));
  var m = l - c / 2;
  var rgb2;
  if (h2 < 60) {
    rgb2 = [c, x, 0];
  } else if (h2 < 120) {
    rgb2 = [x, c, 0];
  } else if (h2 < 180) {
    rgb2 = [0, c, x];
  } else if (h2 < 240) {
    rgb2 = [0, x, c];
  } else if (h2 < 300) {
    rgb2 = [x, 0, c];
  } else if (h2 < 360) {
    rgb2 = [c, 0, x];
  } else {
    rgb2 = [0, 0, 0];
  }
  return [Math.round((rgb2[0] + m) * 255), Math.round((rgb2[1] + m) * 255), Math.round((rgb2[2] + m) * 255), (_a2 = hsl2[3]) !== null && _a2 !== void 0 ? _a2 : 1];
}
function stringToRGBA(color2) {
  if (color2.charAt(0) === "#") {
    if (color2.length === 4 || color2.length === 5) {
      return hexToRGBA(toFullHex(color2));
    } else {
      return hexToRGBA(color2);
    }
  } else if (color2.indexOf("(") !== -1) {
    var _a2 = splitBracket(color2), prefix2 = _a2.prefix, value = _a2.value;
    if (!prefix2 || !value) {
      return void 0;
    }
    var arr2 = splitComma(value);
    var colorArr = [0, 0, 0, 1];
    var length = arr2.length;
    switch (prefix2) {
      case RGB:
      case RGBA:
        for (var i = 0; i < length; ++i) {
          colorArr[i] = parseFloat(arr2[i]);
        }
        return colorArr;
      case HSL:
      case HSLA:
        for (var i = 0; i < length; ++i) {
          if (arr2[i].indexOf("%") !== -1) {
            colorArr[i] = parseFloat(arr2[i]) / 100;
          } else {
            colorArr[i] = parseFloat(arr2[i]);
          }
        }
        return hslToRGBA(colorArr);
    }
  }
  return void 0;
}
function $$1(selectors, multi) {
  if (!doc) {
    return multi ? [] : null;
  }
  return multi ? doc.querySelectorAll(selectors) : doc.querySelector(selectors);
}
function hasClass(element, className) {
  if (element.classList) {
    return element.classList.contains(className);
  }
  return !!element.className.match(new RegExp("(\\s|^)" + className + "(\\s|$)"));
}
function addClass(element, className) {
  if (element.classList) {
    element.classList.add(className);
  } else {
    element.className += " " + className;
  }
}
function removeClass(element, className) {
  if (element.classList) {
    element.classList.remove(className);
  } else {
    var reg = new RegExp("(\\s|^)" + className + "(\\s|$)");
    element.className = element.className.replace(reg, " ");
  }
}
function fromCSS(elements, properties) {
  if (!elements || !properties || !properties.length) {
    return {};
  }
  var element;
  if (elements instanceof Element) {
    element = elements;
  } else if (elements.length) {
    element = elements[0];
  } else {
    return {};
  }
  var cssObject = {};
  var styles = getWindow(element).getComputedStyle(element);
  var length = properties.length;
  for (var i = 0; i < length; ++i) {
    cssObject[properties[i]] = styles[properties[i]];
  }
  return cssObject;
}
function addEvent$1(el, type, listener, options) {
  el.addEventListener(type, listener, options);
}
function removeEvent(el, type, listener, options) {
  el.removeEventListener(type, listener, options);
}
function getDocument(el) {
  return (el === null || el === void 0 ? void 0 : el.ownerDocument) || doc;
}
function getWindow(el) {
  var _a2;
  return ((_a2 = el === null || el === void 0 ? void 0 : el.ownerDocument) === null || _a2 === void 0 ? void 0 : _a2.defaultView) || window;
}
function isWindow(val) {
  return val && "postMessage" in val && "blur" in val && "self" in val;
}
function isNode(el) {
  return isObject$2(el) && el.nodeName && el.nodeType && "ownerDocument" in el;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$e = function(d, b) {
  extendStatics$e = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics$e(d, b);
};
function __extends$e(d, b) {
  extendStatics$e(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$d = function() {
  __assign$d = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$d.apply(this, arguments);
};
function __rest$4(s, e2) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __spreadArrays$5() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a2 = arguments[i], j2 = 0, jl = a2.length; j2 < jl; j2++, k++)
      r[k] = a2[j2];
  return r;
}
function isDiff(a2, b) {
  if (a2 === b) {
    return false;
  }
  for (var i in a2) {
    if (!(i in b)) {
      return true;
    }
  }
  for (var i in b) {
    if (a2[i] !== b[i]) {
      return true;
    }
  }
  return false;
}
function diffObject(a2, b) {
  var keys1 = Object.keys(a2);
  var keys2 = Object.keys(b);
  var result = diff$1(keys1, keys2, function(key) {
    return key;
  });
  var added = {};
  var removed = {};
  var changed = {};
  result.added.forEach(function(index2) {
    var name2 = keys2[index2];
    added[name2] = b[name2];
  });
  result.removed.forEach(function(index2) {
    var name2 = keys1[index2];
    removed[name2] = a2[name2];
  });
  result.maintained.forEach(function(_a2) {
    var index2 = _a2[0];
    var name2 = keys1[index2];
    var values = [a2[name2], b[name2]];
    if (a2[name2] !== b[name2]) {
      changed[name2] = values;
    }
  });
  return {
    added,
    removed,
    changed
  };
}
function executeHooks(hooks) {
  hooks.forEach(function(hook) {
    hook();
  });
}
function fillKeys(keys2) {
  var index2 = 0;
  return keys2.map(function(key) {
    return key == null ? "$compat" + ++index2 : "" + key;
  });
}
function createProvider(el, key, index2, container) {
  if (isString$2(el) || isNumber$1(el)) {
    return new TextProvider("text_" + el, key, index2, container, null, {});
  }
  var providerClass = typeof el.type === "string" ? ElementProvider : el.type.prototype.render ? ComponentProvider : FunctionProvider;
  return new providerClass(el.type, key, index2, container, el.ref, el.props);
}
function flat$1(arr2) {
  var arr22 = [];
  arr2.forEach(function(el) {
    arr22 = arr22.concat(isArray$1(el) ? flat$1(el) : el);
  });
  return arr22;
}
function getAttributes(props2) {
  var className = props2.className, otherProps = __rest$4(props2, ["className"]);
  if (className != null) {
    otherProps.class = className;
  }
  delete otherProps.style;
  delete otherProps.children;
  return otherProps;
}
function fillProps(props2, defaultProps) {
  if (!defaultProps) {
    return props2;
  }
  for (var name2 in defaultProps) {
    if (isUndefined$2(props2[name2])) {
      props2[name2] = defaultProps[name2];
    }
  }
  return props2;
}
function createElement$1(type, props2) {
  var children = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    children[_i - 2] = arguments[_i];
  }
  var _a2 = props2 || {}, key = _a2.key, ref2 = _a2.ref, otherProps = __rest$4(_a2, ["key", "ref"]);
  return {
    type,
    key,
    ref: ref2,
    props: __assign$d(__assign$d({}, otherProps), {
      children: flat$1(children).filter(function(child) {
        return child != null && child !== false;
      })
    })
  };
}
var Provider = /* @__PURE__ */ function() {
  function Provider2(type, key, index2, container, ref2, props2) {
    if (props2 === void 0) {
      props2 = {};
    }
    this.type = type;
    this.key = key;
    this.index = index2;
    this.container = container;
    this.ref = ref2;
    this.props = props2;
    this._providers = [];
  }
  var __proto = Provider2.prototype;
  __proto._should = function(nextProps, nextState) {
    return true;
  };
  __proto._update = function(hooks, nextElement, nextState, isForceUpdate) {
    if (this.base && !isString$2(nextElement) && !isForceUpdate && !this._should(nextElement.props, nextState)) {
      return false;
    }
    this.original = nextElement;
    this._setState(nextState);
    var prevProps = this.props;
    if (!isString$2(nextElement)) {
      this.props = nextElement.props;
      this.ref = nextElement.ref;
    }
    this._render(hooks, this.base ? prevProps : {}, nextState);
    return true;
  };
  __proto._mounted = function() {
    var ref2 = this.ref;
    ref2 && ref2(this.base);
  };
  __proto._setState = function(nextstate) {
    return;
  };
  __proto._updated = function() {
    var ref2 = this.ref;
    ref2 && ref2(this.base);
  };
  __proto._destroy = function() {
    var ref2 = this.ref;
    ref2 && ref2(null);
  };
  return Provider2;
}();
function diffAttributes(attrs1, attrs2, el) {
  var _a2 = diffObject(attrs1, attrs2), added = _a2.added, removed = _a2.removed, changed = _a2.changed;
  for (var name2 in added) {
    el.setAttribute(name2, added[name2]);
  }
  for (var name2 in changed) {
    el.setAttribute(name2, changed[name2][1]);
  }
  for (var name2 in removed) {
    el.removeAttribute(name2);
  }
}
function diffEvents(events1, events2, provier) {
  var _a2 = diffObject(events1, events2), added = _a2.added, removed = _a2.removed, changed = _a2.changed;
  for (var name2 in removed) {
    provier.removeEventListener(name2);
  }
  for (var name2 in added) {
    provier.addEventListener(name2, added[name2]);
  }
  for (var name2 in changed) {
    provier.removeEventListener(name2);
    provier.addEventListener(name2, changed[name2][1]);
  }
  for (var name2 in removed) {
    provier.removeEventListener(name2);
  }
}
function diffStyle(style1, style2, el) {
  var style = el.style;
  var _a2 = diffObject(style1, style2), added = _a2.added, removed = _a2.removed, changed = _a2.changed;
  for (var beforeName in added) {
    var name2 = decamelize(beforeName, "-");
    if (style.setProperty) {
      style.setProperty(name2, added[beforeName]);
    } else {
      style[name2] = added[beforeName];
    }
  }
  for (var beforeName in changed) {
    var name2 = decamelize(beforeName, "-");
    if (style.setProperty) {
      style.setProperty(name2, changed[beforeName][1]);
    } else {
      style[name2] = changed[beforeName][1];
    }
  }
  for (var beforeName in removed) {
    var name2 = decamelize(beforeName, "-");
    if (style.removeProperty) {
      style.removeProperty(name2);
    } else {
      style[name2] = "";
    }
  }
}
function splitProps(props2) {
  var attributes = {};
  var events2 = {};
  for (var name2 in props2) {
    if (name2.indexOf("on") === 0) {
      events2[name2.replace("on", "").toLowerCase()] = props2[name2];
    } else {
      attributes[name2] = props2[name2];
    }
  }
  return {
    attributes,
    events: events2
  };
}
var TextProvider = /* @__PURE__ */ function(_super) {
  __extends$e(TextProvider2, _super);
  function TextProvider2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = TextProvider2.prototype;
  __proto._render = function(hooks) {
    var _this = this;
    var isMount = !this.base;
    if (isMount) {
      this.base = document.createTextNode(this.type.replace("text_", ""));
    }
    hooks.push(function() {
      if (isMount) {
        _this._mounted();
      } else {
        _this._updated();
      }
    });
    return true;
  };
  __proto._unmount = function() {
    this.base.parentNode.removeChild(this.base);
  };
  return TextProvider2;
}(Provider);
var ElementProvider = /* @__PURE__ */ function(_super) {
  __extends$e(ElementProvider2, _super);
  function ElementProvider2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.events = {};
    _this._isSVG = false;
    return _this;
  }
  var __proto = ElementProvider2.prototype;
  __proto.addEventListener = function(name2, callback) {
    var events2 = this.events;
    events2[name2] = function(e2) {
      e2.nativeEvent = e2;
      callback(e2);
    };
    this.base.addEventListener(name2, events2[name2]);
  };
  __proto.removeEventListener = function(name2) {
    var events2 = this.events;
    this.base.removeEventListener(name2, events2[name2]);
    delete events2[name2];
  };
  __proto._should = function(nextProps) {
    return isDiff(this.props, nextProps);
  };
  __proto._render = function(hooks, prevProps) {
    var _this = this;
    var isMount = !this.base;
    if (isMount) {
      var isSVG2 = this._hasSVG();
      this._isSVG = isSVG2;
      var element = this.props.portalContainer;
      if (!element) {
        var type = this.type;
        if (isSVG2) {
          element = document.createElementNS("http://www.w3.org/2000/svg", type);
        } else {
          element = document.createElement(type);
        }
      }
      this.base = element;
    }
    renderProviders(this, this._providers, this.props.children, hooks, null);
    var base2 = this.base;
    var _a2 = splitProps(prevProps), prevAttributes = _a2.attributes, prevEvents = _a2.events;
    var _b = splitProps(this.props), nextAttributes = _b.attributes, nextEvents = _b.events;
    diffAttributes(getAttributes(prevAttributes), getAttributes(nextAttributes), base2);
    diffEvents(prevEvents, nextEvents, this);
    diffStyle(prevProps.style || {}, this.props.style || {}, base2);
    hooks.push(function() {
      if (isMount) {
        _this._mounted();
      } else {
        _this._updated();
      }
    });
    return true;
  };
  __proto._unmount = function() {
    var events2 = this.events;
    var base2 = this.base;
    for (var name2 in events2) {
      base2.removeEventListener(name2, events2[name2]);
    }
    this._providers.forEach(function(provider) {
      provider._unmount();
    });
    this.events = {};
    if (!this.props.portalContainer) {
      base2.parentNode.removeChild(base2);
    }
  };
  __proto._hasSVG = function() {
    if (this._isSVG || this.type === "svg") {
      return true;
    }
    var containerNode = findContainerNode(this.container);
    return containerNode && "ownerSVGElement" in containerNode;
  };
  return ElementProvider2;
}(Provider);
function findContainerNode(provider) {
  if (!provider) {
    return null;
  }
  var base2 = provider.base;
  if (base2 instanceof Node) {
    return base2;
  }
  return findContainerNode(provider.container);
}
function findDOMNode(comp) {
  if (!comp) {
    return null;
  }
  if (comp instanceof Node) {
    return comp;
  }
  var providers = comp.$_provider._providers;
  if (!providers.length) {
    return null;
  }
  return findDOMNode(providers[0].base);
}
var FunctionProvider = /* @__PURE__ */ function(_super) {
  __extends$e(FunctionProvider2, _super);
  function FunctionProvider2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = FunctionProvider2.prototype;
  __proto._render = function(hooks) {
    var template = this.type(this.props);
    renderProviders(this, this._providers, template ? [template] : [], hooks);
    return true;
  };
  __proto._unmount = function() {
    this._providers.forEach(function(provider) {
      provider._unmount();
    });
  };
  return FunctionProvider2;
}(Provider);
var ContainerProvider = /* @__PURE__ */ function(_super) {
  __extends$e(ContainerProvider2, _super);
  function ContainerProvider2(base2) {
    var _this = _super.call(this, "container", "container", 0, null) || this;
    _this.base = base2;
    return _this;
  }
  var __proto = ContainerProvider2.prototype;
  __proto._render = function() {
    return true;
  };
  __proto._unmount = function() {
    return;
  };
  return ContainerProvider2;
}(Provider);
var ComponentProvider = /* @__PURE__ */ function(_super) {
  __extends$e(ComponentProvider2, _super);
  function ComponentProvider2(type, key, index2, container, ref2, props2) {
    if (props2 === void 0) {
      props2 = {};
    }
    return _super.call(this, type, key, index2, container, ref2, fillProps(props2, type.defaultProps)) || this;
  }
  var __proto = ComponentProvider2.prototype;
  __proto._should = function(nextProps, nextState) {
    return this.base.shouldComponentUpdate(fillProps(nextProps, this.type.defaultProps), nextState || this.base.state);
  };
  __proto._render = function(hooks, prevProps) {
    var _this = this;
    this.props = fillProps(this.props, this.type.defaultProps);
    var isMount = !this.base;
    if (isMount) {
      this.base = new this.type(this.props);
      this.base.$_provider = this;
    } else {
      this.base.props = this.props;
    }
    var base2 = this.base;
    var prevState = base2.state;
    var template = base2.render();
    if (template && template.props && !template.props.children.length) {
      template.props.children = this.props.children;
    }
    renderProviders(this, this._providers, template ? [template] : [], hooks);
    hooks.push(function() {
      if (isMount) {
        _this._mounted();
        base2.componentDidMount();
      } else {
        _this._updated();
        base2.componentDidUpdate(prevProps, prevState);
      }
    });
  };
  __proto._setState = function(nextState) {
    var base2 = this.base;
    if (!base2 || !nextState) {
      return;
    }
    base2.state = nextState;
  };
  __proto._unmount = function() {
    this._providers.forEach(function(provider) {
      provider._unmount();
    });
    clearTimeout(this.base.$_timer);
    this.base.componentWillUnmount();
  };
  return ComponentProvider2;
}(Provider);
var Component$1 = /* @__PURE__ */ function() {
  function Component2(props2) {
    if (props2 === void 0) {
      props2 = {};
    }
    this.props = props2;
    this.state = {};
    this.$_timer = 0;
    this.$_state = {};
  }
  var __proto = Component2.prototype;
  __proto.shouldComponentUpdate = function(props2, state) {
    return true;
  };
  __proto.render = function() {
    return null;
  };
  __proto.setState = function(state, callback, isForceUpdate) {
    var _this = this;
    if (!this.$_timer) {
      this.$_state = {};
    }
    clearTimeout(this.$_timer);
    this.$_timer = 0;
    this.$_state = __assign$d(__assign$d({}, this.$_state), state);
    if (!isForceUpdate) {
      this.$_timer = setTimeout(function() {
        _this.$_timer = 0;
        _this.$_setState(callback, isForceUpdate);
      });
    } else {
      this.$_setState(callback, isForceUpdate);
    }
    return;
  };
  __proto.forceUpdate = function(callback) {
    this.setState({}, callback, true);
  };
  __proto.componentDidMount = function() {
  };
  __proto.componentDidUpdate = function(prevProps, prevState) {
  };
  __proto.componentWillUnmount = function() {
  };
  __proto.$_setState = function(callback, isForceUpdate) {
    var hooks = [];
    var provider = this.$_provider;
    var isUpdate = renderProviders(provider.container, [provider], [provider.original], hooks, __assign$d(__assign$d({}, this.state), this.$_state), isForceUpdate);
    if (isUpdate) {
      if (callback) {
        hooks.push(callback);
      }
      executeHooks(hooks);
    }
  };
  return Component2;
}();
var PureComponent = /* @__PURE__ */ function(_super) {
  __extends$e(PureComponent2, _super);
  function PureComponent2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = PureComponent2.prototype;
  __proto.shouldComponentUpdate = function(props2, state) {
    return isDiff(this.props, props2) || isDiff(this.state, state);
  };
  return PureComponent2;
}(Component$1);
var _Portal = /* @__PURE__ */ function(_super) {
  __extends$e(_Portal2, _super);
  function _Portal2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  var __proto = _Portal2.prototype;
  __proto.componentDidMount = function() {
    var _a2 = this.props, element = _a2.element, container = _a2.container;
    this._portalProvider = new ContainerProvider(container);
    renderProvider(element, container, this._portalProvider);
  };
  __proto.componentDidUpdate = function() {
    var _a2 = this.props, element = _a2.element, container = _a2.container;
    renderProvider(element, container, this._portalProvider);
  };
  __proto.componentWillUnmount = function() {
    var container = this.props.container;
    renderProvider(null, container, this._portalProvider);
    this._portalProvider = null;
  };
  return _Portal2;
}(PureComponent);
function updateProvider(provider, children, nextState) {
  var hooks = [];
  renderProviders(provider, provider._providers, children, hooks, nextState);
  executeHooks(hooks);
}
function getNextSibiling(provider, childProvider) {
  var childProviders = provider._providers;
  var length = childProviders.length;
  for (var i = childProvider.index + 1; i < length; ++i) {
    var el = findDOMNode(childProviders[i].base);
    if (el) {
      return el;
    }
  }
  return null;
}
function diffProviders(containerProvider, providers, children) {
  var childrenKeys = children.map(function(p) {
    return isString$2(p) ? null : p.key;
  });
  var keys1 = fillKeys(providers.map(function(p) {
    return p.key;
  }));
  var keys2 = fillKeys(childrenKeys);
  var result = diff$1(keys1, keys2, function(key) {
    return key;
  });
  result.removed.forEach(function(index2) {
    providers.splice(index2, 1)[0]._unmount();
  });
  result.ordered.forEach(function(_a2) {
    var from = _a2[0], to = _a2[1];
    var childrenProvider = providers.splice(from, 1)[0];
    providers.splice(to, 0, childrenProvider);
    var el = findDOMNode(childrenProvider.base);
    var next = findDOMNode(providers[to + 1] && providers[to + 1].base);
    if (el) {
      el.parentNode.insertBefore(el, next);
    }
  });
  result.added.forEach(function(index2) {
    providers.splice(index2, 0, createProvider(children[index2], childrenKeys[index2], index2, containerProvider));
  });
  var changed = result.maintained.filter(function(_a2) {
    _a2[0];
    var to = _a2[1];
    var el = children[to];
    var childProvider = providers[to];
    var type = isString$2(el) ? "text_" + el : el.type;
    if (type !== childProvider.type) {
      childProvider._unmount();
      providers.splice(to, 1, createProvider(el, childrenKeys[to], to, containerProvider));
      return true;
    }
    childProvider.index = to;
    return false;
  });
  return __spreadArrays$5(result.added, changed.map(function(_a2) {
    _a2[0];
    var to = _a2[1];
    return to;
  }));
}
function renderProviders(containerProvider, providers, children, updatedHooks, nextState, isForceUpdate) {
  var result = diffProviders(containerProvider, providers, children);
  var updated = providers.filter(function(childProvider, i) {
    return childProvider._update(updatedHooks, children[i], nextState, isForceUpdate);
  });
  var containerNode = findContainerNode(containerProvider);
  if (containerNode) {
    result.reverse().forEach(function(index2) {
      var childProvider = providers[index2];
      var el = findDOMNode(childProvider.base);
      if (!el) {
        return;
      }
      if (containerNode !== el && !el.parentNode) {
        var nextElement = getNextSibiling(containerProvider, childProvider);
        containerNode.insertBefore(el, nextElement);
      }
    });
  }
  return updated.length > 0;
}
function renderProvider(element, container, provider) {
  if (provider === void 0) {
    provider = container.__REACT_COMPAT__;
  }
  var isProvider = !!provider;
  if (!provider) {
    provider = new ContainerProvider(container);
  }
  updateProvider(provider, element ? [element] : []);
  if (!isProvider) {
    container.__REACT_COMPAT__ = provider;
  }
  return provider;
}
function render(element, container, callback) {
  var provider = container.__REACT_COMPAT__;
  if (element && !provider) {
    container.innerHTML = "";
  }
  renderProvider(element, container, provider);
  callback && callback();
}
function createPortal(el, container) {
  return createElement$1(_Portal, {
    element: el,
    container
  });
}
var version$2 = "simple-1.1.0";
function some(arr2, callback) {
  var length = arr2.length;
  for (var i = 0; i < length; ++i) {
    if (callback(arr2[i], i)) {
      return true;
    }
  }
  return false;
}
function find$1(arr2, callback) {
  var length = arr2.length;
  for (var i = 0; i < length; ++i) {
    if (callback(arr2[i], i)) {
      return arr2[i];
    }
  }
  return null;
}
function getUserAgentString(agent2) {
  var userAgent2 = agent2;
  if (typeof userAgent2 === "undefined") {
    if (typeof navigator === "undefined" || !navigator) {
      return "";
    }
    userAgent2 = navigator.userAgent || "";
  }
  return userAgent2.toLowerCase();
}
function execRegExp(pattern, text) {
  try {
    return new RegExp(pattern, "g").exec(text);
  } catch (e2) {
    return null;
  }
}
function hasUserAgentData() {
  if (typeof navigator === "undefined" || !navigator || !navigator.userAgentData) {
    return false;
  }
  var userAgentData = navigator.userAgentData;
  var brands = userAgentData.brands || userAgentData.uaList;
  return !!(brands && brands.length);
}
function findVersion(versionTest, userAgent2) {
  var result = execRegExp("(" + versionTest + ")((?:\\/|\\s|:)([0-9|\\.|_]+))", userAgent2);
  return result ? result[3] : "";
}
function convertVersion(text) {
  return text.replace(/_/g, ".");
}
function findPreset(presets, userAgent2) {
  var userPreset = null;
  var version2 = "-1";
  some(presets, function(preset) {
    var result = execRegExp("(" + preset.test + ")((?:\\/|\\s|:)([0-9|\\.|_]+))?", userAgent2);
    if (!result || preset.brand) {
      return false;
    }
    userPreset = preset;
    version2 = result[3] || "-1";
    if (preset.versionAlias) {
      version2 = preset.versionAlias;
    } else if (preset.versionTest) {
      version2 = findVersion(preset.versionTest.toLowerCase(), userAgent2) || version2;
    }
    version2 = convertVersion(version2);
    return true;
  });
  return {
    preset: userPreset,
    version: version2
  };
}
function findPresetBrand(presets, brands) {
  var brandInfo = {
    brand: "",
    version: "-1"
  };
  some(presets, function(preset) {
    var result = findBrand(brands, preset);
    if (!result) {
      return false;
    }
    brandInfo.brand = preset.id;
    brandInfo.version = preset.versionAlias || result.version;
    return brandInfo.version !== "-1";
  });
  return brandInfo;
}
function findBrand(brands, preset) {
  return find$1(brands, function(_a2) {
    var brand = _a2.brand;
    return execRegExp("" + preset.test, brand.toLowerCase());
  });
}
var BROWSER_PRESETS = [{
  test: "phantomjs",
  id: "phantomjs"
}, {
  test: "whale",
  id: "whale"
}, {
  test: "edgios|edge|edg",
  id: "edge"
}, {
  test: "msie|trident|windows phone",
  id: "ie",
  versionTest: "iemobile|msie|rv"
}, {
  test: "miuibrowser",
  id: "miui browser"
}, {
  test: "samsungbrowser",
  id: "samsung internet"
}, {
  test: "samsung",
  id: "samsung internet",
  versionTest: "version"
}, {
  test: "chrome|crios",
  id: "chrome"
}, {
  test: "firefox|fxios",
  id: "firefox"
}, {
  test: "android",
  id: "android browser",
  versionTest: "version"
}, {
  test: "safari|iphone|ipad|ipod",
  id: "safari",
  versionTest: "version"
}];
var CHROMIUM_PRESETS = [{
  test: "(?=.*applewebkit/(53[0-7]|5[0-2]|[0-4]))(?=.*\\schrome)",
  id: "chrome",
  versionTest: "chrome"
}, {
  test: "chromium",
  id: "chrome"
}, {
  test: "whale",
  id: "chrome",
  versionAlias: "-1",
  brand: true
}];
var WEBKIT_PRESETS = [{
  test: "applewebkit",
  id: "webkit",
  versionTest: "applewebkit|safari"
}];
var WEBVIEW_PRESETS = [{
  test: "(?=(iphone|ipad))(?!(.*version))",
  id: "webview"
}, {
  test: "(?=(android|iphone|ipad))(?=.*(naver|daum|; wv))",
  id: "webview"
}, {
  test: "webview",
  id: "webview"
}];
var OS_PRESETS = [{
  test: "windows phone",
  id: "windows phone"
}, {
  test: "windows 2000",
  id: "window",
  versionAlias: "5.0"
}, {
  test: "windows nt",
  id: "window"
}, {
  test: "win32|windows",
  id: "window"
}, {
  test: "iphone|ipad|ipod",
  id: "ios",
  versionTest: "iphone os|cpu os"
}, {
  test: "macos|macintel|mac os x",
  id: "mac"
}, {
  test: "android|linux armv81",
  id: "android"
}, {
  test: "tizen",
  id: "tizen"
}, {
  test: "webos|web0s",
  id: "webos"
}];
function isWebView(userAgent2) {
  return !!findPreset(WEBVIEW_PRESETS, userAgent2).preset;
}
function getLegacyAgent(userAgent2) {
  var nextAgent = getUserAgentString(userAgent2);
  var isMobile = !!/mobi/g.exec(nextAgent);
  var browser2 = {
    name: "unknown",
    version: "-1",
    majorVersion: -1,
    webview: isWebView(nextAgent),
    chromium: false,
    chromiumVersion: "-1",
    webkit: false,
    webkitVersion: "-1"
  };
  var os = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  var _a2 = findPreset(BROWSER_PRESETS, nextAgent), browserPreset = _a2.preset, browserVersion = _a2.version;
  var _b = findPreset(OS_PRESETS, nextAgent), osPreset = _b.preset, osVersion = _b.version;
  var chromiumPreset = findPreset(CHROMIUM_PRESETS, nextAgent);
  browser2.chromium = !!chromiumPreset.preset;
  browser2.chromiumVersion = chromiumPreset.version;
  if (!browser2.chromium) {
    var webkitPreset = findPreset(WEBKIT_PRESETS, nextAgent);
    browser2.webkit = !!webkitPreset.preset;
    browser2.webkitVersion = webkitPreset.version;
  }
  if (osPreset) {
    os.name = osPreset.id;
    os.version = osVersion;
    os.majorVersion = parseInt(osVersion, 10);
  }
  if (browserPreset) {
    browser2.name = browserPreset.id;
    browser2.version = browserVersion;
    if (browser2.webview && os.name === "ios" && browser2.name !== "safari") {
      browser2.webview = false;
    }
  }
  browser2.majorVersion = parseInt(browser2.version, 10);
  return {
    browser: browser2,
    os,
    isMobile,
    isHints: false
  };
}
function getClientHintsAgent(osData) {
  var userAgentData = navigator.userAgentData;
  var brands = (userAgentData.uaList || userAgentData.brands).slice();
  var fullVersionList = osData && osData.fullVersionList;
  var isMobile = userAgentData.mobile || false;
  var firstBrand = brands[0];
  var platform = (osData && osData.platform || userAgentData.platform || navigator.platform).toLowerCase();
  var browser2 = {
    name: firstBrand.brand,
    version: firstBrand.version,
    majorVersion: -1,
    webkit: false,
    webkitVersion: "-1",
    chromium: false,
    chromiumVersion: "-1",
    webview: !!findPresetBrand(WEBVIEW_PRESETS, brands).brand || isWebView(getUserAgentString())
  };
  var os = {
    name: "unknown",
    version: "-1",
    majorVersion: -1
  };
  browser2.webkit = !browser2.chromium && some(WEBKIT_PRESETS, function(preset) {
    return findBrand(brands, preset);
  });
  var chromiumBrand = findPresetBrand(CHROMIUM_PRESETS, brands);
  browser2.chromium = !!chromiumBrand.brand;
  browser2.chromiumVersion = chromiumBrand.version;
  if (!browser2.chromium) {
    var webkitBrand = findPresetBrand(WEBKIT_PRESETS, brands);
    browser2.webkit = !!webkitBrand.brand;
    browser2.webkitVersion = webkitBrand.version;
  }
  var platfomResult = find$1(OS_PRESETS, function(preset) {
    return new RegExp("" + preset.test, "g").exec(platform);
  });
  os.name = platfomResult ? platfomResult.id : "";
  if (osData) {
    os.version = osData.platformVersion;
  }
  if (fullVersionList && fullVersionList.length) {
    var browserBrandByFullVersionList = findPresetBrand(BROWSER_PRESETS, fullVersionList);
    browser2.name = browserBrandByFullVersionList.brand || browser2.name;
    browser2.version = browserBrandByFullVersionList.version || browser2.version;
  } else {
    var browserBrand = findPresetBrand(BROWSER_PRESETS, brands);
    browser2.name = browserBrand.brand || browser2.name;
    browser2.version = browserBrand.brand && osData ? osData.uaFullVersion : browserBrand.version;
  }
  if (browser2.webkit) {
    os.name = isMobile ? "ios" : "mac";
  }
  if (os.name === "ios" && browser2.webview) {
    browser2.version = "-1";
  }
  os.version = convertVersion(os.version);
  browser2.version = convertVersion(browser2.version);
  os.majorVersion = parseInt(os.version, 10);
  browser2.majorVersion = parseInt(browser2.version, 10);
  return {
    browser: browser2,
    os,
    isMobile,
    isHints: true
  };
}
function agent$1(userAgent2) {
  if (typeof userAgent2 === "undefined" && hasUserAgentData()) {
    return getClientHintsAgent();
  } else {
    return getLegacyAgent(userAgent2);
  }
}
function add(matrix2, inverseMatrix, startIndex, fromIndex, n, k) {
  for (var i = 0; i < n; ++i) {
    var x = startIndex + i * n;
    var fromX = fromIndex + i * n;
    matrix2[x] += matrix2[fromX] * k;
    inverseMatrix[x] += inverseMatrix[fromX] * k;
  }
}
function swap(matrix2, inverseMatrix, startIndex, fromIndex, n) {
  for (var i = 0; i < n; ++i) {
    var x = startIndex + i * n;
    var fromX = fromIndex + i * n;
    var v = matrix2[x];
    var iv = inverseMatrix[x];
    matrix2[x] = matrix2[fromX];
    matrix2[fromX] = v;
    inverseMatrix[x] = inverseMatrix[fromX];
    inverseMatrix[fromX] = iv;
  }
}
function divide(matrix2, inverseMatrix, startIndex, n, k) {
  for (var i = 0; i < n; ++i) {
    var x = startIndex + i * n;
    matrix2[x] /= k;
    inverseMatrix[x] /= k;
  }
}
function ignoreDimension(matrix2, m, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix2.length);
  }
  var newMatrix = matrix2.slice();
  for (var i = 0; i < n; ++i) {
    newMatrix[i * n + m - 1] = 0;
    newMatrix[(m - 1) * n + i] = 0;
  }
  newMatrix[(m - 1) * (n + 1)] = 1;
  return newMatrix;
}
function invert(matrix2, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix2.length);
  }
  var newMatrix = matrix2.slice();
  var inverseMatrix = createIdentityMatrix(n);
  for (var i = 0; i < n; ++i) {
    var identityIndex = n * i + i;
    if (!throttle$3(newMatrix[identityIndex], TINY_NUM$1)) {
      for (var j2 = i + 1; j2 < n; ++j2) {
        if (newMatrix[n * i + j2]) {
          swap(newMatrix, inverseMatrix, i, j2, n);
          break;
        }
      }
    }
    if (!throttle$3(newMatrix[identityIndex], TINY_NUM$1)) {
      return [];
    }
    divide(newMatrix, inverseMatrix, i, n, newMatrix[identityIndex]);
    for (var j2 = 0; j2 < n; ++j2) {
      var targetStartIndex = j2;
      var targetIndex = j2 + i * n;
      var target = newMatrix[targetIndex];
      if (!throttle$3(target, TINY_NUM$1) || i === j2) {
        continue;
      }
      add(newMatrix, inverseMatrix, targetStartIndex, i, n, -target);
    }
  }
  return inverseMatrix;
}
function transpose(matrix2, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix2.length);
  }
  var newMatrix = [];
  for (var i = 0; i < n; ++i) {
    for (var j2 = 0; j2 < n; ++j2) {
      newMatrix[j2 * n + i] = matrix2[n * i + j2];
    }
  }
  return newMatrix;
}
function getOrigin(matrix2, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix2.length);
  }
  var originMatrix = [];
  var w = matrix2[n * n - 1];
  for (var i = 0; i < n - 1; ++i) {
    originMatrix[i] = matrix2[n * (n - 1) + i] / w;
  }
  originMatrix[n - 1] = 0;
  return originMatrix;
}
function fromTranslation(pos, n) {
  var newMatrix = createIdentityMatrix(n);
  for (var i = 0; i < n - 1; ++i) {
    newMatrix[n * (n - 1) + i] = pos[i] || 0;
  }
  return newMatrix;
}
function convertPositionMatrix(matrix2, n) {
  var newMatrix = matrix2.slice();
  for (var i = matrix2.length; i < n - 1; ++i) {
    newMatrix[i] = 0;
  }
  newMatrix[n - 1] = 1;
  return newMatrix;
}
function convertDimension(matrix2, n, m) {
  if (n === void 0) {
    n = Math.sqrt(matrix2.length);
  }
  if (n === m) {
    return matrix2;
  }
  var newMatrix = createIdentityMatrix(m);
  var length = Math.min(n, m);
  for (var i = 0; i < length - 1; ++i) {
    for (var j2 = 0; j2 < length - 1; ++j2) {
      newMatrix[i * m + j2] = matrix2[i * n + j2];
    }
    newMatrix[(i + 1) * m - 1] = matrix2[(i + 1) * n - 1];
    newMatrix[(m - 1) * m + i] = matrix2[(n - 1) * n + i];
  }
  newMatrix[m * m - 1] = matrix2[n * n - 1];
  return newMatrix;
}
function multiplies(n) {
  var matrixes = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    matrixes[_i - 1] = arguments[_i];
  }
  var m = createIdentityMatrix(n);
  matrixes.forEach(function(matrix2) {
    m = multiply(m, matrix2, n);
  });
  return m;
}
function multiply(matrix2, matrix22, n) {
  if (n === void 0) {
    n = Math.sqrt(matrix2.length);
  }
  var newMatrix = [];
  var m = matrix2.length / n;
  var k = matrix22.length / m;
  if (!m) {
    return matrix22;
  } else if (!k) {
    return matrix2;
  }
  for (var i = 0; i < n; ++i) {
    for (var j2 = 0; j2 < k; ++j2) {
      newMatrix[j2 * n + i] = 0;
      for (var l = 0; l < m; ++l) {
        newMatrix[j2 * n + i] += matrix2[l * n + i] * matrix22[j2 * m + l];
      }
    }
  }
  return newMatrix;
}
function plus(pos1, pos2) {
  var length = Math.min(pos1.length, pos2.length);
  var nextPos = pos1.slice();
  for (var i = 0; i < length; ++i) {
    nextPos[i] = nextPos[i] + pos2[i];
  }
  return nextPos;
}
function minus(pos1, pos2) {
  var length = Math.min(pos1.length, pos2.length);
  var nextPos = pos1.slice();
  for (var i = 0; i < length; ++i) {
    nextPos[i] = nextPos[i] - pos2[i];
  }
  return nextPos;
}
function convertCSStoMatrix(a2, is2d) {
  if (is2d === void 0) {
    is2d = a2.length === 6;
  }
  if (is2d) {
    return [a2[0], a2[1], 0, a2[2], a2[3], 0, a2[4], a2[5], 1];
  }
  return a2;
}
function convertMatrixtoCSS(a2, is2d) {
  if (is2d === void 0) {
    is2d = a2.length === 9;
  }
  if (is2d) {
    return [a2[0], a2[1], a2[3], a2[4], a2[6], a2[7]];
  }
  return a2;
}
function calculate(matrix2, matrix22, n) {
  if (n === void 0) {
    n = matrix22.length;
  }
  var result = multiply(matrix2, matrix22, n);
  var k = result[n - 1];
  return result.map(function(v) {
    return v / k;
  });
}
function rotateX3d(matrix2, rad) {
  return multiply(matrix2, [1, 0, 0, 0, 0, Math.cos(rad), Math.sin(rad), 0, 0, -Math.sin(rad), Math.cos(rad), 0, 0, 0, 0, 1], 4);
}
function rotateY3d(matrix2, rad) {
  return multiply(matrix2, [Math.cos(rad), 0, -Math.sin(rad), 0, 0, 1, 0, 0, Math.sin(rad), 0, Math.cos(rad), 0, 0, 0, 0, 1], 4);
}
function rotateZ3d(matrix2, rad) {
  return multiply(matrix2, createRotateMatrix(rad, 4));
}
function scale3d(matrix2, _a2) {
  var _b = _a2[0], sx = _b === void 0 ? 1 : _b, _c = _a2[1], sy = _c === void 0 ? 1 : _c, _d = _a2[2], sz = _d === void 0 ? 1 : _d;
  return multiply(matrix2, [sx, 0, 0, 0, 0, sy, 0, 0, 0, 0, sz, 0, 0, 0, 0, 1], 4);
}
function rotate(pos, rad) {
  return calculate(createRotateMatrix(rad, 3), convertPositionMatrix(pos, 3));
}
function translate3d(matrix2, _a2) {
  var _b = _a2[0], tx = _b === void 0 ? 0 : _b, _c = _a2[1], ty = _c === void 0 ? 0 : _c, _d = _a2[2], tz = _d === void 0 ? 0 : _d;
  return multiply(matrix2, [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, tx, ty, tz, 1], 4);
}
function matrix3d$1(matrix1, matrix2) {
  return multiply(matrix1, matrix2, 4);
}
function createRotateMatrix(rad, n) {
  var cos = Math.cos(rad);
  var sin = Math.sin(rad);
  var m = createIdentityMatrix(n);
  m[0] = cos;
  m[1] = sin;
  m[n] = -sin;
  m[n + 1] = cos;
  return m;
}
function createIdentityMatrix(n) {
  var length = n * n;
  var matrix2 = [];
  for (var i = 0; i < length; ++i) {
    matrix2[i] = i % (n + 1) ? 0 : 1;
  }
  return matrix2;
}
function createScaleMatrix(scale, n) {
  var m = createIdentityMatrix(n);
  var length = Math.min(scale.length, n - 1);
  for (var i = 0; i < length; ++i) {
    m[(n + 1) * i] = scale[i];
  }
  return m;
}
function createOriginMatrix(origin, n) {
  var m = createIdentityMatrix(n);
  var length = Math.min(origin.length, n - 1);
  for (var i = 0; i < length; ++i) {
    m[n * (n - 1) + i] = origin[i];
  }
  return m;
}
function createWarpMatrix(pos0, pos1, pos2, pos3, nextPos0, nextPos1, nextPos2, nextPos3) {
  var x0 = pos0[0], y0 = pos0[1];
  var x1 = pos1[0], y1 = pos1[1];
  var x2 = pos2[0], y2 = pos2[1];
  var x3 = pos3[0], y3 = pos3[1];
  var u0 = nextPos0[0], v0 = nextPos0[1];
  var u1 = nextPos1[0], v1 = nextPos1[1];
  var u2 = nextPos2[0], v2 = nextPos2[1];
  var u3 = nextPos3[0], v3 = nextPos3[1];
  var matrix2 = [x0, 0, x1, 0, x2, 0, x3, 0, y0, 0, y1, 0, y2, 0, y3, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, x0, 0, x1, 0, x2, 0, x3, 0, y0, 0, y1, 0, y2, 0, y3, 0, 1, 0, 1, 0, 1, 0, 1, -u0 * x0, -v0 * x0, -u1 * x1, -v1 * x1, -u2 * x2, -v2 * x2, -u3 * x3, -v3 * x3, -u0 * y0, -v0 * y0, -u1 * y1, -v1 * y1, -u2 * y2, -v2 * y2, -u3 * y3, -v3 * y3];
  var inverseMatrix = invert(matrix2, 8);
  if (!inverseMatrix.length) {
    return [];
  }
  var h2 = multiply(inverseMatrix, [u0, v0, u1, v1, u2, v2, u3, v3], 8);
  h2[8] = 1;
  return convertDimension(transpose(h2), 3, 4);
}
var __assign$c = function() {
  __assign$c = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$c.apply(this, arguments);
};
function createMatrix() {
  return [
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1,
    0,
    0,
    0,
    0,
    1
  ];
}
function parseMat(transform2, size) {
  if (size === void 0) {
    size = 0;
  }
  return toMat(parse$1(transform2, size));
}
function calculateMatrixDist(matrix2, pos) {
  var res = calculate(matrix2, [pos[0], pos[1] || 0, pos[2] || 0, 1], 4);
  var w = res[3] || 1;
  return [
    res[0] / w,
    res[1] / w,
    res[2] / w
  ];
}
function getDistElementMatrix(el, container) {
  if (container === void 0) {
    container = document.body;
  }
  var target = el;
  var matrix2 = createMatrix();
  while (target) {
    var transform2 = getComputedStyle(target).transform;
    matrix2 = matrix3d$1(parseMat(transform2), matrix2);
    if (target === container) {
      break;
    }
    target = target.parentElement;
  }
  matrix2 = invert(matrix2, 4);
  matrix2[12] = 0;
  matrix2[13] = 0;
  matrix2[14] = 0;
  return matrix2;
}
function toMat(matrixInfos) {
  var target = createMatrix();
  matrixInfos.forEach(function(info) {
    var matrixFunction = info.matrixFunction, functionValue = info.functionValue;
    if (!matrixFunction) {
      return;
    }
    target = matrixFunction(target, functionValue);
  });
  return target;
}
function parse$1(transform2, size) {
  if (size === void 0) {
    size = 0;
  }
  var transforms = isArray$1(transform2) ? transform2 : splitSpace(transform2);
  return transforms.map(function(t) {
    var _a2 = splitBracket(t), name2 = _a2.prefix, value = _a2.value;
    var matrixFunction = null;
    var functionName = name2;
    var functionValue = "";
    if (name2 === "translate" || name2 === "translateX" || name2 === "translate3d") {
      var nextSize_1 = isObject$2(size) ? __assign$c(__assign$c({}, size), { "o%": size["%"] }) : {
        "%": size,
        "o%": size
      };
      var _b = splitComma(value).map(function(v, i) {
        if (i === 0 && "x%" in nextSize_1) {
          nextSize_1["%"] = size["x%"];
        } else if (i === 1 && "y%" in nextSize_1) {
          nextSize_1["%"] = size["y%"];
        } else {
          nextSize_1["%"] = size["o%"];
        }
        return convertUnitSize(v, nextSize_1);
      }), posX = _b[0], _c = _b[1], posY = _c === void 0 ? 0 : _c, _d = _b[2], posZ = _d === void 0 ? 0 : _d;
      matrixFunction = translate3d;
      functionValue = [posX, posY, posZ];
    } else if (name2 === "translateY") {
      var nextSize = isObject$2(size) ? __assign$c({ "%": size["y%"] }, size) : {
        "%": size
      };
      var posY = convertUnitSize(value, nextSize);
      matrixFunction = translate3d;
      functionValue = [0, posY, 0];
    } else if (name2 === "translateZ") {
      var posZ = parseFloat(value);
      matrixFunction = translate3d;
      functionValue = [0, 0, posZ];
    } else if (name2 === "scale" || name2 === "scale3d") {
      var _e = splitComma(value).map(function(v) {
        return parseFloat(v);
      }), sx = _e[0], _f = _e[1], sy = _f === void 0 ? sx : _f, _g = _e[2], sz = _g === void 0 ? 1 : _g;
      matrixFunction = scale3d;
      functionValue = [sx, sy, sz];
    } else if (name2 === "scaleX") {
      var sx = parseFloat(value);
      matrixFunction = scale3d;
      functionValue = [sx, 1, 1];
    } else if (name2 === "scaleY") {
      var sy = parseFloat(value);
      matrixFunction = scale3d;
      functionValue = [1, sy, 1];
    } else if (name2 === "scaleZ") {
      var sz = parseFloat(value);
      matrixFunction = scale3d;
      functionValue = [1, 1, sz];
    } else if (name2 === "rotate" || name2 === "rotateZ" || name2 === "rotateX" || name2 === "rotateY") {
      var _h = splitUnit(value), unit = _h.unit, unitValue = _h.value;
      var rad = unit === "rad" ? unitValue : unitValue * Math.PI / 180;
      if (name2 === "rotate" || name2 === "rotateZ") {
        functionName = "rotateZ";
        matrixFunction = rotateZ3d;
      } else if (name2 === "rotateX") {
        matrixFunction = rotateX3d;
      } else if (name2 === "rotateY") {
        matrixFunction = rotateY3d;
      }
      functionValue = rad;
    } else if (name2 === "matrix3d") {
      matrixFunction = matrix3d$1;
      functionValue = splitComma(value).map(function(v) {
        return parseFloat(v);
      });
    } else if (name2 === "matrix") {
      var m = splitComma(value).map(function(v) {
        return parseFloat(v);
      });
      matrixFunction = matrix3d$1;
      functionValue = [
        m[0],
        m[1],
        0,
        0,
        m[2],
        m[3],
        0,
        0,
        0,
        0,
        1,
        0,
        m[4],
        m[5],
        0,
        1
      ];
    } else {
      functionName = "";
    }
    return {
      name: name2,
      functionName,
      value,
      matrixFunction,
      functionValue
    };
  });
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __spreadArrays$4() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a2 = arguments[i], j2 = 0, jl = a2.length; j2 < jl; j2++, k++)
      r[k] = a2[j2];
  return r;
}
function tinyThrottle(num) {
  return throttle$3(num, TINY_NUM$1);
}
function isSameConstants(linearConstants1, linearConstants2) {
  return linearConstants1.every(function(v, i) {
    return tinyThrottle(v - linearConstants2[i]) === 0;
  });
}
function isSamePoint(point1, point2) {
  return !tinyThrottle(point1[0] - point2[0]) && !tinyThrottle(point1[1] - point2[1]);
}
function getAreaSize(points) {
  if (points.length < 3) {
    return 0;
  }
  return Math.abs(sum(points.map(function(point, i) {
    var nextPoint = points[i + 1] || points[0];
    return point[0] * nextPoint[1] - nextPoint[0] * point[1];
  }))) / 2;
}
function fitPoints(points, rect) {
  var width = rect.width, height = rect.height, left = rect.left, top = rect.top;
  var _a2 = getMinMaxs(points), minX = _a2.minX, minY = _a2.minY, maxX = _a2.maxX, maxY = _a2.maxY;
  var ratioX = width / (maxX - minX);
  var ratioY = height / (maxY - minY);
  return points.map(function(point) {
    return [left + (point[0] - minX) * ratioX, top + (point[1] - minY) * ratioY];
  });
}
function getMinMaxs(points) {
  var xs = points.map(function(point) {
    return point[0];
  });
  var ys = points.map(function(point) {
    return point[1];
  });
  return {
    minX: Math.min.apply(Math, xs),
    minY: Math.min.apply(Math, ys),
    maxX: Math.max.apply(Math, xs),
    maxY: Math.max.apply(Math, ys)
  };
}
function isInside(pos, points, excludeLine) {
  var x = pos[0], y = pos[1];
  var _a2 = getMinMaxs(points), minX = _a2.minX, maxX = _a2.maxX;
  var xLine = [[minX, y], [maxX, y]];
  var xLinearConstants = getLinearConstants(xLine[0], xLine[1]);
  var lines = convertLines(points);
  var intersectionPosInfos = [];
  lines.forEach(function(line) {
    var linearConstants = getLinearConstants(line[0], line[1]);
    var standardPoint = line[0];
    if (isSameConstants(xLinearConstants, linearConstants)) {
      intersectionPosInfos.push({
        pos,
        line,
        type: "line"
      });
    } else {
      var xPoints = getPointsOnLines(getIntersectionPointsByConstants(xLinearConstants, linearConstants), [xLine, line]);
      xPoints.forEach(function(point) {
        if (line.some(function(linePoint) {
          return isSamePoint(linePoint, point);
        })) {
          intersectionPosInfos.push({
            pos: point,
            line,
            type: "point"
          });
        } else if (tinyThrottle(standardPoint[1] - y) !== 0) {
          intersectionPosInfos.push({
            pos: point,
            line,
            type: "intersection"
          });
        }
      });
    }
  });
  if (!excludeLine) {
    if (find$2(intersectionPosInfos, function(p) {
      return p[0] === x;
    })) {
      return true;
    }
  }
  var intersectionCount = 0;
  var xMap = {};
  intersectionPosInfos.forEach(function(_a3) {
    var pos2 = _a3.pos, type = _a3.type, line = _a3.line;
    if (pos2[0] > x) {
      return;
    }
    if (type === "intersection") {
      ++intersectionCount;
    } else if (type === "line") {
      return;
    } else if (type === "point") {
      var point = find$2(line, function(linePoint) {
        return linePoint[1] !== y;
      });
      var prevValue = xMap[pos2[0]];
      var nextValue = point[1] > y ? 1 : -1;
      if (!prevValue) {
        xMap[pos2[0]] = nextValue;
      } else if (prevValue !== nextValue) {
        ++intersectionCount;
      }
    }
  });
  return intersectionCount % 2 === 1;
}
function getLinearConstants(point1, point2) {
  var x1 = point1[0], y1 = point1[1];
  var x2 = point2[0], y2 = point2[1];
  var dx = x2 - x1;
  var dy = y2 - y1;
  if (Math.abs(dx) < TINY_NUM$1) {
    dx = 0;
  }
  if (Math.abs(dy) < TINY_NUM$1) {
    dy = 0;
  }
  var a2 = 0;
  var b = 0;
  var c = 0;
  if (!dx) {
    if (dy) {
      a2 = -1;
      c = x1;
    }
  } else if (!dy) {
    b = 1;
    c = -y1;
  } else {
    a2 = -dy / dx;
    b = 1;
    c = -a2 * x1 - y1;
  }
  return [a2, b, c];
}
function getIntersectionPointsByConstants(linearConstants1, linearConstants2) {
  var a1 = linearConstants1[0], b1 = linearConstants1[1], c1 = linearConstants1[2];
  var a2 = linearConstants2[0], b2 = linearConstants2[1], c2 = linearConstants2[2];
  var isZeroA = a1 === 0 && a2 === 0;
  var isZeroB = b1 === 0 && b2 === 0;
  var results = [];
  if (isZeroA && isZeroB) {
    return [];
  } else if (isZeroA) {
    var y1 = -c1 / b1;
    var y2 = -c2 / b2;
    if (y1 !== y2) {
      return [];
    } else {
      return [[-Infinity, y1], [Infinity, y1]];
    }
  } else if (isZeroB) {
    var x1 = -c1 / a1;
    var x2 = -c2 / a2;
    if (x1 !== x2) {
      return [];
    } else {
      return [[x1, -Infinity], [x1, Infinity]];
    }
  } else if (a1 === 0) {
    var y = -c1 / b1;
    var x = -(b2 * y + c2) / a2;
    results = [[x, y]];
  } else if (a2 === 0) {
    var y = -c2 / b2;
    var x = -(b1 * y + c1) / a1;
    results = [[x, y]];
  } else if (b1 === 0) {
    var x = -c1 / a1;
    var y = -(a2 * x + c2) / b2;
    results = [[x, y]];
  } else if (b2 === 0) {
    var x = -c2 / a2;
    var y = -(a1 * x + c1) / b1;
    results = [[x, y]];
  } else {
    var x = (b1 * c2 - b2 * c1) / (b2 * a1 - b1 * a2);
    var y = -(a1 * x + c1) / b1;
    results = [[x, y]];
  }
  return results.map(function(result) {
    return [result[0], result[1]];
  });
}
function getPointsOnLines(points, lines) {
  var minMaxs = lines.map(function(line) {
    return [0, 1].map(function(order) {
      return [Math.min(line[0][order], line[1][order]), Math.max(line[0][order], line[1][order])];
    });
  });
  var results = [];
  if (points.length === 2) {
    var _a2 = points[0], x = _a2[0], y = _a2[1];
    if (!tinyThrottle(x - points[1][0])) {
      var top = Math.max.apply(Math, minMaxs.map(function(minMax) {
        return minMax[1][0];
      }));
      var bottom = Math.min.apply(Math, minMaxs.map(function(minMax) {
        return minMax[1][1];
      }));
      if (tinyThrottle(top - bottom) > 0) {
        return [];
      }
      results = [[x, top], [x, bottom]];
    } else if (!tinyThrottle(y - points[1][1])) {
      var left = Math.max.apply(Math, minMaxs.map(function(minMax) {
        return minMax[0][0];
      }));
      var right = Math.min.apply(Math, minMaxs.map(function(minMax) {
        return minMax[0][1];
      }));
      if (tinyThrottle(left - right) > 0) {
        return [];
      }
      results = [[left, y], [right, y]];
    }
  }
  if (!results.length) {
    results = points.filter(function(point) {
      var pointX = point[0], pointY = point[1];
      return minMaxs.every(function(minMax) {
        return 0 <= tinyThrottle(pointX - minMax[0][0]) && 0 <= tinyThrottle(minMax[0][1] - pointX) && 0 <= tinyThrottle(pointY - minMax[1][0]) && 0 <= tinyThrottle(minMax[1][1] - pointY);
      });
    });
  }
  return results.map(function(result) {
    return [tinyThrottle(result[0]), tinyThrottle(result[1])];
  });
}
function convertLines(points) {
  return __spreadArrays$4(points.slice(1), [points[0]]).map(function(point, i) {
    return [points[i], point];
  });
}
function getOverlapPointInfos(points1, points2) {
  var targetPoints1 = points1.slice();
  var targetPoints2 = points2.slice();
  if (getShapeDirection(targetPoints1) === -1) {
    targetPoints1.reverse();
  }
  if (getShapeDirection(targetPoints2) === -1) {
    targetPoints2.reverse();
  }
  var lines1 = convertLines(targetPoints1);
  var lines2 = convertLines(targetPoints2);
  var linearConstantsList1 = lines1.map(function(line1) {
    return getLinearConstants(line1[0], line1[1]);
  });
  var linearConstantsList2 = lines2.map(function(line2) {
    return getLinearConstants(line2[0], line2[1]);
  });
  var overlapInfos = [];
  linearConstantsList1.forEach(function(linearConstants1, i) {
    var line1 = lines1[i];
    var linePointInfos = [];
    linearConstantsList2.forEach(function(linearConstants2, j2) {
      var intersectionPoints = getIntersectionPointsByConstants(linearConstants1, linearConstants2);
      var points = getPointsOnLines(intersectionPoints, [line1, lines2[j2]]);
      linePointInfos.push.apply(linePointInfos, points.map(function(pos) {
        return {
          index1: i,
          index2: j2,
          pos,
          type: "intersection"
        };
      }));
    });
    linePointInfos.sort(function(a2, b) {
      return getDist$2(line1[0], a2.pos) - getDist$2(line1[0], b.pos);
    });
    overlapInfos.push.apply(overlapInfos, linePointInfos);
    if (isInside(line1[1], targetPoints2)) {
      overlapInfos.push({
        index1: i,
        index2: -1,
        pos: line1[1],
        type: "inside"
      });
    }
  });
  lines2.forEach(function(line2, i) {
    if (!isInside(line2[1], targetPoints1)) {
      return;
    }
    var isNext = false;
    var index2 = findIndex(overlapInfos, function(_a2) {
      var index22 = _a2.index2;
      if (index22 === i) {
        isNext = true;
        return false;
      }
      if (isNext) {
        return true;
      }
      return false;
    });
    if (index2 === -1) {
      isNext = false;
      index2 = findIndex(overlapInfos, function(_a2) {
        var index1 = _a2.index1, index22 = _a2.index2;
        if (index1 === -1 && index22 + 1 === i) {
          isNext = true;
          return false;
        }
        if (isNext) {
          return true;
        }
        return false;
      });
    }
    if (index2 === -1) {
      overlapInfos.push({
        index1: -1,
        index2: i,
        pos: line2[1],
        type: "inside"
      });
    } else {
      overlapInfos.splice(index2, 0, {
        index1: -1,
        index2: i,
        pos: line2[1],
        type: "inside"
      });
    }
  });
  var pointMap = {};
  return overlapInfos.filter(function(_a2) {
    var pos = _a2.pos;
    var key = pos[0] + "x" + pos[1];
    if (pointMap[key]) {
      return false;
    }
    pointMap[key] = true;
    return true;
  });
}
function getOverlapPoints(points1, points2) {
  var infos = getOverlapPointInfos(points1, points2);
  return infos.map(function(_a2) {
    var pos = _a2.pos;
    return pos;
  });
}
function getOverlapSize(points1, points2) {
  var points = getOverlapPoints(points1, points2);
  return getAreaSize(points);
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$d = function(d, b) {
  extendStatics$d = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics$d(d, b);
};
function __extends$d(d, b) {
  extendStatics$d(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var findKeyCallback = typeof Map === "function" ? void 0 : function() {
  var childrenCount = 0;
  return function(el) {
    return el.__DIFF_KEY__ || (el.__DIFF_KEY__ = ++childrenCount);
  };
}();
var ChildrenDiffer = /* @__PURE__ */ function(_super) {
  __extends$d(ChildrenDiffer2, _super);
  function ChildrenDiffer2(list) {
    if (list === void 0) {
      list = [];
    }
    return _super.call(this, list, findKeyCallback) || this;
  }
  return ChildrenDiffer2;
}(ListDiffer);
function diff(prevList, list) {
  return diff$1(prevList, list, findKeyCallback);
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$b = function() {
  __assign$b = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$b.apply(this, arguments);
};
function __spreadArrays$3() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a2 = arguments[i], j2 = 0, jl = a2.length; j2 < jl; j2++, k++)
      r[k] = a2[j2];
  return r;
}
var EventEmitter$2 = /* @__PURE__ */ function() {
  function EventEmitter2() {
    this._events = {};
  }
  var __proto = EventEmitter2.prototype;
  __proto.on = function(eventName, listener) {
    if (isObject$2(eventName)) {
      for (var name2 in eventName) {
        this.on(name2, eventName[name2]);
      }
    } else {
      this._addEvent(eventName, listener, {});
    }
    return this;
  };
  __proto.off = function(eventName, listener) {
    if (!eventName) {
      this._events = {};
    } else if (isObject$2(eventName)) {
      for (var name2 in eventName) {
        this.off(name2);
      }
    } else if (!listener) {
      this._events[eventName] = [];
    } else {
      var events2 = this._events[eventName];
      if (events2) {
        var index2 = findIndex(events2, function(e2) {
          return e2.listener === listener;
        });
        if (index2 > -1) {
          events2.splice(index2, 1);
        }
      }
    }
    return this;
  };
  __proto.once = function(eventName, listener) {
    var _this = this;
    if (listener) {
      this._addEvent(eventName, listener, {
        once: true
      });
    }
    return new Promise(function(resolve) {
      _this._addEvent(eventName, resolve, {
        once: true
      });
    });
  };
  __proto.emit = function(eventName, param) {
    var _this = this;
    if (param === void 0) {
      param = {};
    }
    var events2 = this._events[eventName];
    if (!eventName || !events2) {
      return true;
    }
    var isStop = false;
    param.eventType = eventName;
    param.stop = function() {
      isStop = true;
    };
    param.currentTarget = this;
    __spreadArrays$3(events2).forEach(function(info) {
      info.listener(param);
      if (info.once) {
        _this.off(eventName, info.listener);
      }
    });
    return !isStop;
  };
  __proto.trigger = function(eventName, param) {
    if (param === void 0) {
      param = {};
    }
    return this.emit(eventName, param);
  };
  __proto._addEvent = function(eventName, listener, options) {
    var events2 = this._events;
    events2[eventName] = events2[eventName] || [];
    var listeners = events2[eventName];
    listeners.push(__assign$b({
      listener
    }, options));
  };
  return EventEmitter2;
}();
var EventEmitter$3 = EventEmitter$2;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$c = function(d, b) {
  extendStatics$c = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics$c(d, b);
};
function __extends$c(d, b) {
  extendStatics$c(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$a = function() {
  __assign$a = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$a.apply(this, arguments);
};
function getDefaultScrollPosition$1(e2) {
  var container = e2.container;
  if (container === document.body) {
    return [container.scrollLeft || document.documentElement.scrollLeft, container.scrollTop || document.documentElement.scrollTop];
  }
  return [container.scrollLeft, container.scrollTop];
}
function checkDefaultScrollEvent(container, callback) {
  container.addEventListener("scroll", callback);
  return function() {
    container.removeEventListener("scroll", callback);
  };
}
function getContainerElement(container) {
  if (!container) {
    return null;
  } else if (isString$2(container)) {
    return document.querySelector(container);
  }
  if (isFunction$2(container)) {
    return container();
  } else if (container instanceof Element) {
    return container;
  } else if ("current" in container) {
    return container.current;
  } else if ("value" in container) {
    return container.value;
  }
}
var DragScroll = /* @__PURE__ */ function(_super) {
  __extends$c(DragScroll2, _super);
  function DragScroll2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this._startRect = null;
    _this._startPos = [];
    _this._prevTime = 0;
    _this._timer = 0;
    _this._prevScrollPos = [0, 0];
    _this._isWait = false;
    _this._flag = false;
    _this._currentOptions = null;
    _this._lock = false;
    _this._unregister = null;
    _this._onScroll = function() {
      var options = _this._currentOptions;
      if (_this._lock || !options) {
        return;
      }
      _this.emit("scrollDrag", {
        next: function(inputEvent) {
          _this.checkScroll({
            container: options.container,
            inputEvent
          });
        }
      });
    };
    return _this;
  }
  var __proto = DragScroll2.prototype;
  __proto.dragStart = function(e2, options) {
    var container = getContainerElement(options.container);
    if (!container) {
      this._flag = false;
      return;
    }
    var top = 0;
    var left = 0;
    var width = 0;
    var height = 0;
    if (container === document.body) {
      width = window.innerWidth;
      height = window.innerHeight;
    } else {
      var rect = container.getBoundingClientRect();
      top = rect.top;
      left = rect.left;
      width = rect.width;
      height = rect.height;
    }
    this._flag = true;
    this._startPos = [e2.clientX, e2.clientY];
    this._startRect = {
      top,
      left,
      width,
      height
    };
    this._prevScrollPos = this._getScrollPosition([0, 0], options);
    this._currentOptions = options;
    this._registerScrollEvent(options);
  };
  __proto.drag = function(e2, options) {
    clearTimeout(this._timer);
    if (!this._flag) {
      return;
    }
    var clientX = e2.clientX, clientY = e2.clientY;
    var _a2 = options.threshold, threshold = _a2 === void 0 ? 0 : _a2;
    var _b = this, _startRect = _b._startRect, _startPos = _b._startPos;
    this._currentOptions = options;
    var direction2 = [0, 0];
    if (_startRect.top > clientY - threshold) {
      if (_startPos[1] > _startRect.top || clientY < _startPos[1]) {
        direction2[1] = -1;
      }
    } else if (_startRect.top + _startRect.height < clientY + threshold) {
      if (_startPos[1] < _startRect.top + _startRect.height || clientY > _startPos[1]) {
        direction2[1] = 1;
      }
    }
    if (_startRect.left > clientX - threshold) {
      if (_startPos[0] > _startRect.left || clientX < _startPos[0]) {
        direction2[0] = -1;
      }
    } else if (_startRect.left + _startRect.width < clientX + threshold) {
      if (_startPos[0] < _startRect.left + _startRect.width || clientX > _startPos[0]) {
        direction2[0] = 1;
      }
    }
    if (!direction2[0] && !direction2[1]) {
      return false;
    }
    return this._continueDrag(__assign$a(__assign$a({}, options), {
      direction: direction2,
      inputEvent: e2,
      isDrag: true
    }));
  };
  __proto.checkScroll = function(options) {
    var _this = this;
    if (this._isWait) {
      return false;
    }
    var _a2 = options.prevScrollPos, prevScrollPos = _a2 === void 0 ? this._prevScrollPos : _a2, direction2 = options.direction, _b = options.throttleTime, throttleTime = _b === void 0 ? 0 : _b, inputEvent = options.inputEvent, isDrag2 = options.isDrag;
    var nextScrollPos = this._getScrollPosition(direction2 || [0, 0], options);
    var offsetX = nextScrollPos[0] - prevScrollPos[0];
    var offsetY = nextScrollPos[1] - prevScrollPos[1];
    var nextDirection = direction2 || [offsetX ? Math.abs(offsetX) / offsetX : 0, offsetY ? Math.abs(offsetY) / offsetY : 0];
    this._prevScrollPos = nextScrollPos;
    this._lock = false;
    if (!offsetX && !offsetY) {
      return false;
    }
    this.emit("move", {
      offsetX: nextDirection[0] ? offsetX : 0,
      offsetY: nextDirection[1] ? offsetY : 0,
      inputEvent
    });
    if (throttleTime && isDrag2) {
      clearTimeout(this._timer);
      this._timer = window.setTimeout(function() {
        _this._continueDrag(options);
      }, throttleTime);
    }
    return true;
  };
  __proto.dragEnd = function() {
    this._flag = false;
    this._lock = false;
    clearTimeout(this._timer);
    this._unregisterScrollEvent();
  };
  __proto._getScrollPosition = function(direction2, options) {
    var container = options.container, _a2 = options.getScrollPosition, getScrollPosition = _a2 === void 0 ? getDefaultScrollPosition$1 : _a2;
    return getScrollPosition({
      container: getContainerElement(container),
      direction: direction2
    });
  };
  __proto._continueDrag = function(options) {
    var _this = this;
    var _a2;
    var container = options.container, direction2 = options.direction, throttleTime = options.throttleTime, useScroll = options.useScroll, isDrag2 = options.isDrag, inputEvent = options.inputEvent;
    if (!this._flag || isDrag2 && this._isWait) {
      return;
    }
    var nowTime = now();
    var distTime = Math.max(throttleTime + this._prevTime - nowTime, 0);
    if (distTime > 0) {
      clearTimeout(this._timer);
      this._timer = window.setTimeout(function() {
        _this._continueDrag(options);
      }, distTime);
      return false;
    }
    this._prevTime = nowTime;
    var prevScrollPos = this._getScrollPosition(direction2, options);
    this._prevScrollPos = prevScrollPos;
    if (isDrag2) {
      this._isWait = true;
    }
    if (!useScroll) {
      this._lock = true;
    }
    var param = {
      container: getContainerElement(container),
      direction: direction2,
      inputEvent
    };
    (_a2 = options.requestScroll) === null || _a2 === void 0 ? void 0 : _a2.call(options, param);
    this.emit("scroll", param);
    this._isWait = false;
    return useScroll || this.checkScroll(__assign$a(__assign$a({}, options), {
      prevScrollPos,
      direction: direction2,
      inputEvent
    }));
  };
  __proto._registerScrollEvent = function(options) {
    this._unregisterScrollEvent();
    var checkScrollEvent = options.checkScrollEvent;
    if (!checkScrollEvent) {
      return;
    }
    var callback = checkScrollEvent === true ? checkDefaultScrollEvent : checkScrollEvent;
    var container = getContainerElement(options.container);
    if (checkScrollEvent === true && (container === document.body || container === document.documentElement)) {
      this._unregister = checkDefaultScrollEvent(window, this._onScroll);
    } else {
      this._unregister = callback(container, this._onScroll);
    }
  };
  __proto._unregisterScrollEvent = function() {
    var _a2;
    (_a2 = this._unregister) === null || _a2 === void 0 ? void 0 : _a2.call(this);
    this._unregister = null;
  };
  return DragScroll2;
}(EventEmitter$3);
var DragScroll$1 = DragScroll;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$b = function(d, b) {
  extendStatics$b = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics$b(d, b);
};
function __extends$b(d, b) {
  extendStatics$b(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$9 = function() {
  __assign$9 = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$9.apply(this, arguments);
};
function getRad(pos1, pos2) {
  var distX = pos2[0] - pos1[0];
  var distY = pos2[1] - pos1[1];
  var rad = Math.atan2(distY, distX);
  return rad >= 0 ? rad : rad + Math.PI * 2;
}
function getRotatiion(touches) {
  return getRad([
    touches[0].clientX,
    touches[0].clientY
  ], [
    touches[1].clientX,
    touches[1].clientY
  ]) / Math.PI * 180;
}
function isMultiTouch(e2) {
  return e2.touches && e2.touches.length >= 2;
}
function getEventClients(e2) {
  if (!e2) {
    return [];
  }
  if (e2.touches) {
    return getClients(e2.touches);
  } else {
    return [getClient$1(e2)];
  }
}
function isMouseEvent(e2) {
  return e2 && (e2.type.indexOf("mouse") > -1 || "button" in e2);
}
function getPosition(clients, prevClients, startClients) {
  var length = startClients.length;
  var _a2 = getAverageClient(clients, length), clientX = _a2.clientX, clientY = _a2.clientY, originalClientX = _a2.originalClientX, originalClientY = _a2.originalClientY;
  var _b = getAverageClient(prevClients, length), prevX = _b.clientX, prevY = _b.clientY;
  var _c = getAverageClient(startClients, length), startX = _c.clientX, startY = _c.clientY;
  var deltaX = clientX - prevX;
  var deltaY = clientY - prevY;
  var distX = clientX - startX;
  var distY = clientY - startY;
  return {
    clientX: originalClientX,
    clientY: originalClientY,
    deltaX,
    deltaY,
    distX,
    distY
  };
}
function getDist$1(clients) {
  return Math.sqrt(Math.pow(clients[0].clientX - clients[1].clientX, 2) + Math.pow(clients[0].clientY - clients[1].clientY, 2));
}
function getClients(touches) {
  var length = Math.min(touches.length, 2);
  var clients = [];
  for (var i = 0; i < length; ++i) {
    clients.push(getClient$1(touches[i]));
  }
  return clients;
}
function getClient$1(e2) {
  return {
    clientX: e2.clientX,
    clientY: e2.clientY
  };
}
function getAverageClient(clients, length) {
  if (length === void 0) {
    length = clients.length;
  }
  var sumClient = {
    clientX: 0,
    clientY: 0,
    originalClientX: 0,
    originalClientY: 0
  };
  for (var i = 0; i < length; ++i) {
    var client = clients[i];
    sumClient.originalClientX += "originalClientX" in client ? client.originalClientX : client.clientX;
    sumClient.originalClientY += "originalClientY" in client ? client.originalClientY : client.clientY;
    sumClient.clientX += client.clientX;
    sumClient.clientY += client.clientY;
  }
  if (!length) {
    return sumClient;
  }
  return {
    clientX: sumClient.clientX / length,
    clientY: sumClient.clientY / length,
    originalClientX: sumClient.originalClientX / length,
    originalClientY: sumClient.originalClientY / length
  };
}
var ClientStore = /* @__PURE__ */ function() {
  function ClientStore2(clients) {
    this.prevClients = [];
    this.startClients = [];
    this.movement = 0;
    this.length = 0;
    this.startClients = clients;
    this.prevClients = clients;
    this.length = clients.length;
  }
  ClientStore2.prototype.getAngle = function(clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }
    return getRotatiion(clients);
  };
  ClientStore2.prototype.getRotation = function(clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }
    return getRotatiion(clients) - getRotatiion(this.startClients);
  };
  ClientStore2.prototype.getPosition = function(clients, isAdd) {
    if (clients === void 0) {
      clients = this.prevClients;
    }
    var position2 = getPosition(clients || this.prevClients, this.prevClients, this.startClients);
    var deltaX = position2.deltaX, deltaY = position2.deltaY;
    this.movement += Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    this.prevClients = clients;
    return position2;
  };
  ClientStore2.prototype.getPositions = function(clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }
    var prevClients = this.prevClients;
    return this.startClients.map(function(startClient, i) {
      return getPosition([clients[i]], [prevClients[i]], [startClient]);
    });
  };
  ClientStore2.prototype.getMovement = function(clients) {
    var movement = this.movement;
    if (!clients) {
      return movement;
    }
    var currentClient = getAverageClient(clients, this.length);
    var prevClient = getAverageClient(this.prevClients, this.length);
    var deltaX = currentClient.clientX - prevClient.clientX;
    var deltaY = currentClient.clientY - prevClient.clientY;
    return Math.sqrt(deltaX * deltaX + deltaY * deltaY) + movement;
  };
  ClientStore2.prototype.getDistance = function(clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }
    return getDist$1(clients);
  };
  ClientStore2.prototype.getScale = function(clients) {
    if (clients === void 0) {
      clients = this.prevClients;
    }
    return getDist$1(clients) / getDist$1(this.startClients);
  };
  ClientStore2.prototype.move = function(deltaX, deltaY) {
    this.startClients.forEach(function(client) {
      client.clientX -= deltaX;
      client.clientY -= deltaY;
    });
    this.prevClients.forEach(function(client) {
      client.clientX -= deltaX;
      client.clientY -= deltaY;
    });
  };
  return ClientStore2;
}();
var INPUT_TAGNAMES = ["textarea", "input"];
var Gesto = /* @__PURE__ */ function(_super) {
  __extends$b(Gesto2, _super);
  function Gesto2(targets, options) {
    if (options === void 0) {
      options = {};
    }
    var _this = _super.call(this) || this;
    _this.options = {};
    _this.flag = false;
    _this.pinchFlag = false;
    _this.data = {};
    _this.isDrag = false;
    _this.isPinch = false;
    _this.clientStores = [];
    _this.targets = [];
    _this.prevTime = 0;
    _this.doubleFlag = false;
    _this._useMouse = false;
    _this._useTouch = false;
    _this._useDrag = false;
    _this._dragFlag = false;
    _this._isTrusted = false;
    _this._isMouseEvent = false;
    _this._isSecondaryButton = false;
    _this._preventMouseEvent = false;
    _this._prevInputEvent = null;
    _this._isDragAPI = false;
    _this._isIdle = true;
    _this._window = window;
    _this.onDragStart = function(e2, isTrusted) {
      if (isTrusted === void 0) {
        isTrusted = true;
      }
      if (!_this.flag && e2.cancelable === false) {
        return;
      }
      var isDragAPI = e2.type.indexOf("drag") >= -1;
      if (_this.flag && isDragAPI) {
        return;
      }
      _this._isDragAPI = true;
      var _a3 = _this.options, container2 = _a3.container, pinchOutside = _a3.pinchOutside, preventWheelClick = _a3.preventWheelClick, preventRightClick = _a3.preventRightClick, preventDefault = _a3.preventDefault, checkInput = _a3.checkInput, dragFocusedInput = _a3.dragFocusedInput, preventClickEventOnDragStart = _a3.preventClickEventOnDragStart, preventClickEventOnDrag = _a3.preventClickEventOnDrag, preventClickEventByCondition = _a3.preventClickEventByCondition;
      var useTouch = _this._useTouch;
      var isDragStart = !_this.flag;
      _this._isSecondaryButton = e2.which === 3 || e2.button === 2;
      if (preventWheelClick && (e2.which === 2 || e2.button === 1) || preventRightClick && (e2.which === 3 || e2.button === 2)) {
        _this.stop();
        return false;
      }
      if (isDragStart) {
        var activeElement = _this._window.document.activeElement;
        var target = e2.target;
        if (target) {
          var tagName = target.tagName.toLowerCase();
          var hasInput = INPUT_TAGNAMES.indexOf(tagName) > -1;
          var hasContentEditable = target.isContentEditable;
          if (hasInput || hasContentEditable) {
            if (checkInput || !dragFocusedInput && activeElement === target) {
              return false;
            }
            if (activeElement && (activeElement === target || hasContentEditable && activeElement.isContentEditable && activeElement.contains(target))) {
              if (dragFocusedInput) {
                target.blur();
              } else {
                return false;
              }
            }
          } else if ((preventDefault || e2.type === "touchstart") && activeElement) {
            var activeTagName = activeElement.tagName.toLowerCase();
            if (activeElement.isContentEditable || INPUT_TAGNAMES.indexOf(activeTagName) > -1) {
              activeElement.blur();
            }
          }
          if (preventClickEventOnDragStart || preventClickEventOnDrag || preventClickEventByCondition) {
            addEvent$1(_this._window, "click", _this._onClick, true);
          }
        }
        _this.clientStores = [new ClientStore(getEventClients(e2))];
        _this._isIdle = false;
        _this.flag = true;
        _this.isDrag = false;
        _this._isTrusted = isTrusted;
        _this._dragFlag = true;
        _this._prevInputEvent = e2;
        _this.data = {};
        _this.doubleFlag = now() - _this.prevTime < 200;
        _this._isMouseEvent = isMouseEvent(e2);
        if (!_this._isMouseEvent && _this._preventMouseEvent) {
          _this._preventMouseEvent = false;
        }
        var result = _this._preventMouseEvent || _this.emit("dragStart", __assign$9(__assign$9({ data: _this.data, datas: _this.data, inputEvent: e2, isMouseEvent: _this._isMouseEvent, isSecondaryButton: _this._isSecondaryButton, isTrusted, isDouble: _this.doubleFlag }, _this.getCurrentStore().getPosition()), { preventDefault: function() {
          e2.preventDefault();
        }, preventDrag: function() {
          _this._dragFlag = false;
        } }));
        if (result === false) {
          _this.stop();
        }
        if (_this._isMouseEvent && _this.flag && preventDefault) {
          e2.preventDefault();
        }
      }
      if (!_this.flag) {
        return false;
      }
      var timer = 0;
      if (isDragStart) {
        _this._attchDragEvent();
        if (useTouch && pinchOutside) {
          timer = setTimeout(function() {
            addEvent$1(container2, "touchstart", _this.onDragStart, {
              passive: false
            });
          });
        }
      } else if (useTouch && pinchOutside) {
        removeEvent(container2, "touchstart", _this.onDragStart);
      }
      if (_this.flag && isMultiTouch(e2)) {
        clearTimeout(timer);
        if (isDragStart && e2.touches.length !== e2.changedTouches.length) {
          return;
        }
        if (!_this.pinchFlag) {
          _this.onPinchStart(e2);
        }
      }
    };
    _this.onDrag = function(e2, isScroll) {
      if (!_this.flag) {
        return;
      }
      var preventDefault = _this.options.preventDefault;
      if (!_this._isMouseEvent && preventDefault) {
        e2.preventDefault();
      }
      _this._prevInputEvent = e2;
      var clients = getEventClients(e2);
      var result = _this.moveClients(clients, e2, false);
      if (_this._dragFlag) {
        if (_this.pinchFlag || result.deltaX || result.deltaY) {
          var dragResult = _this._preventMouseEvent || _this.emit("drag", __assign$9(__assign$9({}, result), { isScroll: !!isScroll, inputEvent: e2 }));
          if (dragResult === false) {
            _this.stop();
            return;
          }
        }
        if (_this.pinchFlag) {
          _this.onPinch(e2, clients);
        }
      }
      _this.getCurrentStore().getPosition(clients, true);
    };
    _this.onDragEnd = function(e2) {
      if (!_this.flag) {
        return;
      }
      var _a3 = _this.options, pinchOutside = _a3.pinchOutside, container2 = _a3.container, preventClickEventOnDrag = _a3.preventClickEventOnDrag, preventClickEventOnDragStart = _a3.preventClickEventOnDragStart, preventClickEventByCondition = _a3.preventClickEventByCondition;
      var isDrag2 = _this.isDrag;
      if (preventClickEventOnDrag || preventClickEventOnDragStart || preventClickEventByCondition) {
        requestAnimationFrame(function() {
          _this._allowClickEvent();
        });
      }
      if (!preventClickEventByCondition && !preventClickEventOnDragStart && preventClickEventOnDrag && !isDrag2) {
        _this._allowClickEvent();
      }
      if (_this._useTouch && pinchOutside) {
        removeEvent(container2, "touchstart", _this.onDragStart);
      }
      if (_this.pinchFlag) {
        _this.onPinchEnd(e2);
      }
      var clients = (e2 === null || e2 === void 0 ? void 0 : e2.touches) ? getEventClients(e2) : [];
      var clientsLength = clients.length;
      if (clientsLength === 0 || !_this.options.keepDragging) {
        _this.flag = false;
      } else {
        _this._addStore(new ClientStore(clients));
      }
      var position2 = _this._getPosition();
      var currentTime = now();
      var isDouble = !isDrag2 && _this.doubleFlag;
      _this._prevInputEvent = null;
      _this.prevTime = isDrag2 || isDouble ? 0 : currentTime;
      if (!_this.flag) {
        _this._dettachDragEvent();
        _this._preventMouseEvent || _this.emit("dragEnd", __assign$9({ data: _this.data, datas: _this.data, isDouble, isDrag: isDrag2, isClick: !isDrag2, isMouseEvent: _this._isMouseEvent, isSecondaryButton: _this._isSecondaryButton, inputEvent: e2, isTrusted: _this._isTrusted }, position2));
        _this.clientStores = [];
        if (!_this._isMouseEvent) {
          _this._preventMouseEvent = true;
          requestAnimationFrame(function() {
            requestAnimationFrame(function() {
              _this._preventMouseEvent = false;
            });
          });
        }
        _this._isIdle = true;
      }
    };
    _this.onBlur = function() {
      _this.onDragEnd();
    };
    _this._allowClickEvent = function() {
      removeEvent(_this._window, "click", _this._onClick, true);
    };
    _this._onClick = function(e2) {
      _this._allowClickEvent();
      _this._preventMouseEvent = false;
      var preventClickEventByCondition = _this.options.preventClickEventByCondition;
      if (preventClickEventByCondition === null || preventClickEventByCondition === void 0 ? void 0 : preventClickEventByCondition(e2)) {
        return;
      }
      e2.stopPropagation();
      e2.preventDefault();
    };
    _this._onContextMenu = function(e2) {
      var options2 = _this.options;
      if (!options2.preventRightClick) {
        e2.preventDefault();
      } else {
        _this.onDragEnd(e2);
      }
    };
    _this._passCallback = function() {
    };
    var elements = [].concat(targets);
    var firstTarget = elements[0];
    _this._window = isWindow(firstTarget) ? firstTarget : getWindow(firstTarget);
    _this.options = __assign$9({ checkInput: false, container: firstTarget && !("document" in firstTarget) ? getWindow(firstTarget) : firstTarget, preventRightClick: true, preventWheelClick: true, preventClickEventOnDragStart: false, preventClickEventOnDrag: false, preventClickEventByCondition: null, preventDefault: true, checkWindowBlur: false, keepDragging: false, pinchThreshold: 0, events: ["touch", "mouse"] }, options);
    var _a2 = _this.options, container = _a2.container, events2 = _a2.events, checkWindowBlur = _a2.checkWindowBlur;
    _this._useDrag = events2.indexOf("drag") > -1;
    _this._useTouch = events2.indexOf("touch") > -1;
    _this._useMouse = events2.indexOf("mouse") > -1;
    _this.targets = elements;
    if (_this._useDrag) {
      elements.forEach(function(el) {
        addEvent$1(el, "dragstart", _this.onDragStart);
      });
    }
    if (_this._useMouse) {
      elements.forEach(function(el) {
        addEvent$1(el, "mousedown", _this.onDragStart);
        addEvent$1(el, "mousemove", _this._passCallback);
      });
      addEvent$1(container, "contextmenu", _this._onContextMenu);
    }
    if (checkWindowBlur) {
      addEvent$1(getWindow(), "blur", _this.onBlur);
    }
    if (_this._useTouch) {
      var passive_1 = {
        passive: false
      };
      elements.forEach(function(el) {
        addEvent$1(el, "touchstart", _this.onDragStart, passive_1);
        addEvent$1(el, "touchmove", _this._passCallback, passive_1);
      });
    }
    return _this;
  }
  Gesto2.prototype.stop = function() {
    this.isDrag = false;
    this.data = {};
    this.clientStores = [];
    this.pinchFlag = false;
    this.doubleFlag = false;
    this.prevTime = 0;
    this.flag = false;
    this._isIdle = true;
    this._allowClickEvent();
    this._dettachDragEvent();
    this._isDragAPI = false;
  };
  Gesto2.prototype.getMovement = function(clients) {
    return this.getCurrentStore().getMovement(clients) + this.clientStores.slice(1).reduce(function(prev, cur) {
      return prev + cur.movement;
    }, 0);
  };
  Gesto2.prototype.isDragging = function() {
    return this.isDrag;
  };
  Gesto2.prototype.isIdle = function() {
    return this._isIdle;
  };
  Gesto2.prototype.isFlag = function() {
    return this.flag;
  };
  Gesto2.prototype.isPinchFlag = function() {
    return this.pinchFlag;
  };
  Gesto2.prototype.isDoubleFlag = function() {
    return this.doubleFlag;
  };
  Gesto2.prototype.isPinching = function() {
    return this.isPinch;
  };
  Gesto2.prototype.scrollBy = function(deltaX, deltaY, e2, isCallDrag) {
    if (isCallDrag === void 0) {
      isCallDrag = true;
    }
    if (!this.flag) {
      return;
    }
    this.clientStores[0].move(deltaX, deltaY);
    isCallDrag && this.onDrag(e2, true);
  };
  Gesto2.prototype.move = function(_a2, inputEvent) {
    var deltaX = _a2[0], deltaY = _a2[1];
    var store = this.getCurrentStore();
    var nextClients = store.prevClients;
    return this.moveClients(nextClients.map(function(_a3) {
      var clientX = _a3.clientX, clientY = _a3.clientY;
      return {
        clientX: clientX + deltaX,
        clientY: clientY + deltaY,
        originalClientX: clientX,
        originalClientY: clientY
      };
    }), inputEvent, true);
  };
  Gesto2.prototype.triggerDragStart = function(e2) {
    this.onDragStart(e2, false);
  };
  Gesto2.prototype.setEventData = function(data) {
    var currentData = this.data;
    for (var name_1 in data) {
      currentData[name_1] = data[name_1];
    }
    return this;
  };
  Gesto2.prototype.setEventDatas = function(data) {
    return this.setEventData(data);
  };
  Gesto2.prototype.getCurrentEvent = function(inputEvent) {
    if (inputEvent === void 0) {
      inputEvent = this._prevInputEvent;
    }
    return __assign$9(__assign$9({ data: this.data, datas: this.data }, this._getPosition()), { movement: this.getMovement(), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: false, inputEvent });
  };
  Gesto2.prototype.getEventData = function() {
    return this.data;
  };
  Gesto2.prototype.getEventDatas = function() {
    return this.data;
  };
  Gesto2.prototype.unset = function() {
    var _this = this;
    var targets = this.targets;
    var container = this.options.container;
    this.off();
    removeEvent(this._window, "blur", this.onBlur);
    if (this._useDrag) {
      targets.forEach(function(el) {
        removeEvent(el, "dragstart", _this.onDragStart);
      });
    }
    if (this._useMouse) {
      targets.forEach(function(target) {
        removeEvent(target, "mousedown", _this.onDragStart);
      });
      removeEvent(container, "contextmenu", this._onContextMenu);
    }
    if (this._useTouch) {
      targets.forEach(function(target) {
        removeEvent(target, "touchstart", _this.onDragStart);
      });
      removeEvent(container, "touchstart", this.onDragStart);
    }
    this._prevInputEvent = null;
    this._allowClickEvent();
    this._dettachDragEvent();
  };
  Gesto2.prototype.onPinchStart = function(e2) {
    var _this = this;
    var pinchThreshold = this.options.pinchThreshold;
    if (this.isDrag && this.getMovement() > pinchThreshold) {
      return;
    }
    var store = new ClientStore(getEventClients(e2));
    this.pinchFlag = true;
    this._addStore(store);
    var result = this.emit("pinchStart", __assign$9(__assign$9({ data: this.data, datas: this.data, angle: store.getAngle(), touches: this.getCurrentStore().getPositions() }, store.getPosition()), { inputEvent: e2, isTrusted: this._isTrusted, preventDefault: function() {
      e2.preventDefault();
    }, preventDrag: function() {
      _this._dragFlag = false;
    } }));
    if (result === false) {
      this.pinchFlag = false;
    }
  };
  Gesto2.prototype.onPinch = function(e2, clients) {
    if (!this.flag || !this.pinchFlag || clients.length < 2) {
      return;
    }
    var store = this.getCurrentStore();
    this.isPinch = true;
    this.emit("pinch", __assign$9(__assign$9({ data: this.data, datas: this.data, movement: this.getMovement(clients), angle: store.getAngle(clients), rotation: store.getRotation(clients), touches: store.getPositions(clients), scale: store.getScale(clients), distance: store.getDistance(clients) }, store.getPosition(clients)), { inputEvent: e2, isTrusted: this._isTrusted }));
  };
  Gesto2.prototype.onPinchEnd = function(e2) {
    if (!this.pinchFlag) {
      return;
    }
    var isPinch = this.isPinch;
    this.isPinch = false;
    this.pinchFlag = false;
    var store = this.getCurrentStore();
    this.emit("pinchEnd", __assign$9(__assign$9({ data: this.data, datas: this.data, isPinch, touches: store.getPositions() }, store.getPosition()), { inputEvent: e2 }));
  };
  Gesto2.prototype.getCurrentStore = function() {
    return this.clientStores[0];
  };
  Gesto2.prototype.moveClients = function(clients, inputEvent, isAdd) {
    var position2 = this._getPosition(clients, isAdd);
    var isPrevDrag = this.isDrag;
    if (position2.deltaX || position2.deltaY) {
      this.isDrag = true;
    }
    var isFirstDrag = false;
    if (!isPrevDrag && this.isDrag) {
      isFirstDrag = true;
    }
    return __assign$9(__assign$9({ data: this.data, datas: this.data }, position2), { movement: this.getMovement(clients), isDrag: this.isDrag, isPinch: this.isPinch, isScroll: false, isMouseEvent: this._isMouseEvent, isSecondaryButton: this._isSecondaryButton, inputEvent, isTrusted: this._isTrusted, isFirstDrag });
  };
  Gesto2.prototype._addStore = function(store) {
    this.clientStores.splice(0, 0, store);
  };
  Gesto2.prototype._getPosition = function(clients, isAdd) {
    var store = this.getCurrentStore();
    var position2 = store.getPosition(clients, isAdd);
    var _a2 = this.clientStores.slice(1).reduce(function(prev, cur) {
      var storePosition = cur.getPosition();
      prev.distX += storePosition.distX;
      prev.distY += storePosition.distY;
      return prev;
    }, position2), distX = _a2.distX, distY = _a2.distY;
    return __assign$9(__assign$9({}, position2), { distX, distY });
  };
  Gesto2.prototype._attchDragEvent = function() {
    var win = this._window;
    var container = this.options.container;
    var passive = {
      passive: false
    };
    if (this._isDragAPI) {
      addEvent$1(container, "dragover", this.onDrag, passive);
      addEvent$1(win, "dragend", this.onDragEnd);
    }
    if (this._useMouse) {
      addEvent$1(container, "mousemove", this.onDrag);
      addEvent$1(win, "mouseup", this.onDragEnd);
    }
    if (this._useTouch) {
      addEvent$1(container, "touchmove", this.onDrag, passive);
      addEvent$1(win, "touchend", this.onDragEnd, passive);
      addEvent$1(win, "touchcancel", this.onDragEnd, passive);
    }
  };
  Gesto2.prototype._dettachDragEvent = function() {
    var win = this._window;
    var container = this.options.container;
    if (this._isDragAPI) {
      removeEvent(container, "dragover", this.onDrag);
      removeEvent(win, "dragend", this.onDragEnd);
    }
    if (this._useMouse) {
      removeEvent(container, "mousemove", this.onDrag);
      removeEvent(win, "mouseup", this.onDragEnd);
    }
    if (this._useTouch) {
      removeEvent(container, "touchstart", this.onDragStart);
      removeEvent(container, "touchmove", this.onDrag);
      removeEvent(win, "touchend", this.onDragEnd);
      removeEvent(win, "touchcancel", this.onDragEnd);
    }
  };
  return Gesto2;
}(EventEmitter$3);
function hash(str) {
  var hash2 = 5381, i = str.length;
  while (i) {
    hash2 = hash2 * 33 ^ str.charCodeAt(--i);
  }
  return hash2 >>> 0;
}
var stringHash = hash;
function getHash(str) {
  return stringHash(str).toString(36);
}
function getShadowRoot(parentElement) {
  if (parentElement && parentElement.getRootNode) {
    var rootNode = parentElement.getRootNode();
    if (rootNode.nodeType === 11) {
      return rootNode;
    }
  }
  return;
}
function replaceStyle(className, css2, options) {
  if (options.original) {
    return css2;
  }
  return css2.replace(/([^};{\s}][^};{]*|^\s*){/mg, function(_, selector) {
    var trimmedSelector = selector.trim();
    return (trimmedSelector ? splitComma(trimmedSelector) : [""]).map(function(subSelector) {
      var trimmedSubSelector = subSelector.trim();
      if (trimmedSubSelector.indexOf("@") === 0) {
        return trimmedSubSelector;
      } else if (trimmedSubSelector.indexOf(":global") > -1) {
        return trimmedSubSelector.replace(/\:global/g, "");
      } else if (trimmedSubSelector.indexOf(":host") > -1) {
        return "".concat(trimmedSubSelector.replace(/\:host/g, ".".concat(className)));
      } else if (trimmedSubSelector) {
        return ".".concat(className, " ").concat(trimmedSubSelector);
      } else {
        return ".".concat(className);
      }
    }).join(", ") + " {";
  });
}
function injectStyle(className, css2, options, el, shadowRoot) {
  var doc2 = getDocument(el);
  var style = doc2.createElement("style");
  style.setAttribute("type", "text/css");
  style.setAttribute("data-styled-id", className);
  style.setAttribute("data-styled-count", "1");
  if (options.nonce) {
    style.setAttribute("nonce", options.nonce);
  }
  style.innerHTML = replaceStyle(className, css2, options);
  (shadowRoot || doc2.head || doc2.body).appendChild(style);
  return style;
}
function styled$1(css2) {
  var injectClassName = "rCS" + getHash(css2);
  return {
    className: injectClassName,
    inject: function(el, options) {
      if (options === void 0) {
        options = {};
      }
      var shadowRoot = getShadowRoot(el);
      var styleElement = (shadowRoot || el.ownerDocument || document).querySelector('style[data-styled-id="'.concat(injectClassName, '"]'));
      if (!styleElement) {
        styleElement = injectStyle(injectClassName, css2, options, el, shadowRoot);
      } else {
        var count = parseFloat(styleElement.getAttribute("data-styled-count")) || 0;
        styleElement.setAttribute("data-styled-count", "".concat(count + 1));
      }
      return {
        destroy: function() {
          var _a2;
          var injectCount = parseFloat(styleElement.getAttribute("data-styled-count")) || 0;
          if (injectCount <= 1) {
            if (styleElement.remove) {
              styleElement.remove();
            } else {
              (_a2 = styleElement.parentNode) === null || _a2 === void 0 ? void 0 : _a2.removeChild(styleElement);
            }
            styleElement = null;
          } else {
            styleElement.setAttribute("data-styled-count", "".concat(injectCount - 1));
          }
        }
      };
    }
  };
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$a = function(d, b) {
  extendStatics$a = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics$a(d, b);
};
function __extends$a(d, b) {
  extendStatics$a(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$8 = function() {
  __assign$8 = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$8.apply(this, arguments);
};
function __rest$3(s, e2) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
var StyledElement = /* @__PURE__ */ function(_super) {
  __extends$a(StyledElement2, _super);
  function StyledElement2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.injectResult = null;
    _this.tag = "div";
    return _this;
  }
  var __proto = StyledElement2.prototype;
  __proto.render = function() {
    var _a2 = this.props, _b = _a2.className, className = _b === void 0 ? "" : _b;
    _a2.cspNonce;
    var portalContainer = _a2.portalContainer, attributes = __rest$3(_a2, ["className", "cspNonce", "portalContainer"]);
    var cssId = this.injector.className;
    var Tag = this.tag;
    var portalAttributes = {};
    if (version$2.indexOf("simple") > -1 && portalContainer) {
      portalAttributes = {
        portalContainer
      };
    }
    return createElement$1(Tag, __assign$8({
      "ref": ref(this, "element"),
      "data-styled-id": cssId,
      "className": className + " " + cssId
    }, portalAttributes, attributes));
  };
  __proto.componentDidMount = function() {
    this.injectResult = this.injector.inject(this.element, {
      nonce: this.props.cspNonce
    });
  };
  __proto.componentWillUnmount = function() {
    this.injectResult.destroy();
    this.injectResult = null;
  };
  __proto.getElement = function() {
    return this.element;
  };
  return StyledElement2;
}(Component$1);
function styled(tag, css2) {
  var injector2 = styled$1(css2);
  return /* @__PURE__ */ function(_super) {
    __extends$a(Styled, _super);
    function Styled() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.injector = injector2;
      _this.tag = tag;
      return _this;
    }
    return Styled;
  }(StyledElement);
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$9 = function(d, b) {
  extendStatics$9 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics$9(d, b);
};
function __extends$9(d, b) {
  extendStatics$9(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$7 = function() {
  __assign$7 = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$7.apply(this, arguments);
};
function __rest$2(s, e2) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate$4(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __spreadArrays$2() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a2 = arguments[i], j2 = 0, jl = a2.length; j2 < jl; j2++, k++)
      r[k] = a2[j2];
  return r;
}
function makeAble(name2, able) {
  var _a2;
  return __assign$7({
    events: {},
    props: (_a2 = {}, _a2[name2] = Boolean, _a2),
    name: name2
  }, able);
}
function getSVGCursor(scale, degree) {
  return 'data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="' + 32 * scale + 'px" height="' + 32 * scale + 'px" viewBox="0 0 32 32" ><path d="M 16,5 L 12,10 L 14.5,10 L 14.5,22 L 12,22 L 16,27 L 20,22 L 17.5,22 L 17.5,10 L 20, 10 L 16,5 Z" stroke-linejoin="round" stroke-width="1.2" fill="black" stroke="white" style="transform:rotate(' + degree + 'deg);transform-origin: 16px 16px"></path></svg>';
}
function getCursorCSS(degree) {
  var x1 = getSVGCursor(1, degree);
  var x2 = getSVGCursor(2, degree);
  var degree45 = Math.round(degree / 45) * 45 % 180;
  var defaultCursor = "ns-resize";
  if (degree45 === 135) {
    defaultCursor = "nwse-resize";
  } else if (degree45 === 45) {
    defaultCursor = "nesw-resize";
  } else if (degree45 === 90) {
    defaultCursor = "ew-resize";
  }
  return "cursor:" + defaultCursor + ";cursor: url('" + x1 + "') 16 16, " + defaultCursor + ";cursor: -webkit-image-set(url('" + x1 + "') 1x, url('" + x2 + "') 2x) 16 16, " + defaultCursor + ";";
}
var agent = agent$1();
var IS_WEBKIT = agent.browser.webkit;
var IS_WEBKIT605 = IS_WEBKIT && function() {
  var res = /applewebkit\/([^\s]+)/g.exec(navigator.userAgent.toLowerCase());
  return res ? parseFloat(res[1]) < 605 : false;
}();
var PREFIX$1 = "moveable-";
var MOVEABLE_CSS = "\n{\n	position: absolute;\n	width: 1px;\n	height: 1px;\n	left: 0;\n	top: 0;\n    z-index: 3000;\n    --moveable-color: #4af;\n    --zoom: 1;\n    --zoompx: 1px;\n    will-change: transform;\n}\n.control-box {\n    z-index: 0;\n}\n.line, .control {\n    position: absolute;\n	left: 0;\n    top: 0;\n    will-change: transform;\n}\n.control {\n	width: 14px;\n	height: 14px;\n	border-radius: 50%;\n	border: 2px solid #fff;\n	box-sizing: border-box;\n    background: #4af;\n    background: var(--moveable-color);\n	margin-top: -7px;\n    margin-left: -7px;\n    border: 2px solid #fff;\n    z-index: 10;\n}\n.padding {\n    position: absolute;\n    top: 0px;\n    left: 0px;\n    width: 100px;\n    height: 100px;\n    transform-origin: 0 0;\n}\n.line {\n	width: 1px;\n    height: 1px;\n    background: #4af;\n    background: var(--moveable-color);\n	transform-origin: 0px 50%;\n}\n.line.dashed {\n    box-sizing: border-box;\n    background: transparent;\n}\n.line.dashed.horizontal {\n    border-top: 1px dashed #4af;\n    border-top-color: #4af;\n    border-top-color: var(--moveable-color);\n}\n.line.dashed.vertical {\n    border-left: 1px dashed #4af;\n    border-left-color: #4af;\n    border-left-color: var(--moveable-color);\n}\n.line.vertical {\n    transform: translateX(-50%);\n}\n.line.horizontal {\n    transform: translateY(-50%);\n}\n.line.vertical.bold {\n    width: 2px;\n}\n.line.horizontal.bold {\n    height: 2px;\n}\n\n.control.origin {\n	border-color: #f55;\n	background: #fff;\n	width: 12px;\n	height: 12px;\n	margin-top: -6px;\n    margin-left: -6px;\n	pointer-events: none;\n}\n" + [0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165].map(function(degree) {
  return '\n.direction[data-rotation="' + degree + '"] {\n	' + getCursorCSS(degree) + "\n}\n";
}).join("\n") + "\n.group {\n    z-index: -1;\n}\n.area {\n    position: absolute;\n}\n.area-pieces {\n    position: absolute;\n    top: 0;\n    left: 0;\n    display: none;\n}\n.area.avoid, .area.pass {\n    pointer-events: none;\n}\n.area.avoid+.area-pieces {\n    display: block;\n}\n.area-piece {\n    position: absolute;\n}\n\n" + (IS_WEBKIT605 ? ':global svg *:before {\n	content:"";\n	transform-origin: inherit;\n}' : "") + "\n";
var NEARBY_POS = [[0, 1, 2], [1, 0, 3], [2, 0, 3], [3, 1, 2]];
var FLOAT_POINT_NUM = 1e-4;
var TINY_NUM = 1e-7;
var MIN_SCALE = 1e-9;
var MAX_NUM = Math.pow(10, 10);
var MIN_NUM = -MAX_NUM;
var DIRECTIONS = ["n", "w", "s", "e", "nw", "ne", "sw", "se"];
var DIRECTION_INDEXES = {
  n: [0, 1],
  s: [2, 3],
  w: [2, 0],
  e: [1, 3],
  nw: [0],
  ne: [1],
  sw: [2],
  se: [3]
};
var DIRECTION_ROTATIONS = {
  n: 0,
  s: 180,
  w: 270,
  e: 90,
  nw: 315,
  ne: 45,
  sw: 225,
  se: 135
};
var MOVEABLE_METHODS = ["isMoveableElement", "updateRect", "updateTarget", "destroy", "dragStart", "isInside", "hitTest", "setState", "getRect", "request", "isDragging", "getManager"];
function multiply2(pos1, pos2) {
  return [pos1[0] * pos2[0], pos1[1] * pos2[1]];
}
function prefix$2() {
  var classNames = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    classNames[_i] = arguments[_i];
  }
  return prefixNames.apply(void 0, __spreadArrays$2([PREFIX$1], classNames));
}
function getTransformMatrix(transform2) {
  if (!transform2 || transform2 === "none") {
    return [1, 0, 0, 1, 0, 0];
  }
  if (isObject$2(transform2)) {
    return transform2;
  }
  var value = splitBracket(transform2).value;
  return value.split(/s*,\s*/g).map(function(v) {
    return parseFloat(v);
  });
}
function getAbsoluteMatrix(matrix2, n, origin) {
  return multiplies(n, createOriginMatrix(origin, n), matrix2, createOriginMatrix(origin.map(function(a2) {
    return -a2;
  }), n));
}
function measureSVGSize(el, unit, isHorizontal) {
  if (unit === "%") {
    var viewBox = getSVGViewBox(el.ownerSVGElement);
    return viewBox[isHorizontal ? "width" : "height"] / 100;
  }
  return 1;
}
function getBeforeTransformOrigin(el) {
  var relativeOrigin = getTransformOrigin(getComputedStyle$1(el, ":before"));
  return relativeOrigin.map(function(o, i) {
    var _a2 = splitUnit(o), value = _a2.value, unit = _a2.unit;
    return value * measureSVGSize(el, unit, i === 0);
  });
}
function getTransformOrigin(style) {
  var transformOrigin2 = style.transformOrigin;
  return transformOrigin2 ? transformOrigin2.split(" ") : ["0", "0"];
}
function getOffsetInfo(el, lastParent, isParent) {
  var body = document.body;
  var target = !el || isParent ? el : el.parentElement;
  var isEnd = el === lastParent || target === lastParent;
  var position2 = "relative";
  while (target && target !== body) {
    if (lastParent === target) {
      isEnd = true;
    }
    var style = getComputedStyle$1(target);
    var transform2 = style.transform;
    position2 = style.position;
    if (target.tagName.toLowerCase() === "svg" || position2 !== "static" || transform2 && transform2 !== "none") {
      break;
    }
    target = target.parentElement;
    position2 = "relative";
  }
  return {
    isStatic: position2 === "static",
    isEnd: isEnd || !target || target === body,
    offsetParent: target || body
  };
}
function getOffsetPosInfo(el, container, style, isFixed2) {
  var _a2;
  var tagName = el.tagName.toLowerCase();
  var offsetLeft = el.offsetLeft;
  var offsetTop = el.offsetTop;
  if (isFixed2) {
    var containerClientRect = (container || document.documentElement).getBoundingClientRect();
    offsetLeft -= containerClientRect.left;
    offsetTop -= containerClientRect.top;
  }
  var isSVG2 = isUndefined$2(offsetLeft);
  var hasOffset = !isSVG2;
  var origin;
  var targetOrigin;
  if (!hasOffset && tagName !== "svg") {
    origin = IS_WEBKIT605 ? getBeforeTransformOrigin(el) : getTransformOrigin(style).map(function(pos) {
      return parseFloat(pos);
    });
    targetOrigin = origin.slice();
    hasOffset = true;
    _a2 = getSVGGraphicsOffset(el, origin), offsetLeft = _a2[0], offsetTop = _a2[1], origin[0] = _a2[2], origin[1] = _a2[3];
  } else {
    origin = getTransformOrigin(style).map(function(pos) {
      return parseFloat(pos);
    });
    targetOrigin = origin.slice();
  }
  return {
    tagName,
    isSVG: isSVG2,
    hasOffset,
    offset: [offsetLeft || 0, offsetTop || 0],
    origin,
    targetOrigin
  };
}
function getBodyOffset(el, isSVG2, style) {
  if (style === void 0) {
    style = getComputedStyle$1(el);
  }
  var bodyStyle = getComputedStyle$1(document.body);
  var bodyPosition = bodyStyle.position;
  if (!isSVG2 && (!bodyPosition || bodyPosition === "static")) {
    return [0, 0];
  }
  var marginLeft2 = parseInt(bodyStyle.marginLeft, 10);
  var marginTop2 = parseInt(bodyStyle.marginTop, 10);
  if (style.position === "absolute") {
    if (style.top !== "auto" || style.bottom !== "auto") {
      marginTop2 = 0;
    }
    if (style.left !== "auto" || style.right !== "auto") {
      marginLeft2 = 0;
    }
  }
  return [marginLeft2, marginTop2];
}
function convert3DMatrixes(matrixes) {
  matrixes.forEach(function(info) {
    var matrix2 = info.matrix;
    if (matrix2) {
      info.matrix = convertDimension(matrix2, 3, 4);
    }
  });
}
function getMatrixStackInfo(target, container) {
  var el = target;
  var matrixes = [];
  var isEnd = target === container;
  var is3d = false;
  var n = 3;
  var transformOrigin2;
  var targetTransformOrigin;
  var targetMatrix;
  var offsetContainer = getOffsetInfo(container, container, true).offsetParent;
  while (el && !isEnd) {
    var style = getComputedStyle$1(el);
    var position2 = style.position;
    var isFixed2 = position2 === "fixed";
    var matrix2 = convertCSStoMatrix(getTransformMatrix(style.transform));
    var length = matrix2.length;
    if (!is3d && length === 16) {
      is3d = true;
      n = 4;
      convert3DMatrixes(matrixes);
    }
    if (is3d && length === 9) {
      matrix2 = convertDimension(matrix2, 3, 4);
    }
    var _a2 = getOffsetPosInfo(el, container, style, isFixed2), tagName = _a2.tagName, hasOffset = _a2.hasOffset, isSVG2 = _a2.isSVG, origin = _a2.origin, targetOrigin = _a2.targetOrigin, offsetPos = _a2.offset;
    var offsetLeft = offsetPos[0], offsetTop = offsetPos[1];
    if (tagName === "svg" && targetMatrix) {
      matrixes.push({
        type: "target",
        target: el,
        matrix: getSVGMatrix(el, n)
      });
      matrixes.push({
        type: "offset",
        target: el,
        matrix: createIdentityMatrix(n)
      });
    } else if (tagName === "g" && target !== el) {
      offsetLeft = 0;
      offsetTop = 0;
    }
    var _b = getOffsetInfo(el, container), offsetParent = _b.offsetParent, isOffsetEnd = _b.isEnd, isStatic = _b.isStatic;
    if (IS_WEBKIT && hasOffset && !isSVG2 && isStatic && (position2 === "relative" || position2 === "static")) {
      offsetLeft -= offsetParent.offsetLeft;
      offsetTop -= offsetParent.offsetTop;
      isEnd = isEnd || isOffsetEnd;
    }
    var parentClientLeft = 0;
    var parentClientTop = 0;
    if (hasOffset && offsetContainer !== offsetParent) {
      parentClientLeft = offsetParent.clientLeft;
      parentClientTop = offsetParent.clientTop;
    }
    if (hasOffset && offsetParent === document.body) {
      var margin = getBodyOffset(el, false, style);
      offsetLeft += margin[0];
      offsetTop += margin[1];
    }
    matrixes.push({
      type: "target",
      target: el,
      matrix: getAbsoluteMatrix(matrix2, n, origin)
    });
    if (hasOffset) {
      matrixes.push({
        type: "offset",
        target: el,
        matrix: createOriginMatrix([offsetLeft - el.scrollLeft + parentClientLeft, offsetTop - el.scrollTop + parentClientTop], n)
      });
    } else {
      matrixes.push({
        type: "offset",
        target: el,
        origin
      });
    }
    if (!targetMatrix) {
      targetMatrix = matrix2;
    }
    if (!transformOrigin2) {
      transformOrigin2 = origin;
    }
    if (!targetTransformOrigin) {
      targetTransformOrigin = targetOrigin;
    }
    if (isEnd || isFixed2) {
      break;
    } else {
      el = offsetParent;
      isEnd = isOffsetEnd;
    }
  }
  if (!targetMatrix) {
    targetMatrix = createIdentityMatrix(n);
  }
  if (!transformOrigin2) {
    transformOrigin2 = [0, 0];
  }
  if (!targetTransformOrigin) {
    targetTransformOrigin = [0, 0];
  }
  return {
    offsetContainer,
    matrixes,
    targetMatrix,
    transformOrigin: transformOrigin2,
    targetOrigin: targetTransformOrigin,
    is3d
  };
}
function calculateElementInfo(target, container, rootContainer, isAbsolute3d) {
  var _a2;
  if (rootContainer === void 0) {
    rootContainer = container;
  }
  var width = 0;
  var height = 0;
  var rotation = 0;
  var allResult = {};
  if (target) {
    var style = getComputedStyle$1(target);
    width = target.offsetWidth;
    height = target.offsetHeight;
    if (isUndefined$2(width)) {
      _a2 = getSize(target, style, true), width = _a2[0], height = _a2[1];
    }
  }
  if (target) {
    var result = calculateMatrixStack(target, container, rootContainer, isAbsolute3d);
    var position2 = calculateMoveablePosition(result.allMatrix, result.transformOrigin, width, height);
    allResult = __assign$7(__assign$7({}, result), position2);
    var rotationPosition = calculateMoveablePosition(result.allMatrix, [50, 50], 100, 100);
    rotation = getRotationRad([rotationPosition.pos1, rotationPosition.pos2], rotationPosition.direction);
  }
  var n = isAbsolute3d ? 4 : 3;
  return __assign$7({
    width,
    height,
    rotation,
    rootMatrix: createIdentityMatrix(n),
    beforeMatrix: createIdentityMatrix(n),
    offsetMatrix: createIdentityMatrix(n),
    allMatrix: createIdentityMatrix(n),
    targetMatrix: createIdentityMatrix(n),
    targetTransform: "",
    transformOrigin: [0, 0],
    targetOrigin: [0, 0],
    is3d: !!isAbsolute3d,
    left: 0,
    top: 0,
    right: 0,
    bottom: 0,
    origin: [0, 0],
    pos1: [0, 0],
    pos2: [0, 0],
    pos3: [0, 0],
    pos4: [0, 0],
    direction: 1
  }, allResult);
}
function getElementInfo$1(target, container, rootContainer) {
  if (rootContainer === void 0) {
    rootContainer = container;
  }
  return calculateElementInfo(target, container, rootContainer, true);
}
function calculateMatrixStack(target, container, rootContainer, isAbsolute3d) {
  if (rootContainer === void 0) {
    rootContainer = container;
  }
  var _a2 = getMatrixStackInfo(target, container), matrixes = _a2.matrixes, is3d = _a2.is3d, prevTargetMatrix = _a2.targetMatrix, transformOrigin2 = _a2.transformOrigin, targetOrigin = _a2.targetOrigin, offsetContainer = _a2.offsetContainer;
  var _b = getMatrixStackInfo(offsetContainer, rootContainer), rootMatrixes = _b.matrixes, isRoot3d = _b.is3d;
  var isNext3d = isAbsolute3d || isRoot3d || is3d;
  var n = isNext3d ? 4 : 3;
  var isSVGGraphicElement = target.tagName.toLowerCase() !== "svg" && "ownerSVGElement" in target;
  var targetMatrix = prevTargetMatrix;
  var allMatrix = createIdentityMatrix(n);
  var rootMatrix = createIdentityMatrix(n);
  var beforeMatrix = createIdentityMatrix(n);
  var offsetMatrix = createIdentityMatrix(n);
  var length = matrixes.length;
  var originalRootContainer = rootContainer || document.body;
  var endContainer = getOffsetInfo(originalRootContainer, originalRootContainer, true).offsetParent;
  rootMatrixes.reverse();
  matrixes.reverse();
  if (!is3d && isNext3d) {
    targetMatrix = convertDimension(targetMatrix, 3, 4);
    convert3DMatrixes(matrixes);
  }
  if (!isRoot3d && isNext3d) {
    convert3DMatrixes(rootMatrixes);
  }
  rootMatrixes.forEach(function(info) {
    rootMatrix = multiply(rootMatrix, info.matrix, n);
  });
  matrixes.forEach(function(info, i) {
    if (length - 2 === i) {
      beforeMatrix = allMatrix.slice();
    }
    if (length - 1 === i) {
      offsetMatrix = allMatrix.slice();
    }
    if (!info.matrix) {
      var nextInfo = matrixes[i + 1];
      var offset = getSVGOffset(info, nextInfo, endContainer, n, multiply(rootMatrix, allMatrix, n));
      info.matrix = createOriginMatrix(offset, n);
    }
    allMatrix = multiply(allMatrix, info.matrix, n);
  });
  var isMatrix3d = !isSVGGraphicElement && is3d;
  if (!targetMatrix) {
    targetMatrix = createIdentityMatrix(isMatrix3d ? 4 : 3);
  }
  var targetTransform = makeMatrixCSS(isSVGGraphicElement && targetMatrix.length === 16 ? convertDimension(targetMatrix, 4, 3) : targetMatrix, isMatrix3d);
  rootMatrix = ignoreDimension(rootMatrix, n, n);
  return {
    rootMatrix,
    beforeMatrix,
    offsetMatrix,
    allMatrix,
    targetMatrix,
    targetTransform,
    transformOrigin: transformOrigin2,
    targetOrigin,
    is3d: isNext3d
  };
}
function makeMatrixCSS(matrix2, is3d) {
  if (is3d === void 0) {
    is3d = matrix2.length > 9;
  }
  return (is3d ? "matrix3d" : "matrix") + "(" + convertMatrixtoCSS(matrix2, !is3d).join(",") + ")";
}
function getSVGViewBox(el) {
  var clientWidth = el.clientWidth;
  var clientHeight = el.clientHeight;
  if (!el) {
    return {
      x: 0,
      y: 0,
      width: 0,
      height: 0,
      clientWidth,
      clientHeight
    };
  }
  var viewBox = el.viewBox;
  var baseVal = viewBox && viewBox.baseVal || {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  };
  return {
    x: baseVal.x,
    y: baseVal.y,
    width: baseVal.width || clientWidth,
    height: baseVal.height || clientHeight,
    clientWidth,
    clientHeight
  };
}
function getSVGMatrix(el, n) {
  var _a2 = getSVGViewBox(el), viewBoxWidth = _a2.width, viewBoxHeight = _a2.height, clientWidth = _a2.clientWidth, clientHeight = _a2.clientHeight;
  var scaleX = clientWidth / viewBoxWidth;
  var scaleY = clientHeight / viewBoxHeight;
  var preserveAspectRatio = el.preserveAspectRatio.baseVal;
  var align = preserveAspectRatio.align;
  var meetOrSlice = preserveAspectRatio.meetOrSlice;
  var svgOrigin = [0, 0];
  var scale = [scaleX, scaleY];
  var translate = [0, 0];
  if (align !== 1) {
    var xAlign = (align - 2) % 3;
    var yAlign = Math.floor((align - 2) / 3);
    svgOrigin[0] = viewBoxWidth * xAlign / 2;
    svgOrigin[1] = viewBoxHeight * yAlign / 2;
    var scaleDimension = meetOrSlice === 2 ? Math.max(scaleY, scaleX) : Math.min(scaleX, scaleY);
    scale[0] = scaleDimension;
    scale[1] = scaleDimension;
    translate[0] = (clientWidth - viewBoxWidth) / 2 * xAlign;
    translate[1] = (clientHeight - viewBoxHeight) / 2 * yAlign;
  }
  var scaleMatrix2 = createScaleMatrix(scale, n);
  scaleMatrix2[n * (n - 1)] = translate[0], scaleMatrix2[n * (n - 1) + 1] = translate[1];
  return getAbsoluteMatrix(scaleMatrix2, n, svgOrigin);
}
function getSVGGraphicsOffset(el, origin) {
  if (!el.getBBox) {
    return [0, 0];
  }
  var bbox = el.getBBox();
  var viewBox = getSVGViewBox(el.ownerSVGElement);
  var left = bbox.x - viewBox.x;
  var top = bbox.y - viewBox.y;
  return [left, top, origin[0] - left, origin[1] - top];
}
function calculatePosition(matrix2, pos, n) {
  return calculate(matrix2, convertPositionMatrix(pos, n), n);
}
function calculatePoses(matrix2, width, height, n) {
  return [[0, 0], [width, 0], [0, height], [width, height]].map(function(pos) {
    return calculatePosition(matrix2, pos, n);
  });
}
function getRect$2(poses) {
  var posesX = poses.map(function(pos) {
    return pos[0];
  });
  var posesY = poses.map(function(pos) {
    return pos[1];
  });
  var left = Math.min.apply(Math, posesX);
  var top = Math.min.apply(Math, posesY);
  var right = Math.max.apply(Math, posesX);
  var bottom = Math.max.apply(Math, posesY);
  var rectWidth = right - left;
  var rectHeight = bottom - top;
  return {
    left,
    top,
    right,
    bottom,
    width: rectWidth,
    height: rectHeight
  };
}
function calculateRect(matrix2, width, height, n) {
  var poses = calculatePoses(matrix2, width, height, n);
  return getRect$2(poses);
}
function getSVGOffset(offsetInfo, targetInfo, container, n, beforeMatrix) {
  var _a2;
  var target = offsetInfo.target;
  var origin = offsetInfo.origin;
  var targetMatrix = targetInfo.matrix;
  var _b = getSize(target, void 0, true), width = _b[0], height = _b[1];
  var containerClientRect = container.getBoundingClientRect();
  var margin = [0, 0];
  if (container === document.body) {
    margin = getBodyOffset(target, true);
  }
  var rect = target.getBoundingClientRect();
  var rectLeft = rect.left - containerClientRect.left + container.scrollLeft - (container.clientLeft || 0) + margin[0];
  var rectTop = rect.top - containerClientRect.top + container.scrollTop - (container.clientTop || 0) + margin[1];
  var rectWidth = rect.width;
  var rectHeight = rect.height;
  var mat = multiplies(n, beforeMatrix, targetMatrix);
  var _c = calculateRect(mat, width, height, n), prevLeft = _c.left, prevTop = _c.top, prevWidth = _c.width, prevHeight = _c.height;
  var posOrigin = calculatePosition(mat, origin, n);
  var prevOrigin = minus(posOrigin, [prevLeft, prevTop]);
  var rectOrigin = [rectLeft + prevOrigin[0] * rectWidth / prevWidth, rectTop + prevOrigin[1] * rectHeight / prevHeight];
  var offset = [0, 0];
  var count = 0;
  while (++count < 10) {
    var inverseBeforeMatrix = invert(beforeMatrix, n);
    _a2 = minus(calculatePosition(inverseBeforeMatrix, rectOrigin, n), calculatePosition(inverseBeforeMatrix, posOrigin, n)), offset[0] = _a2[0], offset[1] = _a2[1];
    var mat2 = multiplies(n, beforeMatrix, createOriginMatrix(offset, n), targetMatrix);
    var _d = calculateRect(mat2, width, height, n), nextLeft = _d.left, nextTop = _d.top;
    var distLeft = nextLeft - rectLeft;
    var distTop = nextTop - rectTop;
    if (Math.abs(distLeft) < 2 && Math.abs(distTop) < 2) {
      break;
    }
    rectOrigin[0] -= distLeft;
    rectOrigin[1] -= distTop;
  }
  return offset.map(function(p) {
    return Math.round(p);
  });
}
function calculateMoveablePosition(matrix2, origin, width, height) {
  var is3d = matrix2.length === 16;
  var n = is3d ? 4 : 3;
  var poses = calculatePoses(matrix2, width, height, n);
  var _a2 = poses[0], x1 = _a2[0], y1 = _a2[1], _b = poses[1], x2 = _b[0], y2 = _b[1], _c = poses[2], x3 = _c[0], y3 = _c[1], _d = poses[3], x4 = _d[0], y4 = _d[1];
  var _e = calculatePosition(matrix2, origin, n), originX = _e[0], originY = _e[1];
  var left = Math.min(x1, x2, x3, x4);
  var top = Math.min(y1, y2, y3, y4);
  var right = Math.max(x1, x2, x3, x4);
  var bottom = Math.max(y1, y2, y3, y4);
  x1 = x1 - left || 0;
  x2 = x2 - left || 0;
  x3 = x3 - left || 0;
  x4 = x4 - left || 0;
  y1 = y1 - top || 0;
  y2 = y2 - top || 0;
  y3 = y3 - top || 0;
  y4 = y4 - top || 0;
  originX = originX - left || 0;
  originY = originY - top || 0;
  var direction2 = getShapeDirection(poses);
  return {
    left,
    top,
    right,
    bottom,
    origin: [originX, originY],
    pos1: [x1, y1],
    pos2: [x2, y2],
    pos3: [x3, y3],
    pos4: [x4, y4],
    direction: direction2
  };
}
function getDistSize(vec) {
  return Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);
}
function getDiagonalSize(pos1, pos2) {
  return getDistSize([pos2[0] - pos1[0], pos2[1] - pos1[1]]);
}
function getLineStyle(pos1, pos2, zoom, rad) {
  if (zoom === void 0) {
    zoom = 1;
  }
  if (rad === void 0) {
    rad = getRad$1(pos1, pos2);
  }
  var width = getDiagonalSize(pos1, pos2);
  return {
    transform: "translateY(-50%) translate(" + pos1[0] + "px, " + pos1[1] + "px) rotate(" + rad + "rad) scaleY(" + zoom + ")",
    width: width + "px"
  };
}
function getControlTransform(rotation, zoom) {
  var poses = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    poses[_i - 2] = arguments[_i];
  }
  var length = poses.length;
  var x = poses.reduce(function(prev, pos) {
    return prev + pos[0];
  }, 0) / length;
  var y = poses.reduce(function(prev, pos) {
    return prev + pos[1];
  }, 0) / length;
  return {
    transform: "translateZ(0px) translate(" + x + "px, " + y + "px) rotate(" + rotation + "rad) scale(" + zoom + ")"
  };
}
function getCSSSize(target) {
  var style = getComputedStyle$1(target);
  return [parseFloat(style.width), parseFloat(style.height)];
}
function getSize(target, style, isOffset, isBoxSizing) {
  if (style === void 0) {
    style = getComputedStyle$1(target);
  }
  if (isBoxSizing === void 0) {
    isBoxSizing = isOffset || style.boxSizing === "border-box";
  }
  var width = target.offsetWidth;
  var height = target.offsetHeight;
  var hasOffset = !isUndefined$2(width);
  if ((isOffset || isBoxSizing) && hasOffset) {
    return [width, height];
  }
  if (!hasOffset && target.tagName.toLowerCase() !== "svg") {
    var bbox = target.getBBox();
    return [bbox.width, bbox.height];
  }
  width = target.clientWidth;
  height = target.clientHeight;
  if (isOffset || isBoxSizing) {
    var borderLeft = parseFloat(style.borderLeftWidth) || 0;
    var borderRight = parseFloat(style.borderRightWidth) || 0;
    var borderTop = parseFloat(style.borderTopWidth) || 0;
    var borderBottom = parseFloat(style.borderBottomWidth) || 0;
    return [width + borderLeft + borderRight, height + borderTop + borderBottom];
  } else {
    var paddingLeft2 = parseFloat(style.paddingLeft) || 0;
    var paddingRight2 = parseFloat(style.paddingRight) || 0;
    var paddingTop2 = parseFloat(style.paddingTop) || 0;
    var paddingBottom2 = parseFloat(style.paddingBottom) || 0;
    return [width - paddingLeft2 - paddingRight2, height - paddingTop2 - paddingBottom2];
  }
}
function getRotationRad(poses, direction2) {
  return getRad$1(direction2 > 0 ? poses[0] : poses[1], direction2 > 0 ? poses[1] : poses[0]);
}
function getTargetInfo(moveableElement, target, container, parentContainer, rootContainer) {
  var beforeDirection = 1;
  var beforeOrigin = [0, 0];
  var targetClientRect = resetClientRect();
  var containerClientRect = resetClientRect();
  var moveableClientRect = resetClientRect();
  var result = calculateElementInfo(target, container, rootContainer, false);
  if (target) {
    var n = result.is3d ? 4 : 3;
    var beforePosition = calculateMoveablePosition(result.offsetMatrix, plus(result.transformOrigin, getOrigin(result.targetMatrix, n)), result.width, result.height);
    beforeDirection = beforePosition.direction;
    beforeOrigin = plus(beforePosition.origin, [beforePosition.left - result.left, beforePosition.top - result.top]);
    targetClientRect = getClientRect(target);
    containerClientRect = getClientRect(getOffsetInfo(parentContainer, parentContainer, true).offsetParent || document.body, true);
    if (moveableElement) {
      moveableClientRect = getClientRect(moveableElement);
    }
  }
  return __assign$7({
    targetClientRect,
    containerClientRect,
    moveableClientRect,
    beforeDirection,
    beforeOrigin,
    originalBeforeOrigin: beforeOrigin,
    target
  }, result);
}
function resetClientRect() {
  return {
    left: 0,
    right: 0,
    top: 0,
    bottom: 0,
    width: 0,
    height: 0,
    clientLeft: 0,
    clientTop: 0,
    clientWidth: 0,
    clientHeight: 0,
    scrollWidth: 0,
    scrollHeight: 0
  };
}
function getClientRect(el, isExtends) {
  var left = 0;
  var top = 0;
  var width = 0;
  var height = 0;
  if (el === document.body || el === document.documentElement) {
    width = window.innerWidth;
    height = window.innerHeight;
    left = -(document.documentElement.scrollLeft || document.body.scrollLeft);
    top = -(document.documentElement.scrollTop || document.body.scrollTop);
  } else {
    var clientRect = el.getBoundingClientRect();
    left = clientRect.left;
    top = clientRect.top;
    width = clientRect.width;
    height = clientRect.height;
  }
  var rect = {
    left,
    right: left + width,
    top,
    bottom: top + height,
    width,
    height
  };
  if (isExtends) {
    rect.clientLeft = el.clientLeft;
    rect.clientTop = el.clientTop;
    rect.clientWidth = el.clientWidth;
    rect.clientHeight = el.clientHeight;
    rect.scrollWidth = el.scrollWidth;
    rect.scrollHeight = el.scrollHeight;
    rect.overflow = getComputedStyle$1(el).overflow !== "visible";
  }
  return rect;
}
function getDirection(target) {
  if (!target) {
    return;
  }
  var direciton = target.getAttribute("data-direction");
  if (!direciton) {
    return;
  }
  var dir = [0, 0];
  direciton.indexOf("w") > -1 && (dir[0] = -1);
  direciton.indexOf("e") > -1 && (dir[0] = 1);
  direciton.indexOf("n") > -1 && (dir[1] = -1);
  direciton.indexOf("s") > -1 && (dir[1] = 1);
  return dir;
}
function getAbsolutePoses(poses, dist) {
  return [plus(dist, poses[0]), plus(dist, poses[1]), plus(dist, poses[2]), plus(dist, poses[3])];
}
function getAbsolutePosesByState(_a2) {
  var left = _a2.left, top = _a2.top, pos1 = _a2.pos1, pos2 = _a2.pos2, pos3 = _a2.pos3, pos4 = _a2.pos4;
  return getAbsolutePoses([pos1, pos2, pos3, pos4], [left, top]);
}
function roundSign(num) {
  return Math.round(num % 1 === -0.5 ? num - 1 : num);
}
function unset(self2, name2) {
  if (self2[name2]) {
    self2[name2].unset();
    self2[name2] = null;
  }
}
function fillParams(moveable, e2, params) {
  var datas = e2.datas;
  if (!datas.datas) {
    datas.datas = {};
  }
  var nextParams = __assign$7(__assign$7({}, params), {
    target: moveable.state.target,
    clientX: e2.clientX,
    clientY: e2.clientY,
    inputEvent: e2.inputEvent,
    currentTarget: moveable,
    moveable,
    datas: datas.datas
  });
  if (datas.isStartEvent) {
    datas.lastEvent = nextParams;
  } else {
    datas.isStartEvent = true;
  }
  return nextParams;
}
function fillEndParams(moveable, e2, params) {
  var datas = e2.datas;
  var isDrag2 = "isDrag" in params ? params.isDrag : e2.isDrag;
  if (!datas.datas) {
    datas.datas = {};
  }
  return __assign$7(__assign$7({
    isDrag: isDrag2
  }, params), {
    moveable,
    target: moveable.state.target,
    clientX: e2.clientX,
    clientY: e2.clientY,
    inputEvent: e2.inputEvent,
    currentTarget: moveable,
    lastEvent: datas.lastEvent,
    isDouble: e2.isDouble,
    datas: datas.datas
  });
}
function triggerEvent(moveable, name2, params, isManager) {
  return moveable.triggerEvent(name2, params, isManager);
}
function getComputedStyle$1(el, pseudoElt) {
  return window.getComputedStyle(el, pseudoElt);
}
function filterAbles(ables, methods, triggerAblesSimultaneously) {
  var enabledAbles = {};
  var ableGroups = {};
  return ables.filter(function(able) {
    var name2 = able.name;
    if (enabledAbles[name2] || !methods.some(function(method) {
      return able[method];
    })) {
      return false;
    }
    if (!triggerAblesSimultaneously && able.ableGroup) {
      if (ableGroups[able.ableGroup]) {
        return false;
      }
      ableGroups[able.ableGroup] = true;
    }
    enabledAbles[name2] = true;
    return true;
  });
}
function equals(a1, a2) {
  return a1 === a2 || a1 == null && a2 == null;
}
function selectValue() {
  var values = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    values[_i] = arguments[_i];
  }
  var length = values.length - 1;
  for (var i = 0; i < length; ++i) {
    var value = values[i];
    if (!isUndefined$2(value)) {
      return value;
    }
  }
  return values[length];
}
function groupBy(arr2, func) {
  var groups = [];
  var groupKeys = [];
  arr2.forEach(function(el, index2) {
    var groupKey = func(el, index2, arr2);
    var keyIndex = groupKeys.indexOf(groupKey);
    var group = groups[keyIndex] || [];
    if (keyIndex === -1) {
      groupKeys.push(groupKey);
      groups.push(group);
    }
    group.push(el);
  });
  return groups;
}
function groupByMap(arr2, func) {
  var groups = [];
  var groupKeys = {};
  arr2.forEach(function(el, index2) {
    var groupKey = func(el, index2, arr2);
    var group = groupKeys[groupKey];
    if (!group) {
      group = [];
      groupKeys[groupKey] = group;
      groups.push(group);
    }
    group.push(el);
  });
  return groups;
}
function flat(arr2) {
  return arr2.reduce(function(prev, cur) {
    return prev.concat(cur);
  }, []);
}
function maxOffset() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  args.sort(function(a2, b) {
    return Math.abs(b) - Math.abs(a2);
  });
  return args[0];
}
function minOffset() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  args.sort(function(a2, b) {
    return Math.abs(a2) - Math.abs(b);
  });
  return args[0];
}
function calculateInversePosition(matrix2, pos, n) {
  return calculate(invert(matrix2, n), convertPositionMatrix(pos, n), n);
}
function convertDragDist(state, e2) {
  var _a2;
  var is3d = state.is3d, rootMatrix = state.rootMatrix;
  var n = is3d ? 4 : 3;
  _a2 = calculateInversePosition(rootMatrix, [e2.distX, e2.distY], n), e2.distX = _a2[0], e2.distY = _a2[1];
  return e2;
}
function calculatePadding(matrix2, pos, transformOrigin2, origin, n) {
  return minus(calculatePosition(matrix2, plus(transformOrigin2, pos), n), origin);
}
function convertCSSSize(value, size, isRelative) {
  return isRelative ? value / size * 100 + "%" : value + "px";
}
function moveControlPos(controlPoses, index2, dist, isRect) {
  var _a2 = controlPoses[index2], direction2 = _a2.direction, sub = _a2.sub;
  var dists = controlPoses.map(function() {
    return [0, 0];
  });
  var directions = direction2 ? direction2.split("") : [];
  if (isRect && index2 < 8) {
    var verticalDirection_1 = directions.filter(function(dir) {
      return dir === "w" || dir === "e";
    })[0];
    var horizontalDirection_1 = directions.filter(function(dir) {
      return dir === "n" || dir === "s";
    })[0];
    dists[index2] = dist;
    controlPoses.forEach(function(controlPose, i) {
      var controlDir = controlPose.direction;
      if (!controlDir) {
        return;
      }
      if (controlDir.indexOf(verticalDirection_1) > -1) {
        dists[i][0] = dist[0];
      }
      if (controlDir.indexOf(horizontalDirection_1) > -1) {
        dists[i][1] = dist[1];
      }
    });
    if (verticalDirection_1) {
      dists[1][0] = dist[0] / 2;
      dists[5][0] = dist[0] / 2;
    }
    if (horizontalDirection_1) {
      dists[3][1] = dist[1] / 2;
      dists[7][1] = dist[1] / 2;
    }
  } else if (direction2 && !sub) {
    directions.forEach(function(dir) {
      var isVertical = dir === "n" || dir === "s";
      controlPoses.forEach(function(controlPose, i) {
        var dirDir = controlPose.direction, dirHorizontal = controlPose.horizontal, dirVertical = controlPose.vertical;
        if (!dirDir || dirDir.indexOf(dir) === -1) {
          return;
        }
        dists[i] = [isVertical || !dirHorizontal ? 0 : dist[0], !isVertical || !dirVertical ? 0 : dist[1]];
      });
    });
  } else {
    dists[index2] = dist;
  }
  return dists;
}
function getTinyDist(v) {
  return Math.abs(v) <= TINY_NUM ? 0 : v;
}
function directionCondition(moveable, e2) {
  if (e2.isRequest) {
    if (e2.requestAble === "resizable" || e2.requestAble === "scalable") {
      return e2.parentDirection;
    } else {
      return false;
    }
  }
  return hasClass(e2.inputEvent.target, prefix$2("direction"));
}
function invertObject(obj) {
  var nextObj = {};
  for (var name2 in obj) {
    nextObj[obj[name2]] = name2;
  }
  return nextObj;
}
function getTransform(transforms, index2) {
  var beforeFunctionTexts = transforms.slice(0, index2 < 0 ? void 0 : index2);
  var beforeFunctionTexts2 = transforms.slice(0, index2 < 0 ? void 0 : index2 + 1);
  var targetFunctionText = transforms[index2] || "";
  var afterFunctionTexts = index2 < 0 ? [] : transforms.slice(index2);
  var afterFunctionTexts2 = index2 < 0 ? [] : transforms.slice(index2 + 1);
  var beforeFunctions = parse$1(beforeFunctionTexts);
  var beforeFunctions2 = parse$1(beforeFunctionTexts2);
  var targetFunctions = parse$1([targetFunctionText]);
  var afterFunctions = parse$1(afterFunctionTexts);
  var afterFunctions2 = parse$1(afterFunctionTexts2);
  var beforeFunctionMatrix = toMat(beforeFunctions);
  var beforeFunctionMatrix2 = toMat(beforeFunctions2);
  var afterFunctionMatrix = toMat(afterFunctions);
  var afterFunctionMatrix2 = toMat(afterFunctions2);
  var allFunctionMatrix = multiply(beforeFunctionMatrix, afterFunctionMatrix, 4);
  return {
    transforms,
    beforeFunctionMatrix,
    beforeFunctionMatrix2,
    targetFunctionMatrix: toMat(targetFunctions),
    afterFunctionMatrix,
    afterFunctionMatrix2,
    allFunctionMatrix,
    beforeFunctions,
    beforeFunctions2,
    targetFunction: targetFunctions[0],
    afterFunctions,
    afterFunctions2,
    beforeFunctionTexts,
    beforeFunctionTexts2,
    targetFunctionText,
    afterFunctionTexts,
    afterFunctionTexts2
  };
}
function isArrayFormat(arr2) {
  if (!arr2 || !isObject$2(arr2)) {
    return false;
  }
  return isArray$1(arr2) || "length" in arr2;
}
function getRefTarget(target, isSelector) {
  if (!target) {
    return null;
  }
  if (isString$2(target)) {
    if (isSelector) {
      return document.querySelector(target);
    }
    return target;
  }
  if (isFunction$2(target)) {
    return target();
  }
  if ("current" in target) {
    return target.current;
  }
  return target;
}
function getRefTargets(targets, isSelector) {
  if (!targets) {
    return [];
  }
  var userTargets = isArrayFormat(targets) ? [].slice.call(targets) : [targets];
  return userTargets.reduce(function(prev, target) {
    if (isString$2(target) && isSelector) {
      return __spreadArrays$2(prev, [].slice.call(document.querySelectorAll(target)));
    }
    prev.push(getRefTarget(target, isSelector));
    return prev;
  }, []);
}
function getElementTargets(targets, selectorMap) {
  var elementTargets = [];
  targets.forEach(function(target) {
    if (!target) {
      return;
    }
    if (isString$2(target)) {
      if (selectorMap[target]) {
        elementTargets.push.apply(elementTargets, selectorMap[target]);
      }
      return;
    }
    elementTargets.push(target);
  });
  return elementTargets;
}
function getAbsoluteRotation(pos1, pos2, direction2) {
  var deg2 = getRad$1(pos1, pos2) / Math.PI * 180;
  deg2 = direction2 >= 0 ? deg2 : 180 - deg2;
  deg2 = deg2 >= 0 ? deg2 : 360 + deg2;
  return deg2;
}
function getDragDistByState(state, dist) {
  var rootMatrix = state.rootMatrix, is3d = state.is3d;
  var n = is3d ? 4 : 3;
  var inverseMatrix = invert(rootMatrix, n);
  if (!is3d) {
    inverseMatrix = convertDimension(inverseMatrix, 3, 4);
  }
  inverseMatrix[12] = 0;
  inverseMatrix[13] = 0;
  inverseMatrix[14] = 0;
  return calculateMatrixDist(inverseMatrix, dist);
}
var Pinchable = makeAble("pinchable", {
  events: {
    onPinchStart: "pinchStart",
    onPinch: "pinch",
    onPinchEnd: "pinchEnd",
    onPinchGroupStart: "pinchGroupStart",
    onPinchGroup: "pinchGroup",
    onPinchGroupEnd: "pinchGroupEnd"
  },
  dragStart: function() {
    return true;
  },
  pinchStart: function(moveable, e2) {
    var datas = e2.datas, targets = e2.targets, angle2 = e2.angle, originalDatas = e2.originalDatas;
    var _a2 = moveable.props, pinchable = _a2.pinchable, ables = _a2.ables;
    if (!pinchable) {
      return false;
    }
    var eventName = "onPinch" + (targets ? "Group" : "") + "Start";
    var controlEventName = "drag" + (targets ? "Group" : "") + "ControlStart";
    var pinchAbles = (pinchable === true ? moveable.controlAbles : ables.filter(function(able) {
      return pinchable.indexOf(able.name) > -1;
    })).filter(function(able) {
      return able.canPinch && able[controlEventName];
    });
    var params = fillParams(moveable, e2, {});
    if (targets) {
      params.targets = targets;
    }
    var result = triggerEvent(moveable, eventName, params);
    datas.isPinch = result !== false;
    datas.ables = pinchAbles;
    var isPinch = datas.isPinch;
    if (!isPinch) {
      return false;
    }
    pinchAbles.forEach(function(able) {
      originalDatas[able.name] = originalDatas[able.name] || {};
      if (!able[controlEventName]) {
        return;
      }
      var ableEvent = __assign$7(__assign$7({}, e2), {
        datas: originalDatas[able.name],
        parentRotate: angle2,
        isPinch: true
      });
      able[controlEventName](moveable, ableEvent);
    });
    moveable.state.snapRenderInfo = {
      request: e2.isRequest,
      direction: [0, 0]
    };
    return isPinch;
  },
  pinch: function(moveable, e2) {
    var datas = e2.datas, pinchScale = e2.scale, distance2 = e2.distance, originalDatas = e2.originalDatas, inputEvent = e2.inputEvent, targets = e2.targets, angle2 = e2.angle;
    if (!datas.isPinch) {
      return;
    }
    var parentDistance = distance2 * (1 - 1 / pinchScale);
    var params = fillParams(moveable, e2, {});
    if (targets) {
      params.targets = targets;
    }
    var eventName = "onPinch" + (targets ? "Group" : "");
    triggerEvent(moveable, eventName, params);
    var ables = datas.ables;
    var controlEventName = "drag" + (targets ? "Group" : "") + "Control";
    ables.forEach(function(able) {
      if (!able[controlEventName]) {
        return;
      }
      able[controlEventName](moveable, __assign$7(__assign$7({}, e2), {
        datas: originalDatas[able.name],
        inputEvent,
        parentDistance,
        parentRotate: angle2,
        isPinch: true
      }));
    });
    return params;
  },
  pinchEnd: function(moveable, e2) {
    var datas = e2.datas, isPinch = e2.isPinch, inputEvent = e2.inputEvent, targets = e2.targets, originalDatas = e2.originalDatas;
    if (!datas.isPinch) {
      return;
    }
    var eventName = "onPinch" + (targets ? "Group" : "") + "End";
    var params = fillEndParams(moveable, e2, {
      isDrag: isPinch
    });
    if (targets) {
      params.targets = targets;
    }
    triggerEvent(moveable, eventName, params);
    var ables = datas.ables;
    var controlEventName = "drag" + (targets ? "Group" : "") + "ControlEnd";
    ables.forEach(function(able) {
      if (!able[controlEventName]) {
        return;
      }
      able[controlEventName](moveable, __assign$7(__assign$7({}, e2), {
        isDrag: isPinch,
        datas: originalDatas[able.name],
        inputEvent,
        isPinch: true
      }));
    });
    return isPinch;
  },
  pinchGroupStart: function(moveable, e2) {
    return this.pinchStart(moveable, __assign$7(__assign$7({}, e2), {
      targets: moveable.props.targets
    }));
  },
  pinchGroup: function(moveable, e2) {
    return this.pinch(moveable, __assign$7(__assign$7({}, e2), {
      targets: moveable.props.targets
    }));
  },
  pinchGroupEnd: function(moveable, e2) {
    return this.pinchEnd(moveable, __assign$7(__assign$7({}, e2), {
      targets: moveable.props.targets
    }));
  }
});
function setCustomDrag(e2, state, delta, isPinch, isConvert) {
  var result = state.gesto.move(delta, e2.inputEvent);
  var datas = result.originalDatas || result.datas;
  var draggableDatas = datas.draggable || (datas.draggable = {});
  return __assign$7(__assign$7({}, isConvert ? convertDragDist(state, result) : result), {
    isDrag: true,
    isPinch: !!isPinch,
    parentEvent: true,
    datas: draggableDatas,
    originalDatas: e2.originalDatas
  });
}
var CustomGesto = /* @__PURE__ */ function() {
  function CustomGesto2() {
    this.prevX = 0;
    this.prevY = 0;
    this.startX = 0;
    this.startY = 0;
    this.isDrag = false;
    this.isFlag = false;
    this.datas = {
      draggable: {}
    };
  }
  var __proto = CustomGesto2.prototype;
  __proto.dragStart = function(client, e2) {
    this.isDrag = false;
    this.isFlag = false;
    var originalDatas = e2.originalDatas;
    this.datas = originalDatas;
    if (!originalDatas.draggable) {
      originalDatas.draggable = {};
    }
    return __assign$7(__assign$7({}, this.move(client, e2.inputEvent)), {
      type: "dragstart"
    });
  };
  __proto.drag = function(client, inputEvent) {
    return this.move([client[0] - this.prevX, client[1] - this.prevY], inputEvent);
  };
  __proto.move = function(delta, inputEvent) {
    var clientX;
    var clientY;
    if (!this.isFlag) {
      this.prevX = delta[0];
      this.prevY = delta[1];
      this.startX = delta[0];
      this.startY = delta[1];
      clientX = delta[0];
      clientY = delta[1];
      this.isFlag = true;
    } else {
      clientX = this.prevX + delta[0];
      clientY = this.prevY + delta[1];
      this.isDrag = true;
    }
    this.prevX = clientX;
    this.prevY = clientY;
    return {
      type: "drag",
      clientX,
      clientY,
      inputEvent,
      isDrag: this.isDrag,
      distX: clientX - this.startX,
      distY: clientY - this.startY,
      deltaX: delta[0],
      deltaY: delta[1],
      datas: this.datas.draggable,
      originalDatas: this.datas,
      parentEvent: true,
      parentGesto: this
    };
  };
  return CustomGesto2;
}();
function fillChildEvents(moveable, name2, e2) {
  var datas = e2.originalDatas;
  datas.groupable = datas.groupable || {};
  var groupableDatas = datas.groupable;
  groupableDatas.childDatas = groupableDatas.childDatas || [];
  var childDatas = groupableDatas.childDatas;
  return moveable.moveables.map(function(_, i) {
    childDatas[i] = childDatas[i] || {};
    childDatas[i][name2] = childDatas[i][name2] || {};
    return __assign$7(__assign$7({}, e2), {
      datas: childDatas[i][name2],
      originalDatas: childDatas[i]
    });
  });
}
function triggerChildGesto(moveable, able, type, delta, e2, isConvert) {
  var isStart = !!type.match(/Start$/g);
  var isEnd = !!type.match(/End$/g);
  var isPinch = e2.isPinch;
  var datas = e2.datas;
  var events2 = fillChildEvents(moveable, able.name, e2);
  var moveables = moveable.moveables;
  var childs = events2.map(function(ev, i) {
    var childMoveable = moveables[i];
    var childEvent = ev;
    if (isStart) {
      childEvent = new CustomGesto().dragStart(delta, ev);
    } else {
      if (!childMoveable.state.gesto) {
        childMoveable.state.gesto = datas.childGestos[i];
      }
      childEvent = setCustomDrag(ev, childMoveable.state, delta, isPinch, isConvert);
    }
    var result = able[type](childMoveable, __assign$7(__assign$7({}, childEvent), {
      parentFlag: true
    }));
    if (isEnd) {
      childMoveable.state.gesto = null;
    }
    return result;
  });
  if (isStart) {
    datas.childGestos = moveables.map(function(child) {
      return child.state.gesto;
    });
  }
  return childs;
}
function triggerChildAbles(moveable, able, type, e2, eachEvent, callback) {
  if (eachEvent === void 0) {
    eachEvent = function(_, ev) {
      return ev;
    };
  }
  var isEnd = !!type.match(/End$/g);
  var events2 = fillChildEvents(moveable, able.name, e2);
  var moveables = moveable.moveables;
  var childs = events2.map(function(ev, i) {
    var childMoveable = moveables[i];
    var childEvent = ev;
    childEvent = eachEvent(childMoveable, ev);
    var result = able[type](childMoveable, __assign$7(__assign$7({}, childEvent), {
      parentFlag: true
    }));
    result && callback && callback(childMoveable, ev, result, i);
    if (isEnd) {
      childMoveable.state.gesto = null;
    }
    return result;
  });
  return childs;
}
function calculatePointerDist(moveable, e2) {
  var clientX = e2.clientX, clientY = e2.clientY, datas = e2.datas;
  var _a2 = moveable.state, moveableClientRect = _a2.moveableClientRect, rootMatrix = _a2.rootMatrix, is3d = _a2.is3d, pos1 = _a2.pos1;
  var left = moveableClientRect.left, top = moveableClientRect.top;
  var n = is3d ? 4 : 3;
  var _b = minus(calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n), pos1), posX = _b[0], posY = _b[1];
  var _c = getDragDist({
    datas,
    distX: posX,
    distY: posY
  }), distX = _c[0], distY = _c[1];
  return [distX, distY];
}
function setDragStart(moveable, _a2) {
  var datas = _a2.datas;
  var _b = moveable.state, allMatrix = _b.allMatrix, beforeMatrix = _b.beforeMatrix, is3d = _b.is3d, left = _b.left, top = _b.top, origin = _b.origin, offsetMatrix = _b.offsetMatrix, targetMatrix = _b.targetMatrix, transformOrigin2 = _b.transformOrigin;
  var n = is3d ? 4 : 3;
  datas.is3d = is3d;
  datas.matrix = allMatrix;
  datas.targetMatrix = targetMatrix;
  datas.beforeMatrix = beforeMatrix;
  datas.offsetMatrix = offsetMatrix;
  datas.transformOrigin = transformOrigin2;
  datas.inverseMatrix = invert(allMatrix, n);
  datas.inverseBeforeMatrix = invert(beforeMatrix, n);
  datas.absoluteOrigin = convertPositionMatrix(plus([left, top], origin), n);
  datas.startDragBeforeDist = calculate(datas.inverseBeforeMatrix, datas.absoluteOrigin, n);
  datas.startDragDist = calculate(datas.inverseMatrix, datas.absoluteOrigin, n);
}
function getTransformDirection(e2) {
  return calculateMoveablePosition(e2.datas.beforeTransform, [50, 50], 100, 100).direction;
}
function resolveTransformEvent(event, functionName) {
  var datas = event.datas, originalDatas = event.originalDatas.beforeRenderable;
  var index2 = datas.transformIndex;
  var nextTransforms = originalDatas.nextTransforms;
  var nextTransformAppendedIndexes = originalDatas.nextTransformAppendedIndexes;
  var nextIndex = index2 === -1 ? nextTransforms.length : index2 + nextTransformAppendedIndexes.filter(function(i) {
    return i < index2;
  }).length;
  var result = getTransform(nextTransforms, nextIndex);
  var targetFunction = result.targetFunction;
  var matFunctionName = functionName === "rotate" ? "rotateZ" : functionName;
  datas.beforeFunctionTexts = result.beforeFunctionTexts;
  datas.afterFunctionTexts = result.afterFunctionTexts;
  datas.beforeTransform = result.beforeFunctionMatrix;
  datas.beforeTransform2 = result.beforeFunctionMatrix2;
  datas.targetTansform = result.targetFunctionMatrix;
  datas.afterTransform = result.afterFunctionMatrix;
  datas.afterTransform2 = result.afterFunctionMatrix2;
  datas.targetAllTransform = result.allFunctionMatrix;
  if (targetFunction.functionName === matFunctionName) {
    datas.afterFunctionTexts.splice(0, 1);
    datas.isAppendTransform = false;
  } else {
    datas.isAppendTransform = true;
    originalDatas.nextTransformAppendedIndexes = __spreadArrays$2(nextTransformAppendedIndexes, [nextIndex]);
  }
}
function convertTransformFormat(datas, value, dist) {
  return datas.beforeFunctionTexts.join(" ") + " " + (datas.isAppendTransform ? dist : value) + " " + datas.afterFunctionTexts.join(" ");
}
function getTransformDist(_a2) {
  var datas = _a2.datas, distX = _a2.distX, distY = _a2.distY;
  var _b = getBeforeDragDist({
    datas,
    distX,
    distY
  }), bx = _b[0], by = _b[1];
  var res = getTransfromMatrix(datas, fromTranslation([bx, by], 4));
  return calculate(res, convertPositionMatrix([0, 0, 0], 4), 4);
}
function getTransfromMatrix(datas, targetMatrix, isAfter) {
  var beforeTransform = datas.beforeTransform, afterTransform = datas.afterTransform, beforeTransform2 = datas.beforeTransform2, afterTransform2 = datas.afterTransform2, targetAllTransform = datas.targetAllTransform;
  var nextTargetMatrix = isAfter ? multiply(targetAllTransform, targetMatrix, 4) : multiply(targetMatrix, targetAllTransform, 4);
  var res1 = multiply(invert(isAfter ? beforeTransform2 : beforeTransform, 4), nextTargetMatrix, 4);
  var afterTargetMatrix = multiply(res1, invert(isAfter ? afterTransform2 : afterTransform, 4), 4);
  return afterTargetMatrix;
}
function getBeforeDragDist(_a2) {
  var datas = _a2.datas, distX = _a2.distX, distY = _a2.distY;
  var inverseBeforeMatrix = datas.inverseBeforeMatrix, is3d = datas.is3d, startDragBeforeDist = datas.startDragBeforeDist, absoluteOrigin = datas.absoluteOrigin;
  var n = is3d ? 4 : 3;
  return minus(calculate(inverseBeforeMatrix, plus(absoluteOrigin, [distX, distY]), n), startDragBeforeDist);
}
function getDragDist(_a2, isBefore) {
  var datas = _a2.datas, distX = _a2.distX, distY = _a2.distY;
  var inverseBeforeMatrix = datas.inverseBeforeMatrix, inverseMatrix = datas.inverseMatrix, is3d = datas.is3d, startDragBeforeDist = datas.startDragBeforeDist, startDragDist = datas.startDragDist, absoluteOrigin = datas.absoluteOrigin;
  var n = is3d ? 4 : 3;
  return minus(calculate(isBefore ? inverseBeforeMatrix : inverseMatrix, plus(absoluteOrigin, [distX, distY]), n), isBefore ? startDragBeforeDist : startDragDist);
}
function getInverseDragDist(_a2, isBefore) {
  var datas = _a2.datas, distX = _a2.distX, distY = _a2.distY;
  var beforeMatrix = datas.beforeMatrix, matrix2 = datas.matrix, is3d = datas.is3d, startDragBeforeDist = datas.startDragBeforeDist, startDragDist = datas.startDragDist, absoluteOrigin = datas.absoluteOrigin;
  var n = is3d ? 4 : 3;
  return minus(calculate(isBefore ? beforeMatrix : matrix2, plus(isBefore ? startDragBeforeDist : startDragDist, [distX, distY]), n), absoluteOrigin);
}
function calculateTransformOrigin(transformOrigin2, width, height, prevWidth, prevHeight, prevOrigin) {
  if (prevWidth === void 0) {
    prevWidth = width;
  }
  if (prevHeight === void 0) {
    prevHeight = height;
  }
  if (prevOrigin === void 0) {
    prevOrigin = [0, 0];
  }
  if (!transformOrigin2) {
    return prevOrigin;
  }
  return transformOrigin2.map(function(pos, i) {
    var _a2 = splitUnit(pos), value = _a2.value, unit = _a2.unit;
    var prevSize = i ? prevHeight : prevWidth;
    var size = i ? height : width;
    if (pos === "%" || isNaN(value)) {
      var measureRatio = prevSize ? prevOrigin[i] / prevSize : 0;
      return size * measureRatio;
    } else if (unit !== "%") {
      return value;
    }
    return size * value / 100;
  });
}
function getPosIndexesByDirection(direction2) {
  var indexes = [];
  if (direction2[1] >= 0) {
    if (direction2[0] >= 0) {
      indexes.push(3);
    }
    if (direction2[0] <= 0) {
      indexes.push(2);
    }
  }
  if (direction2[1] <= 0) {
    if (direction2[0] >= 0) {
      indexes.push(1);
    }
    if (direction2[0] <= 0) {
      indexes.push(0);
    }
  }
  return indexes;
}
function getPosesByDirection(poses, direction2) {
  return getPosIndexesByDirection(direction2).map(function(index2) {
    return poses[index2];
  });
}
function getPosByDirection(poses, direction2) {
  var nextPoses = getPosesByDirection(poses, direction2);
  return [average(nextPoses.map(function(pos) {
    return pos[0];
  })), average(nextPoses.map(function(pos) {
    return pos[1];
  }))];
}
function getPosByReverseDirection(poses, direction2) {
  return getPosByDirection(poses, direction2.map(function(dir) {
    return -dir;
  }));
}
function getDist(startPos, matrix2, width, height, n, fixedDirection) {
  var poses = calculatePoses(matrix2, width, height, n);
  var fixedPos = getPosByDirection(poses, fixedDirection);
  var distX = startPos[0] - fixedPos[0];
  var distY = startPos[1] - fixedPos[1];
  return [distX, distY];
}
function getNextMatrix(offsetMatrix, targetMatrix, origin, n) {
  return multiply(offsetMatrix, getAbsoluteMatrix(targetMatrix, n, origin), n);
}
function getNextTransformMatrix(state, datas, transform2) {
  var transformOrigin2 = state.transformOrigin, offsetMatrix = state.offsetMatrix, is3d = state.is3d;
  var beforeTransform = datas.beforeTransform, afterTransform = datas.afterTransform;
  var n = is3d ? 4 : 3;
  var targetTransform = parseMat([transform2]);
  return getNextMatrix(offsetMatrix, convertDimension(multiply(multiply(beforeTransform, targetTransform, 4), afterTransform, 4), 4, n), transformOrigin2, n);
}
function scaleMatrix(state, scale) {
  var transformOrigin2 = state.transformOrigin, offsetMatrix = state.offsetMatrix, is3d = state.is3d, targetMatrix = state.targetMatrix;
  var n = is3d ? 4 : 3;
  return getNextMatrix(offsetMatrix, multiply(targetMatrix, createScaleMatrix(scale, n), n), transformOrigin2, n);
}
function fillTransformStartEvent(e2) {
  var originalDatas = e2.originalDatas.beforeRenderable;
  return {
    setTransform: function(transform2, index2) {
      if (index2 === void 0) {
        index2 = -1;
      }
      originalDatas.startTransforms = isArray$1(transform2) ? transform2 : splitSpace(transform2);
      setTransformIndex(e2, index2);
    },
    setTransformIndex: function(index2) {
      setTransformIndex(e2, index2);
    }
  };
}
function setDefaultTransformIndex(e2, property) {
  var originalDatas = e2.originalDatas.beforeRenderable;
  var startTransforms = originalDatas.startTransforms;
  setTransformIndex(e2, findIndex(startTransforms, function(func) {
    return func.indexOf(property + "(") === 0;
  }));
}
function setTransformIndex(e2, index2) {
  var originalDatas = e2.originalDatas.beforeRenderable;
  var datas = e2.datas;
  datas.transformIndex = index2;
  if (index2 === -1) {
    return;
  }
  var transform2 = originalDatas.startTransforms[index2];
  if (!transform2) {
    return;
  }
  var info = parse$1([transform2]);
  datas.startValue = info[0].functionValue;
}
function fillOriginalTransform(e2, transform2) {
  var originalDatas = e2.originalDatas.beforeRenderable;
  originalDatas.nextTransforms = splitSpace(transform2);
}
function fillTransformEvent(moveable, nextTransform, delta, isPinch, e2) {
  fillOriginalTransform(e2, nextTransform);
  return {
    transform: nextTransform,
    drag: Draggable.drag(moveable, setCustomDrag(e2, moveable.state, delta, isPinch, false))
  };
}
function getTranslateDist(moveable, transform2, fixedDirection, fixedPosition, datas) {
  var state = moveable.state;
  var left = state.left, top = state.top;
  var groupable = moveable.props.groupable;
  var nextMatrix = getNextTransformMatrix(moveable.state, datas, transform2);
  var groupLeft = groupable ? left : 0;
  var groupTop = groupable ? top : 0;
  var nextFixedPosition = getDirectionOffset(moveable, fixedDirection, nextMatrix);
  var dist = minus(fixedPosition, nextFixedPosition);
  return minus(dist, [groupLeft, groupTop]);
}
function getScaleDist(moveable, scaleDist, fixedDirection, fixedPosition, datas) {
  return getTranslateDist(moveable, "scale(" + scaleDist.join(", ") + ")", fixedDirection, fixedPosition, datas);
}
function getOriginDirection(moveable) {
  var _a2 = moveable.state, width = _a2.width, height = _a2.height, transformOrigin2 = _a2.transformOrigin;
  return [-1 + transformOrigin2[0] / (width / 2), -1 + transformOrigin2[1] / (height / 2)];
}
function getDirectionOffset(moveable, direction2, nextMatrix) {
  if (nextMatrix === void 0) {
    nextMatrix = moveable.state.allMatrix;
  }
  var _a2 = moveable.state, width = _a2.width, height = _a2.height, is3d = _a2.is3d;
  var n = is3d ? 4 : 3;
  var nextFixedOffset = [width / 2 * (1 + direction2[0]), height / 2 * (1 + direction2[1])];
  return calculatePosition(nextMatrix, nextFixedOffset, n);
}
function getRotateDist(moveable, rotateDist, fixedPosition, datas) {
  var fixedDirection = getOriginDirection(moveable);
  return getTranslateDist(moveable, "rotate(" + rotateDist + "deg)", fixedDirection, fixedPosition, datas);
}
function getResizeDist(moveable, width, height, fixedDirection, fixedPosition, transformOrigin2) {
  var groupable = moveable.props.groupable;
  var _a2 = moveable.state, prevOrigin = _a2.transformOrigin, targetMatrix = _a2.targetMatrix, offsetMatrix = _a2.offsetMatrix, is3d = _a2.is3d, prevWidth = _a2.width, prevHeight = _a2.height, left = _a2.left, top = _a2.top;
  var n = is3d ? 4 : 3;
  var nextOrigin = calculateTransformOrigin(transformOrigin2, width, height, prevWidth, prevHeight, prevOrigin);
  var groupLeft = groupable ? left : 0;
  var groupTop = groupable ? top : 0;
  var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, nextOrigin, n);
  var dist = getDist(fixedPosition, nextMatrix, width, height, n, fixedDirection);
  return minus(dist, [groupLeft, groupTop]);
}
function getAbsolutePosition(moveable, direction2) {
  return getPosByDirection(getAbsolutePosesByState(moveable.state), direction2);
}
function calculateContainerPos(rootMatrix, containerRect, n) {
  var clientPos = calculatePosition(rootMatrix, [containerRect.clientLeft, containerRect.clientTop], n);
  return [containerRect.left + clientPos[0], containerRect.top + clientPos[1]];
}
function getGapGuidelines(guidelines, type, snapThreshold, index2, _a2, _b) {
  var start = _a2[0], end = _a2[1];
  var otherStart = _b[0], otherEnd = _b[1];
  var totalGuidelines = [];
  var otherIndex = index2 ? 0 : 1;
  var otherType = type === "vertical" ? "horizontal" : "vertical";
  var elementGuidelines = groupBy(guidelines.filter(function(_a3) {
    var guidelineType = _a3.type;
    return guidelineType === type;
  }), function(_a3) {
    var element = _a3.element;
    return element;
  }).map(function(group) {
    return group[0];
  }).filter(function(_a3) {
    var pos = _a3.pos, sizes = _a3.sizes;
    return pos[otherIndex] <= otherEnd && otherStart <= pos[otherIndex] + sizes[otherIndex];
  });
  elementGuidelines.forEach(function(guideline1) {
    var elementStart = guideline1.pos[index2];
    var elementEnd = elementStart + guideline1.sizes[index2];
    elementGuidelines.forEach(function(guideline2) {
      var guideline2Pos = guideline2.pos, guideline2Sizes = guideline2.sizes, guideline2Element = guideline2.element, guidline2ClassName = guideline2.className;
      var targetStart = guideline2Pos[index2];
      var targetEnd = targetStart + guideline2Sizes[index2];
      var pos = 0;
      var gap = 0;
      var canSnap = true;
      if (elementEnd <= targetStart) {
        gap = elementEnd - targetStart;
        pos = targetEnd - gap;
        if (start < pos - snapThreshold) {
          canSnap = false;
        }
      } else if (targetEnd <= elementStart) {
        gap = elementStart - targetEnd;
        pos = targetStart - gap;
        if (end > pos + snapThreshold) {
          canSnap = false;
        }
      } else {
        return;
      }
      if (canSnap) {
        totalGuidelines.push({
          pos: otherType === "vertical" ? [pos, guideline2Pos[1]] : [guideline2Pos[0], pos],
          element: guideline2Element,
          sizes: guideline2Sizes,
          size: 0,
          type: otherType,
          gap,
          className: guidline2ClassName,
          gapGuidelines: elementGuidelines
        });
      }
      if (elementEnd <= start && end <= targetStart) {
        var centerPos = (targetStart + elementEnd - (end - start)) / 2;
        if (throttle$3(start - (centerPos - snapThreshold), 0.1) >= 0) {
          totalGuidelines.push({
            pos: otherType === "vertical" ? [centerPos, guideline2Pos[1]] : [guideline2Pos[0], centerPos],
            className: guidline2ClassName,
            element: guideline2Element,
            sizes: guideline2Sizes,
            size: 0,
            type: otherType,
            gap: elementEnd - start,
            gapGuidelines: elementGuidelines
          });
        }
      }
    });
  });
  return totalGuidelines;
}
function getDefaultGuidelines(horizontalGuidelines, verticalGuidelines, width, height, clientLeft, clientTop, snapOffset) {
  if (clientLeft === void 0) {
    clientLeft = 0;
  }
  if (clientTop === void 0) {
    clientTop = 0;
  }
  if (snapOffset === void 0) {
    snapOffset = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
  }
  var guidelines = [];
  var snapOffsetLeft = snapOffset.left, snapOffsetTop = snapOffset.top, snapOffsetBottom = snapOffset.bottom, snapOffsetRight = snapOffset.right;
  var snapWidth = width + snapOffsetRight - snapOffsetLeft;
  var snapHeight = height + snapOffsetBottom - snapOffsetTop;
  horizontalGuidelines && horizontalGuidelines.forEach(function(pos) {
    guidelines.push({
      type: "horizontal",
      pos: [snapOffsetLeft, throttle$3(pos - clientTop + snapOffsetTop, 0.1)],
      size: snapWidth
    });
  });
  verticalGuidelines && verticalGuidelines.forEach(function(pos) {
    guidelines.push({
      type: "vertical",
      pos: [throttle$3(pos - clientLeft + snapOffsetLeft, 0.1), snapOffsetTop],
      size: snapHeight
    });
  });
  return guidelines;
}
function calculateElementGuidelines(moveable, values) {
  var guidelines = [];
  if (!values.length) {
    return guidelines;
  }
  var state = moveable.state;
  var snapCenter = moveable.props.snapCenter;
  var containerClientRect = state.containerClientRect, _a2 = state.targetClientRect, clientTop = _a2.top, clientLeft = _a2.left, rootMatrix = state.rootMatrix, is3d = state.is3d;
  var n = is3d ? 4 : 3;
  var _b = calculateContainerPos(rootMatrix, containerClientRect, n), containerLeft = _b[0], containerTop = _b[1];
  var poses = getAbsolutePosesByState(state);
  var _c = getMinMaxs(poses), targetLeft = _c.minX, targetTop = _c.minY;
  var _d = minus([targetLeft, targetTop], calculateInversePosition(rootMatrix, [clientLeft - containerLeft, clientTop - containerTop], n)).map(function(pos) {
    return roundSign(pos);
  }), distLeft = _d[0], distTop = _d[1];
  values.forEach(function(value) {
    var element = value.element, topValue = value.top, leftValue = value.left, rightValue = value.right, bottomValue = value.bottom, className = value.className;
    var rect = element.getBoundingClientRect();
    var left = rect.left - containerLeft;
    var top = rect.top - containerTop;
    var bottom = top + rect.height;
    var right = left + rect.width;
    var _a3 = calculateInversePosition(rootMatrix, [left, top], n), elementLeft = _a3[0], elementTop = _a3[1];
    var _b2 = calculateInversePosition(rootMatrix, [right, bottom], n), elementRight = _b2[0], elementBottom = _b2[1];
    var width = elementRight - elementLeft;
    var height = elementBottom - elementTop;
    var sizes = [width, height];
    if (topValue !== false) {
      guidelines.push({
        type: "vertical",
        element,
        pos: [throttle$3(elementLeft + distLeft, 0.1), elementTop],
        size: height,
        sizes,
        className
      });
    }
    if (bottomValue !== false) {
      guidelines.push({
        type: "vertical",
        element,
        pos: [throttle$3(elementRight + distLeft, 0.1), elementTop],
        size: height,
        sizes,
        className
      });
    }
    if (leftValue !== false) {
      guidelines.push({
        type: "horizontal",
        element,
        pos: [elementLeft, throttle$3(elementTop + distTop, 0.1)],
        size: width,
        sizes,
        className
      });
    }
    if (rightValue !== false) {
      guidelines.push({
        type: "horizontal",
        element,
        pos: [elementLeft, throttle$3(elementBottom + distTop, 0.1)],
        size: width,
        sizes,
        className
      });
    }
    if (snapCenter) {
      guidelines.push({
        type: "vertical",
        element,
        pos: [throttle$3((elementLeft + elementRight) / 2 + distLeft, 0.1), elementTop],
        size: height,
        sizes,
        center: true,
        className
      });
      guidelines.push({
        type: "horizontal",
        element,
        pos: [elementLeft, throttle$3((elementTop + elementBottom) / 2 + distTop, 0.1)],
        size: width,
        sizes,
        center: true,
        className
      });
    }
  });
  return guidelines;
}
function getElementGuidelines(moveable, isRefresh, prevGuidelines) {
  if (prevGuidelines === void 0) {
    prevGuidelines = [];
  }
  var guidelines = [];
  var state = moveable.state;
  if (isRefresh && state.guidelines && state.guidelines.length) {
    return guidelines;
  }
  var _a2 = moveable.props.elementGuidelines, elementGuidelines = _a2 === void 0 ? [] : _a2;
  if (!elementGuidelines.length) {
    return guidelines;
  }
  var prevValues = state.elementGuidelineValues || [];
  var nextValues = elementGuidelines.map(function(el) {
    if (isObject$2(el) && "element" in el) {
      return el;
    }
    return {
      element: getRefTarget(el, true)
    };
  }).filter(function(value) {
    return value.element;
  });
  state.elementGuidelineValues = nextValues;
  var _b = diff(prevValues.map(function(v) {
    return v.element;
  }), nextValues.map(function(v) {
    return v.element;
  })), added = _b.added, removed = _b.removed;
  var removedElements = removed.map(function(index2) {
    return prevValues[index2].element;
  });
  var addedGuidelines = calculateElementGuidelines(moveable, added.map(function(index2) {
    return nextValues[index2];
  }).filter(function(value) {
    return value.refresh && isRefresh || !value.refresh && !isRefresh;
  }));
  return __spreadArrays$2(prevGuidelines.filter(function(guideline) {
    return removedElements.indexOf(guideline.element) === -1;
  }), addedGuidelines);
}
function getTotalGuidelines(moveable) {
  var _a2 = moveable.state, snapOffset = _a2.snapOffset, staticGuidelines = _a2.staticGuidelines, _b = _a2.containerClientRect, overflow2 = _b.overflow, containerHeight = _b.scrollHeight, containerWidth = _b.scrollWidth, containerClientHeight = _b.clientHeight, containerClientWidth = _b.clientWidth, clientLeft = _b.clientLeft, clientTop = _b.clientTop;
  var _c = moveable.props, _d = _c.snapHorizontal, snapHorizontal = _d === void 0 ? true : _d, _e = _c.snapVertical, snapVertical = _e === void 0 ? true : _e, _f = _c.snapGap, snapGap = _f === void 0 ? true : _f, verticalGuidelines = _c.verticalGuidelines, horizontalGuidelines = _c.horizontalGuidelines, _g = _c.snapThreshold, snapThreshold = _g === void 0 ? 5 : _g, _h = _c.snapGridWidth, snapGridWidth = _h === void 0 ? 0 : _h, _j = _c.snapGridHeight, snapGridHeight = _j === void 0 ? 0 : _j;
  var totalGuidelines = __spreadArrays$2(staticGuidelines, getElementGuidelines(moveable, true));
  if (snapGap) {
    var _k = getRect$2(getAbsolutePosesByState(moveable.state)), top = _k.top, left = _k.left, bottom = _k.bottom, right = _k.right;
    var elementGuidelines = staticGuidelines.filter(function(_a3) {
      var element = _a3.element;
      return element;
    });
    totalGuidelines.push.apply(totalGuidelines, __spreadArrays$2(getGapGuidelines(elementGuidelines, "horizontal", snapThreshold, 0, [left, right], [top, bottom]), getGapGuidelines(elementGuidelines, "vertical", snapThreshold, 1, [top, bottom], [left, right])));
  }
  totalGuidelines.push.apply(totalGuidelines, getGridGuidelines(snapGridWidth, snapGridHeight, overflow2 ? containerWidth : containerClientWidth, overflow2 ? containerHeight : containerClientHeight, clientLeft, clientTop));
  totalGuidelines.push.apply(totalGuidelines, getDefaultGuidelines(snapHorizontal && horizontalGuidelines || false, snapVertical && verticalGuidelines || false, overflow2 ? containerWidth : containerClientWidth, overflow2 ? containerHeight : containerClientHeight, clientLeft, clientTop, snapOffset));
  return totalGuidelines;
}
function getGridGuidelines(snapGridWidth, snapGridHeight, containerWidth, containerHeight, clientLeft, clientTop) {
  if (clientLeft === void 0) {
    clientLeft = 0;
  }
  if (clientTop === void 0) {
    clientTop = 0;
  }
  var guidelines = [];
  if (snapGridHeight) {
    for (var pos = 0; pos <= containerHeight; pos += snapGridHeight) {
      guidelines.push({
        type: "horizontal",
        pos: [0, throttle$3(pos - clientTop, 0.1)],
        size: containerWidth,
        hide: true
      });
    }
  }
  if (snapGridWidth) {
    for (var pos = 0; pos <= containerWidth; pos += snapGridWidth) {
      guidelines.push({
        type: "vertical",
        pos: [throttle$3(pos - clientLeft, 0.1), 0],
        size: containerHeight,
        hide: true
      });
    }
  }
  return guidelines;
}
function checkMoveableSnapPoses(moveable, posesX, posesY, snapCenter, customSnapThreshold) {
  var props2 = moveable.props;
  var _a2 = props2.snapElement, snapElement = _a2 === void 0 ? true : _a2;
  var snapThreshold = selectValue(customSnapThreshold, props2.snapThreshold, 5);
  return checkSnapPoses(moveable.state.guidelines, posesX, posesY, {
    snapThreshold,
    snapCenter,
    snapElement
  });
}
function checkSnapPoses(guidelines, posesX, posesY, options) {
  return {
    vertical: checkSnap(guidelines, "vertical", posesX, options),
    horizontal: checkSnap(guidelines, "horizontal", posesY, options)
  };
}
function checkSnapKeepRatio(moveable, startPos, endPos) {
  var endX = endPos[0], endY = endPos[1];
  var startX = startPos[0], startY = startPos[1];
  var _a2 = minus(endPos, startPos), dx = _a2[0], dy = _a2[1];
  var isBottom = dy > 0;
  var isRight = dx > 0;
  dx = getTinyDist(dx);
  dy = getTinyDist(dy);
  var verticalInfo = {
    isSnap: false,
    offset: 0,
    pos: 0
  };
  var horizontalInfo = {
    isSnap: false,
    offset: 0,
    pos: 0
  };
  if (dx === 0 && dy === 0) {
    return {
      vertical: verticalInfo,
      horizontal: horizontalInfo
    };
  }
  var _b = checkMoveableSnapPoses(moveable, dx ? [endX] : [], dy ? [endY] : []), verticalSnapInfo = _b.vertical, horizontalSnapInfo = _b.horizontal;
  verticalSnapInfo.posInfos.filter(function(_a3) {
    var pos = _a3.pos;
    return isRight ? pos >= startX : pos <= startX;
  });
  horizontalSnapInfo.posInfos.filter(function(_a3) {
    var pos = _a3.pos;
    return isBottom ? pos >= startY : pos <= startY;
  });
  verticalSnapInfo.isSnap = verticalSnapInfo.posInfos.length > 0;
  horizontalSnapInfo.isSnap = horizontalSnapInfo.posInfos.length > 0;
  var _c = getNearestSnapGuidelineInfo(verticalSnapInfo), isVerticalSnap = _c.isSnap, verticalGuideline = _c.guideline;
  var _d = getNearestSnapGuidelineInfo(horizontalSnapInfo), isHorizontalSnap = _d.isSnap, horizontalGuideline = _d.guideline;
  var horizontalPos = isHorizontalSnap ? horizontalGuideline.pos[1] : 0;
  var verticalPos = isVerticalSnap ? verticalGuideline.pos[0] : 0;
  if (dx === 0) {
    if (isHorizontalSnap) {
      horizontalInfo.isSnap = true;
      horizontalInfo.pos = horizontalGuideline.pos[1];
      horizontalInfo.offset = endY - horizontalInfo.pos;
    }
  } else if (dy === 0) {
    if (isVerticalSnap) {
      verticalInfo.isSnap = true;
      verticalInfo.pos = verticalPos;
      verticalInfo.offset = endX - verticalPos;
    }
  } else {
    var a2 = dy / dx;
    var b = endPos[1] - a2 * endX;
    var y = 0;
    var x = 0;
    var isSnap = false;
    if (isVerticalSnap) {
      x = verticalPos;
      y = a2 * x + b;
      isSnap = true;
    } else if (isHorizontalSnap) {
      y = horizontalPos;
      x = (y - b) / a2;
      isSnap = true;
    }
    if (isSnap) {
      verticalInfo.isSnap = true;
      verticalInfo.pos = x;
      verticalInfo.offset = endX - x;
      horizontalInfo.isSnap = true;
      horizontalInfo.pos = y;
      horizontalInfo.offset = endY - y;
    }
  }
  return {
    vertical: verticalInfo,
    horizontal: horizontalInfo
  };
}
function checkSnaps(moveable, rect, isCenter, customSnapThreshold) {
  var snapCenter = moveable.props.snapCenter;
  var isSnapCenter = snapCenter && isCenter;
  var verticalNames = ["left", "right"];
  var horizontalNames = ["top", "bottom"];
  if (isSnapCenter) {
    verticalNames.push("center");
    horizontalNames.push("middle");
  }
  verticalNames = verticalNames.filter(function(name2) {
    return name2 in rect;
  });
  horizontalNames = horizontalNames.filter(function(name2) {
    return name2 in rect;
  });
  return checkMoveableSnapPoses(moveable, verticalNames.map(function(name2) {
    return rect[name2];
  }), horizontalNames.map(function(name2) {
    return rect[name2];
  }), isSnapCenter, customSnapThreshold);
}
function getNearestSnapGuidelineInfo(snapInfo) {
  var isSnap = snapInfo.isSnap;
  if (!isSnap) {
    return {
      isSnap: false,
      offset: 0,
      dist: -1,
      pos: 0,
      guideline: null
    };
  }
  var posInfo = snapInfo.posInfos[0];
  var guidelineInfo = posInfo.guidelineInfos[0];
  var offset = guidelineInfo.offset;
  var dist = guidelineInfo.dist;
  var guideline = guidelineInfo.guideline;
  return {
    isSnap,
    offset,
    dist,
    pos: posInfo.pos,
    guideline
  };
}
function checkSnap(guidelines, targetType, targetPoses, _a2) {
  var _b = _a2 === void 0 ? {} : _a2, _c = _b.snapThreshold, snapThreshold = _c === void 0 ? 5 : _c, snapElement = _b.snapElement, snapCenter = _b.snapCenter;
  if (!guidelines || !guidelines.length) {
    return {
      isSnap: false,
      index: -1,
      posInfos: []
    };
  }
  var isVertical = targetType === "vertical";
  var posType = isVertical ? 0 : 1;
  var snapPosInfos = targetPoses.map(function(targetPos, index2) {
    var guidelineInfos = guidelines.map(function(guideline) {
      var pos = guideline.pos;
      var offset = targetPos - pos[posType];
      return {
        offset,
        dist: Math.abs(offset),
        guideline
      };
    }).filter(function(_a3) {
      var guideline = _a3.guideline, dist = _a3.dist;
      var type = guideline.type, center = guideline.center, element = guideline.element;
      if (!snapElement && element || !snapCenter && center || type !== targetType || dist > snapThreshold) {
        return false;
      }
      return true;
    }).sort(function(a2, b) {
      return a2.dist - b.dist;
    });
    return {
      pos: targetPos,
      index: index2,
      guidelineInfos
    };
  }).filter(function(snapPosInfo) {
    return snapPosInfo.guidelineInfos.length > 0;
  }).sort(function(a2, b) {
    return a2.guidelineInfos[0].dist - b.guidelineInfos[0].dist;
  });
  var isSnap = snapPosInfos.length > 0;
  return {
    isSnap,
    index: isSnap ? snapPosInfos[0].index : -1,
    posInfos: snapPosInfos
  };
}
function getSnapInfosByDirection(moveable, poses, snapDirection) {
  var nextPoses = [];
  if (snapDirection[0] && snapDirection[1]) {
    nextPoses = [snapDirection, [-snapDirection[0], snapDirection[1]], [snapDirection[0], -snapDirection[1]]].map(function(direction2) {
      return getPosByDirection(poses, direction2);
    });
  } else if (!snapDirection[0] && !snapDirection[1]) {
    var alignPoses = [poses[0], poses[1], poses[3], poses[2], poses[0]];
    for (var i = 0; i < 4; ++i) {
      nextPoses.push(alignPoses[i]);
      nextPoses.push([(alignPoses[i][0] + alignPoses[i + 1][0]) / 2, (alignPoses[i][1] + alignPoses[i + 1][1]) / 2]);
    }
  } else {
    if (moveable.props.keepRatio) {
      nextPoses = [[-1, -1], [-1, 1], [1, -1], [1, 1], snapDirection].map(function(dir) {
        return getPosByDirection(poses, dir);
      });
    } else {
      nextPoses = getPosesByDirection(poses, snapDirection);
      if (nextPoses.length > 1) {
        nextPoses.push([(nextPoses[0][0] + nextPoses[1][0]) / 2, (nextPoses[0][1] + nextPoses[1][1]) / 2]);
      }
    }
  }
  return checkMoveableSnapPoses(moveable, nextPoses.map(function(pos) {
    return pos[0];
  }), nextPoses.map(function(pos) {
    return pos[1];
  }), true, 1);
}
function checkSnapBoundPriority(a2, b) {
  var aDist = Math.abs(a2.offset);
  var bDist = Math.abs(b.offset);
  if (a2.isBound && b.isBound) {
    return bDist - aDist;
  } else if (a2.isBound) {
    return -1;
  } else if (b.isBound) {
    return 1;
  } else if (a2.isSnap && b.isSnap) {
    return bDist - aDist;
  } else if (a2.isSnap) {
    return -1;
  } else if (b.isSnap) {
    return 1;
  } else if (aDist < TINY_NUM) {
    return 1;
  } else if (bDist < TINY_NUM) {
    return -1;
  }
  return aDist - bDist;
}
function getNearOffsetInfo(offsets, index2) {
  return offsets.slice().sort(function(a2, b) {
    var aSign = a2.sign[index2];
    var bSign = b.sign[index2];
    var aOffset = a2.offset[index2];
    var bOffset = b.offset[index2];
    if (!aSign) {
      return 1;
    } else if (!bSign) {
      return -1;
    }
    return checkSnapBoundPriority({
      isBound: a2.isBound,
      isSnap: a2.isSnap,
      offset: aOffset
    }, {
      isBound: b.isBound,
      isSnap: b.isSnap,
      offset: bOffset
    });
  })[0];
}
function isStartLine(dot2, line) {
  var cx = average([line[0][0], line[1][0]]);
  var cy = average([line[0][1], line[1][1]]);
  return {
    vertical: cx <= dot2[0],
    horizontal: cy <= dot2[1]
  };
}
function hitTestLine(dot2, _a2) {
  var pos1 = _a2[0], pos2 = _a2[1];
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];
  if (Math.abs(dx) < TINY_NUM) {
    dx = 0;
  }
  if (Math.abs(dy) < TINY_NUM) {
    dy = 0;
  }
  var test1;
  var test2;
  if (!dx) {
    test1 = pos1[0];
    test2 = dot2[0];
  } else if (!dy) {
    test1 = pos1[1];
    test2 = dot2[1];
  } else {
    var a2 = dy / dx;
    test1 = a2 * (dot2[0] - pos1[0]) + pos1[1];
    test2 = dot2[1];
  }
  return test1 - test2;
}
function isSameStartLine(dots, line, error) {
  if (error === void 0) {
    error = TINY_NUM;
  }
  var centerSign = hitTestLine(dots[0], line) <= 0;
  return dots.slice(1).every(function(dot2) {
    var value = hitTestLine(dot2, line);
    var sign2 = value <= 0;
    return sign2 === centerSign || Math.abs(value) <= error;
  });
}
function checkInnerBoundDot(pos, start, end, isStart, threshold) {
  if (threshold === void 0) {
    threshold = 0;
  }
  if (isStart && start - threshold <= pos || !isStart && pos <= end + threshold) {
    return {
      isBound: true,
      offset: isStart ? start - pos : end - pos
    };
  }
  return {
    isBound: false,
    offset: 0
  };
}
function checkInnerBound(moveable, line, center) {
  var bounds = moveable.props.innerBounds;
  if (!bounds) {
    return {
      isAllBound: false,
      isBound: false,
      isVerticalBound: false,
      isHorizontalBound: false,
      offset: [0, 0]
    };
  }
  var left = bounds.left, top = bounds.top, width = bounds.width, height = bounds.height;
  var leftLine = [[left, top], [left, top + height]];
  var topLine = [[left, top], [left + width, top]];
  var rightLine = [[left + width, top], [left + width, top + height]];
  var bottomLine = [[left, top + height], [left + width, top + height]];
  var _a2 = isStartLine(center, line), isHorizontalStart = _a2.horizontal, isVerticalStart = _a2.vertical;
  if (isSameStartLine([center, [left, top], [left + width, top], [left, top + height], [left + width, top + height]], line)) {
    return {
      isAllBound: false,
      isBound: false,
      isVerticalBound: false,
      isHorizontalBound: false,
      offset: [0, 0]
    };
  }
  var topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart);
  var bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart);
  var leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart);
  var rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart);
  var isAllVerticalBound = topBoundInfo.isBound && bottomBoundInfo.isBound;
  var isVerticalBound = topBoundInfo.isBound || bottomBoundInfo.isBound;
  var isAllHorizontalBound = leftBoundInfo.isBound && rightBoundInfo.isBound;
  var isHorizontalBound = leftBoundInfo.isBound || rightBoundInfo.isBound;
  var verticalOffset = maxOffset(topBoundInfo.offset, bottomBoundInfo.offset);
  var horizontalOffset = maxOffset(leftBoundInfo.offset, rightBoundInfo.offset);
  var offset = [0, 0];
  var isBound = false;
  var isAllBound = false;
  if (Math.abs(horizontalOffset) < Math.abs(verticalOffset)) {
    offset = [verticalOffset, 0];
    isBound = isVerticalBound;
    isAllBound = isAllVerticalBound;
  } else {
    offset = [0, horizontalOffset];
    isBound = isHorizontalBound;
    isAllBound = isAllHorizontalBound;
  }
  return {
    isAllBound,
    isVerticalBound,
    isHorizontalBound,
    isBound,
    offset
  };
}
function checkLineBoundCollision(line, boundLine, isStart, threshold, isRender) {
  var dot1 = line[0];
  var dot2 = line[1];
  var boundDot1 = boundLine[0];
  var boundDot2 = boundLine[1];
  var dy1 = getTinyDist(dot2[1] - dot1[1]);
  var dx1 = getTinyDist(dot2[0] - dot1[0]);
  var dy2 = getTinyDist(boundDot2[1] - boundDot1[1]);
  var dx2 = getTinyDist(boundDot2[0] - boundDot1[0]);
  if (!dx2) {
    if (isRender && !dy1) {
      return {
        isBound: false,
        offset: 0
      };
    } else if (dx1) {
      var y = dy1 / dx1 * (boundDot1[0] - dot1[0]) + dot1[1];
      return checkInnerBoundDot(y, boundDot1[1], boundDot2[1], isStart, threshold);
    } else {
      var offset = boundDot1[0] - dot1[0];
      var isBound = Math.abs(offset) <= (threshold || 0);
      return {
        isBound,
        offset: isBound ? offset : 0
      };
    }
  } else if (!dy2) {
    if (isRender && !dx1) {
      return {
        isBound: false,
        offset: 0
      };
    } else if (dy1) {
      var x = (boundDot1[1] - dot1[1]) / (dy1 / dx1) + dot1[0];
      return checkInnerBoundDot(x, boundDot1[0], boundDot2[0], isStart, threshold);
    } else {
      var offset = boundDot1[1] - dot1[1];
      var isBound = Math.abs(offset) <= (threshold || 0);
      return {
        isBound,
        offset: isBound ? offset : 0
      };
    }
  }
  return {
    isBound: false,
    offset: 0
  };
}
function getInnerBoundInfo(moveable, lines, center, datas) {
  return lines.map(function(_a2) {
    var multiple = _a2[0], pos1 = _a2[1], pos2 = _a2[2];
    var _b = checkInnerBound(moveable, [pos1, pos2], center), isBound = _b.isBound, offset = _b.offset, isVerticalBound = _b.isVerticalBound, isHorizontalBound = _b.isHorizontalBound;
    var sizeOffset = getDragDist({
      datas,
      distX: offset[0],
      distY: offset[1]
    }).map(function(size, i) {
      return size * (multiple[i] ? 2 / multiple[i] : 0);
    });
    return {
      sign: multiple,
      isBound,
      isVerticalBound,
      isHorizontalBound,
      isSnap: false,
      offset: sizeOffset
    };
  });
}
function getInnerBoundDragInfo(moveable, poses, datas) {
  var _a2;
  var lines = getCheckInnerBoundLines(poses, [0, 0], false).map(function(_a3) {
    var sign2 = _a3[0], pos1 = _a3[1], pos2 = _a3[2];
    return [sign2.map(function(dir) {
      return Math.abs(dir) * 2;
    }), pos1, pos2];
  });
  var innerBoundInfo = getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas);
  var widthOffsetInfo = getNearOffsetInfo(innerBoundInfo, 0);
  var heightOffsetInfo = getNearOffsetInfo(innerBoundInfo, 1);
  var verticalOffset = 0;
  var horizontalOffset = 0;
  var isVerticalBound = widthOffsetInfo.isVerticalBound || heightOffsetInfo.isVerticalBound;
  var isHorizontalBound = widthOffsetInfo.isHorizontalBound || heightOffsetInfo.isHorizontalBound;
  if (isVerticalBound || isHorizontalBound) {
    _a2 = getInverseDragDist({
      datas,
      distX: -widthOffsetInfo.offset[0],
      distY: -heightOffsetInfo.offset[1]
    }), verticalOffset = _a2[0], horizontalOffset = _a2[1];
  }
  return {
    vertical: {
      isBound: isVerticalBound,
      offset: verticalOffset
    },
    horizontal: {
      isBound: isHorizontalBound,
      offset: horizontalOffset
    }
  };
}
function getCheckSnapLineDirections(direction2, keepRatio) {
  var lineDirections = [];
  var x = direction2[0];
  var y = direction2[1];
  if (x && y) {
    lineDirections.push([[0, y * 2], direction2, [-x, y]], [[x * 2, 0], direction2, [x, -y]]);
  } else if (x) {
    lineDirections.push([[x * 2, 0], [x, 1], [x, -1]]);
    if (keepRatio) {
      lineDirections.push([[0, -1], [x, -1], [-x, -1]], [[0, 1], [x, 1], [-x, 1]]);
    }
  } else if (y) {
    lineDirections.push([[0, y * 2], [1, y], [-1, y]]);
    if (keepRatio) {
      lineDirections.push([[-1, 0], [-1, y], [-1, -y]], [[1, 0], [1, y], [1, -y]]);
    }
  } else {
    lineDirections.push([[-1, 0], [-1, -1], [-1, 1]], [[1, 0], [1, -1], [1, 1]], [[0, -1], [-1, -1], [1, -1]], [[0, 1], [-1, 1], [1, 1]]);
  }
  return lineDirections;
}
function getCheckInnerBoundLines(poses, direction2, keepRatio) {
  return getCheckSnapLineDirections(direction2, keepRatio).map(function(_a2) {
    var sign2 = _a2[0], dir1 = _a2[1], dir2 = _a2[2];
    return [sign2, getPosByDirection(poses, dir1), getPosByDirection(poses, dir2)];
  });
}
function isBoundRotate(relativePoses, boundDots, center, rad) {
  var nextPoses = rad ? relativePoses.map(function(pos) {
    return rotate(pos, rad);
  }) : relativePoses;
  var dots = __spreadArrays$2([center], boundDots);
  return [[nextPoses[0], nextPoses[1]], [nextPoses[1], nextPoses[3]], [nextPoses[3], nextPoses[2]], [nextPoses[2], nextPoses[0]]].some(function(line) {
    return !isSameStartLine(dots, line);
  });
}
function getDistPointLine(_a2) {
  var pos1 = _a2[0], pos2 = _a2[1];
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];
  if (!dx) {
    return Math.abs(pos1[0]);
  }
  if (!dy) {
    return Math.abs(pos1[1]);
  }
  var a2 = dy / dx;
  return Math.abs((-a2 * pos1[0] + pos1[1]) / Math.sqrt(Math.pow(a2, 2) + 1));
}
function solveReverseLine(_a2) {
  var pos1 = _a2[0], pos2 = _a2[1];
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];
  if (!dx) {
    return [pos1[0], 0];
  }
  if (!dy) {
    return [0, pos1[1]];
  }
  var a2 = dy / dx;
  var b = -a2 * pos1[0] + pos1[1];
  return [-b / (a2 + 1 / a2), b / (a2 * a2 + 1)];
}
function checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation) {
  var bounds = moveable.props.innerBounds;
  var rad = rotation * Math.PI / 180;
  if (!bounds) {
    return [];
  }
  var left = bounds.left, top = bounds.top, width = bounds.width, height = bounds.height;
  var relativeLeft = left - origin[0];
  var relativeRight = left + width - origin[0];
  var relativeTop = top - origin[1];
  var relativeBottom = top + height - origin[1];
  var dots = [[relativeLeft, relativeTop], [relativeRight, relativeTop], [relativeLeft, relativeBottom], [relativeRight, relativeBottom]];
  var center = getPosByDirection(nextPoses, [0, 0]);
  if (!isBoundRotate(nextPoses, dots, center, 0)) {
    return [];
  }
  var result = [];
  var dotInfos = dots.map(function(dot2) {
    return [getDistSize(dot2), getRad$1([0, 0], dot2)];
  });
  [[nextPoses[0], nextPoses[1]], [nextPoses[1], nextPoses[3]], [nextPoses[3], nextPoses[2]], [nextPoses[2], nextPoses[0]]].forEach(function(line) {
    var lineRad = getRad$1([0, 0], solveReverseLine(line));
    var lineDist = getDistPointLine(line);
    result.push.apply(result, dotInfos.filter(function(_a2) {
      var dotDist = _a2[0];
      return dotDist && lineDist <= dotDist;
    }).map(function(_a2) {
      var dotDist = _a2[0], dotRad = _a2[1];
      var distRad = Math.acos(dotDist ? lineDist / dotDist : 0);
      var nextRad1 = dotRad + distRad;
      var nextRad2 = dotRad - distRad;
      return [rad + nextRad1 - lineRad, rad + nextRad2 - lineRad];
    }).reduce(function(prev, cur) {
      prev.push.apply(prev, cur);
      return prev;
    }, []).filter(function(nextRad) {
      return !isBoundRotate(prevPoses, dots, center, nextRad);
    }).map(function(nextRad) {
      return throttle$3(nextRad * 180 / Math.PI, TINY_NUM);
    }));
  });
  return result;
}
function checkInnerBoundPoses(moveable) {
  var innerBounds = moveable.props.innerBounds;
  if (!innerBounds) {
    return {
      vertical: [],
      horizontal: []
    };
  }
  var _a2 = moveable.getRect(), pos1 = _a2.pos1, pos2 = _a2.pos2, pos3 = _a2.pos3, pos4 = _a2.pos4;
  var poses = [pos1, pos2, pos3, pos4];
  var center = getPosByDirection(poses, [0, 0]);
  var left = innerBounds.left, top = innerBounds.top, width = innerBounds.width, height = innerBounds.height;
  var leftLine = [[left, top], [left, top + height]];
  var topLine = [[left, top], [left + width, top]];
  var rightLine = [[left + width, top], [left + width, top + height]];
  var bottomLine = [[left, top + height], [left + width, top + height]];
  var lines = [[pos1, pos2], [pos2, pos4], [pos4, pos3], [pos3, pos1]];
  var horizontalPoses = [];
  var verticalPoses = [];
  var boundMap = {
    top: false,
    bottom: false,
    left: false,
    right: false
  };
  lines.forEach(function(line) {
    var _a3 = isStartLine(center, line), isHorizontalStart = _a3.horizontal, isVerticalStart = _a3.vertical;
    var topBoundInfo = checkLineBoundCollision(line, topLine, isVerticalStart, 1, true);
    var bottomBoundInfo = checkLineBoundCollision(line, bottomLine, isVerticalStart, 1, true);
    var leftBoundInfo = checkLineBoundCollision(line, leftLine, isHorizontalStart, 1, true);
    var rightBoundInfo = checkLineBoundCollision(line, rightLine, isHorizontalStart, 1, true);
    if (topBoundInfo.isBound && !boundMap.top) {
      horizontalPoses.push(top);
      boundMap.top = true;
    }
    if (bottomBoundInfo.isBound && !boundMap.bottom) {
      horizontalPoses.push(top + height);
      boundMap.bottom = true;
    }
    if (leftBoundInfo.isBound && !boundMap.left) {
      verticalPoses.push(left);
      boundMap.left = true;
    }
    if (rightBoundInfo.isBound && !boundMap.right) {
      verticalPoses.push(left + width);
      boundMap.right = true;
    }
  });
  return {
    horizontal: horizontalPoses,
    vertical: verticalPoses
  };
}
function checkBoundPoses(bounds, verticalPoses, horizontalPoses) {
  var _a2 = bounds || {}, _b = _a2.position, position2 = _b === void 0 ? "client" : _b, _c = _a2.left, left = _c === void 0 ? -Infinity : _c, _d = _a2.top, top = _d === void 0 ? -Infinity : _d, _e = _a2.right, right = _e === void 0 ? Infinity : _e, _f = _a2.bottom, bottom = _f === void 0 ? Infinity : _f;
  var nextBounds = {
    position: position2,
    left,
    top,
    right,
    bottom
  };
  return {
    vertical: checkBounds(nextBounds, verticalPoses, true),
    horizontal: checkBounds(nextBounds, horizontalPoses, false)
  };
}
function getBounds(moveable, externalBounds) {
  var _a2 = moveable.state, _b = _a2.containerClientRect, containerHeight = _b.clientHeight, containerWidth = _b.clientWidth, clientLeft = _b.clientLeft, clientTop = _b.clientTop, _c = _a2.snapOffset, snapOffsetLeft = _c.left, snapOffsetTop = _c.top, snapOffsetRight = _c.right, snapOffsetBottom = _c.bottom;
  var bounds = externalBounds || moveable.props.bounds || {};
  var position2 = bounds.position || "client";
  var isCSS = position2 === "css";
  var _d = bounds.left, left = _d === void 0 ? -Infinity : _d, _e = bounds.top, top = _e === void 0 ? -Infinity : _e;
  var _f = bounds.right, right = _f === void 0 ? isCSS ? -Infinity : Infinity : _f, _g = bounds.bottom, bottom = _g === void 0 ? isCSS ? -Infinity : Infinity : _g;
  if (isCSS) {
    right = containerWidth + snapOffsetRight - snapOffsetLeft - right;
    bottom = containerHeight + snapOffsetBottom - snapOffsetTop - bottom;
  }
  return {
    left: left + snapOffsetLeft - clientLeft,
    right: right + snapOffsetLeft - clientLeft,
    top: top + snapOffsetTop - clientTop,
    bottom: bottom + snapOffsetTop - clientTop
  };
}
function checkBoundKeepRatio(moveable, startPos, endPos) {
  var _a2 = getBounds(moveable), left = _a2.left, top = _a2.top, right = _a2.right, bottom = _a2.bottom;
  var endX = endPos[0], endY = endPos[1];
  var _b = minus(endPos, startPos), dx = _b[0], dy = _b[1];
  if (Math.abs(dx) < TINY_NUM) {
    dx = 0;
  }
  if (Math.abs(dy) < TINY_NUM) {
    dy = 0;
  }
  var isBottom = dy > 0;
  var isRight = dx > 0;
  var verticalInfo = {
    isBound: false,
    offset: 0,
    pos: 0
  };
  var horizontalInfo = {
    isBound: false,
    offset: 0,
    pos: 0
  };
  if (dx === 0 && dy === 0) {
    return {
      vertical: verticalInfo,
      horizontal: horizontalInfo
    };
  } else if (dx === 0) {
    if (isBottom) {
      if (bottom < endY) {
        horizontalInfo.pos = bottom;
        horizontalInfo.offset = endY - bottom;
      }
    } else {
      if (top > endY) {
        horizontalInfo.pos = top;
        horizontalInfo.offset = endY - top;
      }
    }
  } else if (dy === 0) {
    if (isRight) {
      if (right < endX) {
        verticalInfo.pos = right;
        verticalInfo.offset = endX - right;
      }
    } else {
      if (left > endX) {
        verticalInfo.pos = left;
        verticalInfo.offset = endX - left;
      }
    }
  } else {
    var a2 = dy / dx;
    var b = endPos[1] - a2 * endX;
    var y = 0;
    var x = 0;
    var isBound = false;
    if (isRight && right <= endX) {
      y = a2 * right + b;
      x = right;
      isBound = true;
    } else if (!isRight && endX <= left) {
      y = a2 * left + b;
      x = left;
      isBound = true;
    }
    if (isBound) {
      if (y < top || y > bottom) {
        isBound = false;
      }
    }
    if (!isBound) {
      if (isBottom && bottom <= endY) {
        y = bottom;
        x = (y - b) / a2;
        isBound = true;
      } else if (!isBottom && endY <= top) {
        y = top;
        x = (y - b) / a2;
        isBound = true;
      }
    }
    if (isBound) {
      verticalInfo.isBound = true;
      verticalInfo.pos = x;
      verticalInfo.offset = endX - x;
      horizontalInfo.isBound = true;
      horizontalInfo.pos = y;
      horizontalInfo.offset = endY - y;
    }
  }
  return {
    vertical: verticalInfo,
    horizontal: horizontalInfo
  };
}
function checkBounds(bounds, poses, isVertical) {
  var startBoundPos = bounds[isVertical ? "left" : "top"];
  var endBoundPos = bounds[isVertical ? "right" : "bottom"];
  var minPos = Math.min.apply(Math, poses);
  var maxPos = Math.max.apply(Math, poses);
  var boundInfos = [];
  if (startBoundPos + 1 > minPos) {
    boundInfos.push({
      isBound: true,
      offset: minPos - startBoundPos,
      pos: startBoundPos
    });
  }
  if (endBoundPos - 1 < maxPos) {
    boundInfos.push({
      isBound: true,
      offset: maxPos - endBoundPos,
      pos: endBoundPos
    });
  }
  if (!boundInfos.length) {
    boundInfos.push({
      isBound: false,
      offset: 0,
      pos: 0
    });
  }
  return boundInfos.sort(function(a2, b) {
    return Math.abs(b.offset) - Math.abs(a2.offset);
  });
}
function isBoundRotate$1(relativePoses, boundRect, rad) {
  var nextPoses = rad ? relativePoses.map(function(pos) {
    return rotate(pos, rad);
  }) : relativePoses;
  return nextPoses.some(function(pos) {
    return pos[0] < boundRect.left && Math.abs(pos[0] - boundRect.left) > 0.1 || pos[0] > boundRect.right && Math.abs(pos[0] - boundRect.right) > 0.1 || pos[1] < boundRect.top && Math.abs(pos[1] - boundRect.top) > 0.1 || pos[1] > boundRect.bottom && Math.abs(pos[1] - boundRect.bottom) > 0.1;
  });
}
function boundRotate(vec, boundPos, index2) {
  var r = getDistSize(vec);
  var nextPos = Math.sqrt(r * r - boundPos * boundPos) || 0;
  return [nextPos, -nextPos].sort(function(a2, b) {
    return Math.abs(a2 - vec[index2 ? 0 : 1]) - Math.abs(b - vec[index2 ? 0 : 1]);
  }).map(function(pos) {
    return getRad$1([0, 0], index2 ? [pos, boundPos] : [boundPos, pos]);
  });
}
function checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation) {
  if (!moveable.props.bounds) {
    return [];
  }
  var rad = rotation * Math.PI / 180;
  var _a2 = getBounds(moveable), left = _a2.left, top = _a2.top, right = _a2.right, bottom = _a2.bottom;
  var relativeLeft = left - origin[0];
  var relativeRight = right - origin[0];
  var relativeTop = top - origin[1];
  var relativeBottom = bottom - origin[1];
  var boundRect = {
    left: relativeLeft,
    top: relativeTop,
    right: relativeRight,
    bottom: relativeBottom
  };
  if (!isBoundRotate$1(nextPoses, boundRect, 0)) {
    return [];
  }
  var result = [];
  [[relativeLeft, 0], [relativeRight, 0], [relativeTop, 1], [relativeBottom, 1]].forEach(function(_a3) {
    var boundPos = _a3[0], index2 = _a3[1];
    nextPoses.forEach(function(nextPos) {
      var relativeRad1 = getRad$1([0, 0], nextPos);
      result.push.apply(result, boundRotate(nextPos, boundPos, index2).map(function(relativeRad2) {
        return rad + relativeRad2 - relativeRad1;
      }).filter(function(nextRad) {
        return !isBoundRotate$1(prevPoses, boundRect, nextRad);
      }).map(function(nextRad) {
        return throttle$3(nextRad * 180 / Math.PI, TINY_NUM);
      }));
    });
  });
  return result;
}
var DIRECTION_NAMES = {
  horizontal: ["left", "top", "width", "Y", "X"],
  vertical: ["top", "left", "height", "X", "Y"]
};
function groupByElementGuidelines(guidelines, clientPos, size, index2) {
  var groupInfos = [];
  var group = groupBy(guidelines.filter(function(_a2) {
    var element = _a2.element, gap = _a2.gap;
    return element && !gap;
  }), function(_a2) {
    var element = _a2.element, pos = _a2.pos;
    var elementPos = pos[index2];
    var sign2 = Math.min(0, elementPos - clientPos) < 0 ? -1 : 1;
    var groupKey = sign2 + "_" + pos[index2 ? 0 : 1];
    var groupInfo = find$2(groupInfos, function(_a3) {
      var groupElement = _a3[0], groupPos = _a3[1];
      return element === groupElement && elementPos === groupPos;
    });
    if (groupInfo) {
      return groupInfo[2];
    }
    groupInfos.push([element, elementPos, groupKey]);
    return groupKey;
  });
  group.forEach(function(elementGuidelines) {
    elementGuidelines.sort(function(a2, b) {
      var result = getElementGuidelineDist(a2.pos[index2], a2.size, clientPos, size).size - getElementGuidelineDist(b.pos[index2], a2.size, clientPos, size).size;
      return result || a2.pos[index2 ? 0 : 1] - b.pos[index2 ? 0 : 1];
    });
  });
  return group;
}
function getElementGuidelineDist(elementPos, elementSize, targetPos, targetSize) {
  var relativePos = elementPos - targetPos;
  var startPos = relativePos < 0 ? relativePos + elementSize : targetSize;
  var endPos = relativePos < 0 ? 0 : relativePos;
  var size = endPos - startPos;
  return {
    size,
    pos: startPos
  };
}
function renderGuideline(info, React) {
  var _a2;
  var direction2 = info.direction, classNames = info.classNames, size = info.size, pos = info.pos, zoom = info.zoom, key = info.key;
  var isHorizontal = direction2 === "horizontal";
  var scaleDirection = isHorizontal ? "Y" : "X";
  return React.createElement("div", {
    key,
    className: classNames.join(" "),
    style: (_a2 = {}, _a2[isHorizontal ? "width" : "height"] = "" + size, _a2.transform = "translate(" + pos[0] + ", " + pos[1] + ") translate" + scaleDirection + "(-50%) scale" + scaleDirection + "(" + zoom + ")", _a2)
  });
}
function renderInnerGuideline(info, React) {
  return renderGuideline(__assign$7(__assign$7({}, info), {
    classNames: __spreadArrays$2([prefix$2("line", "guideline", info.direction)], info.classNames).filter(function(className) {
      return className;
    }),
    size: info.size || info.sizeValue + "px",
    pos: info.pos || info.posValue.map(function(v) {
      return throttle$3(v, 0.1) + "px";
    })
  }), React);
}
function renderElementGroups(moveable, direction2, groups, minPos, clientPos, clientSize, targetPos, snapThreshold, snapDigit, index2, snapDistFormat, React) {
  var _a2 = moveable.props, zoom = _a2.zoom, _b = _a2.isDisplaySnapDigit, isDisplaySnapDigit = _b === void 0 ? true : _b;
  var _c = DIRECTION_NAMES[direction2], posName1 = _c[0], posName2 = _c[1], sizeName = _c[2], scaleDirection = _c[4];
  return flat(groups.map(function(elementGuidelines, i) {
    var isFirstRenderSize = true;
    return elementGuidelines.map(function(_a3, j2) {
      var _b2;
      var pos = _a3.pos, size = _a3.size;
      var _c2 = getElementGuidelineDist(pos[index2], size, clientPos, clientSize), linePos = _c2.pos, lineSize = _c2.size;
      if (lineSize < snapThreshold) {
        return null;
      }
      var isRenderSize = isFirstRenderSize;
      isFirstRenderSize = false;
      var snapSize = isDisplaySnapDigit && isRenderSize ? parseFloat(lineSize.toFixed(snapDigit)) : 0;
      return React.createElement("div", {
        key: direction2 + "LinkGuideline" + i + "-" + j2,
        className: prefix$2("guideline-group", direction2),
        style: (_b2 = {}, _b2[posName1] = minPos + linePos + "px", _b2[posName2] = -targetPos + pos[index2 ? 0 : 1] + "px", _b2[sizeName] = lineSize + "px", _b2)
      }, renderInnerGuideline({
        direction: direction2,
        classNames: [prefix$2("dashed")],
        size: "100%",
        posValue: [0, 0],
        sizeValue: lineSize,
        zoom
      }, React), React.createElement("div", {
        className: prefix$2("size-value"),
        style: {
          transform: "translate" + scaleDirection + "(-50%) scale(" + zoom + ")"
        }
      }, snapSize > 0 ? snapDistFormat(snapSize) : ""));
    });
  }));
}
function renderSnapPoses(moveable, direction2, snapPoses, minPos, targetPos, size, index2, React) {
  var zoom = moveable.props.zoom;
  return snapPoses.map(function(_a2, i) {
    var type = _a2.type, pos = _a2.pos;
    var renderPos = [0, 0];
    renderPos[index2] = minPos;
    renderPos[index2 ? 0 : 1] = -targetPos + pos;
    return renderInnerGuideline({
      key: direction2 + "TargetGuideline" + i,
      classNames: [prefix$2("target", "bold", type)],
      posValue: renderPos,
      sizeValue: size,
      zoom,
      direction: direction2
    }, React);
  });
}
function filterElementInnerGuidelines(moveable, guidelines, index2, targetPos, clientPos, targetSizes) {
  var isDisplayInnerSnapDigit = moveable.props.isDisplayInnerSnapDigit;
  var otherIndex = index2 ? 0 : 1;
  var targetContentPos = targetPos[index2];
  var targetContentSize = targetSizes[index2];
  var gapGuidelines = [];
  var nextGuidelines = guidelines.filter(function(guideline) {
    var element = guideline.element, pos = guideline.pos, size = guideline.size;
    if (isDisplayInnerSnapDigit && element && pos[index2] < targetContentPos && targetContentPos + targetContentSize < pos[index2] + size) {
      var contentPos = pos[index2] - targetContentPos;
      var inlinePos = pos[otherIndex] - targetPos[otherIndex];
      gapGuidelines.push(__assign$7(__assign$7({}, guideline), {
        inner: true,
        gap: contentPos,
        renderPos: index2 ? [inlinePos, contentPos] : [contentPos, inlinePos]
      }));
      gapGuidelines.push(__assign$7(__assign$7({}, guideline), {
        inner: true,
        gap: pos[index2] + size - targetContentPos - targetContentSize,
        renderPos: index2 ? [inlinePos, targetContentSize] : [targetContentSize, inlinePos]
      }));
      return false;
    }
    return true;
  });
  nextGuidelines = nextGuidelines.filter(function(guideline1) {
    var element1 = guideline1.element, pos1 = guideline1.pos, size1 = guideline1.size;
    var contentPos1 = pos1[index2];
    if (!element1) {
      return true;
    }
    return nextGuidelines.every(function(guideline2) {
      var element2 = guideline2.element, pos2 = guideline2.pos, size2 = guideline2.size;
      var contentPos2 = pos2[index2];
      if (!element2 || guideline1 === guideline2) {
        return true;
      }
      return contentPos1 + size1 <= contentPos2 || contentPos2 + size2 <= contentPos1 || contentPos1 < contentPos2 && contentPos2 + size2 < contentPos1 + size1;
    });
  });
  var groups = groupByElementGuidelines(nextGuidelines, clientPos[index2], targetContentSize, index2);
  gapGuidelines = gapGuidelines.filter(function(guideline) {
    var gap = guideline.gap;
    var inlinePos = guideline.pos[otherIndex];
    return groups.every(function(group) {
      return group.every(function(groupGuideline) {
        var groupPos = groupGuideline.pos;
        var renderPos = -targetContentPos + groupPos[index2];
        if (groupPos[otherIndex] !== inlinePos) {
          return true;
        }
        if (gap < 0 && renderPos < 0) {
          return false;
        }
        if (gap > 0 && renderPos > targetSizes[index2]) {
          return false;
        }
        return true;
      });
    });
  });
  return {
    guidelines: nextGuidelines,
    groups,
    gapGuidelines
  };
}
function renderGuidelines(moveable, direction2, guidelines, targetPos, React) {
  var zoom = moveable.props.zoom;
  return guidelines.filter(function(_a2) {
    var hide = _a2.hide;
    return !hide;
  }).map(function(guideline, i) {
    var pos = guideline.pos, size = guideline.size, element = guideline.element;
    var renderPos = [-targetPos[0] + pos[0], -targetPos[1] + pos[1]];
    return renderInnerGuideline({
      key: direction2 + "Guideline" + i,
      classNames: element ? [prefix$2("bold")] : [],
      direction: direction2,
      posValue: renderPos,
      sizeValue: size,
      zoom
    }, React);
  });
}
function renderGapGuidelines(moveable, direction2, gapGuidelines, snapDistFormat, React) {
  var _a2 = moveable.props, _b = _a2.snapDigit, snapDigit = _b === void 0 ? 0 : _b, _c = _a2.isDisplaySnapDigit, isDisplaySnapDigit = _c === void 0 ? true : _c, zoom = _a2.zoom;
  var scaleDirection = direction2 === "horizontal" ? "X" : "Y";
  var sizeName = direction2 === "horizontal" ? "width" : "height";
  return gapGuidelines.map(function(_a3, i) {
    var _b2;
    var renderPos = _a3.renderPos, gap = _a3.gap, className = _a3.className, inner = _a3.inner;
    var absGap = Math.abs(gap);
    var snapSize = isDisplaySnapDigit ? parseFloat(absGap.toFixed(snapDigit)) : 0;
    return React.createElement("div", {
      key: direction2 + "GapGuideline" + i,
      className: prefix$2("guideline-group", direction2),
      style: (_b2 = {
        left: renderPos[0] + "px",
        top: renderPos[1] + "px"
      }, _b2[sizeName] = absGap + "px", _b2)
    }, renderInnerGuideline({
      direction: direction2,
      classNames: [prefix$2(inner ? "dashed" : "gap"), className],
      size: "100%",
      posValue: [0, 0],
      sizeValue: absGap,
      zoom
    }, React), React.createElement("div", {
      className: prefix$2("size-value", "gap"),
      style: {
        transform: "translate" + scaleDirection + "(-50%) scale(" + zoom + ")"
      }
    }, snapSize > 0 ? snapDistFormat(snapSize) : ""));
  });
}
function snapStart(moveable) {
  var state = moveable.state;
  if (state.guidelines && state.guidelines.length) {
    return;
  }
  var container = moveable.state.container;
  var snapContainer = moveable.props.snapContainer || container;
  var containerClientRect = state.containerClientRect;
  var snapOffset = {
    left: 0,
    top: 0,
    bottom: 0,
    right: 0
  };
  if (container !== snapContainer) {
    var snapContainerTarget = getRefTarget(snapContainer, true);
    if (snapContainerTarget) {
      var snapContainerRect = getClientRect(snapContainerTarget);
      var offset1 = getDragDistByState(state, [snapContainerRect.left - containerClientRect.left, snapContainerRect.top - containerClientRect.top]);
      var offset2 = getDragDistByState(state, [snapContainerRect.right - containerClientRect.right, snapContainerRect.bottom - containerClientRect.bottom]);
      snapOffset.left = throttle$3(offset1[0], 0.1);
      snapOffset.top = throttle$3(offset1[1], 0.1);
      snapOffset.right = throttle$3(offset2[0], 0.1);
      snapOffset.bottom = throttle$3(offset2[1], 0.1);
    }
  }
  state.snapOffset = snapOffset;
  state.elementGuidelineValues = [];
  state.staticGuidelines = getElementGuidelines(moveable, false);
  state.guidelines = getTotalGuidelines(moveable);
  state.enableSnap = true;
}
function hasGuidelines(moveable, ableName) {
  var _a2 = moveable.props, snappable = _a2.snappable, bounds = _a2.bounds, innerBounds = _a2.innerBounds, verticalGuidelines = _a2.verticalGuidelines, horizontalGuidelines = _a2.horizontalGuidelines, snapGridWidth = _a2.snapGridWidth, snapGridHeight = _a2.snapGridHeight, _b = moveable.state, guidelines = _b.guidelines, enableSnap = _b.enableSnap;
  if (!snappable || !enableSnap || ableName && snappable !== true && snappable.indexOf(ableName) < 0) {
    return false;
  }
  if (snapGridWidth || snapGridHeight || bounds || innerBounds || guidelines && guidelines.length || verticalGuidelines && verticalGuidelines.length || horizontalGuidelines && horizontalGuidelines.length) {
    return true;
  }
  return false;
}
function solveNextOffset(pos1, pos2, offset, isVertical, datas) {
  var sizeOffset = solveEquation(pos1, pos2, offset, isVertical);
  if (!sizeOffset) {
    return {
      isOutside: false,
      offset: [0, 0]
    };
  }
  var size = getDist$2(pos1, pos2);
  var dist1 = getDist$2(sizeOffset, pos1);
  var dist2 = getDist$2(sizeOffset, pos2);
  var isOutside = dist1 > size || dist2 > size;
  var _a2 = getDragDist({
    datas,
    distX: sizeOffset[0],
    distY: sizeOffset[1]
  }), widthOffset = _a2[0], heightOffset = _a2[1];
  return {
    offset: [widthOffset, heightOffset],
    isOutside
  };
}
function getNextFixedPoses(matrix2, width, height, fixedPos, direction2, is3d) {
  var nextPoses = calculatePoses(matrix2, width, height, is3d ? 4 : 3);
  var nextPos = getPosByReverseDirection(nextPoses, direction2);
  return getAbsolutePoses(nextPoses, minus(fixedPos, nextPos));
}
function getSnapBoundOffset(boundInfo, snapInfo) {
  if (boundInfo.isBound) {
    return boundInfo.offset;
  } else if (snapInfo.isSnap) {
    return snapInfo.offset;
  }
  return 0;
}
function getSnapBound(boundInfo, snapInfo) {
  if (boundInfo.isBound) {
    return boundInfo.offset;
  } else if (snapInfo.isSnap) {
    return getNearestSnapGuidelineInfo(snapInfo).offset;
  }
  return 0;
}
function checkSnapBoundsKeepRatio(moveable, startPos, endPos, isRequest) {
  var _a2 = checkBoundKeepRatio(moveable, startPos, endPos), horizontalBoundInfo = _a2.horizontal, verticalBoundInfo = _a2.vertical;
  var _b = isRequest ? {
    horizontal: {
      isSnap: false
    },
    vertical: {
      isSnap: false
    }
  } : checkSnapKeepRatio(moveable, startPos, endPos), horizontalSnapInfo = _b.horizontal, verticalSnapInfo = _b.vertical;
  var horizontalOffset = getSnapBoundOffset(horizontalBoundInfo, horizontalSnapInfo);
  var verticalOffset = getSnapBoundOffset(verticalBoundInfo, verticalSnapInfo);
  var horizontalDist = Math.abs(horizontalOffset);
  var verticalDist = Math.abs(verticalOffset);
  return {
    horizontal: {
      isBound: horizontalBoundInfo.isBound,
      isSnap: horizontalSnapInfo.isSnap,
      offset: horizontalOffset,
      dist: horizontalDist
    },
    vertical: {
      isBound: verticalBoundInfo.isBound,
      isSnap: verticalSnapInfo.isSnap,
      offset: verticalOffset,
      dist: verticalDist
    }
  };
}
function checkMoveableSnapBounds(moveable, isRequest, poses, boundPoses) {
  if (boundPoses === void 0) {
    boundPoses = poses;
  }
  var _a2 = checkBoundPoses(getBounds(moveable), boundPoses.map(function(pos) {
    return pos[0];
  }), boundPoses.map(function(pos) {
    return pos[1];
  })), horizontalBoundInfos = _a2.horizontal, verticalBoundInfos = _a2.vertical;
  var _b = isRequest ? {
    horizontal: {
      isSnap: false,
      index: -1
    },
    vertical: {
      isSnap: false,
      index: -1
    }
  } : checkMoveableSnapPoses(moveable, poses.map(function(pos) {
    return pos[0];
  }), poses.map(function(pos) {
    return pos[1];
  }), moveable.props.snapCenter), horizontalSnapInfo = _b.horizontal, verticalSnapInfo = _b.vertical;
  var horizontalOffset = getSnapBound(horizontalBoundInfos[0], horizontalSnapInfo);
  var verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);
  var horizontalDist = Math.abs(horizontalOffset);
  var verticalDist = Math.abs(verticalOffset);
  return {
    horizontal: {
      isBound: horizontalBoundInfos[0].isBound,
      isSnap: horizontalSnapInfo.isSnap,
      snapIndex: horizontalSnapInfo.index,
      offset: horizontalOffset,
      dist: horizontalDist,
      bounds: horizontalBoundInfos,
      snap: horizontalSnapInfo
    },
    vertical: {
      isBound: verticalBoundInfos[0].isBound,
      isSnap: verticalSnapInfo.isSnap,
      snapIndex: verticalSnapInfo.index,
      offset: verticalOffset,
      dist: verticalDist,
      bounds: verticalBoundInfos,
      snap: verticalSnapInfo
    }
  };
}
function checkSnapBounds(guideines, bounds, posesX, posesY, options) {
  if (options === void 0) {
    options = {};
  }
  var _a2 = checkBoundPoses(bounds, posesX, posesY), horizontalBoundInfos = _a2.horizontal, verticalBoundInfos = _a2.vertical;
  var _b = options.isRequest ? {
    horizontal: {
      isSnap: false,
      index: -1
    },
    vertical: {
      isSnap: false,
      index: -1
    }
  } : checkSnapPoses(guideines, posesX, posesY, options), horizontalSnapInfo = _b.horizontal, verticalSnapInfo = _b.vertical;
  var horizontalOffset = getSnapBound(horizontalBoundInfos[0], horizontalSnapInfo);
  var verticalOffset = getSnapBound(verticalBoundInfos[0], verticalSnapInfo);
  var horizontalDist = Math.abs(horizontalOffset);
  var verticalDist = Math.abs(verticalOffset);
  return {
    horizontal: {
      isBound: horizontalBoundInfos[0].isBound,
      isSnap: horizontalSnapInfo.isSnap,
      snapIndex: horizontalSnapInfo.index,
      offset: horizontalOffset,
      dist: horizontalDist,
      bounds: horizontalBoundInfos,
      snap: horizontalSnapInfo
    },
    vertical: {
      isBound: verticalBoundInfos[0].isBound,
      isSnap: verticalSnapInfo.isSnap,
      snapIndex: verticalSnapInfo.index,
      offset: verticalOffset,
      dist: verticalDist,
      bounds: verticalBoundInfos,
      snap: verticalSnapInfo
    }
  };
}
function checkMaxBounds(moveable, poses, direction2, fixedPosition, datas) {
  var fixedDirection = [-direction2[0], -direction2[1]];
  var _a2 = moveable.state, width = _a2.width, height = _a2.height;
  var bounds = moveable.props.bounds;
  var maxWidth = Infinity;
  var maxHeight = Infinity;
  if (bounds) {
    var directions = [[direction2[0], -direction2[1]], [-direction2[0], direction2[1]]];
    var _b = bounds.left, left_1 = _b === void 0 ? -Infinity : _b, _c = bounds.top, top_1 = _c === void 0 ? -Infinity : _c, _d = bounds.right, right_1 = _d === void 0 ? Infinity : _d, _e = bounds.bottom, bottom_1 = _e === void 0 ? Infinity : _e;
    directions.forEach(function(otherDirection) {
      var isCheckVertical = otherDirection[0] !== fixedDirection[0];
      var isCheckHorizontal = otherDirection[1] !== fixedDirection[1];
      var otherPos = getPosByDirection(poses, otherDirection);
      var deg2 = getRad$1(fixedPosition, otherPos) * 360 / Math.PI;
      if (isCheckHorizontal) {
        var nextOtherPos = otherPos.slice();
        if (Math.abs(deg2 - 360) < 2 || Math.abs(deg2 - 180) < 2) {
          nextOtherPos[1] = fixedPosition[1];
        }
        var _a3 = solveNextOffset(fixedPosition, nextOtherPos, (fixedPosition[1] < otherPos[1] ? bottom_1 : top_1) - otherPos[1], false, datas), _b2 = _a3.offset, heightOffset = _b2[1], isHeightOutside = _a3.isOutside;
        if (!isNaN(heightOffset)) {
          maxHeight = height + (isHeightOutside ? 1 : -1) * Math.abs(heightOffset);
        }
      }
      if (isCheckVertical) {
        var nextOtherPos = otherPos.slice();
        if (Math.abs(deg2 - 90) < 2 || Math.abs(deg2 - 270) < 2) {
          nextOtherPos[0] = fixedPosition[0];
        }
        var _c2 = solveNextOffset(fixedPosition, nextOtherPos, (fixedPosition[0] < otherPos[0] ? right_1 : left_1) - otherPos[0], true, datas), widthOffset = _c2.offset[0], isWidthOutside = _c2.isOutside;
        if (!isNaN(widthOffset)) {
          maxWidth = width + (isWidthOutside ? 1 : -1) * Math.abs(widthOffset);
        }
      }
    });
  }
  return {
    maxWidth,
    maxHeight
  };
}
function checkSnapRightLine(startPos, endPos, snapBoundInfo, keepRatio) {
  var rad = getRad$1(startPos, endPos) / Math.PI * 180;
  var _a2 = snapBoundInfo.vertical, isVerticalBound = _a2.isBound, isVerticalSnap = _a2.isSnap, verticalDist = _a2.dist, _b = snapBoundInfo.horizontal, isHorizontalBound = _b.isBound, isHorizontalSnap = _b.isSnap, horizontalDist = _b.dist;
  var rad180 = rad % 180;
  var isHorizontalLine = rad180 < 3 || rad180 > 177;
  var isVerticalLine = rad180 > 87 && rad180 < 93;
  if (horizontalDist < verticalDist) {
    if (isVerticalBound || isVerticalSnap && !isVerticalLine && (!keepRatio || !isHorizontalLine)) {
      return "vertical";
    }
  }
  if (isHorizontalBound || isHorizontalSnap && !isHorizontalLine && (!keepRatio || !isVerticalLine)) {
    return "horizontal";
  }
  return "";
}
function getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas) {
  return directions.map(function(_a2) {
    var startDirection = _a2[0], endDirection = _a2[1];
    var otherStartPos = getPosByDirection(poses, startDirection);
    var otherEndPos = getPosByDirection(poses, endDirection);
    var snapBoundInfo = keepRatio ? checkSnapBoundsKeepRatio(moveable, otherStartPos, otherEndPos, isRequest) : checkMoveableSnapBounds(moveable, isRequest, [otherEndPos]);
    var _b = snapBoundInfo.horizontal, otherHorizontalOffset = _b.offset, isOtherHorizontalBound = _b.isBound, isOtherHorizontalSnap = _b.isSnap, _c = snapBoundInfo.vertical, otherVerticalOffset = _c.offset, isOtherVerticalBound = _c.isBound, isOtherVerticalSnap = _c.isSnap;
    var multiple = minus(endDirection, startDirection);
    if (!otherVerticalOffset && !otherHorizontalOffset) {
      return {
        isBound: isOtherVerticalBound || isOtherHorizontalBound,
        isSnap: isOtherVerticalSnap || isOtherHorizontalSnap,
        sign: multiple,
        offset: [0, 0]
      };
    }
    var snapLine = checkSnapRightLine(otherStartPos, otherEndPos, snapBoundInfo, keepRatio);
    if (!snapLine) {
      return {
        sign: multiple,
        isBound: false,
        isSnap: false,
        offset: [0, 0]
      };
    }
    var isVertical = snapLine === "vertical";
    var sizeOffset = solveNextOffset(otherStartPos, otherEndPos, -(isVertical ? otherVerticalOffset : otherHorizontalOffset), isVertical, datas).offset.map(function(size, i) {
      return size * (multiple[i] ? 2 / multiple[i] : 0);
    });
    return {
      sign: multiple,
      isBound: isVertical ? isOtherVerticalBound : isOtherHorizontalBound,
      isSnap: isVertical ? isOtherVerticalSnap : isOtherHorizontalSnap,
      offset: sizeOffset
    };
  });
}
function getCheckSnapDirections(direction2, keepRatio) {
  var directions = [];
  var fixedDirection = [-direction2[0], -direction2[1]];
  if (direction2[0] && direction2[1]) {
    directions.push([fixedDirection, [direction2[0], -direction2[1]]], [fixedDirection, [-direction2[0], direction2[1]]]);
    if (keepRatio) {
      directions.push([fixedDirection, direction2]);
    }
  } else if (direction2[0]) {
    if (keepRatio) {
      directions.push([fixedDirection, [fixedDirection[0], -1]], [fixedDirection, [fixedDirection[0], 1]], [fixedDirection, [direction2[0], -1]], [fixedDirection, direction2], [fixedDirection, [direction2[0], 1]]);
    } else {
      directions.push([[fixedDirection[0], -1], [direction2[0], -1]], [[fixedDirection[0], 0], [direction2[0], 0]], [[fixedDirection[0], 1], [direction2[0], 1]]);
    }
  } else if (direction2[1]) {
    if (keepRatio) {
      directions.push([fixedDirection, [-1, fixedDirection[1]]], [fixedDirection, [1, fixedDirection[1]]], [fixedDirection, [-1, direction2[1]]], [fixedDirection, [1, direction2[1]]], [fixedDirection, direction2]);
    } else {
      directions.push([[-1, fixedDirection[1]], [-1, direction2[1]]], [[0, fixedDirection[1]], [0, direction2[1]]], [[1, fixedDirection[1]], [1, direction2[1]]]);
    }
  } else {
    directions.push([fixedDirection, [1, 0]], [fixedDirection, [-1, 0]], [fixedDirection, [0, -1]], [fixedDirection, [0, 1]], [[1, 0], [1, -1]], [[1, 0], [1, 1]], [[0, 1], [1, 1]], [[0, 1], [-1, 1]], [[-1, 0], [-1, -1]], [[-1, 0], [-1, 1]], [[0, -1], [1, -1]], [[0, -1], [-1, -1]]);
  }
  return directions;
}
function getSizeOffsetInfo(moveable, poses, direction2, keepRatio, isRequest, datas) {
  var directions = getCheckSnapDirections(direction2, keepRatio);
  var lines = getCheckInnerBoundLines(poses, direction2, keepRatio);
  var offsets = __spreadArrays$2(getSnapBoundInfo(moveable, poses, directions, keepRatio, isRequest, datas), getInnerBoundInfo(moveable, lines, getPosByDirection(poses, [0, 0]), datas));
  var widthOffsetInfo = getNearOffsetInfo(offsets, 0);
  var heightOffsetInfo = getNearOffsetInfo(offsets, 1);
  return {
    width: {
      isBound: widthOffsetInfo.isBound,
      offset: widthOffsetInfo.offset[0]
    },
    height: {
      isBound: heightOffsetInfo.isBound,
      offset: heightOffsetInfo.offset[1]
    }
  };
}
function recheckSizeByTwoDirection(moveable, poses, width, height, maxWidth, maxHeight, direction2, isRequest, datas) {
  var snapPos = getPosByDirection(poses, direction2);
  var _a2 = checkMoveableSnapBounds(moveable, isRequest, [snapPos]), horizontalOffset = _a2.horizontal.offset, verticalOffset = _a2.vertical.offset;
  if (verticalOffset || horizontalOffset) {
    var _b = getDragDist({
      datas,
      distX: -verticalOffset,
      distY: -horizontalOffset
    }), nextWidthOffset = _b[0], nextHeightOffset = _b[1];
    var nextWidth = Math.min(maxWidth || Infinity, width + direction2[0] * nextWidthOffset);
    var nextHeight = Math.min(maxHeight || Infinity, height + direction2[1] * nextHeightOffset);
    return [nextWidth - width, nextHeight - height];
  }
  return [0, 0];
}
function checkSizeDist(moveable, getNextPoses, width, height, direction2, fixedPosition, isRequest, datas) {
  var poses = getAbsolutePosesByState(moveable.state);
  var keepRatio = moveable.props.keepRatio;
  var widthOffset = 0;
  var heightOffset = 0;
  for (var i = 0; i < 2; ++i) {
    var nextPoses = getNextPoses(widthOffset, heightOffset);
    var _a2 = getSizeOffsetInfo(moveable, nextPoses, direction2, keepRatio, isRequest, datas), widthOffsetInfo = _a2.width, heightOffsetInfo = _a2.height;
    var isWidthBound = widthOffsetInfo.isBound;
    var isHeightBound = heightOffsetInfo.isBound;
    var nextWidthOffset = widthOffsetInfo.offset;
    var nextHeightOffset = heightOffsetInfo.offset;
    if (i === 1) {
      if (!isWidthBound) {
        nextWidthOffset = 0;
      }
      if (!isHeightBound) {
        nextHeightOffset = 0;
      }
    }
    if (i === 0 && isRequest && !isWidthBound && !isHeightBound) {
      return [0, 0];
    }
    if (keepRatio) {
      var widthDist = Math.abs(nextWidthOffset) * (width ? 1 / width : 1);
      var heightDist = Math.abs(nextHeightOffset) * (height ? 1 / height : 1);
      var isGetWidthOffset = isWidthBound && isHeightBound ? widthDist < heightDist : isHeightBound || !isWidthBound && widthDist < heightDist;
      if (isGetWidthOffset) {
        nextWidthOffset = width * nextHeightOffset / height;
      } else {
        nextHeightOffset = height * nextWidthOffset / width;
      }
    }
    widthOffset += nextWidthOffset;
    heightOffset += nextHeightOffset;
  }
  if (direction2[0] && direction2[1]) {
    var _b = checkMaxBounds(moveable, poses, direction2, fixedPosition, datas), maxWidth = _b.maxWidth, maxHeight = _b.maxHeight;
    var _c = recheckSizeByTwoDirection(moveable, getNextPoses(widthOffset, heightOffset).map(function(pos) {
      return pos.map(function(p) {
        return throttle$3(p, FLOAT_POINT_NUM);
      });
    }), width + widthOffset, height + heightOffset, maxWidth, maxHeight, direction2, isRequest, datas), nextWidthOffset = _c[0], nextHeightOffset = _c[1];
    widthOffset += nextWidthOffset;
    heightOffset += nextHeightOffset;
  }
  return [widthOffset, heightOffset];
}
function checkSnapRotate(moveable, rect, origin, rotation) {
  if (!hasGuidelines(moveable, "rotatable")) {
    return rotation;
  }
  var pos1 = rect.pos1, pos2 = rect.pos2, pos3 = rect.pos3, pos4 = rect.pos4;
  var rad = rotation * Math.PI / 180;
  var prevPoses = [pos1, pos2, pos3, pos4].map(function(pos) {
    return minus(pos, origin);
  });
  var nextPoses = prevPoses.map(function(pos) {
    return rotate(pos, rad);
  });
  var result = __spreadArrays$2(checkRotateBounds(moveable, prevPoses, nextPoses, origin, rotation), checkRotateInnerBounds(moveable, prevPoses, nextPoses, origin, rotation));
  result.sort(function(a2, b) {
    return Math.abs(a2 - rotation) - Math.abs(b - rotation);
  });
  if (result.length) {
    return result[0];
  } else {
    return rotation;
  }
}
function checkSnapResize(moveable, width, height, direction2, fixedPosition, isRequest, datas) {
  if (!hasGuidelines(moveable, "resizable")) {
    return [0, 0];
  }
  var _a2 = moveable.state, allMatrix = _a2.allMatrix, is3d = _a2.is3d;
  return checkSizeDist(moveable, function(widthOffset, heightOffset) {
    return getNextFixedPoses(allMatrix, width + widthOffset, height + heightOffset, fixedPosition, direction2, is3d);
  }, width, height, direction2, fixedPosition, isRequest, datas);
}
function checkSnapScale(moveable, scale, direction2, isRequest, datas) {
  var width = datas.width, height = datas.height, fixedPosition = datas.fixedPosition;
  if (!hasGuidelines(moveable, "scalable")) {
    return [0, 0];
  }
  var is3d = datas.is3d;
  var sizeDist = checkSizeDist(moveable, function(widthOffset, heightOffset) {
    return getNextFixedPoses(scaleMatrix(datas, plus(scale, [widthOffset / width, heightOffset / height])), width, height, fixedPosition, direction2, is3d);
  }, width, height, direction2, fixedPosition, isRequest, datas);
  return [sizeDist[0] / width, sizeDist[1] / height];
}
function solveEquation(pos1, pos2, snapOffset, isVertical) {
  var dx = pos2[0] - pos1[0];
  var dy = pos2[1] - pos1[1];
  if (Math.abs(dx) < TINY_NUM) {
    dx = 0;
  }
  if (Math.abs(dy) < TINY_NUM) {
    dy = 0;
  }
  if (!dx) {
    if (!isVertical) {
      return [0, snapOffset];
    }
    return [0, 0];
  }
  if (!dy) {
    if (isVertical) {
      return [snapOffset, 0];
    }
    return [0, 0];
  }
  var a2 = dy / dx;
  var b = pos1[1] - a2 * pos1[0];
  if (isVertical) {
    var y = a2 * (pos2[0] + snapOffset) + b;
    return [snapOffset, y - pos2[1]];
  } else {
    var x = (pos2[1] + snapOffset - b) / a2;
    return [x - pos2[0], snapOffset];
  }
}
function startCheckSnapDrag(moveable, datas) {
  datas.absolutePoses = getAbsolutePosesByState(moveable.state);
}
function checkThrottleDragRotate(throttleDragRotate, _a2, _b, _c, _d) {
  var distX = _a2[0], distY = _a2[1];
  var isVerticalBound = _b[0], isHorizontalBound = _b[1];
  var isVerticalSnap = _c[0], isHorizontalSnap = _c[1];
  var verticalOffset = _d[0], horizontalOffset = _d[1];
  var offsetX = -verticalOffset;
  var offsetY = -horizontalOffset;
  if (throttleDragRotate && distX && distY) {
    offsetX = 0;
    offsetY = 0;
    var adjustPoses = [];
    if (isVerticalBound && isHorizontalBound) {
      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);
    } else if (isVerticalBound) {
      adjustPoses.push([verticalOffset, 0]);
    } else if (isHorizontalBound) {
      adjustPoses.push([0, horizontalOffset]);
    } else if (isVerticalSnap && isHorizontalSnap) {
      adjustPoses.push([0, horizontalOffset], [verticalOffset, 0]);
    } else if (isVerticalSnap) {
      adjustPoses.push([verticalOffset, 0]);
    } else if (isHorizontalSnap) {
      adjustPoses.push([0, horizontalOffset]);
    }
    if (adjustPoses.length) {
      adjustPoses.sort(function(a2, b) {
        return getDistSize(minus([distX, distY], a2)) - getDistSize(minus([distX, distY], b));
      });
      var adjustPos = adjustPoses[0];
      if (adjustPos[0] && Math.abs(distX) > TINY_NUM) {
        offsetX = -adjustPos[0];
        offsetY = distY * Math.abs(distX + offsetX) / Math.abs(distX) - distY;
      } else if (adjustPos[1] && Math.abs(distY) > TINY_NUM) {
        var prevDistY = distY;
        offsetY = -adjustPos[1];
        offsetX = distX * Math.abs(distY + offsetY) / Math.abs(prevDistY) - distX;
      }
      if (throttleDragRotate && isHorizontalBound && isVerticalBound) {
        if (Math.abs(offsetX) > TINY_NUM && Math.abs(offsetX) < Math.abs(verticalOffset)) {
          var scale = Math.abs(verticalOffset) / Math.abs(offsetX);
          offsetX *= scale;
          offsetY *= scale;
        } else if (Math.abs(offsetY) > TINY_NUM && Math.abs(offsetY) < Math.abs(horizontalOffset)) {
          var scale = Math.abs(horizontalOffset) / Math.abs(offsetY);
          offsetX *= scale;
          offsetY *= scale;
        } else {
          offsetX = maxOffset(-verticalOffset, offsetX);
          offsetY = maxOffset(-horizontalOffset, offsetY);
        }
      }
    }
  } else {
    offsetX = distX || isVerticalBound ? -verticalOffset : 0;
    offsetY = distY || isHorizontalBound ? -horizontalOffset : 0;
  }
  return [offsetX, offsetY];
}
function checkSnapDrag(moveable, distX, distY, throttleDragRotate, isRequest, datas) {
  if (!hasGuidelines(moveable, "draggable")) {
    return [{
      isSnap: false,
      isBound: false,
      offset: 0
    }, {
      isSnap: false,
      isBound: false,
      offset: 0
    }];
  }
  var poses = getAbsolutePoses(datas.absolutePoses, [distX, distY]);
  var _a2 = getRect$2(poses), left = _a2.left, right = _a2.right, top = _a2.top, bottom = _a2.bottom;
  var snapCenter = moveable.props.snapCenter;
  var snapPoses = [[left, top], [right, top], [left, bottom], [right, bottom]];
  if (snapCenter) {
    snapPoses.push([(left + right) / 2, (top + bottom) / 2]);
  }
  var _b = checkMoveableSnapBounds(moveable, isRequest, snapPoses, poses), verticalSnapBoundInfo = _b.vertical, horizontalSnapBoundInfo = _b.horizontal;
  var _c = getInnerBoundDragInfo(moveable, poses, datas), verticalInnerBoundInfo = _c.vertical, horizontalInnerBoundInfo = _c.horizontal;
  var isVerticalSnap = verticalSnapBoundInfo.isSnap;
  var isHorizontalSnap = horizontalSnapBoundInfo.isSnap;
  var isVerticalBound = verticalSnapBoundInfo.isBound || verticalInnerBoundInfo.isBound;
  var isHorizontalBound = horizontalSnapBoundInfo.isBound || horizontalInnerBoundInfo.isBound;
  var verticalOffset = maxOffset(verticalSnapBoundInfo.offset, verticalInnerBoundInfo.offset);
  var horizontalOffset = maxOffset(horizontalSnapBoundInfo.offset, horizontalInnerBoundInfo.offset);
  var _d = checkThrottleDragRotate(throttleDragRotate, [distX, distY], [isVerticalBound, isHorizontalBound], [isVerticalSnap, isHorizontalSnap], [verticalOffset, horizontalOffset]), offsetX = _d[0], offsetY = _d[1];
  return [{
    isBound: isVerticalBound,
    isSnap: isVerticalSnap,
    offset: offsetX
  }, {
    isBound: isHorizontalBound,
    isSnap: isHorizontalSnap,
    offset: offsetY
  }];
}
function getSnapGuidelines(posInfos) {
  var guidelines = [];
  posInfos.forEach(function(posInfo) {
    posInfo.guidelineInfos.forEach(function(_a2) {
      var guideline = _a2.guideline;
      if (guidelines.indexOf(guideline) > -1) {
        return;
      }
      guidelines.push(guideline);
    });
  });
  return guidelines;
}
function getGapGuidelinesToStart(guidelines, index2, targetPos, targetSizes, guidelinePos, gap, otherPos) {
  var absGap = Math.abs(gap);
  var start = guidelinePos[index2] + (gap > 0 ? targetSizes[0] : 0);
  return guidelines.filter(function(_a2) {
    var gapPos = _a2.pos;
    return gapPos[index2] <= targetPos[index2];
  }).sort(function(_a2, _b) {
    var aPos = _a2.pos;
    var bPos = _b.pos;
    return bPos[index2] - aPos[index2];
  }).filter(function(_a2) {
    var gapPos = _a2.pos, gapSizes = _a2.sizes;
    var nextPos = gapPos[index2];
    if (throttle$3(nextPos + gapSizes[index2], FLOAT_POINT_NUM) === throttle$3(start - absGap, FLOAT_POINT_NUM)) {
      start = nextPos;
      return true;
    }
    return false;
  }).map(function(gapGuideline) {
    var renderPos = -targetPos[index2] + gapGuideline.pos[index2] + gapGuideline.sizes[index2];
    return __assign$7(__assign$7({}, gapGuideline), {
      gap,
      renderPos: index2 ? [otherPos, renderPos] : [renderPos, otherPos]
    });
  });
}
function getGapGuidelinesToEnd(guidelines, index2, targetPos, targetSizes, guidelinePos, gap, otherPos) {
  var absGap = Math.abs(gap);
  var start = guidelinePos[index2] + (gap < 0 ? targetSizes[index2] : 0);
  return guidelines.filter(function(_a2) {
    var gapPos = _a2.pos;
    return gapPos[index2] > targetPos[index2];
  }).sort(function(_a2, _b) {
    var aPos = _a2.pos;
    var bPos = _b.pos;
    return aPos[index2] - bPos[index2];
  }).filter(function(_a2) {
    var gapPos = _a2.pos, gapSizes = _a2.sizes;
    var nextPos = gapPos[index2];
    if (throttle$3(nextPos, FLOAT_POINT_NUM) === throttle$3(start + absGap, FLOAT_POINT_NUM)) {
      start = nextPos + gapSizes[index2];
      return true;
    }
    return false;
  }).map(function(gapGuideline) {
    var renderPos = -targetPos[index2] + gapGuideline.pos[index2] - absGap;
    return __assign$7(__assign$7({}, gapGuideline), {
      gap,
      renderPos: index2 ? [otherPos, renderPos] : [renderPos, otherPos]
    });
  });
}
function getGapGuidelines$1(guidelines, type, targetPos, targetSizes) {
  var elementGuidelines = guidelines.filter(function(_a3) {
    var element = _a3.element, gap = _a3.gap, guidelineType = _a3.type;
    return element && gap && guidelineType === type;
  });
  var _a2 = type === "vertical" ? [0, 1] : [1, 0], index2 = _a2[0], otherIndex = _a2[1];
  return flat(elementGuidelines.map(function(guideline) {
    var pos = guideline.pos;
    var gap = guideline.gap;
    var gapGuidelines = guideline.gapGuidelines;
    var sizes = guideline.sizes;
    var offset = minOffset(pos[otherIndex] + sizes[otherIndex] - targetPos[otherIndex], pos[otherIndex] - targetPos[otherIndex] - targetSizes[otherIndex]);
    var minSize = Math.min(sizes[otherIndex], targetSizes[otherIndex]);
    if (offset > 0 && offset > minSize) {
      offset = (offset - minSize / 2) * 2;
    } else if (offset < 0 && offset < -minSize) {
      offset = (offset + minSize / 2) * 2;
    }
    if (offset === 0) {
      return [];
    }
    var otherPos = (offset > 0 ? 0 : targetSizes[otherIndex]) + offset / 2;
    return __spreadArrays$2(getGapGuidelinesToStart(gapGuidelines, index2, targetPos, targetSizes, pos, gap, otherPos), getGapGuidelinesToEnd(gapGuidelines, index2, targetPos, targetSizes, pos, gap, otherPos));
  }));
}
function addBoundGuidelines(moveable, verticalPoses, horizontalPoses, verticalSnapPoses, horizontalSnapPoses, externalBounds) {
  var _a2 = checkBoundPoses(getBounds(moveable, externalBounds), verticalPoses, horizontalPoses), verticalBoundInfos = _a2.vertical, horizontalBoundInfos = _a2.horizontal;
  verticalBoundInfos.forEach(function(info) {
    if (info.isBound) {
      verticalSnapPoses.push({
        type: "bounds",
        pos: info.pos
      });
    }
  });
  horizontalBoundInfos.forEach(function(info) {
    if (info.isBound) {
      horizontalSnapPoses.push({
        type: "bounds",
        pos: info.pos
      });
    }
  });
  var _b = checkInnerBoundPoses(moveable), verticalInnerBoundPoses = _b.vertical, horizontalInnerBoundPoses = _b.horizontal;
  verticalInnerBoundPoses.forEach(function(innerPos) {
    if (findIndex(verticalSnapPoses, function(_a3) {
      var type = _a3.type, pos = _a3.pos;
      return type === "bounds" && pos === innerPos;
    }) >= 0) {
      return;
    }
    verticalSnapPoses.push({
      type: "bounds",
      pos: innerPos
    });
  });
  horizontalInnerBoundPoses.forEach(function(innerPos) {
    if (findIndex(horizontalSnapPoses, function(_a3) {
      var type = _a3.type, pos = _a3.pos;
      return type === "bounds" && pos === innerPos;
    }) >= 0) {
      return;
    }
    horizontalSnapPoses.push({
      type: "bounds",
      pos: innerPos
    });
  });
}
var Snappable = {
  name: "snappable",
  props: {
    snappable: [Boolean, Array],
    snapContainer: Object,
    snapCenter: Boolean,
    snapHorizontal: Boolean,
    snapVertical: Boolean,
    snapElement: Boolean,
    snapGap: Boolean,
    snapGridWidth: Number,
    snapGridHeight: Number,
    isDisplaySnapDigit: Boolean,
    isDisplayInnerSnapDigit: Boolean,
    snapDigit: Number,
    snapThreshold: Number,
    horizontalGuidelines: Array,
    verticalGuidelines: Array,
    elementGuidelines: Array,
    bounds: Object,
    innerBounds: Object,
    snapDistFormat: Function
  },
  events: {
    onSnap: "snap"
  },
  css: [":host {\n    --bounds-color: #d66;\n}\n.guideline {\n    pointer-events: none;\n    z-index: 2;\n}\n.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}\n.guideline-group {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.guideline-group .size-value {\n    position: absolute;\n    color: #f55;\n    font-size: 12px;\n    font-weight: bold;\n}\n.guideline-group.horizontal .size-value {\n    transform-origin: 50% 100%;\n    transform: translateX(-50%);\n    left: 50%;\n    bottom: 5px;\n}\n.guideline-group.vertical .size-value {\n    transform-origin: 0% 50%;\n    top: 50%;\n    transform: translateY(-50%);\n    left: 5px;\n}\n.guideline.gap {\n    background: #f55;\n}\n.size-value.gap {\n    color: #f55;\n}\n"],
  render: function(moveable, React) {
    var state = moveable.state;
    var targetTop = state.top, targetLeft = state.left, pos1 = state.pos1, pos2 = state.pos2, pos3 = state.pos3, pos4 = state.pos4, snapRenderInfo = state.snapRenderInfo, targetClientRect = state.targetClientRect, containerClientRect = state.containerClientRect, is3d = state.is3d, rootMatrix = state.rootMatrix;
    if (!snapRenderInfo || !hasGuidelines(moveable, "")) {
      return [];
    }
    state.staticGuidelines = getElementGuidelines(moveable, false, state.staticGuidelines);
    state.guidelines = getTotalGuidelines(moveable);
    var n = is3d ? 4 : 3;
    var minLeft = Math.min(pos1[0], pos2[0], pos3[0], pos4[0]);
    var minTop = Math.min(pos1[1], pos2[1], pos3[1], pos4[1]);
    var containerPos = calculateContainerPos(rootMatrix, containerClientRect, n);
    var _a2 = calculateInversePosition(rootMatrix, [targetClientRect.left - containerPos[0], targetClientRect.top - containerPos[1]], n), clientLeft = _a2[0], clientTop = _a2[1];
    var _b = moveable.props, _c = _b.snapThreshold, snapThreshold = _c === void 0 ? 5 : _c, _d = _b.snapDigit, snapDigit = _d === void 0 ? 0 : _d, _e = _b.snapDistFormat, snapDistFormat = _e === void 0 ? function(v) {
      return v;
    } : _e;
    var externalPoses = snapRenderInfo.externalPoses || [];
    var poses = getAbsolutePosesByState(moveable.state);
    var verticalSnapPoses = [];
    var horizontalSnapPoses = [];
    var verticalGuidelines = [];
    var horizontalGuidelines = [];
    var snapInfos = [];
    var _f = getRect$2(poses), width = _f.width, height = _f.height, top = _f.top, left = _f.left, bottom = _f.bottom, right = _f.right;
    var hasExternalPoses = externalPoses.length > 0;
    var externalRect = hasExternalPoses ? getRect$2(externalPoses) : {};
    if (!snapRenderInfo.request) {
      if (snapRenderInfo.direction) {
        snapInfos.push(getSnapInfosByDirection(moveable, poses, snapRenderInfo.direction));
      }
      if (snapRenderInfo.snap) {
        var rect = getRect$2(poses);
        if (snapRenderInfo.center) {
          rect.middle = (rect.top + rect.bottom) / 2;
          rect.center = (rect.left + rect.right) / 2;
        }
        snapInfos.push(checkSnaps(moveable, rect, true, 1));
      }
      if (hasExternalPoses) {
        if (snapRenderInfo.center) {
          externalRect.middle = (externalRect.top + externalRect.bottom) / 2;
          externalRect.center = (externalRect.left + externalRect.right) / 2;
        }
        snapInfos.push(checkSnaps(moveable, externalRect, true, 1));
      }
      snapInfos.forEach(function(snapInfo) {
        var verticalPosInfos = snapInfo.vertical.posInfos, horizontalPosInfos = snapInfo.horizontal.posInfos;
        verticalSnapPoses.push.apply(verticalSnapPoses, verticalPosInfos.filter(function(_a3) {
          var guidelineInfos = _a3.guidelineInfos;
          return guidelineInfos.some(function(_a4) {
            var guideline = _a4.guideline;
            return !guideline.hide;
          });
        }).map(function(posInfo) {
          return {
            type: "snap",
            pos: posInfo.pos
          };
        }));
        horizontalSnapPoses.push.apply(horizontalSnapPoses, horizontalPosInfos.filter(function(_a3) {
          var guidelineInfos = _a3.guidelineInfos;
          return guidelineInfos.some(function(_a4) {
            var guideline = _a4.guideline;
            return !guideline.hide;
          });
        }).map(function(posInfo) {
          return {
            type: "snap",
            pos: posInfo.pos
          };
        }));
        verticalGuidelines.push.apply(verticalGuidelines, getSnapGuidelines(verticalPosInfos));
        horizontalGuidelines.push.apply(horizontalGuidelines, getSnapGuidelines(horizontalPosInfos));
      });
    }
    addBoundGuidelines(moveable, [left, right], [top, bottom], verticalSnapPoses, horizontalSnapPoses);
    if (hasExternalPoses) {
      addBoundGuidelines(moveable, [externalRect.left, externalRect.right], [externalRect.top, externalRect.bottom], verticalSnapPoses, horizontalSnapPoses, snapRenderInfo.externalBounds);
    }
    var gapHorizontalGuidelines = getGapGuidelines$1(verticalGuidelines, "vertical", [targetLeft, targetTop], [width, height]);
    var gapVerticalGuidelines = getGapGuidelines$1(horizontalGuidelines, "horizontal", [targetLeft, targetTop], [width, height]);
    var allGuidelines = __spreadArrays$2(verticalGuidelines, horizontalGuidelines);
    triggerEvent(moveable, "onSnap", {
      guidelines: allGuidelines.filter(function(_a3) {
        var element = _a3.element;
        return !element;
      }),
      elements: groupBy(allGuidelines.filter(function(_a3) {
        var element = _a3.element;
        return element;
      }), function(_a3) {
        var element = _a3.element;
        return element;
      }),
      gaps: __spreadArrays$2(gapVerticalGuidelines, gapHorizontalGuidelines)
    }, true);
    var _g = filterElementInnerGuidelines(moveable, horizontalGuidelines, 0, [targetLeft, targetTop], [clientLeft, clientTop], [width, height]), nextHorizontalGuidelines = _g.guidelines, elementHorizontalGroups = _g.groups, innerGapHorizontalGuidelines = _g.gapGuidelines;
    var _h = filterElementInnerGuidelines(moveable, verticalGuidelines, 1, [targetLeft, targetTop], [clientLeft, clientTop], [width, height]), nextVerticalGuidelines = _h.guidelines, elementVerticalGroups = _h.groups, innerGapVerticalGuidelines = _h.gapGuidelines;
    return __spreadArrays$2(renderGapGuidelines(moveable, "vertical", __spreadArrays$2(gapVerticalGuidelines, innerGapVerticalGuidelines), snapDistFormat, React), renderGapGuidelines(moveable, "horizontal", __spreadArrays$2(gapHorizontalGuidelines, innerGapHorizontalGuidelines), snapDistFormat, React), renderElementGroups(moveable, "horizontal", elementHorizontalGroups, minLeft, clientLeft, width, targetTop, snapThreshold, snapDigit, 0, snapDistFormat, React), renderElementGroups(moveable, "vertical", elementVerticalGroups, minTop, clientTop, height, targetLeft, snapThreshold, snapDigit, 1, snapDistFormat, React), renderGuidelines(moveable, "horizontal", nextHorizontalGuidelines, [targetLeft, targetTop], React), renderGuidelines(moveable, "vertical", nextVerticalGuidelines, [targetLeft, targetTop], React), renderSnapPoses(moveable, "horizontal", horizontalSnapPoses, minLeft, targetTop, width, 0, React), renderSnapPoses(moveable, "vertical", verticalSnapPoses, minTop, targetLeft, height, 1, React));
  },
  dragStart: function(moveable, e2) {
    moveable.state.snapRenderInfo = {
      request: e2.isRequest,
      snap: true,
      center: true
    };
    snapStart(moveable);
  },
  drag: function(moveable) {
    var state = moveable.state;
    state.staticGuidelines = getElementGuidelines(moveable, false, state.staticGuidelines);
    state.guidelines = getTotalGuidelines(moveable);
  },
  pinchStart: function(moveable) {
    this.unset(moveable);
  },
  dragEnd: function(moveable) {
    this.unset(moveable);
  },
  dragControlCondition: function(moveable, e2) {
    if (directionCondition(moveable, e2) || dragControlCondition(moveable, e2)) {
      return true;
    }
    if (!e2.isRequest && e2.inputEvent) {
      return hasClass(e2.inputEvent.target, prefix$2("snap-control"));
    }
  },
  dragControlStart: function(moveable) {
    moveable.state.snapRenderInfo = null;
    snapStart(moveable);
  },
  dragControl: function(moveable) {
    this.drag(moveable);
  },
  dragControlEnd: function(moveable) {
    this.unset(moveable);
  },
  dragGroupStart: function(moveable, e2) {
    this.dragStart(moveable, e2);
  },
  dragGroup: function(moveable) {
    this.drag(moveable);
  },
  dragGroupEnd: function(moveable) {
    this.unset(moveable);
  },
  dragGroupControlStart: function(moveable) {
    moveable.state.snapRenderInfo = null;
    snapStart(moveable);
  },
  dragGroupControl: function(moveable) {
    this.drag(moveable);
  },
  dragGroupControlEnd: function(moveable) {
    this.unset(moveable);
  },
  unset: function(moveable) {
    var state = moveable.state;
    state.enableSnap = false;
    state.staticGuidelines = [];
    state.guidelines = [];
    state.snapRenderInfo = null;
  }
};
var Draggable = {
  name: "draggable",
  props: {
    draggable: Boolean,
    throttleDrag: Number,
    throttleDragRotate: Number,
    startDragRotate: Number,
    edgeDraggable: Boolean
  },
  events: {
    onDragStart: "dragStart",
    onDrag: "drag",
    onDragEnd: "dragEnd",
    onDragGroupStart: "dragGroupStart",
    onDragGroup: "dragGroup",
    onDragGroupEnd: "dragGroupEnd"
  },
  render: function(moveable, React) {
    var _a2 = moveable.props, throttleDragRotate = _a2.throttleDragRotate, zoom = _a2.zoom;
    var _b = moveable.state, dragInfo = _b.dragInfo, beforeOrigin = _b.beforeOrigin;
    if (!throttleDragRotate || !dragInfo) {
      return [];
    }
    var dist = dragInfo.dist;
    if (!dist[0] && !dist[1]) {
      return [];
    }
    var width = getDistSize(dist);
    var rad = getRad$1(dist, [0, 0]);
    return [React.createElement("div", {
      className: prefix$2("line", "horizontal", "dragline", "dashed"),
      key: "dragRotateGuideline",
      style: {
        width: width + "px",
        transform: "translate(" + beforeOrigin[0] + "px, " + beforeOrigin[1] + "px) rotate(" + rad + "rad) scaleY(" + zoom + ")"
      }
    })];
  },
  dragStart: function(moveable, e2) {
    var datas = e2.datas, parentEvent = e2.parentEvent, parentGesto = e2.parentGesto;
    var state = moveable.state;
    var target = state.target, gesto = state.gesto;
    if (gesto) {
      return false;
    }
    state.gesto = parentGesto || moveable.targetGesto;
    var style = getComputedStyle$1(target);
    datas.datas = {};
    datas.left = parseFloat(style.left || "") || 0;
    datas.top = parseFloat(style.top || "") || 0;
    datas.bottom = parseFloat(style.bottom || "") || 0;
    datas.right = parseFloat(style.right || "") || 0;
    datas.startValue = [0, 0];
    setDragStart(moveable, e2);
    setDefaultTransformIndex(e2, "translate");
    startCheckSnapDrag(moveable, datas);
    datas.prevDist = [0, 0];
    datas.prevBeforeDist = [0, 0];
    datas.isDrag = false;
    var params = fillParams(moveable, e2, __assign$7({
      set: function(translate) {
        datas.startValue = translate;
      }
    }, fillTransformStartEvent(e2)));
    var result = parentEvent || triggerEvent(moveable, "onDragStart", params);
    if (result !== false) {
      datas.isDrag = true;
      moveable.state.dragInfo = {
        startRect: moveable.getRect(),
        dist: [0, 0]
      };
    } else {
      state.gesto = null;
      datas.isPinch = false;
    }
    return datas.isDrag ? params : false;
  },
  drag: function(moveable, e2) {
    resolveTransformEvent(e2, "translate");
    var datas = e2.datas, parentEvent = e2.parentEvent, parentFlag = e2.parentFlag, isPinch = e2.isPinch, isRequest = e2.isRequest;
    var distX = e2.distX, distY = e2.distY;
    var isDrag2 = datas.isDrag, prevDist = datas.prevDist, prevBeforeDist = datas.prevBeforeDist, startValue = datas.startValue;
    if (!isDrag2) {
      return;
    }
    var props2 = moveable.props;
    var parentMoveable = props2.parentMoveable;
    var throttleDrag = parentEvent ? 0 : props2.throttleDrag || 0;
    var throttleDragRotate = parentEvent ? 0 : props2.throttleDragRotate || 0;
    var isSnap = false;
    var dragRotateRad = 0;
    if (!parentEvent && throttleDragRotate > 0 && (distX || distY)) {
      var startDragRotate = props2.startDragRotate || 0;
      var deg2 = throttle$3(startDragRotate + getRad$1([0, 0], [distX, distY]) * 180 / Math.PI, throttleDragRotate) - startDragRotate;
      var ry = distY * Math.abs(Math.cos((deg2 - 90) / 180 * Math.PI));
      var rx = distX * Math.abs(Math.cos(deg2 / 180 * Math.PI));
      var r = getDistSize([rx, ry]);
      dragRotateRad = deg2 * Math.PI / 180;
      distX = r * Math.cos(dragRotateRad);
      distY = r * Math.sin(dragRotateRad);
    }
    if (!isPinch && !parentEvent && !parentFlag && (!throttleDragRotate || distX || distY)) {
      var _a2 = checkSnapDrag(moveable, distX, distY, throttleDragRotate, isRequest, datas), verticalInfo = _a2[0], horizontalInfo = _a2[1];
      var isVerticalSnap = verticalInfo.isSnap, isVerticalBound = verticalInfo.isBound, verticalOffset = verticalInfo.offset;
      var isHorizontalSnap = horizontalInfo.isSnap, isHorizontalBound = horizontalInfo.isBound, horizontalOffset = horizontalInfo.offset;
      isSnap = isVerticalSnap || isHorizontalSnap || isVerticalBound || isHorizontalBound;
      distX += verticalOffset;
      distY += horizontalOffset;
    }
    datas.passDeltaX = distX - (datas.passDistX || 0);
    datas.passDeltaY = distY - (datas.passDistY || 0);
    datas.passDistX = distX;
    datas.passDistY = distY;
    var beforeTranslate = plus(getBeforeDragDist({
      datas,
      distX,
      distY
    }), startValue);
    var translate = plus(getTransformDist({
      datas,
      distX,
      distY
    }), startValue);
    if (!throttleDragRotate && !isSnap) {
      throttleArray(translate, throttleDrag);
      throttleArray(beforeTranslate, throttleDrag);
    }
    var beforeDist = minus(beforeTranslate, startValue);
    var dist = minus(translate, startValue);
    var delta = minus(dist, prevDist);
    var beforeDelta = minus(beforeDist, prevBeforeDist);
    datas.prevDist = dist;
    datas.prevBeforeDist = beforeDist;
    var left = datas.left + beforeDist[0];
    var top = datas.top + beforeDist[1];
    var right = datas.right - beforeDist[0];
    var bottom = datas.bottom - beforeDist[1];
    var nextTransform = convertTransformFormat(datas, "translate(" + translate[0] + "px, " + translate[1] + "px)", "translate(" + dist[0] + "px, " + dist[1] + "px)");
    moveable.state.dragInfo.dist = parentEvent ? [0, 0] : dist;
    if (!parentEvent && !parentMoveable && delta.every(function(num) {
      return !num;
    }) && beforeDelta.some(function(num) {
      return !num;
    })) {
      return;
    }
    var _b = moveable.state, width = _b.width, height = _b.height;
    var params = fillParams(moveable, e2, {
      transform: nextTransform,
      dist,
      delta,
      translate,
      beforeDist,
      beforeDelta,
      beforeTranslate,
      left,
      top,
      right,
      bottom,
      width,
      height,
      isPinch
    });
    !parentEvent && triggerEvent(moveable, "onDrag", params);
    return params;
  },
  dragEnd: function(moveable, e2) {
    var parentEvent = e2.parentEvent, datas = e2.datas, isDrag2 = e2.isDrag;
    moveable.state.gesto = null;
    moveable.state.dragInfo = null;
    if (!datas.isDrag) {
      return;
    }
    datas.isDrag = false;
    !parentEvent && triggerEvent(moveable, "onDragEnd", fillEndParams(moveable, e2, {}));
    return isDrag2;
  },
  dragGroupStart: function(moveable, e2) {
    var datas = e2.datas, clientX = e2.clientX, clientY = e2.clientY;
    var params = this.dragStart(moveable, e2);
    if (!params) {
      return false;
    }
    var events2 = triggerChildGesto(moveable, this, "dragStart", [clientX || 0, clientY || 0], e2, false);
    var nextParams = __assign$7(__assign$7({}, params), {
      targets: moveable.props.targets,
      events: events2
    });
    var result = triggerEvent(moveable, "onDragGroupStart", nextParams);
    datas.isDrag = result !== false;
    return datas.isDrag ? params : false;
  },
  dragGroup: function(moveable, e2) {
    var datas = e2.datas;
    if (!datas.isDrag) {
      return;
    }
    var params = this.drag(moveable, e2);
    var _a2 = e2.datas, passDeltaX = _a2.passDeltaX, passDeltaY = _a2.passDeltaY;
    var events2 = triggerChildGesto(moveable, this, "drag", [passDeltaX, passDeltaY], e2, false);
    if (!params) {
      return;
    }
    var nextParams = __assign$7({
      targets: moveable.props.targets,
      events: events2
    }, params);
    triggerEvent(moveable, "onDragGroup", nextParams);
    return nextParams;
  },
  dragGroupEnd: function(moveable, e2) {
    var isDrag2 = e2.isDrag, datas = e2.datas;
    if (!datas.isDrag) {
      return;
    }
    this.dragEnd(moveable, e2);
    triggerChildGesto(moveable, this, "dragEnd", [0, 0], e2, false);
    triggerEvent(moveable, "onDragGroupEnd", fillEndParams(moveable, e2, {
      targets: moveable.props.targets
    }));
    return isDrag2;
  },
  request: function(moveable) {
    var datas = {};
    var rect = moveable.getRect();
    var distX = 0;
    var distY = 0;
    return {
      isControl: false,
      requestStart: function() {
        return {
          datas
        };
      },
      request: function(e2) {
        if ("x" in e2) {
          distX = e2.x - rect.left;
        } else if ("deltaX" in e2) {
          distX += e2.deltaX;
        }
        if ("y" in e2) {
          distY = e2.y - rect.top;
        } else if ("deltaY" in e2) {
          distY += e2.deltaY;
        }
        return {
          datas,
          distX,
          distY
        };
      },
      requestEnd: function() {
        return {
          datas,
          isDrag: true
        };
      }
    };
  },
  unset: function(moveable) {
    moveable.state.dragInfo = null;
  }
};
function renderDirectionControls(moveable, defaultDirections, React, additionalClassName) {
  if (additionalClassName === void 0) {
    additionalClassName = "";
  }
  var _a2 = moveable.state, renderPoses = _a2.renderPoses, radRotation = _a2.rotation, direction2 = _a2.direction;
  var _b = moveable.props, _c = _b.renderDirections, directions = _c === void 0 ? defaultDirections : _c, zoom = _b.zoom;
  var directionMap = {};
  if (!directions) {
    return [];
  }
  var sign2 = direction2 > 0 ? 1 : -1;
  var renderDirections = directions === true ? DIRECTIONS : directions;
  var degRotation = radRotation / Math.PI * 180;
  renderDirections.forEach(function(dir) {
    directionMap[dir] = true;
  });
  return renderDirections.map(function(dir) {
    var indexes = DIRECTION_INDEXES[dir];
    if (!indexes || !directionMap[dir]) {
      return null;
    }
    var directionRotation = (throttle$3(degRotation, 15) + sign2 * DIRECTION_ROTATIONS[dir] + 720) % 180;
    return React.createElement("div", {
      className: prefix$2("control", "direction", dir, additionalClassName),
      "data-rotation": directionRotation,
      "data-direction": dir,
      key: "direction-" + dir,
      style: getControlTransform.apply(void 0, __spreadArrays$2([radRotation, zoom], indexes.map(function(index2) {
        return renderPoses[index2];
      })))
    });
  });
}
function renderLine(React, direction2, pos1, pos2, zoom, key) {
  var classNames = [];
  for (var _i = 6; _i < arguments.length; _i++) {
    classNames[_i - 6] = arguments[_i];
  }
  var rad = getRad$1(pos1, pos2);
  var rotation = direction2 ? throttle$3(rad / Math.PI * 180, 15) % 180 : -1;
  return React.createElement("div", {
    key: "line" + key,
    className: prefix$2.apply(void 0, __spreadArrays$2(["line", "direction", direction2], classNames)),
    "data-rotation": rotation,
    "data-line-index": key,
    "data-direction": direction2,
    style: getLineStyle(pos1, pos2, zoom, rad)
  });
}
function renderAllDirections(moveable, React) {
  return renderDirectionControls(moveable, DIRECTIONS, React);
}
function renderDiagonalDirections(moveable, React) {
  return renderDirectionControls(moveable, ["nw", "ne", "sw", "se"], React);
}
function setRotateStartInfo(moveable, datas, clientX, clientY, origin, rect) {
  var n = moveable.state.is3d ? 4 : 3;
  var nextOrigin = calculatePosition(moveable.state.rootMatrix, origin, n);
  var startAbsoluteOrigin = plus([rect.left, rect.top], nextOrigin);
  datas.startAbsoluteOrigin = startAbsoluteOrigin;
  datas.prevDeg = getRad$1(startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180;
  datas.prevSnapDeg = datas.prevDeg;
  datas.startDeg = datas.prevDeg;
  datas.loop = 0;
}
function getParentDeg(moveable, moveableRect, datas, parentDist, direction2, startValue) {
  var prevDeg = datas.prevDeg;
  var dist = checkSnapRotate(moveable, moveableRect, datas.origin, parentDist);
  datas.prevDeg = dist;
  var delta = dist - prevDeg;
  return [delta, dist, startValue + dist];
}
function getDeg(moveable, moveableRect, datas, deg2, direction2, startValue, throttleRotate, isSnap) {
  var prevDeg = datas.prevDeg, prevSnapDeg = datas.prevSnapDeg, startDeg = datas.startDeg, prevLoop = datas.loop;
  if (prevDeg > deg2 && prevDeg > 270 && deg2 < 90) {
    ++datas.loop;
  } else if (prevDeg < deg2 && prevDeg < 90 && deg2 > 270) {
    --datas.loop;
  }
  var loop = datas.loop;
  var absolutePrevSnapDeg = prevLoop * 360 + prevSnapDeg - startDeg + startValue;
  var absoluteDeg = loop * 360 + deg2 - startDeg + startValue;
  datas.prevDeg = absoluteDeg - loop * 360 + startDeg - startValue;
  absoluteDeg = throttle$3(absoluteDeg, throttleRotate);
  var dist = direction2 * (absoluteDeg - startValue);
  if (isSnap) {
    dist = checkSnapRotate(moveable, moveableRect, datas.origin, dist);
    absoluteDeg = dist / direction2 + startValue;
  }
  datas.prevSnapDeg = absoluteDeg - loop * 360 + startDeg - startValue;
  var delta = direction2 * (absoluteDeg - absolutePrevSnapDeg);
  return [delta, dist, startValue + dist];
}
function getRotateInfo(moveable, moveableRect, datas, direction2, clientX, clientY, startValue, throttleRotate) {
  return getDeg(moveable, moveableRect, datas, getRad$1(datas.startAbsoluteOrigin, [clientX, clientY]) / Math.PI * 180, direction2, startValue, throttleRotate, true);
}
function getRotationPositions(rotationPosition, _a2, direction2) {
  var pos1 = _a2[0], pos2 = _a2[1], pos3 = _a2[2], pos4 = _a2[3];
  if (rotationPosition === "none") {
    return;
  }
  var _b = (rotationPosition || "top").split("-"), dir1 = _b[0], dir2 = _b[1];
  var radPoses = [pos1, pos2];
  if (dir1 === "left") {
    radPoses = [pos3, pos1];
  } else if (dir1 === "right") {
    radPoses = [pos2, pos4];
  } else if (dir1 === "bottom") {
    radPoses = [pos4, pos3];
  }
  var pos = [(radPoses[0][0] + radPoses[1][0]) / 2, (radPoses[0][1] + radPoses[1][1]) / 2];
  var rad = getRotationRad(radPoses, direction2);
  if (dir2) {
    var isStart = dir2 === "top" || dir2 === "left";
    var isReverse = dir1 === "bottom" || dir1 === "left";
    pos = radPoses[isStart && !isReverse || !isStart && isReverse ? 0 : 1];
  }
  return [pos, rad];
}
function dragControlCondition(moveable, e2) {
  if (e2.isRequest) {
    return e2.requestAble === "rotatable";
  }
  var target = e2.inputEvent.target;
  if (hasClass(target, prefix$2("rotation-control"))) {
    return true;
  }
  var rotationTarget = moveable.props.rotationTarget;
  if (rotationTarget) {
    return getRefTargets(rotationTarget, true).some(function(element) {
      if (!element) {
        return false;
      }
      return target === element || target.contains(element);
    });
  }
  return false;
}
var Rotatable = {
  name: "rotatable",
  canPinch: true,
  props: {
    rotatable: Boolean,
    rotationPosition: String,
    throttleRotate: Number,
    renderDirections: Object,
    rotationTarget: Object
  },
  events: {
    onRotateStart: "rotateStart",
    onRotate: "rotate",
    onRotateEnd: "rotateEnd",
    onRotateGroupStart: "rotateGroupStart",
    onRotateGroup: "rotateGroup",
    onRotateGroupEnd: "rotateGroupEnd"
  },
  css: [".rotation {\n            position: absolute;\n            height: 40px;\n            width: 1px;\n            transform-origin: 50% 100%;\n            height: calc(40px * var(--zoom));\n            top: auto;\n            left: 0;\n            bottom: 100%;\n            will-change: transform;\n        }\n        .rotation .rotation-line {\n            display: block;\n            width: 100%;\n            height: 100%;\n            transform-origin: 50% 50%;\n        }\n        .rotation .rotation-control {\n            border-color: #4af;\n            border-color: var(--moveable-color);\n            background:#fff;\n            cursor: alias;\n        }"],
  render: function(moveable, React) {
    var _a2 = moveable.props, rotatable = _a2.rotatable, rotationPosition = _a2.rotationPosition, zoom = _a2.zoom, renderDirections = _a2.renderDirections;
    var _b = moveable.state, renderPoses = _b.renderPoses, direction2 = _b.direction;
    if (!rotatable) {
      return null;
    }
    var positions = getRotationPositions(rotationPosition, renderPoses, direction2);
    var jsxs = [];
    if (positions) {
      var pos = positions[0], rad = positions[1];
      jsxs.push(React.createElement("div", {
        key: "rotation",
        className: prefix$2("rotation"),
        style: {
          transform: "translate(-50%) translate(" + pos[0] + "px, " + pos[1] + "px) rotate(" + rad + "rad)"
        }
      }, React.createElement("div", {
        className: prefix$2("line rotation-line"),
        style: {
          transform: "scaleX(" + zoom + ")"
        }
      }), React.createElement("div", {
        className: prefix$2("control rotation-control"),
        style: {
          transform: "translate(0.5px) scale(" + zoom + ")"
        }
      })));
    }
    if (renderDirections) {
      jsxs.push.apply(jsxs, renderDirectionControls(moveable, [], React));
    }
    return jsxs;
  },
  dragControlCondition,
  dragControlStart: function(moveable, e2) {
    var datas = e2.datas, clientX = e2.clientX, clientY = e2.clientY, parentRotate = e2.parentRotate, parentFlag = e2.parentFlag, isPinch = e2.isPinch, isRequest = e2.isRequest;
    var _a2 = moveable.state, target = _a2.target, left = _a2.left, top = _a2.top, origin = _a2.origin, beforeOrigin = _a2.beforeOrigin, direction2 = _a2.direction, beforeDirection = _a2.beforeDirection, targetTransform = _a2.targetTransform, moveableClientRect = _a2.moveableClientRect;
    if (!isRequest && !target) {
      return false;
    }
    var rect = moveable.getRect();
    datas.rect = rect;
    datas.transform = targetTransform;
    datas.left = left;
    datas.top = top;
    datas.fixedPosition = getDirectionOffset(moveable, getOriginDirection(moveable));
    datas.absoluteInfo = {
      origin: rect.origin,
      startValue: rect.rotation
    };
    setRotateStartInfo(moveable, datas.absoluteInfo, clientX, clientY, origin, moveableClientRect);
    if (isRequest || isPinch || parentFlag) {
      var externalRotate = parentRotate || 0;
      datas.beforeInfo = {
        origin: rect.beforeOrigin,
        prevDeg: externalRotate,
        startDeg: externalRotate,
        prevSnapDeg: externalRotate,
        loop: 0
      };
      datas.afterInfo = {
        origin: rect.origin,
        prevDeg: externalRotate,
        startDeg: externalRotate,
        prevSnapDeg: externalRotate,
        loop: 0
      };
    } else {
      datas.beforeInfo = {
        origin: rect.beforeOrigin
      };
      datas.afterInfo = {
        origin: rect.origin
      };
      setRotateStartInfo(moveable, datas.beforeInfo, clientX, clientY, beforeOrigin, moveableClientRect);
      setRotateStartInfo(moveable, datas.afterInfo, clientX, clientY, origin, moveableClientRect);
    }
    datas.direction = direction2;
    datas.beforeDirection = beforeDirection;
    datas.startValue = 0;
    datas.datas = {};
    setDefaultTransformIndex(e2, "rotate");
    var params = fillParams(moveable, e2, __assign$7(__assign$7({
      set: function(rotatation) {
        datas.startValue = rotatation * Math.PI / 180;
      }
    }, fillTransformStartEvent(e2)), {
      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e2))
    }));
    var result = triggerEvent(moveable, "onRotateStart", params);
    datas.isRotate = result !== false;
    moveable.state.snapRenderInfo = {
      request: e2.isRequest
    };
    return datas.isRotate ? params : false;
  },
  dragControl: function(moveable, e2) {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _j;
    var datas = e2.datas, clientX = e2.clientX, clientY = e2.clientY, parentRotate = e2.parentRotate, parentFlag = e2.parentFlag, isPinch = e2.isPinch, groupDelta = e2.groupDelta;
    var beforeDirection = datas.beforeDirection, beforeInfo = datas.beforeInfo, afterInfo = datas.afterInfo, absoluteInfo = datas.absoluteInfo, isRotate = datas.isRotate, startValue = datas.startValue, rect = datas.rect;
    if (!isRotate) {
      return;
    }
    resolveTransformEvent(e2, "rotate");
    var targetDirection = getTransformDirection(e2);
    var direction2 = beforeDirection * targetDirection;
    var _k = moveable.props, _l = _k.throttleRotate, throttleRotate = _l === void 0 ? 0 : _l, parentMoveable = _k.parentMoveable;
    var delta;
    var dist;
    var rotate2;
    var beforeDelta;
    var beforeDist;
    var beforeRotate;
    var absoluteDelta;
    var absoluteDist;
    var absoluteRotate;
    var startDeg = 180 / Math.PI * startValue;
    var absoluteStartDeg = absoluteInfo.startValue;
    if (!parentFlag && "parentDist" in e2) {
      var parentDist = e2.parentDist;
      _a2 = getParentDeg(moveable, rect, afterInfo, parentDist, direction2, startDeg), delta = _a2[0], dist = _a2[1], rotate2 = _a2[2];
      _b = getParentDeg(moveable, rect, beforeInfo, parentDist, beforeDirection, startDeg), beforeDelta = _b[0], beforeDist = _b[1], beforeRotate = _b[2];
      _c = getParentDeg(moveable, rect, absoluteInfo, parentDist, direction2, absoluteStartDeg), absoluteDelta = _c[0], absoluteDist = _c[1], absoluteRotate = _c[2];
    } else if (isPinch || parentFlag) {
      _d = getDeg(moveable, rect, afterInfo, parentRotate, direction2, startDeg, throttleRotate), delta = _d[0], dist = _d[1], rotate2 = _d[2];
      _e = getDeg(moveable, rect, beforeInfo, parentRotate, beforeDirection, startDeg, throttleRotate), beforeDelta = _e[0], beforeDist = _e[1], beforeRotate = _e[2];
      _f = getDeg(moveable, rect, absoluteInfo, parentRotate, direction2, absoluteStartDeg, throttleRotate), absoluteDelta = _f[0], absoluteDist = _f[1], absoluteRotate = _f[2];
    } else {
      _g = getRotateInfo(moveable, rect, afterInfo, direction2, clientX, clientY, startDeg, throttleRotate), delta = _g[0], dist = _g[1], rotate2 = _g[2];
      _h = getRotateInfo(moveable, rect, beforeInfo, beforeDirection, clientX, clientY, startDeg, throttleRotate), beforeDelta = _h[0], beforeDist = _h[1], beforeRotate = _h[2];
      _j = getRotateInfo(moveable, rect, absoluteInfo, direction2, clientX, clientY, absoluteStartDeg, throttleRotate), absoluteDelta = _j[0], absoluteDist = _j[1], absoluteRotate = _j[2];
    }
    if (!absoluteDelta && !delta && !beforeDelta && !parentMoveable) {
      return;
    }
    var nextTransform = convertTransformFormat(datas, "rotate(" + rotate2 + "deg)", "rotate(" + dist + "deg)");
    var inverseDist = getRotateDist(moveable, dist, datas.fixedPosition, datas);
    var inverseDelta = minus(plus(groupDelta || [0, 0], inverseDist), datas.prevInverseDist || [0, 0]);
    datas.prevInverseDist = inverseDist;
    var params = fillParams(moveable, e2, __assign$7({
      delta,
      dist,
      rotate: rotate2,
      beforeDist,
      beforeDelta,
      beforeRotate,
      absoluteDist,
      absoluteDelta,
      absoluteRotate,
      isPinch: !!isPinch
    }, fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e2)));
    triggerEvent(moveable, "onRotate", params);
    return params;
  },
  dragControlEnd: function(moveable, e2) {
    var datas = e2.datas, isDrag2 = e2.isDrag;
    if (!datas.isRotate) {
      return false;
    }
    datas.isRotate = false;
    triggerEvent(moveable, "onRotateEnd", fillEndParams(moveable, e2, {}));
    return isDrag2;
  },
  dragGroupControlCondition: dragControlCondition,
  dragGroupControlStart: function(moveable, e2) {
    var datas = e2.datas;
    var _a2 = moveable.state, parentLeft = _a2.left, parentTop = _a2.top, parentBeforeOrigin = _a2.beforeOrigin;
    var params = this.dragControlStart(moveable, e2);
    if (!params) {
      return false;
    }
    params.set(datas.beforeDirection * moveable.rotation);
    var events2 = triggerChildAbles(moveable, this, "dragControlStart", e2, function(child, ev) {
      var _a3 = child.state, left = _a3.left, top = _a3.top, beforeOrigin = _a3.beforeOrigin;
      var childClient = plus(minus([left, top], [parentLeft, parentTop]), minus(beforeOrigin, parentBeforeOrigin));
      ev.datas.groupClient = childClient;
      return __assign$7(__assign$7({}, ev), {
        parentRotate: 0
      });
    });
    var nextParams = __assign$7(__assign$7({}, params), {
      targets: moveable.props.targets,
      events: events2
    });
    var result = triggerEvent(moveable, "onRotateGroupStart", nextParams);
    datas.isRotate = result !== false;
    return datas.isRotate ? params : false;
  },
  dragGroupControl: function(moveable, e2) {
    var datas = e2.datas;
    if (!datas.isRotate) {
      return;
    }
    var params = this.dragControl(moveable, e2);
    if (!params) {
      return;
    }
    var direction2 = datas.beforeDirection;
    var parentRotate = params.beforeDist;
    var deg2 = params.beforeDelta;
    var rad = deg2 / 180 * Math.PI;
    var events2 = triggerChildAbles(moveable, this, "dragControl", e2, function(_, ev) {
      var _a2 = ev.datas.groupClient, prevX = _a2[0], prevY = _a2[1];
      var _b = rotate([prevX, prevY], rad * direction2), clientX = _b[0], clientY = _b[1];
      var delta = [clientX - prevX, clientY - prevY];
      ev.datas.groupClient = [clientX, clientY];
      return __assign$7(__assign$7({}, ev), {
        parentRotate,
        groupDelta: delta
      });
    });
    moveable.rotation = direction2 * params.beforeRotate;
    var nextParams = __assign$7({
      targets: moveable.props.targets,
      events: events2,
      set: function(rotation) {
        moveable.rotation = rotation;
      }
    }, params);
    triggerEvent(moveable, "onRotateGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function(moveable, e2) {
    var isDrag2 = e2.isDrag, datas = e2.datas;
    if (!datas.isRotate) {
      return;
    }
    this.dragControlEnd(moveable, e2);
    triggerChildAbles(moveable, this, "dragControlEnd", e2);
    var nextParams = fillEndParams(moveable, e2, {
      targets: moveable.props.targets
    });
    triggerEvent(moveable, "onRotateGroupEnd", nextParams);
    return isDrag2;
  },
  request: function(moveable) {
    var datas = {};
    var distRotate = 0;
    var startRotation = moveable.getRotation();
    return {
      isControl: true,
      requestStart: function() {
        return {
          datas
        };
      },
      request: function(e2) {
        if ("deltaRotate" in e2) {
          distRotate += e2.deltaRotate;
        } else if ("rotate" in e2) {
          distRotate = e2.rotate - startRotation;
        }
        return {
          datas,
          parentDist: distRotate
        };
      },
      requestEnd: function() {
        return {
          datas,
          isDrag: true
        };
      }
    };
  }
};
var Resizable = {
  name: "resizable",
  ableGroup: "size",
  canPinch: true,
  props: {
    resizable: Boolean,
    throttleResize: Number,
    renderDirections: Array,
    keepRatio: Boolean
  },
  events: {
    onResizeStart: "resizeStart",
    onResize: "resize",
    onResizeEnd: "resizeEnd",
    onResizeGroupStart: "resizeGroupStart",
    onResizeGroup: "resizeGroup",
    onResizeGroupEnd: "resizeGroupEnd"
  },
  render: function(moveable, React) {
    var _a2 = moveable.props, resizable = _a2.resizable, edge = _a2.edge;
    if (resizable) {
      if (edge) {
        return renderDiagonalDirections(moveable, React);
      }
      return renderAllDirections(moveable, React);
    }
  },
  dragControlCondition: directionCondition,
  dragControlStart: function(moveable, e2) {
    var _a2;
    var inputEvent = e2.inputEvent, isPinch = e2.isPinch, parentDirection = e2.parentDirection, datas = e2.datas, parentFlag = e2.parentFlag;
    var direction2 = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));
    var _b = moveable.state, target = _b.target, width = _b.width, height = _b.height;
    if (!direction2 || !target) {
      return false;
    }
    !isPinch && setDragStart(moveable, e2);
    datas.datas = {};
    datas.direction = direction2;
    datas.startOffsetWidth = width;
    datas.startOffsetHeight = height;
    datas.prevWidth = 0;
    datas.prevHeight = 0;
    _a2 = getCSSSize(target), datas.startWidth = _a2[0], datas.startHeight = _a2[1];
    var padding = [Math.max(0, width - datas.startWidth), Math.max(0, height - datas.startHeight)];
    datas.minSize = padding;
    datas.maxSize = [Infinity, Infinity];
    if (!parentFlag) {
      var style = getComputedStyle$1(target);
      var position2 = style.position, minWidth = style.minWidth, minHeight = style.minHeight, maxWidth = style.maxWidth, maxHeight = style.maxHeight;
      var isParentElement = position2 === "static" || position2 === "relative";
      var container = isParentElement ? target.parentElement : target.offsetParent;
      var containerWidth = width;
      var containerHeight = height;
      if (container) {
        containerWidth = container.clientWidth;
        containerHeight = container.clientHeight;
        if (isParentElement) {
          var containerStyle = getComputedStyle$1(container);
          containerWidth -= parseFloat(containerStyle.paddingLeft) || 0;
          containerHeight -= parseFloat(containerStyle.paddingTop) || 0;
        }
      }
      datas.minSize = plus([convertUnitSize(minWidth, containerWidth) || 0, convertUnitSize(minHeight, containerHeight) || 0], padding);
      datas.maxSize = plus([convertUnitSize(maxWidth, containerWidth) || Infinity, convertUnitSize(maxHeight, containerHeight) || Infinity], padding);
    }
    var transformOrigin2 = moveable.props.transformOrigin || "% %";
    datas.transformOrigin = transformOrigin2 && isString$2(transformOrigin2) ? transformOrigin2.split(" ") : transformOrigin2;
    datas.isWidth = !direction2[0] && !direction2[1] || direction2[0] || !direction2[1];
    function setRatio(ratio) {
      datas.ratio = ratio && isFinite(ratio) ? ratio : 0;
    }
    function setFixedDirection(fixedDirection) {
      datas.fixedDirection = fixedDirection;
      datas.fixedPosition = getAbsolutePosition(moveable, fixedDirection);
    }
    setRatio(width / height);
    setFixedDirection([-direction2[0], -direction2[1]]);
    var params = fillParams(moveable, e2, {
      direction: direction2,
      set: function(_a3) {
        var startWidth = _a3[0], startHeight = _a3[1];
        datas.startWidth = startWidth;
        datas.startHeight = startHeight;
      },
      setMin: function(minSize) {
        datas.minSize = minSize;
      },
      setMax: function(maxSize) {
        datas.maxSize = [maxSize[0] || Infinity, maxSize[1] || Infinity];
      },
      setRatio,
      setFixedDirection,
      setOrigin: function(origin) {
        datas.transformOrigin = origin;
      },
      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e2))
    });
    var result = triggerEvent(moveable, "onResizeStart", params);
    if (result !== false) {
      datas.isResize = true;
      moveable.state.snapRenderInfo = {
        request: e2.isRequest,
        direction: direction2
      };
    }
    return datas.isResize ? params : false;
  },
  dragControl: function(moveable, e2) {
    var _a2;
    var datas = e2.datas, distX = e2.distX, distY = e2.distY, parentFlag = e2.parentFlag, isPinch = e2.isPinch, parentDistance = e2.parentDistance, parentScale = e2.parentScale, parentKeepRatio = e2.parentKeepRatio, dragClient = e2.dragClient, parentDist = e2.parentDist, isRequest = e2.isRequest;
    var isResize = datas.isResize, transformOrigin2 = datas.transformOrigin, fixedDirection = datas.fixedDirection, startWidth = datas.startWidth, startHeight = datas.startHeight, prevWidth = datas.prevWidth, prevHeight = datas.prevHeight, minSize = datas.minSize, maxSize = datas.maxSize, ratio = datas.ratio, isWidth = datas.isWidth, startOffsetWidth = datas.startOffsetWidth, startOffsetHeight = datas.startOffsetHeight;
    if (!isResize) {
      return;
    }
    var _b = moveable.props, _c = _b.throttleResize, throttleResize = _c === void 0 ? 0 : _c, parentMoveable = _b.parentMoveable, _d = _b.snapThreshold, snapThreshold = _d === void 0 ? 5 : _d;
    var direction2 = datas.direction;
    var sizeDirection = direction2;
    var distWidth = 0;
    var distHeight = 0;
    if (!direction2[0] && !direction2[1]) {
      sizeDirection = [1, 1];
    }
    var keepRatio = ratio && (moveable.props.keepRatio || parentKeepRatio);
    var fixedPosition = dragClient;
    if (!dragClient) {
      if (!parentFlag && isPinch) {
        fixedPosition = getAbsolutePosition(moveable, [0, 0]);
      } else {
        fixedPosition = datas.fixedPosition;
      }
    }
    if (parentDist) {
      distWidth = parentDist[0];
      distHeight = parentDist[1];
      if (keepRatio) {
        if (!distWidth) {
          distWidth = distHeight * ratio;
        } else if (!distHeight) {
          distHeight = distWidth / ratio;
        }
      }
    } else if (parentScale) {
      distWidth = (parentScale[0] - 1) * startOffsetWidth;
      distHeight = (parentScale[1] - 1) * startOffsetHeight;
    } else if (isPinch) {
      if (parentDistance) {
        distWidth = parentDistance;
        distHeight = parentDistance * startOffsetHeight / startOffsetWidth;
      }
    } else {
      var dist = getDragDist({
        datas,
        distX,
        distY
      });
      distWidth = sizeDirection[0] * dist[0];
      distHeight = sizeDirection[1] * dist[1];
      if (keepRatio && startOffsetWidth && startOffsetHeight) {
        var rad = getRad$1([0, 0], dist);
        var standardRad = getRad$1([0, 0], sizeDirection);
        var size = getDistSize([distWidth, distHeight]);
        var signSize = Math.cos(rad - standardRad) * size;
        if (!sizeDirection[0]) {
          distHeight = signSize;
          distWidth = distHeight / ratio;
        } else if (!sizeDirection[1]) {
          distWidth = signSize;
          distHeight = distWidth * ratio;
        } else {
          var startWidthSize = sizeDirection[0] * 2 * startOffsetWidth;
          var startHeightSize = sizeDirection[1] * 2 * startOffsetHeight;
          var distSize = getDistSize([startWidthSize + dist[0], startHeightSize + dist[1]]) - getDistSize([startWidthSize, startHeightSize]);
          var ratioRad = getRad$1([0, 0], [ratio, 1]);
          distWidth = Math.cos(ratioRad) * distSize;
          distHeight = Math.sin(ratioRad) * distSize;
        }
      } else if (!keepRatio) {
        var nextDirection = __spreadArrays$2(direction2);
        if (!startOffsetWidth) {
          if (dist[0] < 0) {
            nextDirection[0] = -1;
          } else if (dist[0] > 0) {
            nextDirection[0] = 1;
          }
        }
        if (!startOffsetHeight) {
          if (dist[1] < 0) {
            nextDirection[1] = -1;
          } else if (dist[1] > 0) {
            nextDirection[1] = 1;
          }
        }
        direction2 = nextDirection;
        sizeDirection = nextDirection;
        distWidth = sizeDirection[0] * dist[0];
        distHeight = sizeDirection[1] * dist[1];
      }
    }
    var nextWidth = sizeDirection[0] || keepRatio ? Math.max(startOffsetWidth + distWidth, TINY_NUM) : startOffsetWidth;
    var nextHeight = sizeDirection[1] || keepRatio ? Math.max(startOffsetHeight + distHeight, TINY_NUM) : startOffsetHeight;
    if (keepRatio && startOffsetWidth && startOffsetHeight) {
      if (isWidth) {
        nextHeight = nextWidth / ratio;
      } else {
        nextWidth = nextHeight * ratio;
      }
    }
    var snapDist = [0, 0];
    if (!isPinch) {
      snapDist = checkSnapResize(moveable, nextWidth, nextHeight, direction2, fixedPosition, isRequest, datas);
    }
    if (parentDist) {
      !parentDist[0] && (snapDist[0] = 0);
      !parentDist[1] && (snapDist[1] = 0);
    }
    if (keepRatio) {
      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {
        if (Math.abs(snapDist[0]) > Math.abs(snapDist[1])) {
          snapDist[1] = 0;
        } else {
          snapDist[0] = 0;
        }
      }
      var isNoSnap = !snapDist[0] && !snapDist[1];
      if (isNoSnap) {
        if (isWidth) {
          nextWidth = throttle$3(nextWidth, throttleResize);
        } else {
          nextHeight = throttle$3(nextHeight, throttleResize);
        }
      }
      if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {
        nextWidth += snapDist[0];
        nextHeight = nextWidth / ratio;
      } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {
        nextHeight += snapDist[1];
        nextWidth = nextHeight * ratio;
      }
    } else {
      if (startOffsetWidth + distWidth < -snapThreshold) {
        snapDist[0] = 0;
      }
      if (startOffsetWidth + distHeight < -snapThreshold) {
        snapDist[1] = 0;
      }
      nextWidth += snapDist[0];
      nextHeight += snapDist[1];
      if (!snapDist[0]) {
        nextWidth = throttle$3(nextWidth, throttleResize);
      }
      if (!snapDist[1]) {
        nextHeight = throttle$3(nextHeight, throttleResize);
      }
    }
    _a2 = calculateBoundSize([nextWidth, nextHeight], minSize, maxSize, keepRatio), nextWidth = _a2[0], nextHeight = _a2[1];
    nextWidth = Math.round(nextWidth);
    nextHeight = Math.round(nextHeight);
    distWidth = nextWidth - startOffsetWidth;
    distHeight = nextHeight - startOffsetHeight;
    var delta = [distWidth - prevWidth, distHeight - prevHeight];
    datas.prevWidth = distWidth;
    datas.prevHeight = distHeight;
    var inverseDelta = getResizeDist(moveable, nextWidth, nextHeight, fixedDirection, fixedPosition, transformOrigin2);
    if (!parentMoveable && delta.every(function(num) {
      return !num;
    }) && inverseDelta.every(function(num) {
      return !num;
    })) {
      return;
    }
    var params = fillParams(moveable, e2, {
      width: startWidth + distWidth,
      height: startHeight + distHeight,
      offsetWidth: nextWidth,
      offsetHeight: nextHeight,
      direction: direction2,
      dist: [distWidth, distHeight],
      delta,
      isPinch: !!isPinch,
      drag: Draggable.drag(moveable, setCustomDrag(e2, moveable.state, inverseDelta, !!isPinch, false))
    });
    triggerEvent(moveable, "onResize", params);
    return params;
  },
  dragControlAfter: function(moveable, e2) {
    var datas = e2.datas;
    var isResize = datas.isResize, startOffsetWidth = datas.startOffsetWidth, startOffsetHeight = datas.startOffsetHeight, prevWidth = datas.prevWidth, prevHeight = datas.prevHeight;
    if (!isResize) {
      return;
    }
    var _a2 = moveable.state, width = _a2.width, height = _a2.height;
    var errorWidth = width - (startOffsetWidth + prevWidth);
    var errorHeight = height - (startOffsetHeight + prevHeight);
    var isErrorWidth = Math.abs(errorWidth) > 3;
    var isErrorHeight = Math.abs(errorHeight) > 3;
    if (isErrorWidth) {
      datas.startWidth += errorWidth;
      datas.startOffsetWidth += errorWidth;
      datas.prevWidth += errorWidth;
    }
    if (isErrorHeight) {
      datas.startHeight += errorHeight;
      datas.startOffsetHeight += errorHeight;
      datas.prevHeight += errorHeight;
    }
    if (isErrorWidth || isErrorHeight) {
      this.dragControl(moveable, e2);
      return true;
    }
  },
  dragControlEnd: function(moveable, e2) {
    var datas = e2.datas, isDrag2 = e2.isDrag;
    if (!datas.isResize) {
      return false;
    }
    datas.isResize = false;
    var params = fillEndParams(moveable, e2, {});
    triggerEvent(moveable, "onResizeEnd", params);
    return isDrag2;
  },
  dragGroupControlCondition: directionCondition,
  dragGroupControlStart: function(moveable, e2) {
    var datas = e2.datas;
    var params = this.dragControlStart(moveable, e2);
    if (!params) {
      return false;
    }
    var originalEvents = fillChildEvents(moveable, "resizable", e2);
    function setDist(child, ev) {
      var fixedDirection = datas.fixedDirection;
      var fixedPosition = datas.fixedPosition;
      var pos = getAbsolutePosition(child, fixedDirection);
      var _a2 = calculate(createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1], 3), originalX = _a2[0], originalY = _a2[1];
      ev.datas.originalX = originalX;
      ev.datas.originalY = originalY;
      return ev;
    }
    var events2 = triggerChildAbles(moveable, this, "dragControlStart", e2, function(child, ev) {
      return setDist(child, ev);
    });
    var nextParams = __assign$7(__assign$7({}, params), {
      targets: moveable.props.targets,
      events: events2,
      setFixedDirection: function(fixedDirection) {
        params.setFixedDirection(fixedDirection);
        events2.forEach(function(ev, i) {
          ev.setFixedDirection(fixedDirection);
          setDist(moveable.moveables[i], originalEvents[i]);
        });
      }
    });
    var result = triggerEvent(moveable, "onResizeGroupStart", nextParams);
    datas.isResize = result !== false;
    return datas.isResize ? params : false;
  },
  dragGroupControl: function(moveable, e2) {
    var datas = e2.datas;
    if (!datas.isResize) {
      return;
    }
    var params = this.dragControl(moveable, e2);
    if (!params) {
      return;
    }
    var offsetWidth = params.offsetWidth, offsetHeight = params.offsetHeight, dist = params.dist;
    var keepRatio = moveable.props.keepRatio;
    var parentScale = [offsetWidth / (offsetWidth - dist[0]), offsetHeight / (offsetHeight - dist[1])];
    var fixedPosition = datas.fixedPosition;
    var events2 = triggerChildAbles(moveable, this, "dragControl", e2, function(_, ev) {
      var _a2 = calculate(createRotateMatrix(moveable.rotation / 180 * Math.PI, 3), [ev.datas.originalX * parentScale[0], ev.datas.originalY * parentScale[1], 1], 3), clientX = _a2[0], clientY = _a2[1];
      return __assign$7(__assign$7({}, ev), {
        parentDist: null,
        parentScale,
        dragClient: plus(fixedPosition, [clientX, clientY]),
        parentKeepRatio: keepRatio
      });
    });
    var nextParams = __assign$7({
      targets: moveable.props.targets,
      events: events2
    }, params);
    triggerEvent(moveable, "onResizeGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function(moveable, e2) {
    var isDrag2 = e2.isDrag, datas = e2.datas;
    if (!datas.isResize) {
      return;
    }
    this.dragControlEnd(moveable, e2);
    triggerChildAbles(moveable, this, "dragControlEnd", e2);
    var nextParams = fillEndParams(moveable, e2, {
      targets: moveable.props.targets
    });
    triggerEvent(moveable, "onResizeGroupEnd", nextParams);
    return isDrag2;
  },
  request: function(moveable) {
    var datas = {};
    var distWidth = 0;
    var distHeight = 0;
    var rect = moveable.getRect();
    return {
      isControl: true,
      requestStart: function(e2) {
        return {
          datas,
          parentDirection: e2.direction || [1, 1]
        };
      },
      request: function(e2) {
        if ("offsetWidth" in e2) {
          distWidth = e2.offsetWidth - rect.offsetWidth;
        } else if ("deltaWidth" in e2) {
          distWidth += e2.deltaWidth;
        }
        if ("offsetHeight" in e2) {
          distHeight = e2.offsetHeight - rect.offsetHeight;
        } else if ("deltaHeight" in e2) {
          distHeight += e2.deltaHeight;
        }
        return {
          datas,
          parentDist: [distWidth, distHeight]
        };
      },
      requestEnd: function() {
        return {
          datas,
          isDrag: true
        };
      }
    };
  }
};
var Scalable = {
  name: "scalable",
  ableGroup: "size",
  canPinch: true,
  props: {
    scalable: Boolean,
    throttleScale: Number,
    renderDirections: String,
    keepRatio: Boolean
  },
  events: {
    onScaleStart: "scaleStart",
    onScale: "scale",
    onScaleEnd: "scaleEnd",
    onScaleGroupStart: "scaleGroupStart",
    onScaleGroup: "scaleGroup",
    onScaleGroupEnd: "scaleGroupEnd"
  },
  render: function(moveable, React) {
    var _a2 = moveable.props, resizable = _a2.resizable, scalable = _a2.scalable, edge = _a2.edge;
    if (!resizable && scalable) {
      if (edge) {
        return renderDiagonalDirections(moveable, React);
      }
      return renderAllDirections(moveable, React);
    }
  },
  dragControlCondition: directionCondition,
  dragControlStart: function(moveable, e2) {
    var datas = e2.datas, isPinch = e2.isPinch, inputEvent = e2.inputEvent, parentDirection = e2.parentDirection;
    var direction2 = parentDirection || (isPinch ? [0, 0] : getDirection(inputEvent.target));
    var _a2 = moveable.state, width = _a2.width, height = _a2.height, targetTransform = _a2.targetTransform, target = _a2.target, pos1 = _a2.pos1, pos2 = _a2.pos2, pos4 = _a2.pos4;
    if (!direction2 || !target) {
      return false;
    }
    if (!isPinch) {
      setDragStart(moveable, e2);
    }
    datas.datas = {};
    datas.transform = targetTransform;
    datas.prevDist = [1, 1];
    datas.direction = direction2;
    datas.width = width;
    datas.height = height;
    datas.startValue = [1, 1];
    var scaleWidth = getDist$2(pos1, pos2);
    var scaleHeight = getDist$2(pos2, pos4);
    var isWidth = !direction2[0] && !direction2[1] || direction2[0] || !direction2[1];
    datas.scaleWidth = scaleWidth;
    datas.scaleHeight = scaleHeight;
    datas.scaleXRatio = scaleWidth / width;
    datas.scaleYRatio = scaleHeight / height;
    setDefaultTransformIndex(e2, "scale");
    datas.isWidth = isWidth;
    function setRatio(ratio) {
      datas.ratio = ratio && isFinite(ratio) ? ratio : 0;
    }
    function setFixedDirection(fixedDirection) {
      datas.fixedDirection = fixedDirection;
      datas.fixedPosition = getAbsolutePosition(moveable, fixedDirection);
    }
    setRatio(getDist$2(pos1, pos2) / getDist$2(pos2, pos4));
    setFixedDirection([-direction2[0], -direction2[1]]);
    var params = fillParams(moveable, e2, __assign$7(__assign$7({
      direction: direction2,
      set: function(scale) {
        datas.startValue = scale;
      },
      setRatio,
      setFixedDirection
    }, fillTransformStartEvent(e2)), {
      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e2))
    }));
    var result = triggerEvent(moveable, "onScaleStart", params);
    if (result !== false) {
      datas.isScale = true;
      moveable.state.snapRenderInfo = {
        request: e2.isRequest,
        direction: direction2
      };
    }
    return datas.isScale ? params : false;
  },
  dragControl: function(moveable, e2) {
    resolveTransformEvent(e2, "scale");
    var datas = e2.datas, distX = e2.distX, distY = e2.distY, parentScale = e2.parentScale, parentDistance = e2.parentDistance, parentKeepRatio = e2.parentKeepRatio, parentFlag = e2.parentFlag, isPinch = e2.isPinch, dragClient = e2.dragClient, parentDist = e2.parentDist, isRequest = e2.isRequest;
    var prevDist = datas.prevDist, direction2 = datas.direction, width = datas.width, height = datas.height, isScale = datas.isScale, startValue = datas.startValue, isWidth = datas.isWidth, ratio = datas.ratio, fixedDirection = datas.fixedDirection, scaleXRatio = datas.scaleXRatio, scaleYRatio = datas.scaleYRatio;
    if (!isScale) {
      return false;
    }
    var _a2 = moveable.props, throttleScale = _a2.throttleScale, parentMoveable = _a2.parentMoveable;
    var sizeDirection = direction2;
    if (!direction2[0] && !direction2[1]) {
      sizeDirection = [1, 1];
    }
    var keepRatio = ratio && (moveable.props.keepRatio || parentKeepRatio);
    var state = moveable.state;
    var scaleX = 1;
    var scaleY = 1;
    var fixedPosition = dragClient;
    if (!dragClient) {
      if (!parentFlag && isPinch) {
        fixedPosition = getAbsolutePosition(moveable, [0, 0]);
      } else {
        fixedPosition = datas.fixedPosition;
      }
    }
    if (parentDist) {
      scaleX = (width + parentDist[0]) / width;
      scaleY = (height + parentDist[1]) / height;
    } else if (parentScale) {
      scaleX = parentScale[0];
      scaleY = parentScale[1];
    } else if (isPinch) {
      if (parentDistance) {
        scaleX = (width + parentDistance) / width;
        scaleY = (height + parentDistance * height / width) / height;
      }
    } else {
      var dragDist = getDragDist({
        datas,
        distX,
        distY
      });
      var distScaleWidth = sizeDirection[0] * dragDist[0] * scaleXRatio;
      var distScaleHeight = sizeDirection[1] * dragDist[1] * scaleYRatio;
      if (keepRatio && width && height) {
        if (!sizeDirection[0]) {
          distScaleWidth = distScaleHeight * ratio;
        } else if (!sizeDirection[1]) {
          distScaleHeight = distScaleWidth / ratio;
        } else {
          var size = getDistSize([distScaleWidth, distScaleHeight]);
          var dragRad = getRad$1([0, 0], dragDist);
          var standardRad = getRad$1([0, 0], sizeDirection);
          var signSize = Math.cos(dragRad - standardRad) * size;
          var ratioRad = getRad$1([0, 0], [ratio, 1]);
          distScaleWidth = Math.cos(ratioRad) * signSize;
          distScaleHeight = Math.sin(ratioRad) * signSize;
        }
      }
      scaleX = (width + distScaleWidth / scaleXRatio) / width;
      scaleY = (height + distScaleHeight / scaleYRatio) / height;
    }
    scaleX = sizeDirection[0] || keepRatio ? scaleX * startValue[0] : startValue[0];
    scaleY = sizeDirection[1] || keepRatio ? scaleY * startValue[1] : startValue[1];
    if (scaleX === 0) {
      scaleX = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;
    }
    if (scaleY === 0) {
      scaleY = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;
    }
    var dist = [scaleX / startValue[0], scaleY / startValue[1]];
    var scale = [scaleX, scaleY];
    if (!isPinch && moveable.props.groupable) {
      var snapRenderInfo = state.snapRenderInfo || {};
      var stateDirection = snapRenderInfo.direction;
      if (isArray$1(stateDirection) && (stateDirection[0] || stateDirection[1])) {
        state.snapRenderInfo = {
          direction: direction2,
          request: e2.isRequest
        };
      }
    }
    var snapDist = [0, 0];
    if (!isPinch) {
      snapDist = checkSnapScale(moveable, dist, direction2, isRequest, datas);
    }
    if (keepRatio) {
      if (sizeDirection[0] && sizeDirection[1] && snapDist[0] && snapDist[1]) {
        if (Math.abs(snapDist[0] * width) > Math.abs(snapDist[1] * height)) {
          snapDist[1] = 0;
        } else {
          snapDist[0] = 0;
        }
      }
      var isNoSnap = !snapDist[0] && !snapDist[1];
      if (isNoSnap) {
        if (isWidth) {
          dist[0] = throttle$3(dist[0] * startValue[0], throttleScale) / startValue[0];
        } else {
          dist[1] = throttle$3(dist[1] * startValue[1], throttleScale) / startValue[1];
        }
      }
      if (sizeDirection[0] && !sizeDirection[1] || snapDist[0] && !snapDist[1] || isNoSnap && isWidth) {
        dist[0] += snapDist[0];
        var snapHeight = width * dist[0] * startValue[0] / ratio;
        dist[1] = snapHeight / height / startValue[1];
      } else if (!sizeDirection[0] && sizeDirection[1] || !snapDist[0] && snapDist[1] || isNoSnap && !isWidth) {
        dist[1] += snapDist[1];
        var snapWidth = height * dist[1] * startValue[1] * ratio;
        dist[0] = snapWidth / width / startValue[0];
      }
    } else {
      dist[0] += snapDist[0];
      dist[1] += snapDist[1];
      if (!snapDist[0]) {
        dist[0] = throttle$3(dist[0] * startValue[0], throttleScale) / startValue[0];
      }
      if (!snapDist[1]) {
        dist[1] = throttle$3(dist[1] * startValue[1], throttleScale) / startValue[1];
      }
    }
    if (dist[0] === 0) {
      dist[0] = (prevDist[0] > 0 ? 1 : -1) * MIN_SCALE;
    }
    if (dist[1] === 0) {
      dist[1] = (prevDist[1] > 0 ? 1 : -1) * MIN_SCALE;
    }
    var delta = [dist[0] / prevDist[0], dist[1] / prevDist[1]];
    scale = multiply2(dist, startValue);
    var inverseDist = getScaleDist(moveable, dist, fixedDirection, fixedPosition, datas);
    var inverseDelta = minus(inverseDist, datas.prevInverseDist || [0, 0]);
    datas.prevDist = dist;
    datas.prevInverseDist = inverseDist;
    if (scaleX === prevDist[0] && scaleY === prevDist[1] && inverseDelta.every(function(num) {
      return !num;
    }) && !parentMoveable) {
      return false;
    }
    var nextTransform = convertTransformFormat(datas, "scale(" + scale.join(", ") + ")", "scale(" + dist.join(", ") + ")");
    var params = fillParams(moveable, e2, __assign$7({
      offsetWidth: width,
      offsetHeight: height,
      direction: direction2,
      scale,
      dist,
      delta,
      isPinch: !!isPinch
    }, fillTransformEvent(moveable, nextTransform, inverseDelta, isPinch, e2)));
    triggerEvent(moveable, "onScale", params);
    return params;
  },
  dragControlEnd: function(moveable, e2) {
    var datas = e2.datas, isDrag2 = e2.isDrag;
    if (!datas.isScale) {
      return false;
    }
    datas.isScale = false;
    triggerEvent(moveable, "onScaleEnd", fillEndParams(moveable, e2, {}));
    return isDrag2;
  },
  dragGroupControlCondition: directionCondition,
  dragGroupControlStart: function(moveable, e2) {
    var datas = e2.datas;
    var params = this.dragControlStart(moveable, e2);
    if (!params) {
      return false;
    }
    var originalEvents = fillChildEvents(moveable, "resizable", e2);
    function setDist(child, ev) {
      var fixedDirection = datas.fixedDirection;
      var fixedPosition = datas.fixedPosition;
      var pos = getAbsolutePosition(child, fixedDirection);
      var _a2 = calculate(createRotateMatrix(-moveable.rotation / 180 * Math.PI, 3), [pos[0] - fixedPosition[0], pos[1] - fixedPosition[1], 1], 3), originalX = _a2[0], originalY = _a2[1];
      ev.datas.originalX = originalX;
      ev.datas.originalY = originalY;
      return ev;
    }
    datas.moveableScale = moveable.scale;
    var events2 = triggerChildAbles(moveable, this, "dragControlStart", e2, function(child, ev) {
      return setDist(child, ev);
    });
    var nextParams = __assign$7(__assign$7({}, params), {
      targets: moveable.props.targets,
      events: events2,
      setFixedDirection: function(fixedDirection) {
        params.setFixedDirection(fixedDirection);
        events2.forEach(function(ev, i) {
          ev.setFixedDirection(fixedDirection);
          setDist(moveable.moveables[i], originalEvents[i]);
        });
      }
    });
    var result = triggerEvent(moveable, "onScaleGroupStart", nextParams);
    datas.isScale = result !== false;
    return datas.isScale ? nextParams : false;
  },
  dragGroupControl: function(moveable, e2) {
    var datas = e2.datas;
    if (!datas.isScale) {
      return;
    }
    var params = this.dragControl(moveable, e2);
    if (!params) {
      return;
    }
    var moveableScale = datas.moveableScale;
    moveable.scale = [params.scale[0] * moveableScale[0], params.scale[1] * moveableScale[1]];
    var keepRatio = moveable.props.keepRatio;
    var dist = params.dist, scale = params.scale;
    var fixedPosition = datas.fixedPosition;
    var events2 = triggerChildAbles(moveable, this, "dragControl", e2, function(_, ev) {
      var _a2 = calculate(createRotateMatrix(moveable.rotation / 180 * Math.PI, 3), [ev.datas.originalX * dist[0], ev.datas.originalY * dist[1], 1], 3), clientX = _a2[0], clientY = _a2[1];
      return __assign$7(__assign$7({}, ev), {
        parentDist: null,
        parentScale: scale,
        parentKeepRatio: keepRatio,
        dragClient: plus(fixedPosition, [clientX, clientY])
      });
    });
    var nextParams = __assign$7({
      targets: moveable.props.targets,
      events: events2
    }, params);
    triggerEvent(moveable, "onScaleGroup", nextParams);
    return nextParams;
  },
  dragGroupControlEnd: function(moveable, e2) {
    var isDrag2 = e2.isDrag, datas = e2.datas;
    if (!datas.isScale) {
      return;
    }
    this.dragControlEnd(moveable, e2);
    triggerChildAbles(moveable, this, "dragControlEnd", e2);
    var nextParams = fillEndParams(moveable, e2, {
      targets: moveable.props.targets
    });
    triggerEvent(moveable, "onScaleGroupEnd", nextParams);
    return isDrag2;
  },
  request: function() {
    var datas = {};
    var distWidth = 0;
    var distHeight = 0;
    return {
      isControl: true,
      requestStart: function(e2) {
        return {
          datas,
          parentDirection: e2.direction || [1, 1]
        };
      },
      request: function(e2) {
        distWidth += e2.deltaWidth;
        distHeight += e2.deltaHeight;
        return {
          datas,
          parentDist: [distWidth, distHeight]
        };
      },
      requestEnd: function() {
        return {
          datas,
          isDrag: true
        };
      }
    };
  }
};
function getMiddleLinePos(pos1, pos2) {
  return pos1.map(function(pos, i) {
    return dot$1(pos, pos2[i], 1, 2);
  });
}
function getTriangleRad(pos1, pos2, pos3) {
  var rad1 = getRad$1(pos1, pos2);
  var rad2 = getRad$1(pos1, pos3);
  var rad = rad2 - rad1;
  return rad >= 0 ? rad : rad + 2 * Math.PI;
}
function isValidPos(poses1, poses2) {
  var rad1 = getTriangleRad(poses1[0], poses1[1], poses1[2]);
  var rad2 = getTriangleRad(poses2[0], poses2[1], poses2[2]);
  var pi = Math.PI;
  if (rad1 >= pi && rad2 <= pi || rad1 <= pi && rad2 >= pi) {
    return false;
  }
  return true;
}
var Warpable = {
  name: "warpable",
  ableGroup: "size",
  props: {
    warpable: Boolean,
    renderDirections: Array
  },
  events: {
    onWarpStart: "warpStart",
    onWarp: "warp",
    onWarpEnd: "warpEnd"
  },
  render: function(moveable, React) {
    var _a2 = moveable.props, resizable = _a2.resizable, scalable = _a2.scalable, warpable = _a2.warpable, zoom = _a2.zoom;
    if (resizable || scalable || !warpable) {
      return [];
    }
    var _b = moveable.state, pos1 = _b.pos1, pos2 = _b.pos2, pos3 = _b.pos3, pos4 = _b.pos4;
    var linePosFrom1 = getMiddleLinePos(pos1, pos2);
    var linePosFrom2 = getMiddleLinePos(pos2, pos1);
    var linePosFrom3 = getMiddleLinePos(pos1, pos3);
    var linePosFrom4 = getMiddleLinePos(pos3, pos1);
    var linePosTo1 = getMiddleLinePos(pos3, pos4);
    var linePosTo2 = getMiddleLinePos(pos4, pos3);
    var linePosTo3 = getMiddleLinePos(pos2, pos4);
    var linePosTo4 = getMiddleLinePos(pos4, pos2);
    return __spreadArrays$2([React.createElement("div", {
      className: prefix$2("line"),
      key: "middeLine1",
      style: getLineStyle(linePosFrom1, linePosTo1, zoom)
    }), React.createElement("div", {
      className: prefix$2("line"),
      key: "middeLine2",
      style: getLineStyle(linePosFrom2, linePosTo2, zoom)
    }), React.createElement("div", {
      className: prefix$2("line"),
      key: "middeLine3",
      style: getLineStyle(linePosFrom3, linePosTo3, zoom)
    }), React.createElement("div", {
      className: prefix$2("line"),
      key: "middeLine4",
      style: getLineStyle(linePosFrom4, linePosTo4, zoom)
    })], renderAllDirections(moveable, React));
  },
  dragControlCondition: function(moveable, e2) {
    if (e2.isRequest) {
      return false;
    }
    return hasClass(e2.inputEvent.target, prefix$2("direction"));
  },
  dragControlStart: function(moveable, e2) {
    var datas = e2.datas, inputEvent = e2.inputEvent;
    var target = moveable.props.target;
    var inputTarget = inputEvent.target;
    var direction2 = getDirection(inputTarget);
    if (!direction2 || !target) {
      return false;
    }
    var state = moveable.state;
    var transformOrigin2 = state.transformOrigin, is3d = state.is3d, targetTransform = state.targetTransform, targetMatrix = state.targetMatrix, width = state.width, height = state.height, left = state.left, top = state.top;
    datas.datas = {};
    datas.targetTransform = targetTransform;
    datas.warpTargetMatrix = is3d ? targetMatrix : convertDimension(targetMatrix, 3, 4);
    datas.targetInverseMatrix = ignoreDimension(invert(datas.warpTargetMatrix, 4), 3, 4);
    datas.direction = direction2;
    datas.left = left;
    datas.top = top;
    datas.poses = [[0, 0], [width, 0], [0, height], [width, height]].map(function(p) {
      return minus(p, transformOrigin2);
    });
    datas.nextPoses = datas.poses.map(function(_a2) {
      var x = _a2[0], y = _a2[1];
      return calculate(datas.warpTargetMatrix, [x, y, 0, 1], 4);
    });
    datas.startValue = createIdentityMatrix(4);
    datas.prevMatrix = createIdentityMatrix(4);
    datas.absolutePoses = getAbsolutePosesByState(state);
    datas.posIndexes = getPosIndexesByDirection(direction2);
    setDragStart(moveable, e2);
    setDefaultTransformIndex(e2, "matrix3d");
    state.snapRenderInfo = {
      request: e2.isRequest,
      direction: direction2
    };
    var params = fillParams(moveable, e2, __assign$7({
      set: function(matrix2) {
        datas.startValue = matrix2;
      }
    }, fillTransformStartEvent(e2)));
    var result = triggerEvent(moveable, "onWarpStart", params);
    if (result !== false) {
      datas.isWarp = true;
    }
    return datas.isWarp;
  },
  dragControl: function(moveable, e2) {
    var datas = e2.datas, isRequest = e2.isRequest;
    var distX = e2.distX, distY = e2.distY;
    var targetInverseMatrix = datas.targetInverseMatrix, prevMatrix = datas.prevMatrix, isWarp = datas.isWarp, startValue = datas.startValue, poses = datas.poses, posIndexes = datas.posIndexes, absolutePoses = datas.absolutePoses;
    if (!isWarp) {
      return false;
    }
    resolveTransformEvent(e2, "matrix3d");
    if (hasGuidelines(moveable, "warpable")) {
      var selectedPoses = posIndexes.map(function(index2) {
        return absolutePoses[index2];
      });
      if (selectedPoses.length > 1) {
        selectedPoses.push([(selectedPoses[0][0] + selectedPoses[1][0]) / 2, (selectedPoses[0][1] + selectedPoses[1][1]) / 2]);
      }
      var _a2 = checkMoveableSnapBounds(moveable, isRequest, selectedPoses.map(function(pos) {
        return [pos[0] + distX, pos[1] + distY];
      })), horizontalSnapInfo = _a2.horizontal, verticalSnapInfo = _a2.vertical;
      distY -= horizontalSnapInfo.offset;
      distX -= verticalSnapInfo.offset;
    }
    var dist = getDragDist({
      datas,
      distX,
      distY
    }, true);
    var nextPoses = datas.nextPoses.slice();
    posIndexes.forEach(function(index2) {
      nextPoses[index2] = plus(nextPoses[index2], dist);
    });
    if (!NEARBY_POS.every(function(nearByPoses) {
      return isValidPos(nearByPoses.map(function(i) {
        return poses[i];
      }), nearByPoses.map(function(i) {
        return nextPoses[i];
      }));
    })) {
      return false;
    }
    var h2 = createWarpMatrix(poses[0], poses[2], poses[1], poses[3], nextPoses[0], nextPoses[2], nextPoses[1], nextPoses[3]);
    if (!h2.length) {
      return false;
    }
    var afterMatrix = multiply(targetInverseMatrix, h2, 4);
    var matrix2 = getTransfromMatrix(datas, afterMatrix, true);
    var delta = multiply(invert(prevMatrix, 4), matrix2, 4);
    datas.prevMatrix = matrix2;
    var totalMatrix = multiply(startValue, matrix2, 4);
    var nextTransform = convertTransformFormat(datas, "matrix3d(" + totalMatrix.join(", ") + ")", "matrix3d(" + matrix2.join(", ") + ")");
    fillOriginalTransform(e2, nextTransform);
    triggerEvent(moveable, "onWarp", fillParams(moveable, e2, {
      delta,
      matrix: totalMatrix,
      dist: matrix2,
      multiply,
      transform: nextTransform
    }));
    return true;
  },
  dragControlEnd: function(moveable, e2) {
    var datas = e2.datas, isDrag2 = e2.isDrag;
    if (!datas.isWarp) {
      return false;
    }
    datas.isWarp = false;
    triggerEvent(moveable, "onWarpEnd", fillEndParams(moveable, e2, {}));
    return isDrag2;
  }
};
var AREA_PIECES = /* @__PURE__ */ prefix$2("area-pieces");
var AREA_PIECE = /* @__PURE__ */ prefix$2("area-piece");
var AVOID = /* @__PURE__ */ prefix$2("avoid");
function restoreStyle(moveable) {
  var el = moveable.areaElement;
  var _a2 = moveable.state, width = _a2.width, height = _a2.height;
  removeClass(el, AVOID);
  el.style.cssText += "left: 0px; top: 0px; width: " + width + "px; height: " + height + "px";
}
function renderPieces(React) {
  return React.createElement("div", {
    key: "area_pieces",
    className: AREA_PIECES
  }, React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }), React.createElement("div", {
    className: AREA_PIECE
  }));
}
var DragArea = {
  name: "dragArea",
  props: {
    dragArea: Boolean,
    passDragArea: Boolean
  },
  events: {
    onClick: "click",
    onClickGroup: "clickGroup"
  },
  render: function(moveable, React) {
    var _a2 = moveable.props, target = _a2.target, dragArea = _a2.dragArea, groupable = _a2.groupable, passDragArea = _a2.passDragArea;
    var _b = moveable.state, width = _b.width, height = _b.height, renderPoses = _b.renderPoses;
    var className = passDragArea ? prefix$2("area", "pass") : prefix$2("area");
    if (groupable) {
      return [React.createElement("div", {
        key: "area",
        ref: ref(moveable, "areaElement"),
        className
      }), renderPieces(React)];
    }
    if (!target || !dragArea) {
      return [];
    }
    var h2 = createWarpMatrix([0, 0], [width, 0], [0, height], [width, height], renderPoses[0], renderPoses[1], renderPoses[2], renderPoses[3]);
    var transform2 = h2.length ? makeMatrixCSS(h2, true) : "none";
    return [React.createElement("div", {
      key: "area",
      ref: ref(moveable, "areaElement"),
      className,
      style: {
        top: "0px",
        left: "0px",
        width: width + "px",
        height: height + "px",
        transformOrigin: "0 0",
        transform: transform2
      }
    }), renderPieces(React)];
  },
  dragStart: function(moveable, _a2) {
    var datas = _a2.datas, clientX = _a2.clientX, clientY = _a2.clientY, inputEvent = _a2.inputEvent;
    if (!inputEvent) {
      return false;
    }
    datas.isDragArea = false;
    var areaElement = moveable.areaElement;
    var state = moveable.state;
    var moveableClientRect = state.moveableClientRect, renderPoses = state.renderPoses, rootMatrix = state.rootMatrix, is3d = state.is3d;
    var left = moveableClientRect.left, top = moveableClientRect.top;
    var _b = getRect$2(renderPoses), relativeLeft = _b.left, relativeTop = _b.top, width = _b.width, height = _b.height;
    var n = is3d ? 4 : 3;
    var _c = calculateInversePosition(rootMatrix, [clientX - left, clientY - top], n), posX = _c[0], posY = _c[1];
    posX -= relativeLeft;
    posY -= relativeTop;
    var rects = [{
      left: relativeLeft,
      top: relativeTop,
      width,
      height: posY - 10
    }, {
      left: relativeLeft,
      top: relativeTop,
      width: posX - 10,
      height
    }, {
      left: relativeLeft,
      top: relativeTop + posY + 10,
      width,
      height: height - posY - 10
    }, {
      left: relativeLeft + posX + 10,
      top: relativeTop,
      width: width - posX - 10,
      height
    }];
    var children = [].slice.call(areaElement.nextElementSibling.children);
    rects.forEach(function(rect, i) {
      children[i].style.cssText = "left: " + rect.left + "px;top: " + rect.top + "px; width: " + rect.width + "px; height: " + rect.height + "px;";
    });
    addClass(areaElement, AVOID);
    state.disableNativeEvent = true;
    return;
  },
  drag: function(moveable, _a2) {
    var datas = _a2.datas, inputEvent = _a2.inputEvent;
    this.enableNativeEvent(moveable);
    if (!inputEvent) {
      return false;
    }
    if (!datas.isDragArea) {
      datas.isDragArea = true;
      restoreStyle(moveable);
    }
  },
  dragEnd: function(moveable, e2) {
    this.enableNativeEvent(moveable);
    var inputEvent = e2.inputEvent, datas = e2.datas;
    if (!inputEvent) {
      return false;
    }
    if (!datas.isDragArea) {
      restoreStyle(moveable);
    }
  },
  dragGroupStart: function(moveable, e2) {
    return this.dragStart(moveable, e2);
  },
  dragGroup: function(moveable, e2) {
    return this.drag(moveable, e2);
  },
  dragGroupEnd: function(moveable, e2) {
    return this.dragEnd(moveable, e2);
  },
  unset: function(moveable) {
    restoreStyle(moveable);
    moveable.state.disableNativeEvent = false;
  },
  enableNativeEvent: function(moveable) {
    var state = moveable.state;
    if (state.disableNativeEvent) {
      requestAnimationFrame(function() {
        state.disableNativeEvent = false;
      });
    }
  }
};
var Origin = makeAble("origin", {
  render: function(moveable, React) {
    var zoom = moveable.props.zoom;
    var _a2 = moveable.state, beforeOrigin = _a2.beforeOrigin, rotation = _a2.rotation;
    return [React.createElement("div", {
      className: prefix$2("control", "origin"),
      style: getControlTransform(rotation, zoom, beforeOrigin),
      key: "beforeOrigin"
    })];
  }
});
function getDefaultScrollPosition(e2) {
  var scrollContainer = e2.scrollContainer;
  return [scrollContainer.scrollLeft, scrollContainer.scrollTop];
}
var Scrollable = {
  name: "scrollable",
  canPinch: true,
  props: {
    scrollable: Boolean,
    scrollContainer: Object,
    scrollThreshold: Number,
    getScrollPosition: Function
  },
  events: {
    onScroll: "scroll",
    onScrollGroup: "scrollGroup"
  },
  dragStart: function(moveable, e2) {
    var props2 = moveable.props;
    var _a2 = props2.scrollContainer, scrollContainer = _a2 === void 0 ? moveable.getContainer() : _a2;
    var dragScroll = new DragScroll$1();
    var scrollContainerElement = getRefTarget(scrollContainer, true);
    e2.datas.dragScroll = dragScroll;
    var gestoName = e2.isControl ? "controlGesto" : "targetGesto";
    var targets = e2.targets;
    dragScroll.on("scroll", function(_a3) {
      var container = _a3.container, direction2 = _a3.direction;
      var params = fillParams(moveable, e2, {
        scrollContainer: container,
        direction: direction2
      });
      var eventName = targets ? "onScrollGroup" : "onScroll";
      if (targets) {
        params.targets = targets;
      }
      triggerEvent(moveable, eventName, params);
    }).on("move", function(_a3) {
      var offsetX = _a3.offsetX, offsetY = _a3.offsetY;
      moveable[gestoName].scrollBy(offsetX, offsetY, e2.inputEvent, false);
    });
    dragScroll.dragStart(e2, {
      container: scrollContainerElement
    });
  },
  checkScroll: function(moveable, e2) {
    var dragScroll = e2.datas.dragScroll;
    if (!dragScroll) {
      return;
    }
    var _a2 = moveable.props, _b = _a2.scrollContainer, scrollContainer = _b === void 0 ? moveable.getContainer() : _b, _c = _a2.scrollThreshold, scrollThreshold = _c === void 0 ? 0 : _c, _d = _a2.getScrollPosition, getScrollPosition = _d === void 0 ? getDefaultScrollPosition : _d;
    dragScroll.drag(e2, {
      container: scrollContainer,
      threshold: scrollThreshold,
      getScrollPosition: function(ev) {
        return getScrollPosition({
          scrollContainer: ev.container,
          direction: ev.direction
        });
      }
    });
    return true;
  },
  drag: function(moveable, e2) {
    return this.checkScroll(moveable, e2);
  },
  dragEnd: function(moveable, e2) {
    e2.datas.dragScroll.dragEnd();
    e2.datas.dragScroll = null;
  },
  dragControlStart: function(moveable, e2) {
    return this.dragStart(moveable, __assign$7(__assign$7({}, e2), {
      isControl: true
    }));
  },
  dragControl: function(moveable, e2) {
    return this.drag(moveable, e2);
  },
  dragControlEnd: function(moveable, e2) {
    return this.dragEnd(moveable, e2);
  },
  dragGroupStart: function(moveable, e2) {
    return this.dragStart(moveable, __assign$7(__assign$7({}, e2), {
      targets: moveable.props.targets
    }));
  },
  dragGroup: function(moveable, e2) {
    return this.drag(moveable, __assign$7(__assign$7({}, e2), {
      targets: moveable.props.targets
    }));
  },
  dragGroupEnd: function(moveable, e2) {
    return this.dragEnd(moveable, __assign$7(__assign$7({}, e2), {
      targets: moveable.props.targets
    }));
  },
  dragGroupControlStart: function(moveable, e2) {
    return this.dragStart(moveable, __assign$7(__assign$7({}, e2), {
      targets: moveable.props.targets,
      isControl: true
    }));
  },
  dragGroupContro: function(moveable, e2) {
    return this.drag(moveable, __assign$7(__assign$7({}, e2), {
      targets: moveable.props.targets
    }));
  },
  dragGroupControEnd: function(moveable, e2) {
    return this.dragEnd(moveable, __assign$7(__assign$7({}, e2), {
      targets: moveable.props.targets
    }));
  }
};
var Default = {
  name: "",
  props: {
    target: Object,
    dragTarget: Object,
    container: Object,
    portalContainer: Object,
    rootContainer: Object,
    zoom: Number,
    transformOrigin: Array,
    edge: Boolean,
    ables: Array,
    className: String,
    pinchThreshold: Number,
    pinchOutside: Boolean,
    triggerAblesSimultaneously: Boolean,
    checkInput: Boolean,
    cspNonce: String,
    translateZ: Number,
    props: Object
  },
  events: {}
};
var Padding = makeAble("padding", {
  render: function(moveable, React) {
    var props2 = moveable.props;
    if (props2.dragArea) {
      return [];
    }
    var padding = props2.padding || {};
    var _a2 = padding.left, left = _a2 === void 0 ? 0 : _a2, _b = padding.top, top = _b === void 0 ? 0 : _b, _c = padding.right, right = _c === void 0 ? 0 : _c, _d = padding.bottom, bottom = _d === void 0 ? 0 : _d;
    var _e = moveable.state, renderPoses = _e.renderPoses, pos1 = _e.pos1, pos2 = _e.pos2, pos3 = _e.pos3, pos4 = _e.pos4;
    var poses = [pos1, pos2, pos3, pos4];
    var paddingDirections = [];
    if (left > 0) {
      paddingDirections.push([0, 2]);
    }
    if (top > 0) {
      paddingDirections.push([0, 1]);
    }
    if (right > 0) {
      paddingDirections.push([1, 3]);
    }
    if (bottom > 0) {
      paddingDirections.push([2, 3]);
    }
    return paddingDirections.map(function(_a3, i) {
      var dir1 = _a3[0], dir2 = _a3[1];
      var paddingPos1 = poses[dir1];
      var paddingPos2 = poses[dir2];
      var paddingPos3 = renderPoses[dir1];
      var paddingPos4 = renderPoses[dir2];
      var h2 = createWarpMatrix([0, 0], [100, 0], [0, 100], [100, 100], paddingPos1, paddingPos2, paddingPos3, paddingPos4);
      if (!h2.length) {
        return void 0;
      }
      return React.createElement("div", {
        key: "padding" + i,
        className: prefix$2("padding"),
        style: {
          transform: makeMatrixCSS(h2, true)
        }
      });
    });
  }
});
var RADIUS_DIRECTIONS = ["nw", "ne", "se", "sw"];
function calculateRatio(values, size) {
  var sumSize = values[0] + values[1];
  var sumRatio = sumSize > size ? size / sumSize : 1;
  values[0] *= sumRatio;
  values[1] = size - values[1] * sumRatio;
  return values;
}
var HORIZONTAL_RADIUS_ORDER = [1, 2, 5, 6];
var VERTICAL_RADIUS_ORDER = [0, 3, 4, 7];
var HORIZONTAL_RADIUS_DIRECTIONS = [1, -1, -1, 1];
var VERTICAL_RADIUS_DIRECTIONS = [1, 1, -1, -1];
function getRadiusStyles(poses, controlPoses, isRelative, width, height, left, top, right, bottom) {
  if (left === void 0) {
    left = 0;
  }
  if (top === void 0) {
    top = 0;
  }
  if (right === void 0) {
    right = width;
  }
  if (bottom === void 0) {
    bottom = height;
  }
  var clipStyles = [];
  var isVertical = false;
  var raws = poses.map(function(pos, i) {
    var _a2 = controlPoses[i], horizontal = _a2.horizontal, vertical = _a2.vertical;
    if (vertical && !isVertical) {
      isVertical = true;
      clipStyles.push("/");
    }
    if (isVertical) {
      var rawPos = Math.max(0, vertical === 1 ? pos[1] - top : bottom - pos[1]);
      clipStyles.push(convertCSSSize(rawPos, height, isRelative));
      return rawPos;
    } else {
      var rawPos = Math.max(0, horizontal === 1 ? pos[0] - left : right - pos[0]);
      clipStyles.push(convertCSSSize(rawPos, width, isRelative));
      return rawPos;
    }
  });
  return {
    styles: clipStyles,
    raws
  };
}
function getRadiusRange(controlPoses) {
  var horizontalRange = [0, 0];
  var verticalRange = [0, 0];
  var length = controlPoses.length;
  for (var i = 0; i < length; ++i) {
    var clipPose = controlPoses[i];
    if (!clipPose.sub) {
      continue;
    }
    if (clipPose.horizontal) {
      if (horizontalRange[1] === 0) {
        horizontalRange[0] = i;
      }
      horizontalRange[1] = i - horizontalRange[0] + 1;
      verticalRange[0] = i + 1;
    }
    if (clipPose.vertical) {
      if (verticalRange[1] === 0) {
        verticalRange[0] = i;
      }
      verticalRange[1] = i - verticalRange[0] + 1;
    }
  }
  return {
    horizontalRange,
    verticalRange
  };
}
function getRadiusValues(values, width, height, left, top, minCounts) {
  var _a2, _b, _c, _d;
  if (minCounts === void 0) {
    minCounts = [0, 0];
  }
  var splitIndex = values.indexOf("/");
  var splitLength = (splitIndex > -1 ? values.slice(0, splitIndex) : values).length;
  var horizontalValues = values.slice(0, splitLength);
  var verticalValues = values.slice(splitLength + 1);
  var _e = horizontalValues[0], nwValue = _e === void 0 ? "0px" : _e, _f = horizontalValues[1], neValue = _f === void 0 ? nwValue : _f, _g = horizontalValues[2], seValue = _g === void 0 ? nwValue : _g, _h = horizontalValues[3], swValue = _h === void 0 ? neValue : _h;
  var _j = verticalValues[0], wnValue = _j === void 0 ? nwValue : _j, _k = verticalValues[1], enValue = _k === void 0 ? wnValue : _k, _l = verticalValues[2], esValue = _l === void 0 ? wnValue : _l, _m = verticalValues[3], wsValue = _m === void 0 ? enValue : _m;
  var horizontalRawPoses = [nwValue, neValue, seValue, swValue].map(function(pos) {
    return convertUnitSize(pos, width);
  });
  var verticalRawPoses = [wnValue, enValue, esValue, wsValue].map(function(pos) {
    return convertUnitSize(pos, height);
  });
  var horizontalPoses = horizontalRawPoses.slice();
  var verticalPoses = verticalRawPoses.slice();
  _a2 = calculateRatio([horizontalPoses[0], horizontalPoses[1]], width), horizontalPoses[0] = _a2[0], horizontalPoses[1] = _a2[1];
  _b = calculateRatio([horizontalPoses[3], horizontalPoses[2]], width), horizontalPoses[3] = _b[0], horizontalPoses[2] = _b[1];
  _c = calculateRatio([verticalPoses[0], verticalPoses[3]], height), verticalPoses[0] = _c[0], verticalPoses[3] = _c[1];
  _d = calculateRatio([verticalPoses[1], verticalPoses[2]], height), verticalPoses[1] = _d[0], verticalPoses[2] = _d[1];
  var nextHorizontalPoses = horizontalPoses.slice(0, Math.max(minCounts[0], horizontalValues.length));
  var nextVerticalPoses = verticalPoses.slice(0, Math.max(minCounts[1], verticalValues.length));
  return __spreadArrays$2(nextHorizontalPoses.map(function(pos, i) {
    var direction2 = RADIUS_DIRECTIONS[i];
    return {
      horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],
      vertical: 0,
      pos: [left + pos, top + (VERTICAL_RADIUS_DIRECTIONS[i] === -1 ? height : 0)],
      sub: true,
      raw: horizontalRawPoses[i],
      direction: direction2
    };
  }), nextVerticalPoses.map(function(pos, i) {
    var direction2 = RADIUS_DIRECTIONS[i];
    return {
      horizontal: 0,
      vertical: VERTICAL_RADIUS_DIRECTIONS[i],
      pos: [left + (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1 ? width : 0), top + pos],
      sub: true,
      raw: verticalRawPoses[i],
      direction: direction2
    };
  }));
}
function removeRadiusPos(controlPoses, poses, index2, startIndex, length) {
  if (length === void 0) {
    length = poses.length;
  }
  var _a2 = getRadiusRange(controlPoses.slice(startIndex)), horizontalRange = _a2.horizontalRange, verticalRange = _a2.verticalRange;
  var radiuslIndex = index2 - startIndex;
  var deleteCount = 0;
  if (radiuslIndex === 0) {
    deleteCount = length;
  } else if (radiuslIndex > 0 && radiuslIndex < horizontalRange[1]) {
    deleteCount = horizontalRange[1] - radiuslIndex;
  } else if (radiuslIndex >= verticalRange[0]) {
    deleteCount = verticalRange[0] + verticalRange[1] - radiuslIndex;
  } else {
    return;
  }
  controlPoses.splice(index2, deleteCount);
  poses.splice(index2, deleteCount);
}
function addRadiusPos(controlPoses, poses, startIndex, horizontalIndex, verticalIndex, distX, distY, right, bottom, left, top) {
  if (left === void 0) {
    left = 0;
  }
  if (top === void 0) {
    top = 0;
  }
  var _a2 = getRadiusRange(controlPoses.slice(startIndex)), horizontalRange = _a2.horizontalRange, verticalRange = _a2.verticalRange;
  if (horizontalIndex > -1) {
    var radiusX = HORIZONTAL_RADIUS_DIRECTIONS[horizontalIndex] === 1 ? distX - left : right - distX;
    for (var i = horizontalRange[1]; i <= horizontalIndex; ++i) {
      var y = VERTICAL_RADIUS_DIRECTIONS[i] === 1 ? top : bottom;
      var x = 0;
      if (horizontalIndex === i) {
        x = distX;
      } else if (i === 0) {
        x = left + radiusX;
      } else if (HORIZONTAL_RADIUS_DIRECTIONS[i] === -1) {
        x = right - (poses[startIndex][0] - left);
      }
      controlPoses.splice(startIndex + i, 0, {
        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[i],
        vertical: 0,
        pos: [x, y]
      });
      poses.splice(startIndex + i, 0, [x, y]);
      if (i === 0) {
        break;
      }
    }
  } else if (verticalIndex > -1) {
    var radiusY = VERTICAL_RADIUS_DIRECTIONS[verticalIndex] === 1 ? distY - top : bottom - distY;
    if (horizontalRange[1] === 0 && verticalRange[1] === 0) {
      var pos = [left + radiusY, top];
      controlPoses.push({
        horizontal: HORIZONTAL_RADIUS_DIRECTIONS[0],
        vertical: 0,
        pos
      });
      poses.push(pos);
    }
    var startVerticalIndex = verticalRange[0];
    for (var i = verticalRange[1]; i <= verticalIndex; ++i) {
      var x = HORIZONTAL_RADIUS_DIRECTIONS[i] === 1 ? left : right;
      var y = 0;
      if (verticalIndex === i) {
        y = distY;
      } else if (i === 0) {
        y = top + radiusY;
      } else if (VERTICAL_RADIUS_DIRECTIONS[i] === 1) {
        y = poses[startIndex + startVerticalIndex][1];
      } else if (VERTICAL_RADIUS_DIRECTIONS[i] === -1) {
        y = bottom - (poses[startIndex + startVerticalIndex][1] - top);
      }
      controlPoses.push({
        horizontal: 0,
        vertical: VERTICAL_RADIUS_DIRECTIONS[i],
        pos: [x, y]
      });
      poses.push([x, y]);
      if (i === 0) {
        break;
      }
    }
  }
}
function splitRadiusPoses(controlPoses, raws) {
  if (raws === void 0) {
    raws = controlPoses.map(function(pos) {
      return pos.raw;
    });
  }
  var horizontals = controlPoses.map(function(pos, i) {
    return pos.horizontal ? raws[i] : null;
  }).filter(function(pos) {
    return pos != null;
  });
  var verticals = controlPoses.map(function(pos, i) {
    return pos.vertical ? raws[i] : null;
  }).filter(function(pos) {
    return pos != null;
  });
  return {
    horizontals,
    verticals
  };
}
var CLIP_DIRECTIONS = [[0, -1, "n"], [1, 0, "e"]];
var CLIP_RECT_DIRECTIONS = [[-1, -1, "nw"], [0, -1, "n"], [1, -1, "ne"], [1, 0, "e"], [1, 1, "se"], [0, 1, "s"], [-1, 1, "sw"], [-1, 0, "w"]];
function getClipStyles(moveable, clipPath, poses) {
  var clipRelative = moveable.props.clipRelative;
  var _a2 = moveable.state, width = _a2.width, height = _a2.height;
  var _b = clipPath, clipType = _b.type, clipPoses = _b.poses;
  var isRect = clipType === "rect";
  var isCircle = clipType === "circle";
  if (clipType === "polygon") {
    return poses.map(function(pos) {
      return convertCSSSize(pos[0], width, clipRelative) + " " + convertCSSSize(pos[1], height, clipRelative);
    });
  } else if (isRect || clipType === "inset") {
    var top = poses[1][1];
    var right = poses[3][0];
    var left = poses[7][0];
    var bottom = poses[5][1];
    if (isRect) {
      return [top, right, bottom, left].map(function(pos) {
        return pos + "px";
      });
    }
    var clipStyles = [top, width - right, height - bottom, left].map(function(pos, i) {
      return convertCSSSize(pos, i % 2 ? width : height, clipRelative);
    });
    if (poses.length > 8) {
      var _c = minus(poses[4], poses[0]), subWidth = _c[0], subHeight = _c[1];
      clipStyles.push.apply(clipStyles, __spreadArrays$2(["round"], getRadiusStyles(poses.slice(8), clipPoses.slice(8), clipRelative, subWidth, subHeight, left, top, right, bottom).styles));
    }
    return clipStyles;
  } else if (isCircle || clipType === "ellipse") {
    var center = poses[0];
    var ry = convertCSSSize(Math.abs(poses[1][1] - center[1]), isCircle ? Math.sqrt((width * width + height * height) / 2) : height, clipRelative);
    var clipStyles = isCircle ? [ry] : [convertCSSSize(Math.abs(poses[2][0] - center[0]), width, clipRelative), ry];
    clipStyles.push("at", convertCSSSize(center[0], width, clipRelative), convertCSSSize(center[1], height, clipRelative));
    return clipStyles;
  }
}
function getRectPoses(top, right, bottom, left) {
  var xs = [left, (left + right) / 2, right];
  var ys = [top, (top + bottom) / 2, bottom];
  return CLIP_RECT_DIRECTIONS.map(function(_a2) {
    var dirx = _a2[0], diry = _a2[1], dir = _a2[2];
    var x = xs[dirx + 1];
    var y = ys[diry + 1];
    return {
      vertical: Math.abs(diry),
      horizontal: Math.abs(dirx),
      direction: dir,
      pos: [x, y]
    };
  });
}
function getClipPath(target, width, height, defaultClip, customClip) {
  var _a2, _b, _c, _d, _e, _f, _g;
  var clipText = customClip;
  if (!clipText) {
    var style = getComputedStyle$1(target);
    var clipPath = style.clipPath;
    clipText = clipPath !== "none" ? clipPath : style.clip;
  }
  if (!clipText || clipText === "none" || clipText === "auto") {
    clipText = defaultClip;
    if (!clipText) {
      return;
    }
  }
  var _h = splitBracket(clipText), _j = _h.prefix, clipPrefix = _j === void 0 ? clipText : _j, _k = _h.value, value = _k === void 0 ? "" : _k;
  var isCircle = clipPrefix === "circle";
  var splitter = " ";
  if (clipPrefix === "polygon") {
    var values = splitComma(value || "0% 0%, 100% 0%, 100% 100%, 0% 100%");
    splitter = ",";
    var poses = values.map(function(pos) {
      var _a3 = pos.split(" "), xPos2 = _a3[0], yPos2 = _a3[1];
      return {
        vertical: 1,
        horizontal: 1,
        pos: [convertUnitSize(xPos2, width), convertUnitSize(yPos2, height)]
      };
    });
    return {
      type: clipPrefix,
      clipText,
      poses,
      splitter
    };
  } else if (isCircle || clipPrefix === "ellipse") {
    var xPos = "";
    var yPos = "";
    var radiusX_1 = 0;
    var radiusY_1 = 0;
    var values = splitSpace(value);
    if (isCircle) {
      var radius = "";
      _a2 = values[0], radius = _a2 === void 0 ? "50%" : _a2, _b = values[2], xPos = _b === void 0 ? "50%" : _b, _c = values[3], yPos = _c === void 0 ? "50%" : _c;
      radiusX_1 = convertUnitSize(radius, Math.sqrt((width * width + height * height) / 2));
      radiusY_1 = radiusX_1;
    } else {
      var xRadius = "";
      var yRadius = "";
      _d = values[0], xRadius = _d === void 0 ? "50%" : _d, _e = values[1], yRadius = _e === void 0 ? "50%" : _e, _f = values[3], xPos = _f === void 0 ? "50%" : _f, _g = values[4], yPos = _g === void 0 ? "50%" : _g;
      radiusX_1 = convertUnitSize(xRadius, width);
      radiusY_1 = convertUnitSize(yRadius, height);
    }
    var centerPos_1 = [convertUnitSize(xPos, width), convertUnitSize(yPos, height)];
    var poses = __spreadArrays$2([{
      vertical: 1,
      horizontal: 1,
      pos: centerPos_1,
      direction: "nesw"
    }], CLIP_DIRECTIONS.slice(0, isCircle ? 1 : 2).map(function(dir) {
      return {
        vertical: Math.abs(dir[1]),
        horizontal: dir[0],
        direction: dir[2],
        sub: true,
        pos: [centerPos_1[0] + dir[0] * radiusX_1, centerPos_1[1] + dir[1] * radiusY_1]
      };
    }));
    return {
      type: clipPrefix,
      clipText,
      radiusX: radiusX_1,
      radiusY: radiusY_1,
      left: centerPos_1[0] - radiusX_1,
      top: centerPos_1[1] - radiusY_1,
      poses,
      splitter
    };
  } else if (clipPrefix === "inset") {
    var values = splitSpace(value || "0 0 0 0");
    var roundIndex = values.indexOf("round");
    var rectLength = (roundIndex > -1 ? values.slice(0, roundIndex) : values).length;
    var radiusValues = values.slice(rectLength + 1);
    var _l = values.slice(0, rectLength), topValue = _l[0], _m = _l[1], rightValue = _m === void 0 ? topValue : _m, _o = _l[2], bottomValue = _o === void 0 ? topValue : _o, _p = _l[3], leftValue = _p === void 0 ? rightValue : _p;
    var _q = [topValue, bottomValue].map(function(pos) {
      return convertUnitSize(pos, height);
    }), top = _q[0], bottom = _q[1];
    var _r = [leftValue, rightValue].map(function(pos) {
      return convertUnitSize(pos, width);
    }), left = _r[0], right = _r[1];
    var nextRight = width - right;
    var nextBottom = height - bottom;
    var radiusPoses = getRadiusValues(radiusValues, nextRight - left, nextBottom - top, left, top);
    var poses = __spreadArrays$2(getRectPoses(top, nextRight, nextBottom, left), radiusPoses);
    return {
      type: "inset",
      clipText,
      poses,
      top,
      left,
      right: nextRight,
      bottom: nextBottom,
      radius: radiusValues,
      splitter
    };
  } else if (clipPrefix === "rect") {
    var values = splitComma(value || "0px, " + width + "px, " + height + "px, 0px");
    splitter = ",";
    var _s = values.map(function(pos) {
      var posValue = splitUnit(pos).value;
      return posValue;
    }), top = _s[0], right = _s[1], bottom = _s[2], left = _s[3];
    var poses = getRectPoses(top, right, bottom, left);
    return {
      type: "rect",
      clipText,
      poses,
      top,
      right,
      bottom,
      left,
      values,
      splitter
    };
  }
  return;
}
function addClipPath(moveable, e2) {
  var _a2 = calculatePointerDist(moveable, e2), distX = _a2[0], distY = _a2[1];
  var _b = e2.datas, clipPath = _b.clipPath, index2 = _b.index;
  var _c = clipPath, clipType = _c.type, clipPoses = _c.poses, splitter = _c.splitter;
  var poses = clipPoses.map(function(pos) {
    return pos.pos;
  });
  if (clipType === "polygon") {
    poses.splice(index2, 0, [distX, distY]);
  } else if (clipType === "inset") {
    var horizontalIndex = HORIZONTAL_RADIUS_ORDER.indexOf(index2);
    var verticalIndex = VERTICAL_RADIUS_ORDER.indexOf(index2);
    var length = clipPoses.length;
    addRadiusPos(clipPoses, poses, 8, horizontalIndex, verticalIndex, distX, distY, poses[4][0], poses[4][1], poses[0][0], poses[0][1]);
    if (length === clipPoses.length) {
      return;
    }
  } else {
    return;
  }
  var clipStyles = getClipStyles(moveable, clipPath, poses);
  triggerEvent(moveable, "onClip", fillParams(moveable, e2, {
    clipEventType: "added",
    clipType,
    poses,
    clipStyles,
    clipStyle: clipType + "(" + clipStyles.join(splitter) + ")",
    distX: 0,
    distY: 0
  }));
}
function removeClipPath(moveable, e2) {
  var _a2 = e2.datas, clipPath = _a2.clipPath, index2 = _a2.index;
  var _b = clipPath, clipType = _b.type, clipPoses = _b.poses, splitter = _b.splitter;
  var poses = clipPoses.map(function(pos) {
    return pos.pos;
  });
  var length = poses.length;
  if (clipType === "polygon") {
    clipPoses.splice(index2, 1);
    poses.splice(index2, 1);
  } else if (clipType === "inset") {
    if (index2 < 8) {
      return;
    }
    removeRadiusPos(clipPoses, poses, index2, 8, length);
    if (length === clipPoses.length) {
      return;
    }
  } else {
    return;
  }
  var clipStyles = getClipStyles(moveable, clipPath, poses);
  triggerEvent(moveable, "onClip", fillParams(moveable, e2, {
    clipEventType: "removed",
    clipType,
    poses,
    clipStyles,
    clipStyle: clipType + "(" + clipStyles.join(splitter) + ")",
    distX: 0,
    distY: 0
  }));
}
var Clippable = {
  name: "clippable",
  props: {
    clippable: Boolean,
    defaultClipPath: String,
    customClipPath: String,
    clipRelative: Boolean,
    clipArea: Boolean,
    dragWithClip: Boolean,
    clipTargetBounds: Boolean,
    clipVerticalGuidelines: Array,
    clipHorizontalGuidelines: Array,
    clipSnapThreshold: Boolean
  },
  events: {
    onClipStart: "clipStart",
    onClip: "clip",
    onClipEnd: "clipEnd"
  },
  css: [".control.clip-control {\n    background: #6d6;\n    cursor: pointer;\n}\n.control.clip-control.clip-radius {\n    background: #d66;\n}\n.line.clip-line {\n    background: #6e6;\n    cursor: move;\n    z-index: 1;\n}\n.clip-area {\n    position: absolute;\n    top: 0;\n    left: 0;\n}\n.clip-ellipse {\n    position: absolute;\n    cursor: move;\n    border: 1px solid #6d6;\n    border: var(--zoompx) solid #6d6;\n    border-radius: 50%;\n    transform-origin: 0px 0px;\n}", ":host {\n    --bounds-color: #d66;\n}", ".guideline {\n    pointer-events: none;\n    z-index: 2;\n}", ".line.guideline.bounds {\n    background: #d66;\n    background: var(--bounds-color);\n}"],
  render: function(moveable, React) {
    var _a2 = moveable.props, customClipPath = _a2.customClipPath, defaultClipPath = _a2.defaultClipPath, clipArea = _a2.clipArea, zoom = _a2.zoom;
    var _b = moveable.state, target = _b.target, width = _b.width, height = _b.height, allMatrix = _b.allMatrix, is3d = _b.is3d, left = _b.left, top = _b.top, pos1 = _b.pos1, pos2 = _b.pos2, pos3 = _b.pos3, pos4 = _b.pos4, clipPathState = _b.clipPathState, snapBoundInfos = _b.snapBoundInfos;
    if (!target) {
      return [];
    }
    var clipPath = getClipPath(target, width, height, defaultClipPath || "inset", clipPathState || customClipPath);
    if (!clipPath) {
      return [];
    }
    var n = is3d ? 4 : 3;
    var type = clipPath.type;
    var clipPoses = clipPath.poses;
    var poses = clipPoses.map(function(pos) {
      var calculatedPos = calculatePosition(allMatrix, pos.pos, n);
      return [calculatedPos[0] - left, calculatedPos[1] - top];
    });
    var controls = [];
    var lines = [];
    var isRect = type === "rect";
    var isInset = type === "inset";
    var isPolygon = type === "polygon";
    if (isRect || isInset || isPolygon) {
      var linePoses_1 = isInset ? poses.slice(0, 8) : poses;
      lines = linePoses_1.map(function(to, i2) {
        var from = i2 === 0 ? linePoses_1[linePoses_1.length - 1] : linePoses_1[i2 - 1];
        var rad2 = getRad$1(from, to);
        var dist = getDiagonalSize(from, to);
        return React.createElement("div", {
          key: "clipLine" + i2,
          className: prefix$2("line", "clip-line", "snap-control"),
          "data-clip-index": i2,
          style: {
            width: dist + "px",
            transform: "translate(" + from[0] + "px, " + from[1] + "px) rotate(" + rad2 + "rad) scaleY(" + zoom + ")"
          }
        });
      });
    }
    controls = poses.map(function(pos, i2) {
      return React.createElement("div", {
        key: "clipControl" + i2,
        className: prefix$2("control", "clip-control", "snap-control"),
        "data-clip-index": i2,
        style: {
          transform: "translate(" + pos[0] + "px, " + pos[1] + "px) scale(" + zoom + ")"
        }
      });
    });
    if (isInset) {
      controls.push.apply(controls, poses.slice(8).map(function(pos, i2) {
        return React.createElement("div", {
          key: "clipRadiusControl" + i2,
          className: prefix$2("control", "clip-control", "clip-radius", "snap-control"),
          "data-clip-index": 8 + i2,
          style: {
            transform: "translate(" + pos[0] + "px, " + pos[1] + "px) scale(" + zoom + ")"
          }
        });
      }));
    }
    if (type === "circle" || type === "ellipse") {
      var clipLeft = clipPath.left, clipTop = clipPath.top, radiusX = clipPath.radiusX, radiusY = clipPath.radiusY;
      var _c = minus(calculatePosition(allMatrix, [clipLeft, clipTop], n), calculatePosition(allMatrix, [0, 0], n)), distLeft = _c[0], distTop = _c[1];
      var ellipseClipPath = "none";
      if (!clipArea) {
        var piece = Math.max(10, radiusX / 5, radiusY / 5);
        var areaPoses = [];
        for (var i = 0; i <= piece; ++i) {
          var rad = Math.PI * 2 / piece * i;
          areaPoses.push([radiusX + (radiusX - zoom) * Math.cos(rad), radiusY + (radiusY - zoom) * Math.sin(rad)]);
        }
        areaPoses.push([radiusX, -2]);
        areaPoses.push([-2, -2]);
        areaPoses.push([-2, radiusY * 2 + 2]);
        areaPoses.push([radiusX * 2 + 2, radiusY * 2 + 2]);
        areaPoses.push([radiusX * 2 + 2, -2]);
        areaPoses.push([radiusX, -2]);
        ellipseClipPath = "polygon(" + areaPoses.map(function(pos) {
          return pos[0] + "px " + pos[1] + "px";
        }).join(", ") + ")";
      }
      controls.push(React.createElement("div", {
        key: "clipEllipse",
        className: prefix$2("clip-ellipse", "snap-control"),
        style: {
          width: radiusX * 2 + "px",
          height: radiusY * 2 + "px",
          clipPath: ellipseClipPath,
          transform: "translate(" + (-left + distLeft) + "px, " + (-top + distTop) + "px) " + makeMatrixCSS(allMatrix)
        }
      }));
    }
    if (clipArea) {
      var _d = getRect$2(__spreadArrays$2([pos1, pos2, pos3, pos4], poses)), allWidth = _d.width, allHeight = _d.height, allLeft_1 = _d.left, allTop_1 = _d.top;
      if (isPolygon || isRect || isInset) {
        var areaPoses = isInset ? poses.slice(0, 8) : poses;
        controls.push(React.createElement("div", {
          key: "clipArea",
          className: prefix$2("clip-area", "snap-control"),
          style: {
            width: allWidth + "px",
            height: allHeight + "px",
            transform: "translate(" + allLeft_1 + "px, " + allTop_1 + "px)",
            clipPath: "polygon(" + areaPoses.map(function(pos) {
              return pos[0] - allLeft_1 + "px " + (pos[1] - allTop_1) + "px";
            }).join(", ") + ")"
          }
        }));
      }
    }
    if (snapBoundInfos) {
      ["vertical", "horizontal"].forEach(function(directionType) {
        var info = snapBoundInfos[directionType];
        var isHorizontal = directionType === "horizontal";
        if (info.isSnap) {
          lines.push.apply(lines, info.snap.posInfos.map(function(_a3, i2) {
            var pos = _a3.pos;
            var snapPos1 = minus(calculatePosition(allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);
            var snapPos2 = minus(calculatePosition(allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);
            return renderLine(React, "", snapPos1, snapPos2, zoom, "clip" + directionType + "snap" + i2, "guideline");
          }));
        }
        if (info.isBound) {
          lines.push.apply(lines, info.bounds.map(function(_a3, i2) {
            var pos = _a3.pos;
            var snapPos1 = minus(calculatePosition(allMatrix, isHorizontal ? [0, pos] : [pos, 0], n), [left, top]);
            var snapPos2 = minus(calculatePosition(allMatrix, isHorizontal ? [width, pos] : [pos, height], n), [left, top]);
            return renderLine(React, "", snapPos1, snapPos2, zoom, "clip" + directionType + "bounds" + i2, "guideline", "bounds", "bold");
          }));
        }
      });
    }
    return __spreadArrays$2(controls, lines);
  },
  dragControlCondition: function(moveable, e2) {
    return e2.inputEvent && (e2.inputEvent.target.getAttribute("class") || "").indexOf("clip") > -1;
  },
  dragStart: function(moveable, e2) {
    var props2 = moveable.props;
    var _a2 = props2.dragWithClip, dragWithClip = _a2 === void 0 ? true : _a2;
    if (dragWithClip) {
      return false;
    }
    return this.dragControlStart(moveable, e2);
  },
  drag: function(moveable, e2) {
    return this.dragControl(moveable, e2);
  },
  dragEnd: function(moveable, e2) {
    return this.dragControlEnd(moveable, e2);
  },
  dragControlStart: function(moveable, e2) {
    var state = moveable.state;
    var _a2 = moveable.props, defaultClipPath = _a2.defaultClipPath, customClipPath = _a2.customClipPath;
    var target = state.target, width = state.width, height = state.height;
    var inputTarget = e2.inputEvent ? e2.inputEvent.target : null;
    var className = inputTarget ? inputTarget.getAttribute("class") : "";
    var datas = e2.datas;
    var clipPath = getClipPath(target, width, height, defaultClipPath || "inset", customClipPath);
    if (!clipPath) {
      return false;
    }
    var clipText = clipPath.clipText, type = clipPath.type, poses = clipPath.poses;
    var result = triggerEvent(moveable, "onClipStart", fillParams(moveable, e2, {
      clipType: type,
      clipStyle: clipText,
      poses: poses.map(function(pos) {
        return pos.pos;
      })
    }));
    if (result === false) {
      datas.isClipStart = false;
      return false;
    }
    datas.isControl = className.indexOf("clip-control") > -1;
    datas.isLine = className.indexOf("clip-line") > -1;
    datas.isArea = className.indexOf("clip-area") > -1 || className.indexOf("clip-ellipse") > -1;
    datas.index = inputTarget ? parseInt(inputTarget.getAttribute("data-clip-index"), 10) : -1;
    datas.clipPath = clipPath;
    datas.isClipStart = true;
    state.clipPathState = clipText;
    setDragStart(moveable, e2);
    return true;
  },
  dragControl: function(moveable, e2) {
    var datas = e2.datas, originalDatas = e2.originalDatas;
    if (!datas.isClipStart) {
      return false;
    }
    var draggableData = originalDatas && originalDatas.draggable || {};
    var _a2 = datas, isControl = _a2.isControl, isLine = _a2.isLine, isArea = _a2.isArea, index2 = _a2.index, clipPath = _a2.clipPath;
    if (!clipPath) {
      return false;
    }
    var _b = draggableData.isDrag ? draggableData.prevDist : getDragDist(e2), distX = _b[0], distY = _b[1];
    var props2 = moveable.props;
    var state = moveable.state;
    var width = state.width, height = state.height;
    var isDragWithTarget = !isArea && !isControl && !isLine;
    var clipType = clipPath.type, clipPoses = clipPath.poses, splitter = clipPath.splitter;
    var poses = clipPoses.map(function(pos) {
      return pos.pos;
    });
    if (isDragWithTarget) {
      distX = -distX;
      distY = -distY;
    }
    var isAll = !isControl || clipPoses[index2].direction === "nesw";
    var isRect = clipType === "inset" || clipType === "rect";
    var dists = clipPoses.map(function() {
      return [0, 0];
    });
    if (isControl && !isAll) {
      var _c = clipPoses[index2], horizontal = _c.horizontal, vertical = _c.vertical;
      var dist = [distX * Math.abs(horizontal), distY * Math.abs(vertical)];
      dists = moveControlPos(clipPoses, index2, dist, isRect);
    } else if (isAll) {
      dists = poses.map(function() {
        return [distX, distY];
      });
    }
    var nextPoses = poses.map(function(pos, i2) {
      return plus(pos, dists[i2]);
    });
    var guidePoses = __spreadArrays$2(nextPoses);
    state.snapBoundInfos = null;
    var isCircle = clipPath.type === "circle";
    var isEllipse = clipPath.type === "ellipse";
    if (isCircle || isEllipse) {
      var guideRect = getRect$2(nextPoses);
      var ry = Math.abs(guideRect.bottom - guideRect.top);
      var rx = Math.abs(isEllipse ? guideRect.right - guideRect.left : ry);
      var bottom = nextPoses[0][1] + ry;
      var left = nextPoses[0][0] - rx;
      var right = nextPoses[0][0] + rx;
      if (isCircle) {
        guidePoses.push([right, guideRect.bottom]);
        dists.push([1, 0]);
      }
      guidePoses.push([guideRect.left, bottom]);
      dists.push([0, 1]);
      guidePoses.push([left, guideRect.bottom]);
      dists.push([1, 0]);
    }
    var guidelines = getDefaultGuidelines((props2.clipHorizontalGuidelines || []).map(function(v) {
      return convertUnitSize("" + v, height);
    }), (props2.clipVerticalGuidelines || []).map(function(v) {
      return convertUnitSize("" + v, width);
    }), width, height);
    var guideXPoses = [];
    var guideYPoses = [];
    if (isCircle || isEllipse) {
      guideXPoses = [guidePoses[4][0], guidePoses[2][0]];
      guideYPoses = [guidePoses[1][1], guidePoses[3][1]];
    } else if (isRect) {
      var rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];
      var rectDists_1 = [dists[0], dists[2], dists[4], dists[6]];
      guideXPoses = rectPoses.filter(function(_, i2) {
        return rectDists_1[i2][0];
      }).map(function(pos) {
        return pos[0];
      });
      guideYPoses = rectPoses.filter(function(_, i2) {
        return rectDists_1[i2][1];
      }).map(function(pos) {
        return pos[1];
      });
    } else {
      guideXPoses = guidePoses.filter(function(_, i2) {
        return dists[i2][0];
      }).map(function(pos) {
        return pos[0];
      });
      guideYPoses = guidePoses.filter(function(_, i2) {
        return dists[i2][1];
      }).map(function(pos) {
        return pos[1];
      });
    }
    var _loop_1 = function(i2) {
      var _a3 = checkSnapBounds(guidelines, props2.clipTargetBounds && {
        left: 0,
        top: 0,
        right: width,
        bottom: height
      }, guideXPoses, guideYPoses, {
        snapThreshold: 5
      }), horizontalSnapInfo = _a3.horizontal, verticalSnapInfo = _a3.vertical;
      var snapOffsetY = horizontalSnapInfo.offset;
      var snapOffsetX = verticalSnapInfo.offset;
      if ((isEllipse || isCircle) && dists[0][0] === 0 && dists[0][1] === 0) {
        var guideRect2 = getRect$2(nextPoses);
        var cy = guideRect2.bottom - guideRect2.top;
        var cx = isEllipse ? guideRect2.right - guideRect2.left : cy;
        var distSnapX = verticalSnapInfo.isBound ? Math.abs(snapOffsetX) : verticalSnapInfo.snapIndex === 0 ? -snapOffsetX : snapOffsetX;
        var distSnapY = horizontalSnapInfo.isBound ? Math.abs(snapOffsetY) : horizontalSnapInfo.snapIndex === 0 ? -snapOffsetY : snapOffsetY;
        cx -= distSnapX;
        cy -= distSnapY;
        if (isCircle) {
          cy = checkSnapBoundPriority(verticalSnapInfo, horizontalSnapInfo) > 0 ? cy : cx;
          cx = cy;
        }
        var center = guidePoses[0];
        guidePoses[1][1] = center[1] - cy;
        guidePoses[2][0] = center[0] + cx;
        guidePoses[3][1] = center[1] + cy;
        guidePoses[4][0] = center[0] - cx;
      } else {
        guidePoses.forEach(function(pos, j2) {
          var dist2 = dists[j2];
          if (dist2[0]) {
            pos[0] -= snapOffsetX;
          }
          if (dist2[1]) {
            pos[1] -= snapOffsetY;
          }
        });
        return "break";
      }
    };
    for (var i = 0; i < 2; ++i) {
      var state_1 = _loop_1();
      if (state_1 === "break")
        break;
    }
    var nextClipStyles = getClipStyles(moveable, clipPath, nextPoses);
    var clipStyle = clipType + "(" + nextClipStyles.join(splitter) + ")";
    state.clipPathState = clipStyle;
    if (isCircle || isEllipse) {
      guideXPoses = [guidePoses[4][0], guidePoses[2][0]];
      guideYPoses = [guidePoses[1][1], guidePoses[3][1]];
    } else if (isRect) {
      var rectPoses = [guidePoses[0], guidePoses[2], guidePoses[4], guidePoses[6]];
      guideXPoses = rectPoses.map(function(pos) {
        return pos[0];
      });
      guideYPoses = rectPoses.map(function(pos) {
        return pos[1];
      });
    } else {
      guideXPoses = guidePoses.map(function(pos) {
        return pos[0];
      });
      guideYPoses = guidePoses.map(function(pos) {
        return pos[1];
      });
    }
    state.snapBoundInfos = checkSnapBounds(guidelines, props2.clipTargetBounds && {
      left: 0,
      top: 0,
      right: width,
      bottom: height
    }, guideXPoses, guideYPoses, {
      snapThreshold: 1
    });
    triggerEvent(moveable, "onClip", fillParams(moveable, e2, {
      clipEventType: "changed",
      clipType,
      poses: nextPoses,
      clipStyle,
      clipStyles: nextClipStyles,
      distX,
      distY
    }));
    return true;
  },
  dragControlEnd: function(moveable, e2) {
    this.unset(moveable);
    var isDrag2 = e2.isDrag, datas = e2.datas, isDouble = e2.isDouble;
    var isLine = datas.isLine, isClipStart = datas.isClipStart, isControl = datas.isControl;
    if (!isClipStart) {
      return false;
    }
    triggerEvent(moveable, "onClipEnd", fillEndParams(moveable, e2, {}));
    if (isDouble) {
      if (isControl) {
        removeClipPath(moveable, e2);
      } else if (isLine) {
        addClipPath(moveable, e2);
      }
    }
    return isDouble || isDrag2;
  },
  unset: function(moveable) {
    moveable.state.clipPathState = "";
    moveable.state.snapBoundInfos = null;
  }
};
var OriginDraggable = {
  name: "originDraggable",
  props: {
    originDraggable: Boolean,
    originRelative: Boolean
  },
  events: {
    onDragOriginStart: "dragOriginStart",
    onDragOrigin: "dragOrigin",
    onDragOriginEnd: "dragOriginEnd"
  },
  css: [":host[data-able-origindraggable] .control.origin {\n    pointer-events: auto;\n}"],
  dragControlCondition: function(_, e2) {
    if (e2.isRequest) {
      return e2.requestAble === "originDraggable";
    }
    return hasClass(e2.inputEvent.target, prefix$2("origin"));
  },
  dragControlStart: function(moveable, e2) {
    var datas = e2.datas;
    setDragStart(moveable, e2);
    var params = fillParams(moveable, e2, {
      dragStart: Draggable.dragStart(moveable, new CustomGesto().dragStart([0, 0], e2))
    });
    var result = triggerEvent(moveable, "onDragOriginStart", params);
    datas.startOrigin = moveable.state.transformOrigin;
    datas.startTargetOrigin = moveable.state.targetOrigin;
    datas.prevOrigin = [0, 0];
    datas.isDragOrigin = true;
    if (result === false) {
      datas.isDragOrigin = false;
      return false;
    }
    return params;
  },
  dragControl: function(moveable, e2) {
    var datas = e2.datas, isPinch = e2.isPinch, isRequest = e2.isRequest;
    if (!datas.isDragOrigin) {
      return false;
    }
    var _a2 = getDragDist(e2), distX = _a2[0], distY = _a2[1];
    var state = moveable.state;
    var width = state.width, height = state.height, offsetMatrix = state.offsetMatrix, targetMatrix = state.targetMatrix, is3d = state.is3d;
    var _b = moveable.props.originRelative, originRelative = _b === void 0 ? true : _b;
    var n = is3d ? 4 : 3;
    var dist = [distX, distY];
    if (isRequest) {
      var distOrigin = e2.distOrigin;
      if (distOrigin[0] || distOrigin[1]) {
        dist = distOrigin;
      }
    }
    var origin = plus(datas.startOrigin, dist);
    var targetOrigin = plus(datas.startTargetOrigin, dist);
    var delta = minus(dist, datas.prevOrigin);
    var nextMatrix = getNextMatrix(offsetMatrix, targetMatrix, origin, n);
    var rect = moveable.getRect();
    var nextRect = getRect$2(calculatePoses(nextMatrix, width, height, n));
    var dragDelta = [rect.left - nextRect.left, rect.top - nextRect.top];
    datas.prevOrigin = dist;
    var transformOrigin2 = [convertCSSSize(targetOrigin[0], width, originRelative), convertCSSSize(targetOrigin[1], height, originRelative)].join(" ");
    var params = fillParams(moveable, e2, {
      width,
      height,
      origin,
      dist,
      delta,
      transformOrigin: transformOrigin2,
      drag: Draggable.drag(moveable, setCustomDrag(e2, moveable.state, dragDelta, !!isPinch, false))
    });
    triggerEvent(moveable, "onDragOrigin", params);
    return params;
  },
  dragControlEnd: function(moveable, e2) {
    var datas = e2.datas;
    if (!datas.isDragOrigin) {
      return false;
    }
    triggerEvent(moveable, "onDragOriginEnd", fillEndParams(moveable, e2, {}));
    return true;
  },
  dragGroupControlCondition: function(moveable, e2) {
    return this.dragControlCondition(moveable, e2);
  },
  dragGroupControlStart: function(moveable, e2) {
    var params = this.dragControlStart(moveable, e2);
    if (!params) {
      return false;
    }
    return true;
  },
  dragGroupControl: function(moveable, e2) {
    var params = this.dragControl(moveable, e2);
    if (!params) {
      return false;
    }
    moveable.transformOrigin = params.transformOrigin;
    return true;
  },
  request: function(moveable) {
    var datas = {};
    var rect = moveable.getRect();
    var distX = 0;
    var distY = 0;
    var transformOrigin2 = rect.transformOrigin;
    var distOrigin = [0, 0];
    return {
      isControl: true,
      requestStart: function() {
        return {
          datas
        };
      },
      request: function(e2) {
        if ("deltaOrigin" in e2) {
          distOrigin[0] += e2.deltaOrigin[0];
          distOrigin[1] += e2.deltaOrigin[1];
        } else if ("origin" in e2) {
          distOrigin[0] = e2.origin[0] - transformOrigin2[0];
          distOrigin[1] = e2.origin[1] - transformOrigin2[1];
        } else {
          if ("x" in e2) {
            distX = e2.x - rect.left;
          } else if ("deltaX" in e2) {
            distX += e2.deltaX;
          }
          if ("y" in e2) {
            distY = e2.y - rect.top;
          } else if ("deltaY" in e2) {
            distY += e2.deltaY;
          }
        }
        return {
          datas,
          distX,
          distY,
          distOrigin
        };
      },
      requestEnd: function() {
        return {
          datas,
          isDrag: true
        };
      }
    };
  }
};
function addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height) {
  var _a2 = splitRadiusPoses(controlPoses), horizontals = _a2.horizontals, verticals = _a2.verticals;
  var horizontalsLength = horizontals.length;
  var verticalsLength = verticals.length;
  var horizontalIndex = -1;
  var verticalIndex = -1;
  if (lineIndex === 0) {
    if (horizontalsLength === 0) {
      horizontalIndex = 0;
    } else if (horizontalsLength === 1) {
      horizontalIndex = 1;
    }
  } else if (lineIndex === 3) {
    if (horizontalsLength <= 2) {
      horizontalIndex = 2;
    } else if (horizontalsLength <= 3) {
      horizontalIndex = 3;
    }
  }
  if (lineIndex === 2) {
    if (verticalsLength === 0) {
      verticalIndex = 0;
    } else if (verticalsLength < 4) {
      verticalIndex = 3;
    }
  } else if (lineIndex === 1) {
    if (verticalsLength <= 1) {
      verticalIndex = 1;
    } else if (verticalsLength <= 2) {
      verticalIndex = 2;
    }
  }
  addRadiusPos(controlPoses, poses, 0, horizontalIndex, verticalIndex, distX, distY, width, height);
}
function getBorderRadius(target, width, height, minCounts, state) {
  if (minCounts === void 0) {
    minCounts = [0, 0];
  }
  var borderRadius;
  var values = [];
  if (!state) {
    var style = getComputedStyle$1(target);
    borderRadius = style && style.borderRadius || "";
  } else {
    borderRadius = state;
  }
  if (!borderRadius || !state && borderRadius === "0px") {
    values = [];
  } else {
    values = splitSpace(borderRadius);
  }
  return getRadiusValues(values, width, height, 0, 0, minCounts);
}
function triggerRoundEvent(moveable, e2, dist, delta, controlPoses, nextPoses) {
  var state = moveable.state;
  var width = state.width, height = state.height;
  var _a2 = getRadiusStyles(nextPoses, controlPoses, moveable.props.roundRelative, width, height), raws = _a2.raws, styles = _a2.styles;
  var _b = splitRadiusPoses(controlPoses, raws), horizontals = _b.horizontals, verticals = _b.verticals;
  var borderRadius = styles.join(" ");
  state.borderRadiusState = borderRadius;
  triggerEvent(moveable, "onRound", fillParams(moveable, e2, {
    horizontals,
    verticals,
    borderRadius,
    width,
    height,
    delta,
    dist
  }));
}
var Roundable = {
  name: "roundable",
  props: {
    roundable: Boolean,
    roundRelative: Boolean,
    minRoundControls: Array,
    maxRoundControls: Array,
    roundClickable: Boolean
  },
  events: {
    onRoundStart: "roundStart",
    onRound: "round",
    onRoundEnd: "roundEnd"
  },
  css: [".control.border-radius {\n    background: #d66;\n    cursor: pointer;\n}", ":host[data-able-roundable] .line.direction {\n    cursor: pointer;\n}"],
  render: function(moveable, React) {
    var _a2 = moveable.state, target = _a2.target, width = _a2.width, height = _a2.height, allMatrix = _a2.allMatrix, is3d = _a2.is3d, left = _a2.left, top = _a2.top, borderRadiusState = _a2.borderRadiusState;
    var _b = moveable.props, _c = _b.minRoundControls, minRoundControls = _c === void 0 ? [0, 0] : _c, _d = _b.maxRoundControls, maxRoundControls = _d === void 0 ? [4, 4] : _d, zoom = _b.zoom;
    if (!target) {
      return null;
    }
    var n = is3d ? 4 : 3;
    var radiusValues = getBorderRadius(target, width, height, minRoundControls, borderRadiusState);
    if (!radiusValues) {
      return null;
    }
    var verticalCount = 0;
    var horizontalCount = 0;
    return radiusValues.map(function(v, i) {
      horizontalCount += Math.abs(v.horizontal);
      verticalCount += Math.abs(v.vertical);
      var pos = minus(calculatePosition(allMatrix, v.pos, n), [left, top]);
      var isDisplay = v.vertical ? verticalCount <= maxRoundControls[1] : horizontalCount <= maxRoundControls[0];
      return React.createElement("div", {
        key: "borderRadiusControl" + i,
        className: prefix$2("control", "border-radius"),
        "data-radius-index": i,
        style: {
          display: isDisplay ? "block" : "none",
          transform: "translate(" + pos[0] + "px, " + pos[1] + "px) scale(" + zoom + ")"
        }
      });
    });
  },
  dragControlCondition: function(moveable, e2) {
    if (!e2.inputEvent || e2.isRequest) {
      return false;
    }
    var className = e2.inputEvent.target.getAttribute("class") || "";
    return className.indexOf("border-radius") > -1 || className.indexOf("moveable-line") > -1 && className.indexOf("moveable-direction") > -1;
  },
  dragControlStart: function(moveable, e2) {
    var inputEvent = e2.inputEvent, datas = e2.datas;
    var inputTarget = inputEvent.target;
    var className = inputTarget.getAttribute("class") || "";
    var isControl = className.indexOf("border-radius") > -1;
    var isLine = className.indexOf("moveable-line") > -1 && className.indexOf("moveable-direction") > -1;
    var controlIndex = isControl ? parseInt(inputTarget.getAttribute("data-radius-index"), 10) : -1;
    var lineIndex = isLine ? parseInt(inputTarget.getAttribute("data-line-index"), 10) : -1;
    if (!isControl && !isLine) {
      return false;
    }
    var result = triggerEvent(moveable, "onRoundStart", fillParams(moveable, e2, {}));
    if (result === false) {
      return false;
    }
    datas.lineIndex = lineIndex;
    datas.controlIndex = controlIndex;
    datas.isControl = isControl;
    datas.isLine = isLine;
    setDragStart(moveable, e2);
    var _a2 = moveable.props, roundRelative = _a2.roundRelative, _b = _a2.minRoundControls, minRoundControls = _b === void 0 ? [0, 0] : _b;
    var state = moveable.state;
    var target = state.target, width = state.width, height = state.height;
    datas.isRound = true;
    datas.prevDist = [0, 0];
    var controlPoses = getBorderRadius(target, width, height, minRoundControls) || [];
    datas.controlPoses = controlPoses;
    state.borderRadiusState = getRadiusStyles(controlPoses.map(function(pos) {
      return pos.pos;
    }), controlPoses, roundRelative, width, height).styles.join(" ");
    return true;
  },
  dragControl: function(moveable, e2) {
    var datas = e2.datas;
    if (!datas.isRound || !datas.isControl || !datas.controlPoses.length) {
      return false;
    }
    var index2 = datas.controlIndex;
    var controlPoses = datas.controlPoses;
    var _a2 = getDragDist(e2), distX = _a2[0], distY = _a2[1];
    var dist = [distX, distY];
    var delta = minus(dist, datas.prevDist);
    var _b = moveable.props.maxRoundControls, maxRoundControls = _b === void 0 ? [4, 4] : _b;
    var _c = moveable.state, width = _c.width, height = _c.height;
    var selectedControlPose = controlPoses[index2];
    var selectedVertical = selectedControlPose.vertical;
    var selectedHorizontal = selectedControlPose.horizontal;
    var dists = controlPoses.map(function(pose) {
      var horizontal = pose.horizontal, vertical = pose.vertical;
      var poseDist = [horizontal * selectedHorizontal * dist[0], vertical * selectedVertical * dist[1]];
      if (horizontal) {
        if (maxRoundControls[0] === 1) {
          return poseDist;
        } else if (maxRoundControls[0] < 4 && horizontal !== selectedHorizontal) {
          return poseDist;
        }
      } else if (maxRoundControls[1] === 0) {
        poseDist[1] = vertical * selectedHorizontal * dist[0] / width * height;
        return poseDist;
      } else if (selectedVertical) {
        if (maxRoundControls[1] === 1) {
          return poseDist;
        } else if (maxRoundControls[1] < 4 && vertical !== selectedVertical) {
          return poseDist;
        }
      }
      return [0, 0];
    });
    dists[index2] = dist;
    var nextPoses = controlPoses.map(function(pos, i) {
      return plus(pos.pos, dists[i]);
    });
    datas.prevDist = [distX, distY];
    triggerRoundEvent(moveable, e2, dist, delta, controlPoses, nextPoses);
    return true;
  },
  dragControlEnd: function(moveable, e2) {
    var state = moveable.state;
    state.borderRadiusState = "";
    var datas = e2.datas, isDouble = e2.isDouble;
    if (!datas.isRound) {
      return false;
    }
    var width = state.width, height = state.height;
    var isControl = datas.isControl, controlIndex = datas.controlIndex, isLine = datas.isLine, lineIndex = datas.lineIndex;
    var controlPoses = datas.controlPoses;
    var poses = controlPoses.map(function(pos) {
      return pos.pos;
    });
    var length = poses.length;
    var _a2 = moveable.props.roundClickable, roundClickable = _a2 === void 0 ? true : _a2;
    if (isDouble && roundClickable) {
      if (isControl) {
        removeRadiusPos(controlPoses, poses, controlIndex, 0);
      } else if (isLine) {
        var _b = calculatePointerDist(moveable, e2), distX = _b[0], distY = _b[1];
        addBorderRadius(controlPoses, poses, lineIndex, distX, distY, width, height);
      }
      if (length !== controlPoses.length) {
        triggerRoundEvent(moveable, e2, [0, 0], [0, 0], controlPoses, poses);
      }
    }
    triggerEvent(moveable, "onRoundEnd", fillEndParams(moveable, e2, {}));
    state.borderRadiusState = "";
    return true;
  },
  unset: function(moveable) {
    moveable.state.borderRadiusState = "";
  }
};
var BeforeRenderable = {
  isPinch: true,
  name: "beforeRenderable",
  props: {},
  events: {
    onBeforeRenderStart: "beforeRenderStart",
    onBeforeRender: "beforeRender",
    onBeforeRenderEnd: "beforeRenderEnd",
    onBeforeRenderGroupStart: "beforeRenderGroupStart",
    onBeforeRenderGroup: "beforeRenderGroup",
    onBeforeRenderGroupEnd: "beforeRenderGroupEnd"
  },
  setTransform: function(moveable, e2) {
    var _a2 = moveable.state, is3d = _a2.is3d, target = _a2.target, targetMatrix = _a2.targetMatrix;
    var transform2 = target === null || target === void 0 ? void 0 : target.style.transform;
    var cssMatrix = is3d ? "matrix3d(" + targetMatrix.join(",") + ")" : "matrix(" + convertMatrixtoCSS(targetMatrix, true) + ")";
    e2.datas.startTransforms = !transform2 || transform2 === "none" ? [cssMatrix] : splitSpace(transform2);
  },
  resetTransform: function(moveable, e2) {
    e2.datas.nextTransforms = e2.datas.startTransforms;
    e2.datas.nextTransformAppendedIndexes = [];
  },
  fillDragStartParams: function(moveable, e2) {
    return fillParams(moveable, e2, {
      setTransform: function(transform2) {
        e2.datas.startTransforms = isArray$1(transform2) ? transform2 : splitSpace(transform2);
      },
      isPinch: !!e2.isPinch
    });
  },
  fillDragParams: function(moveable, e2) {
    return fillParams(moveable, e2, {
      isPinch: !!e2.isPinch
    });
  },
  dragStart: function(moveable, e2) {
    this.setTransform(moveable, e2);
    triggerEvent(moveable, "onBeforeRenderStart", this.fillDragStartParams(moveable, e2));
  },
  drag: function(moveable, e2) {
    this.resetTransform(moveable, e2);
    triggerEvent(moveable, "onBeforeRender", fillParams(moveable, e2, {
      isPinch: !!e2.isPinch
    }));
  },
  dragEnd: function(moveable, e2) {
    triggerEvent(moveable, "onBeforeRenderEnd", fillParams(moveable, e2, {
      isPinch: !!e2.isPinch,
      isDrag: e2.isDrag
    }));
  },
  dragGroupStart: function(moveable, e2) {
    var _this = this;
    this.dragStart(moveable, e2);
    var events2 = fillChildEvents(moveable, "beforeRenderable", e2);
    var moveables = moveable.moveables;
    var params = events2.map(function(childEvent, i) {
      var childMoveable = moveables[i];
      _this.setTransform(childMoveable, childEvent);
      return _this.fillDragStartParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onBeforeRenderGroupStart", fillParams(moveable, e2, {
      isPinch: !!e2.isPinch,
      targets: moveable.props.targets,
      setTransform: function() {
      },
      events: params
    }));
  },
  dragGroup: function(moveable, e2) {
    var _this = this;
    this.drag(moveable, e2);
    var events2 = fillChildEvents(moveable, "beforeRenderable", e2);
    var moveables = moveable.moveables;
    var params = events2.map(function(childEvent, i) {
      var childMoveable = moveables[i];
      _this.resetTransform(childMoveable, childEvent);
      return _this.fillDragParams(childMoveable, childEvent);
    });
    triggerEvent(moveable, "onBeforeRenderGroup", fillParams(moveable, e2, {
      isPinch: !!e2.isPinch,
      targets: moveable.props.targets,
      events: params
    }));
  },
  dragGroupEnd: function(moveable, e2) {
    this.dragEnd(moveable, e2);
    triggerEvent(moveable, "onBeforeRenderGroupEnd", fillParams(moveable, e2, {
      isPinch: !!e2.isPinch,
      isDrag: e2.isDrag,
      targets: moveable.props.targets
    }));
  },
  dragControlStart: function(moveable, e2) {
    return this.dragStart(moveable, e2);
  },
  dragControl: function(moveable, e2) {
    return this.drag(moveable, e2);
  },
  dragControlEnd: function(moveable, e2) {
    return this.dragEnd(moveable, e2);
  },
  dragGroupControlStart: function(moveable, e2) {
    return this.dragGroupStart(moveable, e2);
  },
  dragGroupControl: function(moveable, e2) {
    return this.dragGroup(moveable, e2);
  },
  dragGroupControlEnd: function(moveable, e2) {
    return this.dragGroupEnd(moveable, e2);
  }
};
var Renderable = {
  name: "renderable",
  props: {},
  events: {
    onRenderStart: "renderStart",
    onRender: "render",
    onRenderEnd: "renderEnd",
    onRenderGroupStart: "renderGroupStart",
    onRenderGroup: "renderGroup",
    onRenderGroupEnd: "renderGroupEnd"
  },
  dragStart: function(moveable, e2) {
    triggerEvent(moveable, "onRenderStart", fillParams(moveable, e2, {
      isPinch: !!e2.isPinch
    }));
  },
  drag: function(moveable, e2) {
    triggerEvent(moveable, "onRender", fillParams(moveable, e2, {
      isPinch: !!e2.isPinch
    }));
  },
  dragEnd: function(moveable, e2) {
    triggerEvent(moveable, "onRenderEnd", fillParams(moveable, e2, {
      isPinch: !!e2.isPinch,
      isDrag: e2.isDrag
    }));
  },
  dragGroupStart: function(moveable, e2) {
    triggerEvent(moveable, "onRenderGroupStart", fillParams(moveable, e2, {
      isPinch: !!e2.isPinch,
      targets: moveable.props.targets
    }));
  },
  dragGroup: function(moveable, e2) {
    triggerEvent(moveable, "onRenderGroup", fillParams(moveable, e2, {
      isPinch: !!e2.isPinch,
      targets: moveable.props.targets
    }));
  },
  dragGroupEnd: function(moveable, e2) {
    triggerEvent(moveable, "onRenderGroupEnd", fillParams(moveable, e2, {
      isPinch: !!e2.isPinch,
      isDrag: e2.isDrag,
      targets: moveable.props.targets
    }));
  },
  dragControlStart: function(moveable, e2) {
    return this.dragStart(moveable, e2);
  },
  dragControl: function(moveable, e2) {
    return this.drag(moveable, e2);
  },
  dragControlEnd: function(moveable, e2) {
    return this.dragEnd(moveable, e2);
  },
  dragGroupControlStart: function(moveable, e2) {
    return this.dragGroupStart(moveable, e2);
  },
  dragGroupControl: function(moveable, e2) {
    return this.dragGroup(moveable, e2);
  },
  dragGroupControlEnd: function(moveable, e2) {
    return this.dragGroupEnd(moveable, e2);
  }
};
function triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e2, requestInstant) {
  var isStart = eventType === "Start";
  var target = moveable.state.target;
  var isRequest = e2.isRequest;
  if (!target || isStart && eventAffix.indexOf("Control") > -1 && !isRequest && moveable.areaElement === e2.inputEvent.target) {
    return false;
  }
  var eventName = "" + eventOperation + eventAffix + eventType;
  var conditionName = "" + eventOperation + eventAffix + "Condition";
  var isEnd = eventType === "End";
  var isAfter = eventType.indexOf("After") > -1;
  var isFirstStart = isStart && (!moveable.targetGesto || !moveable.controlGesto || !moveable.targetGesto.isFlag() || !moveable.controlGesto.isFlag());
  if (isFirstStart) {
    moveable.updateRect(eventType, true, false);
  }
  if (eventType === "" && !isAfter && !isRequest) {
    convertDragDist(moveable.state, e2);
  }
  var ables = __spreadArrays$2([BeforeRenderable], moveable[ableType].slice(), [Renderable]);
  if (isRequest) {
    var requestAble_1 = e2.requestAble;
    if (!ables.some(function(able) {
      return able.name === requestAble_1;
    })) {
      ables.push.apply(ables, moveable.props.ables.filter(function(able) {
        return able.name === requestAble_1;
      }));
    }
  }
  if (!ables.length) {
    return false;
  }
  var events2 = ables.filter(function(able) {
    return able[eventName];
  });
  var datas = e2.datas;
  if (isFirstStart) {
    events2.forEach(function(able) {
      able.unset && able.unset(moveable);
    });
  }
  var inputEvent = e2.inputEvent;
  var inputTarget;
  if (isEnd && inputEvent) {
    inputTarget = document.elementFromPoint(e2.clientX, e2.clientY) || inputEvent.target;
  }
  var results = events2.filter(function(able) {
    var ableName = able.name;
    var nextDatas = datas[ableName] || (datas[ableName] = {});
    if (isStart) {
      nextDatas.isEventStart = !able[conditionName] || able[conditionName](moveable, e2);
    }
    if (nextDatas.isEventStart) {
      return able[eventName](moveable, __assign$7(__assign$7({}, e2), {
        datas: nextDatas,
        originalDatas: datas,
        inputTarget
      }));
    }
    return false;
  });
  var isUpdate = results.length;
  var isForceEnd = isStart && events2.length && !isUpdate;
  if (isEnd || isForceEnd) {
    moveable.state.gesto = null;
    if (moveable.moveables) {
      moveable.moveables.forEach(function(childMoveable) {
        childMoveable.state.gesto = null;
      });
    }
  }
  if (isFirstStart && isForceEnd) {
    events2.forEach(function(able) {
      able.unset && able.unset(moveable);
    });
  }
  if (moveable.isUnmounted || isForceEnd) {
    return false;
  }
  if (!isStart && isUpdate && !requestInstant || isEnd) {
    moveable.updateRect(eventType, true, false);
    moveable.forceUpdate();
  }
  if (!isStart && !isEnd && !isAfter && isUpdate && !requestInstant) {
    triggerAble(moveable, ableType, eventOperation, eventAffix, eventType + "After", e2);
  }
  return true;
}
function getTargetAbleGesto(moveable, moveableTarget, eventAffix) {
  var controlBox = moveable.controlBox.getElement();
  var targets = [];
  targets.push(controlBox);
  if (!moveable.props.dragArea || moveable.props.dragTarget) {
    targets.push(moveableTarget);
  }
  var startFunc = function(e2) {
    var eventTarget = e2.inputEvent.target;
    var areaElement = moveable.areaElement;
    return eventTarget === areaElement || !moveable.isMoveableElement(eventTarget) || hasClass(eventTarget, "moveable-area") || hasClass(eventTarget, "moveable-padding");
  };
  return getAbleGesto(moveable, targets, "targetAbles", eventAffix, {
    dragStart: startFunc,
    pinchStart: startFunc
  });
}
function getAbleGesto(moveable, target, ableType, eventAffix, conditionFunctions) {
  if (conditionFunctions === void 0) {
    conditionFunctions = {};
  }
  var _a2 = moveable.props, pinchOutside = _a2.pinchOutside, pinchThreshold = _a2.pinchThreshold;
  var options = {
    container: window,
    pinchThreshold,
    pinchOutside
  };
  var gesto = new Gesto(target, options);
  ["drag", "pinch"].forEach(function(eventOperation) {
    ["Start", "", "End"].forEach(function(eventType) {
      gesto.on("" + eventOperation + eventType, function(e2) {
        var eventName = e2.eventType;
        if (conditionFunctions[eventName] && !conditionFunctions[eventName](e2)) {
          e2.stop();
          return;
        }
        var result = triggerAble(moveable, ableType, eventOperation, eventAffix, eventType, e2);
        if (!result) {
          e2.stop();
        }
      });
    });
  });
  return gesto;
}
var EventManager = /* @__PURE__ */ function() {
  function EventManager2(target, moveable, eventName) {
    var _this = this;
    this.target = target;
    this.moveable = moveable;
    this.eventName = eventName;
    this.ables = [];
    this.onEvent = function(e2) {
      var eventName2 = _this.eventName;
      var moveable2 = _this.moveable;
      if (moveable2.state.disableNativeEvent) {
        return;
      }
      _this.ables.forEach(function(able) {
        able[eventName2](moveable2, {
          inputEvent: e2
        });
      });
    };
    this.target.addEventListener(this.eventName.toLowerCase(), this.onEvent);
  }
  var __proto = EventManager2.prototype;
  __proto.setAbles = function(ables) {
    this.ables = ables;
  };
  __proto.destroy = function() {
    this.target.removeEventListener(this.eventName.toLowerCase(), this.onEvent);
    this.target = null;
    this.moveable = null;
  };
  return EventManager2;
}();
var MoveableManager$1 = /* @__PURE__ */ function(_super) {
  __extends$9(MoveableManager2, _super);
  function MoveableManager2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = __assign$7({
      container: null,
      target: null,
      gesto: null,
      renderPoses: [[0, 0], [0, 0], [0, 0], [0, 0]],
      disableNativeEvent: false
    }, getTargetInfo(null));
    _this.enabledAbles = [];
    _this.targetAbles = [];
    _this.controlAbles = [];
    _this.rotation = 0;
    _this.scale = [1, 1];
    _this.isUnmounted = false;
    _this.events = {
      "mouseEnter": null,
      "mouseLeave": null
    };
    _this.onPreventClick = function(e2) {
      e2.stopPropagation();
      removeEvent(window, "click", _this.onPreventClick, true);
    };
    return _this;
  }
  var __proto = MoveableManager2.prototype;
  __proto.render = function() {
    var props2 = this.props;
    var state = this.state;
    var edge = props2.edge, parentPosition = props2.parentPosition, className = props2.className, propsTarget = props2.target, zoom = props2.zoom, cspNonce = props2.cspNonce, translateZ = props2.translateZ, ControlBoxElement = props2.cssStyled, portalContainer = props2.portalContainer;
    this.checkUpdate();
    this.updateRenderPoses();
    var _a2 = parentPosition || {
      left: 0,
      top: 0
    }, parentLeft = _a2.left, parentTop = _a2.top;
    var left = state.left, top = state.top, stateTarget = state.target, direction2 = state.direction, renderPoses = state.renderPoses;
    var groupTargets = props2.targets;
    var isDisplay = (groupTargets && groupTargets.length || propsTarget) && stateTarget;
    var isDragging = this.isDragging();
    var ableAttributes = {};
    var Renderer2 = {
      createElement: createElement$1
    };
    this.getEnabledAbles().forEach(function(able) {
      ableAttributes["data-able-" + able.name.toLowerCase()] = true;
    });
    return createElement$1(ControlBoxElement, __assign$7({
      cspNonce,
      ref: ref(this, "controlBox"),
      className: prefix$2("control-box", direction2 === -1 ? "reverse" : "", isDragging ? "dragging" : "") + " " + className
    }, ableAttributes, {
      onClick: this.onPreventClick,
      portalContainer,
      style: {
        "position": "absolute",
        "display": isDisplay ? "block" : "none",
        "transform": "translate3d(" + (left - parentLeft) + "px, " + (top - parentTop) + "px, " + translateZ + ")",
        "--zoom": zoom,
        "--zoompx": zoom + "px"
      }
    }), this.renderAbles(), renderLine(Renderer2, edge ? "n" : "", renderPoses[0], renderPoses[1], zoom, 0), renderLine(Renderer2, edge ? "e" : "", renderPoses[1], renderPoses[3], zoom, 1), renderLine(Renderer2, edge ? "w" : "", renderPoses[0], renderPoses[2], zoom, 2), renderLine(Renderer2, edge ? "s" : "", renderPoses[2], renderPoses[3], zoom, 3));
  };
  __proto.componentDidMount = function() {
    this.controlBox.getElement();
    var props2 = this.props;
    var parentMoveable = props2.parentMoveable, container = props2.container, wrapperMoveable = props2.wrapperMoveable;
    this.updateEvent(props2);
    this.updateNativeEvents(props2);
    if (!container && !parentMoveable && !wrapperMoveable) {
      this.updateRect("", false, true);
    }
    this.updateCheckInput();
  };
  __proto.componentDidUpdate = function(prevProps) {
    this.updateNativeEvents(prevProps);
    this.updateEvent(prevProps);
    this.updateCheckInput();
  };
  __proto.componentWillUnmount = function() {
    this.isUnmounted = true;
    unset(this, "targetGesto");
    unset(this, "controlGesto");
    var events2 = this.events;
    for (var name2 in events2) {
      var manager = events2[name2];
      manager && manager.destroy();
    }
  };
  __proto.getContainer = function() {
    var _a2 = this.props, parentMoveable = _a2.parentMoveable, wrapperMoveable = _a2.wrapperMoveable, container = _a2.container;
    return container || wrapperMoveable && wrapperMoveable.getContainer() || parentMoveable && parentMoveable.getContainer() || this.controlBox.getElement().parentElement;
  };
  __proto.isMoveableElement = function(target) {
    return target && (target.getAttribute("class") || "").indexOf(PREFIX$1) > -1;
  };
  __proto.dragStart = function(e2) {
    if (this.targetGesto) {
      this.targetGesto.triggerDragStart(e2);
    }
    return this;
  };
  __proto.hitTest = function(el) {
    var _a2 = this.state, target = _a2.target, pos1 = _a2.pos1, pos2 = _a2.pos2, pos3 = _a2.pos3, pos4 = _a2.pos4, targetClientRect = _a2.targetClientRect;
    if (!target) {
      return 0;
    }
    var rect;
    if (el instanceof Element) {
      var clientRect = el.getBoundingClientRect();
      rect = {
        left: clientRect.left,
        top: clientRect.top,
        width: clientRect.width,
        height: clientRect.height
      };
    } else {
      rect = __assign$7({
        width: 0,
        height: 0
      }, el);
    }
    var rectLeft = rect.left, rectTop = rect.top, rectWidth = rect.width, rectHeight = rect.height;
    var points = fitPoints([pos1, pos2, pos4, pos3], targetClientRect);
    var size = getOverlapSize(points, [[rectLeft, rectTop], [rectLeft + rectWidth, rectTop], [rectLeft + rectWidth, rectTop + rectHeight], [rectLeft, rectTop + rectHeight]]);
    var totalSize = getAreaSize(points);
    if (!size || !totalSize) {
      return 0;
    }
    return Math.min(100, size / totalSize * 100);
  };
  __proto.isInside = function(clientX, clientY) {
    var _a2 = this.state, target = _a2.target, pos1 = _a2.pos1, pos2 = _a2.pos2, pos3 = _a2.pos3, pos4 = _a2.pos4, targetClientRect = _a2.targetClientRect;
    if (!target) {
      return false;
    }
    return isInside([clientX, clientY], fitPoints([pos1, pos2, pos4, pos3], targetClientRect));
  };
  __proto.updateRect = function(type, isTarget, isSetState) {
    if (isSetState === void 0) {
      isSetState = true;
    }
    var props2 = this.props;
    var parentMoveable = props2.parentMoveable;
    var state = this.state;
    var target = state.target || this.props.target;
    var container = this.getContainer();
    var rootContainer = parentMoveable ? parentMoveable.props.rootContainer : props2.rootContainer;
    this.updateState(getTargetInfo(this.controlBox && this.controlBox.getElement(), target, container, container, rootContainer || container), parentMoveable ? false : isSetState);
  };
  __proto.isTargetChanged = function(prevProps, useDragArea) {
    var props2 = this.props;
    var target = props2.dragTarget || props2.target;
    var prevTarget = prevProps.dragTarget || prevProps.target;
    var dragArea = props2.dragArea;
    var prevDragArea = prevProps.dragArea;
    var isTargetChanged = !dragArea && prevTarget !== target;
    return isTargetChanged || (useDragArea || dragArea) && prevDragArea !== dragArea;
  };
  __proto.updateNativeEvents = function(prevProps) {
    var _this = this;
    var props2 = this.props;
    var target = props2.dragArea ? this.areaElement : this.state.target;
    var events2 = this.events;
    var eventKeys = getKeys(events2);
    if (this.isTargetChanged(prevProps)) {
      for (var eventName in events2) {
        var manager = events2[eventName];
        manager && manager.destroy();
        events2[eventName] = null;
      }
    }
    if (!target) {
      return;
    }
    var enabledAbles = this.enabledAbles;
    eventKeys.forEach(function(eventName2) {
      var ables = filterAbles(enabledAbles, [eventName2]);
      var hasAbles = ables.length > 0;
      var manager2 = events2[eventName2];
      if (!hasAbles) {
        if (manager2) {
          manager2.destroy();
          events2[eventName2] = null;
        }
        return;
      }
      if (!manager2) {
        manager2 = new EventManager(target, _this, eventName2);
        events2[eventName2] = manager2;
      }
      manager2.setAbles(ables);
    });
  };
  __proto.updateEvent = function(prevProps) {
    var controlBoxElement = this.controlBox.getElement();
    var hasTargetAble = this.targetAbles.length;
    var hasControlAble = this.controlAbles.length;
    var props2 = this.props;
    var target = props2.dragTarget || props2.target;
    var isTargetChanged = this.isTargetChanged(prevProps, true);
    var isUnset = !hasTargetAble && this.targetGesto || isTargetChanged;
    if (isUnset) {
      unset(this, "targetGesto");
      this.updateState({
        gesto: null
      });
    }
    if (!hasControlAble) {
      unset(this, "controlGesto");
    }
    if (target && hasTargetAble && !this.targetGesto) {
      this.targetGesto = getTargetAbleGesto(this, target, "");
    }
    if (!this.controlGesto && hasControlAble) {
      this.controlGesto = getAbleGesto(this, controlBoxElement, "controlAbles", "Control");
    }
    if (isUnset) {
      this.unsetAbles();
    }
  };
  __proto.isDragging = function() {
    return (this.targetGesto ? this.targetGesto.isFlag() : false) || (this.controlGesto ? this.controlGesto.isFlag() : false);
  };
  __proto.updateTarget = function(type) {
    this.updateRect(type, true);
  };
  __proto.getRect = function() {
    var state = this.state;
    var poses = getAbsolutePosesByState(this.state);
    var pos1 = poses[0], pos2 = poses[1], pos3 = poses[2], pos4 = poses[3];
    var rect = getRect$2(poses);
    var offsetWidth = state.width, offsetHeight = state.height;
    var width = rect.width, height = rect.height, left = rect.left, top = rect.top;
    var statePos = [state.left, state.top];
    var origin = plus(statePos, state.origin);
    var beforeOrigin = plus(statePos, state.beforeOrigin);
    var transformOrigin2 = state.transformOrigin;
    return {
      width,
      height,
      left,
      top,
      pos1,
      pos2,
      pos3,
      pos4,
      offsetWidth,
      offsetHeight,
      beforeOrigin,
      origin,
      transformOrigin: transformOrigin2,
      rotation: this.getRotation()
    };
  };
  __proto.getManager = function() {
    return this;
  };
  __proto.getRotation = function() {
    var _a2 = this.state, pos1 = _a2.pos1, pos2 = _a2.pos2, direction2 = _a2.direction;
    return getAbsoluteRotation(pos1, pos2, direction2);
  };
  __proto.request = function(ableName, param, isInstant) {
    if (param === void 0) {
      param = {};
    }
    var _a2 = this.props, ables = _a2.ables, groupable = _a2.groupable;
    var requsetAble = ables.filter(function(able) {
      return able.name === ableName;
    })[0];
    if (this.isDragging() || !requsetAble || !requsetAble.request) {
      return {
        request: function() {
          return this;
        },
        requestEnd: function() {
          return this;
        }
      };
    }
    var self2 = this;
    var ableRequester = requsetAble.request(this);
    var requestInstant = isInstant || param.isInstant;
    var ableType = ableRequester.isControl ? "controlAbles" : "targetAbles";
    var eventAffix = (groupable ? "Group" : "") + (ableRequester.isControl ? "Control" : "");
    var requester = {
      request: function(ableParam) {
        triggerAble(self2, ableType, "drag", eventAffix, "", __assign$7(__assign$7({}, ableRequester.request(ableParam)), {
          requestAble: ableName,
          isRequest: true
        }), requestInstant);
        return this;
      },
      requestEnd: function() {
        triggerAble(self2, ableType, "drag", eventAffix, "End", __assign$7(__assign$7({}, ableRequester.requestEnd()), {
          requestAble: ableName,
          isRequest: true
        }), requestInstant);
        return this;
      }
    };
    triggerAble(self2, ableType, "drag", eventAffix, "Start", __assign$7(__assign$7({}, ableRequester.requestStart(param)), {
      requestAble: ableName,
      isRequest: true
    }), requestInstant);
    return requestInstant ? requester.request(param).requestEnd() : requester;
  };
  __proto.destroy = function() {
    this.componentWillUnmount();
  };
  __proto.updateRenderPoses = function() {
    var state = this.state;
    var props2 = this.props;
    var originalBeforeOrigin = state.originalBeforeOrigin, transformOrigin2 = state.transformOrigin, allMatrix = state.allMatrix, is3d = state.is3d, pos1 = state.pos1, pos2 = state.pos2, pos3 = state.pos3, pos4 = state.pos4, stateLeft = state.left, stateTop = state.top;
    var _a2 = props2.padding || {}, _b = _a2.left, left = _b === void 0 ? 0 : _b, _c = _a2.top, top = _c === void 0 ? 0 : _c, _d = _a2.bottom, bottom = _d === void 0 ? 0 : _d, _e = _a2.right, right = _e === void 0 ? 0 : _e;
    var n = is3d ? 4 : 3;
    var absoluteOrigin = props2.groupable ? originalBeforeOrigin : plus(originalBeforeOrigin, [stateLeft, stateTop]);
    state.renderPoses = [plus(pos1, calculatePadding(allMatrix, [-left, -top], transformOrigin2, absoluteOrigin, n)), plus(pos2, calculatePadding(allMatrix, [right, -top], transformOrigin2, absoluteOrigin, n)), plus(pos3, calculatePadding(allMatrix, [-left, bottom], transformOrigin2, absoluteOrigin, n)), plus(pos4, calculatePadding(allMatrix, [right, bottom], transformOrigin2, absoluteOrigin, n))];
  };
  __proto.checkUpdate = function() {
    var _a2 = this.props, target = _a2.target, container = _a2.container, parentMoveable = _a2.parentMoveable;
    var _b = this.state, stateTarget = _b.target, stateContainer = _b.container;
    if (!stateTarget && !target) {
      return;
    }
    this.updateAbles();
    var isChanged = !equals(stateTarget, target) || !equals(stateContainer, container);
    if (!isChanged) {
      return;
    }
    this.updateState({
      target,
      container
    });
    if (!parentMoveable && (container || this.controlBox)) {
      this.updateRect("End", false, false);
    }
  };
  __proto.triggerEvent = function(name2, e2) {
    var callback = this.props[name2];
    return callback && callback(e2);
  };
  __proto.useCSS = function(tag, css2) {
    var customStyleMap = this.props.customStyledMap;
    var key = tag + css2;
    if (!customStyleMap[key]) {
      customStyleMap[key] = styled(tag, css2);
    }
    return customStyleMap[key];
  };
  __proto.unsetAbles = function() {
    var _this = this;
    if (this.targetAbles.filter(function(able) {
      if (able.unset) {
        able.unset(_this);
        return true;
      }
      return false;
    }).length) {
      this.forceUpdate();
    }
  };
  __proto.updateAbles = function(ables, eventAffix) {
    if (ables === void 0) {
      ables = this.props.ables;
    }
    if (eventAffix === void 0) {
      eventAffix = "";
    }
    var props2 = this.props;
    var triggerAblesSimultaneously = props2.triggerAblesSimultaneously;
    var enabledAbles = ables.filter(function(able) {
      return able && (able.always || props2[able.name]);
    });
    var dragStart2 = "drag" + eventAffix + "Start";
    var pinchStart = "pinch" + eventAffix + "Start";
    var dragControlStart = "drag" + eventAffix + "ControlStart";
    var targetAbles = filterAbles(enabledAbles, [dragStart2, pinchStart], triggerAblesSimultaneously);
    var controlAbles = filterAbles(enabledAbles, [dragControlStart], triggerAblesSimultaneously);
    this.enabledAbles = enabledAbles;
    this.targetAbles = targetAbles;
    this.controlAbles = controlAbles;
  };
  __proto.updateState = function(nextState, isSetState) {
    if (isSetState) {
      this.setState(nextState);
    } else {
      var state = this.state;
      for (var name2 in nextState) {
        state[name2] = nextState[name2];
      }
    }
  };
  __proto.getEnabledAbles = function() {
    var props2 = this.props;
    var ables = props2.ables;
    return ables.filter(function(able) {
      return able && props2[able.name];
    });
  };
  __proto.renderAbles = function() {
    var _this = this;
    var props2 = this.props;
    var triggerAblesSimultaneously = props2.triggerAblesSimultaneously;
    var Renderer2 = {
      createElement: createElement$1
    };
    return groupByMap(flat(filterAbles(this.getEnabledAbles(), ["render"], triggerAblesSimultaneously).map(function(_a2) {
      var render2 = _a2.render;
      return render2(_this, Renderer2) || [];
    })).filter(function(el) {
      return el;
    }), function(_a2) {
      var key = _a2.key;
      return key;
    }).map(function(group) {
      return group[0];
    });
  };
  __proto.updateCheckInput = function() {
    this.targetGesto && (this.targetGesto.options.checkInput = this.props.checkInput);
  };
  MoveableManager2.defaultProps = {
    target: null,
    dragTarget: null,
    container: null,
    rootContainer: null,
    origin: true,
    edge: false,
    parentMoveable: null,
    wrapperMoveable: null,
    parentPosition: null,
    portalContainer: null,
    ables: [],
    pinchThreshold: 20,
    dragArea: false,
    passDragArea: false,
    transformOrigin: "",
    className: "",
    zoom: 1,
    triggerAblesSimultaneously: false,
    padding: {},
    pinchOutside: true,
    checkInput: false,
    groupable: false,
    cspNonce: "",
    translateZ: 0,
    cssStyled: null,
    customStyledMap: {},
    props: {}
  };
  return MoveableManager2;
}(PureComponent);
var Groupable = {
  name: "groupable",
  props: {
    defaultGroupRotate: Number,
    defaultGroupOrigin: String,
    groupable: Boolean
  },
  events: {},
  render: function(moveable, React) {
    var targets = moveable.props.targets || [];
    moveable.moveables = [];
    var _a2 = moveable.state, left = _a2.left, top = _a2.top;
    var position2 = {
      left,
      top
    };
    return targets.map(function(target, i) {
      return React.createElement(MoveableManager$1, {
        key: "moveable" + i,
        ref: refs(moveable, "moveables", i),
        target,
        origin: false,
        cssStyled: moveable.props.cssStyled,
        customStyledMap: moveable.props.customStyledMap,
        parentMoveable: moveable,
        parentPosition: position2
      });
    });
  }
};
var Clickable = makeAble("clickable", {
  props: {},
  events: {
    onClick: "click",
    onClickGroup: "clickGroup"
  },
  always: true,
  dragStart: function(moveable, e2) {
    if (!e2.isRequest) {
      addEvent$1(window, "click", moveable.onPreventClick, true);
    }
  },
  dragControlStart: function(moveable, e2) {
    this.dragStart(moveable, e2);
  },
  dragGroupStart: function(moveable, e2) {
    this.dragStart(moveable, e2);
    e2.datas.inputTarget = e2.inputEvent && e2.inputEvent.target;
  },
  dragEnd: function(moveable, e2) {
    this.endEvent(moveable);
    var target = moveable.state.target;
    var inputEvent = e2.inputEvent;
    var inputTarget = e2.inputTarget;
    if (!inputEvent || !inputTarget || e2.isDrag || moveable.isMoveableElement(inputTarget)) {
      return;
    }
    var containsTarget = target.contains(inputTarget);
    triggerEvent(moveable, "onClick", fillParams(moveable, e2, {
      isDouble: e2.isDouble,
      inputTarget,
      isTarget: target === inputTarget,
      containsTarget
    }));
  },
  dragGroupEnd: function(moveable, e2) {
    this.endEvent(moveable);
    var inputEvent = e2.inputEvent;
    var inputTarget = e2.inputTarget;
    if (!inputEvent || !inputTarget || e2.isDrag || moveable.isMoveableElement(inputTarget) || e2.datas.inputTarget === inputTarget) {
      return;
    }
    var targets = moveable.props.targets;
    var targetIndex = targets.indexOf(inputTarget);
    var isTarget = targetIndex > -1;
    var containsTarget = false;
    if (targetIndex === -1) {
      targetIndex = findIndex(targets, function(parentTarget) {
        return parentTarget.contains(inputTarget);
      });
      containsTarget = targetIndex > -1;
    }
    triggerEvent(moveable, "onClickGroup", fillParams(moveable, e2, {
      isDouble: e2.isDouble,
      targets,
      inputTarget,
      targetIndex,
      isTarget,
      containsTarget
    }));
  },
  dragControlEnd: function(moveable) {
    this.endEvent(moveable);
  },
  dragGroupControlEnd: function(moveable) {
    this.endEvent(moveable);
  },
  endEvent: function(moveable) {
    var _this = this;
    requestAnimationFrame(function() {
      _this.unset(moveable);
    });
  },
  unset: function(moveable) {
    removeEvent(window, "click", moveable.onPreventClick, true);
  }
});
function getDraggableEvent(e2) {
  var datas = e2.originalDatas.draggable;
  if (!datas) {
    e2.originalDatas.draggable = {};
    datas = e2.originalDatas.draggable;
  }
  return __assign$7(__assign$7({}, e2), {
    datas
  });
}
var edgeDraggable = makeAble("edgeDraggable", {
  dragControlCondition: function(moveable, e2) {
    if (!moveable.props.edgeDraggable || !e2.inputEvent) {
      return false;
    }
    var target = e2.inputEvent.target;
    return hasClass(target, prefix$2("direction")) && hasClass(target, prefix$2("line"));
  },
  dragControlStart: function(moveable, e2) {
    return Draggable.dragStart(moveable, getDraggableEvent(e2));
  },
  dragControl: function(moveable, e2) {
    return Draggable.drag(moveable, getDraggableEvent(e2));
  },
  dragControlEnd: function(moveable, e2) {
    return Draggable.dragEnd(moveable, getDraggableEvent(e2));
  },
  dragGroupControlCondition: function(moveable, e2) {
    if (!moveable.props.edgeDraggable || !e2.inputEvent) {
      return false;
    }
    var target = e2.inputEvent.target;
    return hasClass(target, prefix$2("direction")) && hasClass(target, prefix$2("line"));
  },
  dragGroupControlStart: function(moveable, e2) {
    return Draggable.dragGroupStart(moveable, getDraggableEvent(e2));
  },
  dragGroupControl: function(moveable, e2) {
    return Draggable.dragGroup(moveable, getDraggableEvent(e2));
  },
  dragGroupControlEnd: function(moveable, e2) {
    return Draggable.dragGroupEnd(moveable, getDraggableEvent(e2));
  },
  unset: function(moveable) {
    moveable.state.dragInfo = null;
  }
});
var IndividualGroupable = {
  name: "individualGroupable",
  props: {
    individualGroupable: Boolean
  },
  events: {}
};
var MOVEABLE_ABLES = [BeforeRenderable, Default, Snappable, Pinchable, Draggable, edgeDraggable, Rotatable, Resizable, Scalable, Warpable, Scrollable, Padding, Origin, OriginDraggable, Clippable, Roundable, Groupable, IndividualGroupable, Clickable, DragArea, Renderable];
var MOVEABLE_EVENTS_PROPS_MAP = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(current, able) {
  return __assign$7(__assign$7({}, current), "events" in able ? able.events : {});
}, {});
var MOVEABLE_PROPS_MAP = /* @__PURE__ */ MOVEABLE_ABLES.reduce(function(current, able) {
  return __assign$7(__assign$7({}, current), able.props);
}, {});
var MOVEABLE_EVENTS_MAP = /* @__PURE__ */ invertObject(MOVEABLE_EVENTS_PROPS_MAP);
var MOVEABLE_EVENTS = Object.keys(MOVEABLE_EVENTS_MAP);
var MOVEABLE_PROPS = Object.keys(MOVEABLE_PROPS_MAP);
function getMaxPos(poses, index2) {
  return Math.max.apply(Math, poses.map(function(_a2) {
    var pos1 = _a2[0], pos2 = _a2[1], pos3 = _a2[2], pos4 = _a2[3];
    return Math.max(pos1[index2], pos2[index2], pos3[index2], pos4[index2]);
  }));
}
function getMinPos(poses, index2) {
  return Math.min.apply(Math, poses.map(function(_a2) {
    var pos1 = _a2[0], pos2 = _a2[1], pos3 = _a2[2], pos4 = _a2[3];
    return Math.min(pos1[index2], pos2[index2], pos3[index2], pos4[index2]);
  }));
}
function getGroupRect(moveables, rotation) {
  if (!moveables.length) {
    return [0, 0, 0, 0];
  }
  var moveablePoses = moveables.map(function(_a2) {
    var state = _a2.state;
    return getAbsolutePosesByState(state);
  });
  var minX = MAX_NUM;
  var minY = MAX_NUM;
  var groupWidth = 0;
  var groupHeight = 0;
  var fixedRotation = throttle$3(rotation, TINY_NUM);
  if (fixedRotation % 90) {
    var rad_1 = fixedRotation / 180 * Math.PI;
    var a1_1 = Math.tan(rad_1);
    var a2_1 = -1 / a1_1;
    var b1MinMax_1 = [MIN_NUM, MAX_NUM];
    var b2MinMax_1 = [MIN_NUM, MAX_NUM];
    moveablePoses.forEach(function(poses) {
      poses.forEach(function(pos) {
        var b1 = pos[1] - a1_1 * pos[0];
        var b2 = pos[1] - a2_1 * pos[0];
        b1MinMax_1[0] = Math.max(b1MinMax_1[0], b1);
        b1MinMax_1[1] = Math.min(b1MinMax_1[1], b1);
        b2MinMax_1[0] = Math.max(b2MinMax_1[0], b2);
        b2MinMax_1[1] = Math.min(b2MinMax_1[1], b2);
      });
    });
    b1MinMax_1.forEach(function(b1) {
      b2MinMax_1.forEach(function(b2) {
        var x = (b2 - b1) / (a1_1 - a2_1);
        var y = a1_1 * x + b1;
        minX = Math.min(minX, x);
        minY = Math.min(minY, y);
      });
    });
    var rotatePoses = moveablePoses.map(function(_a2) {
      var pos1 = _a2[0], pos2 = _a2[1], pos3 = _a2[2], pos4 = _a2[3];
      return [rotate(pos1, -rad_1), rotate(pos2, -rad_1), rotate(pos3, -rad_1), rotate(pos4, -rad_1)];
    });
    groupWidth = getMaxPos(rotatePoses, 0) - getMinPos(rotatePoses, 0);
    groupHeight = getMaxPos(rotatePoses, 1) - getMinPos(rotatePoses, 1);
  } else {
    minX = getMinPos(moveablePoses, 0);
    minY = getMinPos(moveablePoses, 1);
    groupWidth = getMaxPos(moveablePoses, 0) - minX;
    groupHeight = getMaxPos(moveablePoses, 1) - minY;
    if (fixedRotation % 180) {
      var changedWidth = groupWidth;
      groupWidth = groupHeight;
      groupHeight = changedWidth;
    }
  }
  return [minX, minY, groupWidth, groupHeight];
}
var MoveableGroup = /* @__PURE__ */ function(_super) {
  __extends$9(MoveableGroup2, _super);
  function MoveableGroup2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.differ = new ChildrenDiffer();
    _this.moveables = [];
    _this.transformOrigin = "50% 50%";
    return _this;
  }
  var __proto = MoveableGroup2.prototype;
  __proto.updateEvent = function(prevProps) {
    var state = this.state;
    var props2 = this.props;
    var prevTarget = prevProps.dragTarget || state.target;
    var nextTarget = props2.dragTarget || this.areaElement;
    if (prevTarget !== nextTarget) {
      unset(this, "targetGesto");
      unset(this, "controlGesto");
      state.target = null;
    }
    if (!state.target) {
      state.target = this.areaElement;
      this.controlBox.getElement().style.display = "block";
      this.targetGesto = getTargetAbleGesto(this, nextTarget, "Group");
      this.controlGesto = getAbleGesto(this, this.controlBox.getElement(), "controlAbles", "GroupControl");
    }
    var isContainerChanged = !equals(prevProps.container, props2.container);
    if (isContainerChanged) {
      state.container = props2.container;
    }
    var _a2 = this.differ.update(props2.targets), added = _a2.added, changed = _a2.changed, removed = _a2.removed;
    if (isContainerChanged || added.length || changed.length || removed.length) {
      this.updateRect();
    }
  };
  __proto.checkUpdate = function() {
    this.updateAbles();
  };
  __proto.updateRect = function(type, isTarget, isSetState) {
    if (isSetState === void 0) {
      isSetState = true;
    }
    if (!this.controlBox) {
      return;
    }
    this.moveables.forEach(function(moveable) {
      moveable.updateRect(type, false, false);
    });
    var state = this.state;
    var props2 = this.props;
    var target = state.target || props2.target;
    if (!isTarget || type !== "" && props2.updateGroup) {
      this.rotation = props2.defaultGroupRotate;
      this.transformOrigin = props2.defaultGroupOrigin || "50% 50%";
      this.scale = [1, 1];
    }
    var rotation = this.rotation;
    var scale = this.scale;
    var _a2 = getGroupRect(this.moveables, rotation), left = _a2[0], top = _a2[1], width = _a2[2], height = _a2[3];
    var transform2 = "rotate(" + rotation + "deg) scale(" + (scale[0] >= 0 ? 1 : -1) + ", " + (scale[1] >= 0 ? 1 : -1) + ")";
    target.style.cssText += "left:0px;top:0px; transform-origin: " + this.transformOrigin + "; width:" + width + "px; height:" + height + "px;" + ("transform:" + transform2);
    state.width = width;
    state.height = height;
    var container = this.getContainer();
    var info = getTargetInfo(this.controlBox.getElement(), target, this.controlBox.getElement(), this.getContainer(), this.props.rootContainer || container);
    var pos = [info.left, info.top];
    var _b = getAbsolutePosesByState(info), pos1 = _b[0], pos2 = _b[1], pos3 = _b[2], pos4 = _b[3];
    var minPos = getMinMaxs([pos1, pos2, pos3, pos4]);
    var delta = [minPos.minX, minPos.minY];
    info.pos1 = minus(pos1, delta);
    info.pos2 = minus(pos2, delta);
    info.pos3 = minus(pos3, delta);
    info.pos4 = minus(pos4, delta);
    info.left = left - info.left + delta[0];
    info.top = top - info.top + delta[1];
    info.origin = minus(plus(pos, info.origin), delta);
    info.beforeOrigin = minus(plus(pos, info.beforeOrigin), delta);
    info.originalBeforeOrigin = plus(pos, info.originalBeforeOrigin);
    var clientRect = info.targetClientRect;
    var direction2 = scale[0] * scale[1] > 0 ? 1 : -1;
    clientRect.top += info.top - state.top;
    clientRect.left += info.left - state.left;
    target.style.transform = "translate(" + -delta[0] + "px, " + -delta[1] + "px) " + transform2;
    this.updateState(__assign$7(__assign$7({}, info), {
      direction: direction2,
      beforeDirection: direction2
    }), isSetState);
  };
  __proto.getRect = function() {
    return __assign$7(__assign$7({}, _super.prototype.getRect.call(this)), {
      children: this.moveables.map(function(child) {
        return child.getRect();
      })
    });
  };
  __proto.triggerEvent = function(name2, e2, isManager) {
    if (isManager || name2.indexOf("Group") > -1) {
      return _super.prototype.triggerEvent.call(this, name2, e2);
    }
  };
  __proto.updateAbles = function() {
    _super.prototype.updateAbles.call(this, __spreadArrays$2(this.props.ables, [Groupable]), "Group");
  };
  MoveableGroup2.defaultProps = __assign$7(__assign$7({}, MoveableManager$1.defaultProps), {
    transformOrigin: ["50%", "50%"],
    groupable: true,
    dragArea: true,
    keepRatio: true,
    targets: [],
    defaultGroupRotate: 0,
    defaultGroupOrigin: "50% 50%"
  });
  return MoveableGroup2;
}(MoveableManager$1);
var MoveableIndividualGroup = /* @__PURE__ */ function(_super) {
  __extends$9(MoveableIndividualGroup2, _super);
  function MoveableIndividualGroup2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.moveables = [];
    return _this;
  }
  var __proto = MoveableIndividualGroup2.prototype;
  __proto.render = function() {
    var _this = this;
    var _a2 = this.props, cspNonce = _a2.cspNonce, ControlBoxElement = _a2.cssStyled, targets = _a2.targets;
    return createElement$1(ControlBoxElement, {
      cspNonce,
      ref: ref(this, "controlBox"),
      className: prefix$2("control-box")
    }, targets.map(function(target, i) {
      return createElement$1(MoveableManager$1, __assign$7({
        key: "moveable" + i,
        ref: refs(_this, "moveables", i)
      }, _this.props, {
        target,
        wrapperMoveable: _this
      }));
    }));
  };
  __proto.componentDidUpdate = function() {
  };
  __proto.updateRect = function(type, isTarget, isSetState) {
    if (isSetState === void 0) {
      isSetState = true;
    }
    this.moveables.forEach(function(moveable) {
      moveable.updateRect(type, isTarget, isSetState);
    });
  };
  __proto.getRect = function() {
    return __assign$7(__assign$7({}, _super.prototype.getRect.call(this)), {
      children: this.moveables.map(function(child) {
        return child.getRect();
      })
    });
  };
  __proto.request = function() {
    return {
      request: function() {
        return this;
      },
      requestEnd: function() {
        return this;
      }
    };
  };
  __proto.dragStart = function() {
    return this;
  };
  __proto.hitTest = function() {
    return 0;
  };
  __proto.isInside = function() {
    return false;
  };
  __proto.isDragging = function() {
    return false;
  };
  __proto.updateRenderPoses = function() {
  };
  __proto.updateEvent = function() {
  };
  __proto.checkUpdate = function() {
  };
  __proto.triggerEvent = function() {
  };
  __proto.updateAbles = function() {
  };
  return MoveableIndividualGroup2;
}(MoveableManager$1);
var InitialMoveable = /* @__PURE__ */ function(_super) {
  __extends$9(InitialMoveable2, _super);
  function InitialMoveable2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.refTargets = [];
    _this.selectorMap = {};
    return _this;
  }
  var __proto = InitialMoveable2.prototype;
  InitialMoveable2.makeStyled = function() {
    var cssMap = {};
    var ables = this.getTotalAbles();
    ables.forEach(function(_a2) {
      var css2 = _a2.css;
      if (!css2) {
        return;
      }
      css2.forEach(function(text) {
        cssMap[text] = true;
      });
    });
    var style = getKeys(cssMap).join("\n");
    this.defaultStyled = styled("div", prefixCSS(PREFIX$1, MOVEABLE_CSS + style));
  };
  InitialMoveable2.getTotalAbles = function() {
    return __spreadArrays$2([Default, Groupable, IndividualGroupable, DragArea], this.defaultAbles);
  };
  __proto.render = function() {
    var moveableContructor = this.constructor;
    if (!moveableContructor.defaultStyled) {
      moveableContructor.makeStyled();
    }
    var _a2 = this.props, userAbles = _a2.ables, userProps = _a2.props, props2 = __rest$2(_a2, ["ables", "props"]);
    var refTargets = getRefTargets(props2.target || props2.targets);
    var elementTargets = getElementTargets(refTargets, this.selectorMap);
    this.refTargets = refTargets;
    var isGroup = elementTargets.length > 1;
    var totalAbles = moveableContructor.getTotalAbles();
    var ables = __spreadArrays$2(totalAbles, userAbles || []);
    var nextProps = __assign$7(__assign$7(__assign$7({}, props2), userProps || {}), {
      ables,
      cssStyled: moveableContructor.defaultStyled,
      customStyledMap: moveableContructor.customStyledMap
    });
    if (isGroup) {
      if (props2.individualGroupable) {
        return createElement$1(MoveableIndividualGroup, __assign$7({
          key: "individual-group",
          ref: ref(this, "moveable")
        }, nextProps, {
          target: null,
          targets: elementTargets
        }));
      }
      return createElement$1(MoveableGroup, __assign$7({
        key: "group",
        ref: ref(this, "moveable")
      }, nextProps, {
        target: null,
        targets: elementTargets
      }));
    } else {
      return createElement$1(MoveableManager$1, __assign$7({
        key: "single",
        ref: ref(this, "moveable")
      }, nextProps, {
        target: elementTargets[0]
      }));
    }
  };
  __proto.componentDidMount = function() {
    this.updateRefs();
  };
  __proto.componentDidUpdate = function() {
    this.updateRefs();
  };
  __proto.updateRefs = function(isReset) {
    var refTargets = getRefTargets(this.props.target || this.props.targets);
    var isUpdate = this.refTargets.some(function(target, i) {
      var nextTarget = refTargets[i];
      if (!target && !nextTarget) {
        return false;
      } else if (target !== nextTarget) {
        return true;
      }
      return false;
    });
    var selectorMap = isReset ? {} : this.selectorMap;
    var nextSelectorMap = {};
    this.refTargets.forEach(function(target) {
      if (isString$2(target)) {
        if (!selectorMap[target]) {
          isUpdate = true;
          nextSelectorMap[target] = [].slice.call(document.querySelectorAll(target));
        } else {
          nextSelectorMap[target] = selectorMap[target];
        }
      }
    });
    this.selectorMap = nextSelectorMap;
    if (isUpdate) {
      this.forceUpdate();
    }
  };
  __proto.getManager = function() {
    return this.moveable;
  };
  InitialMoveable2.defaultAbles = [];
  InitialMoveable2.customStyledMap = {};
  InitialMoveable2.defaultStyled = null;
  __decorate$4([withMethods(MOVEABLE_METHODS)], InitialMoveable2.prototype, "moveable", void 0);
  return InitialMoveable2;
}(PureComponent);
var Moveable$3 = /* @__PURE__ */ function(_super) {
  __extends$9(Moveable2, _super);
  function Moveable2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  Moveable2.defaultAbles = MOVEABLE_ABLES;
  return Moveable2;
}(InitialMoveable);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics$8 = function(d, b) {
  extendStatics$8 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics$8(d, b);
};
function __extends$8(d, b) {
  extendStatics$8(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$6 = function() {
  __assign$6 = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$6.apply(this, arguments);
};
function __decorate$3(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var InnerMoveable = /* @__PURE__ */ function(_super) {
  __extends$8(InnerMoveable2, _super);
  function InnerMoveable2(props2) {
    var _this = _super.call(this, props2) || this;
    _this.state = {};
    _this.state = _this.props;
    return _this;
  }
  var __proto = InnerMoveable2.prototype;
  __proto.render = function() {
    return createPortal(createElement$1(Moveable$3, __assign$6({
      ref: ref(this, "moveable")
    }, this.state)), this.state.parentElement);
  };
  return InnerMoveable2;
}(Component$1);
var PROPERTIES$4 = MOVEABLE_PROPS;
var METHODS$2 = MOVEABLE_METHODS;
var EVENTS$2 = MOVEABLE_EVENTS;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$1$2 = function() {
  __assign$1$2 = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$1$2.apply(this, arguments);
};
function __spreadArrays$1() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a2 = arguments[i], j2 = 0, jl = a2.length; j2 < jl; j2++, k++)
      r[k] = a2[j2];
  return r;
}
var EventEmitter$1 = /* @__PURE__ */ function() {
  function EventEmitter2() {
    this._events = {};
  }
  var __proto = EventEmitter2.prototype;
  __proto.on = function(eventName, listener) {
    if (isObject$2(eventName)) {
      for (var name2 in eventName) {
        this.on(name2, eventName[name2]);
      }
    } else {
      this._addEvent(eventName, listener, {});
    }
    return this;
  };
  __proto.off = function(eventName, listener) {
    if (!eventName) {
      this._events = {};
    } else if (isObject$2(eventName)) {
      for (var name2 in eventName) {
        this.off(name2);
      }
    } else if (!listener) {
      this._events[eventName] = [];
    } else {
      var events2 = this._events[eventName];
      if (events2) {
        var index2 = findIndex(events2, function(e2) {
          return e2.listener === listener;
        });
        if (index2 > -1) {
          events2.splice(index2, 1);
        }
      }
    }
    return this;
  };
  __proto.once = function(eventName, listener) {
    var _this = this;
    if (listener) {
      this._addEvent(eventName, listener, {
        once: true
      });
    }
    return new Promise(function(resolve) {
      _this._addEvent(eventName, resolve, {
        once: true
      });
    });
  };
  __proto.emit = function(eventName, param) {
    var _this = this;
    if (param === void 0) {
      param = {};
    }
    var events2 = this._events[eventName];
    if (!eventName || !events2) {
      return true;
    }
    var isStop = false;
    param.eventType = eventName;
    param.stop = function() {
      isStop = true;
    };
    param.currentTarget = this;
    __spreadArrays$1(events2).forEach(function(info) {
      info.listener(param);
      if (info.once) {
        _this.off(eventName, info.listener);
      }
    });
    return !isStop;
  };
  __proto.trigger = function(eventName, param) {
    if (param === void 0) {
      param = {};
    }
    return this.emit(eventName, param);
  };
  __proto._addEvent = function(eventName, listener, options) {
    var events2 = this._events;
    events2[eventName] = events2[eventName] || [];
    var listeners = events2[eventName];
    listeners.push(__assign$1$2({
      listener
    }, options));
  };
  return EventEmitter2;
}();
var MoveableManager = /* @__PURE__ */ function(_super) {
  __extends$8(MoveableManager2, _super);
  function MoveableManager2(parentElement, options) {
    if (options === void 0) {
      options = {};
    }
    var _this = _super.call(this) || this;
    _this.tempElement = document.createElement("div");
    var nextOptions = __assign$6({
      container: parentElement || document.body
    }, options);
    var events2 = {};
    EVENTS$2.forEach(function(name2) {
      events2[camelize$1("on " + name2)] = function(e2) {
        return _this.trigger(name2, e2);
      };
    });
    render(createElement$1(InnerMoveable, __assign$6({
      ref: ref(_this, "innerMoveable"),
      parentElement
    }, nextOptions, events2)), _this.tempElement);
    var target = nextOptions.target;
    if (isArray$1(target) && target.length > 1) {
      _this.updateRect();
    }
    return _this;
  }
  var __proto = MoveableManager2.prototype;
  __proto.setState = function(state, callback) {
    this.innerMoveable.setState(state, callback);
  };
  __proto.destroy = function() {
    render(null, this.tempElement);
    this.off();
    this.tempElement = null;
    this.innerMoveable = null;
  };
  __proto.getMoveable = function() {
    return this.innerMoveable.moveable;
  };
  MoveableManager2 = __decorate$3([Properties(METHODS$2, function(prototype, property) {
    if (prototype[property]) {
      return;
    }
    prototype[property] = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var self2 = this.getMoveable();
      if (!self2 || !self2[property]) {
        return;
      }
      return self2[property].apply(self2, args);
    };
  }), Properties(PROPERTIES$4, function(prototype, property) {
    Object.defineProperty(prototype, property, {
      get: function() {
        return this.getMoveable().props[property];
      },
      set: function(value) {
        var _a2;
        this.setState((_a2 = {}, _a2[property] = value, _a2));
      },
      enumerable: true,
      configurable: true
    });
  })], MoveableManager2);
  return MoveableManager2;
}(EventEmitter$1);
var Moveable$1 = /* @__PURE__ */ function(_super) {
  __extends$8(Moveable2, _super);
  function Moveable2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return Moveable2;
}(MoveableManager);
function getElementInfo(target, container, rootContainer) {
  return getElementInfo$1(target, container, rootContainer);
}
var Moveable$2 = Moveable$1;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return {
          value: o && o[i++],
          done: !o
        };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e2;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e2 = {
      error
    };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e2)
        throw e2.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
var isUndefined$1 = function(value) {
  return typeof value === "undefined";
};
var ComponentEvent = /* @__PURE__ */ function() {
  function ComponentEvent2(eventType, props2) {
    var e_1, _a2;
    this._canceled = false;
    if (props2) {
      try {
        for (var _b = __values(Object.keys(props2)), _c = _b.next(); !_c.done; _c = _b.next()) {
          var key = _c.value;
          this[key] = props2[key];
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
    this.eventType = eventType;
  }
  var __proto = ComponentEvent2.prototype;
  __proto.stop = function() {
    this._canceled = true;
  };
  __proto.isCanceled = function() {
    return this._canceled;
  };
  return ComponentEvent2;
}();
var Component = /* @__PURE__ */ function() {
  function Component2() {
    this._eventHandler = {};
  }
  var __proto = Component2.prototype;
  __proto.trigger = function(event) {
    var params = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      params[_i - 1] = arguments[_i];
    }
    var eventName = event instanceof ComponentEvent ? event.eventType : event;
    var handlers = __spread(this._eventHandler[eventName] || []);
    if (handlers.length <= 0) {
      return this;
    }
    if (event instanceof ComponentEvent) {
      event.currentTarget = this;
      handlers.forEach(function(handler) {
        handler(event);
      });
    } else {
      handlers.forEach(function(handler) {
        handler.apply(void 0, __spread(params));
      });
    }
    return this;
  };
  __proto.once = function(eventName, handlerToAttach) {
    var _this = this;
    if (typeof eventName === "object" && isUndefined$1(handlerToAttach)) {
      var eventHash = eventName;
      for (var key in eventHash) {
        this.once(key, eventHash[key]);
      }
      return this;
    } else if (typeof eventName === "string" && typeof handlerToAttach === "function") {
      var listener_1 = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        handlerToAttach.apply(void 0, __spread(args));
        _this.off(eventName, listener_1);
      };
      this.on(eventName, listener_1);
    }
    return this;
  };
  __proto.hasOn = function(eventName) {
    return !!this._eventHandler[eventName];
  };
  __proto.on = function(eventName, handlerToAttach) {
    if (typeof eventName === "object" && isUndefined$1(handlerToAttach)) {
      var eventHash = eventName;
      for (var name2 in eventHash) {
        this.on(name2, eventHash[name2]);
      }
      return this;
    } else if (typeof eventName === "string" && typeof handlerToAttach === "function") {
      var handlerList = this._eventHandler[eventName];
      if (isUndefined$1(handlerList)) {
        this._eventHandler[eventName] = [];
        handlerList = this._eventHandler[eventName];
      }
      handlerList.push(handlerToAttach);
    }
    return this;
  };
  __proto.off = function(eventName, handlerToDetach) {
    var e_1, _a2;
    if (isUndefined$1(eventName)) {
      this._eventHandler = {};
      return this;
    }
    if (isUndefined$1(handlerToDetach)) {
      if (typeof eventName === "string") {
        delete this._eventHandler[eventName];
        return this;
      } else {
        var eventHash = eventName;
        for (var name2 in eventHash) {
          this.off(name2, eventHash[name2]);
        }
        return this;
      }
    }
    var handlerList = this._eventHandler[eventName];
    if (handlerList) {
      var idx = 0;
      try {
        for (var handlerList_1 = __values(handlerList), handlerList_1_1 = handlerList_1.next(); !handlerList_1_1.done; handlerList_1_1 = handlerList_1.next()) {
          var handlerFunction = handlerList_1_1.value;
          if (handlerFunction === handlerToDetach) {
            handlerList.splice(idx, 1);
            if (handlerList.length <= 0) {
              delete this._eventHandler[eventName];
            }
            break;
          }
          idx++;
        }
      } catch (e_1_1) {
        e_1 = {
          error: e_1_1
        };
      } finally {
        try {
          if (handlerList_1_1 && !handlerList_1_1.done && (_a2 = handlerList_1.return))
            _a2.call(handlerList_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
    }
    return this;
  };
  Component2.VERSION = "3.0.4";
  return Component2;
}();
function keys(obj) {
  return Object.keys(obj);
}
function isObject$1(val) {
  return typeof val === "object";
}
function isFunction$1(val) {
  return typeof val === "function";
}
var OBSERVERS_PATH = "__observers__";
var COMPUTED_PATH = "__computed__";
var CFCS_DETECTED_DEPENDENCIES_VERSION = 1;
var CFCS_DETECTED_DEPENDENCIES = "__CFCS_DETECTED_DEPENDENCIES__";
var extendStatics$7 = function(d, b) {
  extendStatics$7 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics$7(d, b);
};
function __extends$7(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics$7(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function getDetectedStack() {
  Object[CFCS_DETECTED_DEPENDENCIES] = Object[CFCS_DETECTED_DEPENDENCIES] || {};
  var versionList = Object[CFCS_DETECTED_DEPENDENCIES];
  versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] = versionList[CFCS_DETECTED_DEPENDENCIES_VERSION] || [];
  return versionList[CFCS_DETECTED_DEPENDENCIES_VERSION];
}
function getCurrentDetected() {
  var stack = getDetectedStack();
  return stack[stack.length - 1];
}
function detectDependencies(host) {
  var stack = getDetectedStack();
  var observers = [];
  var detected = {
    host,
    observers,
    push: function(observer) {
      if (host !== observer && observers.indexOf(observer) === -1) {
        observers.push(observer);
      }
    }
  };
  stack.push(detected);
  return detected;
}
function endDetectDependencies() {
  var stack = getDetectedStack();
  return stack.pop();
}
var Observer = /* @__PURE__ */ function() {
  function Observer2(value) {
    this._emitter = new Component();
    this._current = value;
  }
  var __proto = Observer2.prototype;
  Object.defineProperty(__proto, "current", {
    get: function() {
      var currentDetected = getCurrentDetected();
      currentDetected === null || currentDetected === void 0 ? void 0 : currentDetected.push(this);
      return this._current;
    },
    set: function(value) {
      this._setCurrent(value);
    },
    enumerable: false,
    configurable: true
  });
  __proto.subscribe = function(callback) {
    this.current;
    this._emitter.on("update", callback);
    return this;
  };
  __proto.unsubscribe = function(callback) {
    this._emitter.off("update", callback);
    return this;
  };
  __proto._setCurrent = function(value) {
    var prevValue = this._current;
    var isUpdate = value !== prevValue;
    this._current = value;
    if (isUpdate) {
      this._emitter.trigger("update", value, prevValue);
    }
  };
  __proto.toString = function() {
    return "".concat(this.current);
  };
  __proto.valueOf = function() {
    return this.current;
  };
  return Observer2;
}();
var ComputedObserver = /* @__PURE__ */ function(_super) {
  __extends$7(ComputedObserver2, _super);
  function ComputedObserver2(_computedCallback) {
    var _this = _super.call(this) || this;
    _this._computedCallback = _computedCallback;
    _this._registered = [];
    _this._onCheckUpdate = function() {
      _this._setCurrent(_this.current);
    };
    _this._current = _this.current;
    return _this;
  }
  var __proto = ComputedObserver2.prototype;
  Object.defineProperty(__proto, "current", {
    get: function() {
      var _this = this;
      detectDependencies(this);
      var value = this._computedCallback();
      var results = endDetectDependencies();
      this._registered.forEach(function(observer) {
        observer.unsubscribe(_this._onCheckUpdate);
      });
      results.observers.forEach(function(observer) {
        observer.subscribe(_this._onCheckUpdate);
      });
      this._registered = results.observers;
      return value;
    },
    enumerable: false,
    configurable: true
  });
  return ComputedObserver2;
}(Observer);
function injectObserve(prototype, memberName, publicName) {
  if (publicName === void 0) {
    publicName = memberName;
  }
  var nextAttributes = {
    configurable: true,
    get: function() {
      return getObserver(this, publicName).current;
    },
    set: function(value) {
      getObserver(this, publicName, value).current = value;
    }
  };
  Object.defineProperty(prototype, memberName, nextAttributes);
  if (publicName !== memberName) {
    Object.defineProperty(prototype, publicName, {
      configurable: true,
      get: function() {
        return getObserver(this, publicName).current;
      }
    });
  }
}
function Observe() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  if (args.length > 1) {
    return injectObserve(args[0], args[1]);
  }
  return function(prototype, memberName) {
    return injectObserve(prototype, memberName, args[0]);
  };
}
function injectReactiveSubscribe(object) {
  object["subscribe"] = function(name2, callback) {
    this[name2];
    getObserver(this, name2).subscribe(callback);
  };
  object["unsubscribe"] = function(name2, callback) {
    var _this = this;
    if (!name2) {
      keys(getObservers(this)).forEach(function(observerName) {
        _this.unsubscribe(observerName);
      });
      return;
    }
    if (!(name2 in this)) {
      return;
    }
    getObserver(this, name2).unsubscribe(callback);
  };
}
function makeReactiveObject(setup, all3) {
  var result = isFunction$1(setup) ? setup() : setup;
  var reactiveObject = {};
  defineObservers(reactiveObject);
  keys(result).forEach(function(name2) {
    var value = result[name2];
    if (isObserver(value)) {
      setObserver(reactiveObject, name2, value);
    } else {
      setObserver(reactiveObject, name2, observe(value));
    }
    Observe(name2)(reactiveObject, name2);
  });
  injectReactiveSubscribe(reactiveObject);
  return reactiveObject;
}
function reactive(setup) {
  return makeReactiveObject(setup);
}
function partialReactive(setup) {
  return makeReactiveObject(setup);
}
function observe(defaultValue) {
  return new Observer(defaultValue);
}
function computed(computedCallback) {
  return new ComputedObserver(computedCallback);
}
function defineObservers(instance) {
  var observers = {};
  Object.defineProperty(instance, OBSERVERS_PATH, {
    get: function() {
      return observers;
    }
  });
  return observers;
}
function getObservers(instance, isComputed) {
  var _a2, _b;
  if (!instance[OBSERVERS_PATH]) {
    defineObservers(instance);
  }
  var observers = instance[OBSERVERS_PATH];
  if (!isComputed) {
    var computedList = (_b = (_a2 = instance === null || instance === void 0 ? void 0 : instance.constructor) === null || _a2 === void 0 ? void 0 : _a2.prototype) === null || _b === void 0 ? void 0 : _b[COMPUTED_PATH];
    if (computedList) {
      computedList.forEach(function(name2) {
        if (!(name2 in observers) && name2 in instance) {
          instance[name2];
        }
      });
    }
  }
  return observers;
}
function getObserver(instance, name2, defaultValue) {
  var observers = getObservers(instance);
  if (!observers[name2]) {
    observers[name2] = observe(defaultValue);
  }
  return observers[name2];
}
function setObserver(instance, name2, observer) {
  var observers = getObservers(instance);
  observers[name2] = observer;
}
function isObserver(val) {
  return val && isObject$1(val) && "current" in val && "subscribe" in val && "unsubscribe" in val;
}
function __spreadArray$3(to, from, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var OrderMap = /* @__PURE__ */ function() {
  function OrderMap2(separator) {
    this.separator = separator;
    this.orderMap = {};
  }
  OrderMap2.prototype.getFullName = function(names) {
    return names.join(this.separator);
  };
  OrderMap2.prototype.get = function(names) {
    return this.orderMap[this.getFullName(names)];
  };
  OrderMap2.prototype.hasName = function(names) {
    var length = names.length;
    if (!length) {
      return false;
    }
    var lastName = names[length - 1];
    var arr2 = this.get(names.slice(0, length - 1));
    if (arr2) {
      return arr2.indexOf(lastName) >= 0;
    }
    return false;
  };
  OrderMap2.prototype.gets = function(names, isFull) {
    if (isFull === void 0) {
      isFull = true;
    }
    var fullOrders = [];
    var self2 = this;
    function pushOrders(nextNames, stack) {
      var orders = self2.get(nextNames);
      if (!orders) {
        return;
      }
      orders.forEach(function(name2) {
        var nextStack = __spreadArray$3(__spreadArray$3([], stack, true), [name2], false);
        var nextOrders = pushOrders(__spreadArray$3(__spreadArray$3([], nextNames, true), [name2], false), nextStack);
        if (!nextOrders || !nextOrders.length) {
          fullOrders.push(__spreadArray$3(__spreadArray$3([], stack, true), [name2], false));
        }
      });
      return orders;
    }
    pushOrders(names, isFull ? names : []);
    return fullOrders;
  };
  OrderMap2.prototype.set = function(names, orders) {
    var _this = this;
    names.forEach(function(name2, i) {
      _this.addName(names.slice(0, i), name2);
    });
    this.orderMap[this.getFullName(names)] = orders;
    return orders;
  };
  OrderMap2.prototype.add = function(names) {
    var length = names.length;
    if (!length) {
      return [];
    }
    return this.addName(names.slice(0, -1), names[length - 1]);
  };
  OrderMap2.prototype.addName = function(names, name2) {
    var orders = this.get(names) || this.set(names, []);
    if (orders.indexOf(name2) === -1) {
      orders.push(name2);
    }
    return orders;
  };
  OrderMap2.prototype.findIndex = function(names, orderName) {
    var orders = this.orderMap[this.getFullName(names)];
    if (!orders) {
      return -1;
    }
    return orders.indexOf(orderName);
  };
  OrderMap2.prototype.remove = function(names) {
    var fullName = this.getFullName(names);
    var orderMap = this.orderMap;
    for (var name_1 in orderMap) {
      if (name_1.indexOf(fullName) === 0) {
        delete orderMap[name_1];
      }
    }
    var length = names.length;
    if (length) {
      var prevNames = names.slice(0, -1);
      var lastName = names[length - 1];
      this.splice(prevNames, this.findIndex(prevNames, lastName), 1);
    }
    return this;
  };
  OrderMap2.prototype.filter = function(names, callback, isFull) {
    if (isFull === void 0) {
      isFull = true;
    }
    var result = this.gets(names, isFull).filter(callback);
    var map = new OrderMap2(this.separator);
    var stack = isFull ? [] : names;
    result.forEach(function(nextNames) {
      map.add(__spreadArray$3(__spreadArray$3([], stack, true), nextNames, true));
    });
    return map;
  };
  OrderMap2.prototype.splice = function(names, index2, deleteCount) {
    var orders = [];
    for (var _i = 3; _i < arguments.length; _i++) {
      orders[_i - 3] = arguments[_i];
    }
    var currentOrders = this.get(names) || this.set(names, []);
    currentOrders.splice.apply(currentOrders, __spreadArray$3([index2, deleteCount], orders, false));
    return this;
  };
  OrderMap2.prototype.clear = function() {
    this.orderMap = {};
  };
  OrderMap2.prototype.setObject = function(obj) {
    var orderMap = this.orderMap;
    for (var name_2 in obj) {
      orderMap[name_2] = obj[name_2].slice();
    }
  };
  OrderMap2.prototype.getObject = function() {
    var nextMap = {};
    var orderMap = this.orderMap;
    for (var name_3 in orderMap) {
      nextMap[name_3] = orderMap[name_3].slice();
    }
    return nextMap;
  };
  OrderMap2.prototype.clone = function() {
    var map = new OrderMap2(this.separator);
    map.setObject(map.orderMap);
    return map;
  };
  return OrderMap2;
}();
var extendStatics$6 = function(d, b) {
  extendStatics$6 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics$6(d, b);
};
function __extends$6(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics$6(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$5 = function() {
  __assign$5 = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$5.apply(this, arguments);
};
function __decorate$2(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __spreadArray$2(to, from, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function cubic(y1, y2, t) {
  var t2 = 1 - t;
  return t * t * t + 3 * t * t * t2 * y2 + 3 * t * t2 * t2 * y1;
}
function solveFromX(x1, x2, x) {
  var t = x;
  var solveX = x;
  var dx = 1;
  while (Math.abs(dx) > 1 / 1e3) {
    solveX = cubic(x1, x2, t);
    dx = solveX - x;
    if (Math.abs(dx) < 1 / 1e3) {
      return t;
    }
    t -= dx / 2;
  }
  return t;
}
function bezier(x1, y1, x2, y2) {
  var func = function(x) {
    var t = solveFromX(x1, x2, between(x, 0, 1));
    return cubic(y1, y2, t);
  };
  func.easingName = "cubic-bezier(".concat(x1, ",").concat(y1, ",").concat(x2, ",").concat(y2, ")");
  return func;
}
function steps(count, position2) {
  var func = function(time2) {
    var level = 1 / count;
    if (time2 >= 1) {
      return 1;
    }
    return (position2 === "start" ? level : 0) + Math.floor(time2 / level) * level;
  };
  func.easingName = "steps(".concat(count, ", ").concat(position2, ")");
  return func;
}
var STEP_START = /* @__PURE__ */ steps(1, "start");
var STEP_END = /* @__PURE__ */ steps(1, "end");
var LINEAR = /* @__PURE__ */ bezier(0, 0, 1, 1);
var EASE = /* @__PURE__ */ bezier(0.25, 0.1, 0.25, 1);
var EASE_IN = /* @__PURE__ */ bezier(0.42, 0, 1, 1);
var EASE_OUT = /* @__PURE__ */ bezier(0, 0, 0.58, 1);
var EASE_IN_OUT = /* @__PURE__ */ bezier(0.42, 0, 0.58, 1);
var _a;
var PREFIX = "__SCENEJS_";
var DATA_SCENE_ID = "data-scene-id";
var TIMING_FUNCTION = "animation-timing-function";
var ROLES = { transform: {}, filter: {}, attribute: {}, html: true };
var ALIAS = { easing: [TIMING_FUNCTION] };
var FIXED = (_a = {}, _a[TIMING_FUNCTION] = true, _a.contents = true, _a.html = true, _a);
var MAXIMUM = 1e6;
var THRESHOLD = 1e-6;
var DURATION = "duration";
var FILL_MODE = "fillMode";
var DIRECTION = "direction";
var ITERATION_COUNT = "iterationCount";
var DELAY = "delay";
var EASING = "easing";
var PLAY_SPEED = "playSpeed";
var EASING_NAME = "easingName";
var ITERATION_TIME = "iterationTime";
var PAUSED = "paused";
var ENDED = "ended";
var TIMEUPDATE = "timeupdate";
var PLAY = "play";
var RUNNING = "running";
var ITERATION = "iteration";
var START_ANIMATION = "startAnimation";
var PAUSE_ANIMATION = "pauseAnimation";
var ALTERNATE = "alternate";
var REVERSE = "reverse";
var ALTERNATE_REVERSE = "alternate-reverse";
var NORMAL = "normal";
var INFINITE = "infinite";
var PLAY_STATE = "playState";
var PLAY_CSS = "playCSS";
var PREV_TIME = "prevTime";
var TICK_TIME = "tickTime";
var CURRENT_TIME = "currentTime";
var SELECTOR = "selector";
var TRANSFORM_NAME = "transform";
var EASINGS = {
  "linear": LINEAR,
  "ease": EASE,
  "ease-in": EASE_IN,
  "ease-out": EASE_OUT,
  "ease-in-out": EASE_IN_OUT,
  "step-start": STEP_START,
  "step-end": STEP_END
};
var NAME_SEPARATOR = "_///_";
var OPTIONS = [DURATION, FILL_MODE, DIRECTION, ITERATION_COUNT, DELAY, EASING, PLAY_SPEED];
var PropertyObject = /* @__PURE__ */ function() {
  function PropertyObject2(value, options) {
    this.prefix = "";
    this.suffix = "";
    this.model = "";
    this.type = "";
    this.separator = ",";
    options && this.setOptions(options);
    this.value = isString$2(value) ? value.split(this.separator) : value;
  }
  PropertyObject2.prototype.setOptions = function(newOptions) {
    for (var name_1 in newOptions) {
      this[name_1] = newOptions[name_1];
    }
    return this;
  };
  PropertyObject2.prototype.size = function() {
    return this.value.length;
  };
  PropertyObject2.prototype.get = function(index2) {
    return this.value[index2];
  };
  PropertyObject2.prototype.set = function(index2, value) {
    this.value[index2] = value;
    return this;
  };
  PropertyObject2.prototype.clone = function() {
    var _a2 = this, separator = _a2.separator, prefix2 = _a2.prefix, suffix = _a2.suffix, model = _a2.model, type = _a2.type;
    var arr2 = this.value.map(function(v) {
      return isPropertyObject(v) ? v.clone() : v;
    });
    return new PropertyObject2(arr2, {
      separator,
      prefix: prefix2,
      suffix,
      model,
      type
    });
  };
  PropertyObject2.prototype.toValue = function() {
    return this.prefix + this.join() + this.suffix;
  };
  PropertyObject2.prototype.join = function() {
    return this.value.map(function(v) {
      return isPropertyObject(v) ? v.toValue() : v;
    }).join(this.separator);
  };
  PropertyObject2.prototype.forEach = function(func) {
    this.value.forEach(func);
    return this;
  };
  return PropertyObject2;
}();
function splitStyle(str) {
  var properties = splitText(str, ";");
  var obj = {};
  var totalLength = properties.length;
  var length = totalLength;
  for (var i = 0; i < totalLength; ++i) {
    var matches2 = splitText(properties[i], ":");
    if (matches2.length < 2 || !matches2[1]) {
      --length;
      continue;
    }
    obj[matches2[0].trim()] = toPropertyObject(matches2[1].trim());
  }
  return { styles: obj, length };
}
function arrayToColorObject(arr2) {
  var model = RGBA;
  if (arr2.length === 3) {
    arr2[3] = 1;
  }
  return new PropertyObject(arr2, {
    model,
    separator: ",",
    type: "color",
    prefix: "".concat(model, "("),
    suffix: ")"
  });
}
function stringToBracketObject(text) {
  var _a2 = splitBracket(text), model = _a2.prefix, value = _a2.value, afterModel = _a2.suffix;
  if (typeof value === "undefined") {
    return text;
  }
  if (COLOR_MODELS.indexOf(model) > -1) {
    return arrayToColorObject(stringToRGBA(text));
  }
  var obj = toPropertyObject(value, model);
  var arr2 = [value];
  var separator = ",";
  var prefix2 = "".concat(model, "(");
  var suffix = ")".concat(afterModel);
  if (isPropertyObject(obj)) {
    separator = obj.separator;
    arr2 = obj.value;
    prefix2 += obj.prefix;
    suffix = obj.suffix + suffix;
  }
  return new PropertyObject(arr2, {
    separator,
    model,
    prefix: prefix2,
    suffix
  });
}
function arrayToPropertyObject(arr2, separator) {
  return new PropertyObject(arr2, {
    type: "array",
    separator
  });
}
function stringToColorObject(value) {
  var result = stringToRGBA(value);
  return result ? arrayToColorObject(result) : value;
}
function toPropertyObject(value, model) {
  if (!isString$2(value)) {
    if (isArray$1(value)) {
      return arrayToPropertyObject(value, ",");
    }
    return value;
  }
  var values = splitComma(value);
  if (values.length > 1) {
    return arrayToPropertyObject(values.map(function(v) {
      return toPropertyObject(v);
    }), ",");
  }
  values = splitSpace(value);
  if (values.length > 1) {
    return arrayToPropertyObject(values.map(function(v) {
      return toPropertyObject(v);
    }), " ");
  }
  values = /^(['"])([^'"]*)(['"])$/g.exec(value);
  if (values && values[1] === values[3]) {
    return new PropertyObject([toPropertyObject(values[2])], {
      prefix: values[1],
      suffix: values[1]
    });
  } else if (value.indexOf("(") !== -1) {
    return stringToBracketObject(value);
  } else if (value.charAt(0) === "#" && model !== "url") {
    return stringToColorObject(value);
  }
  return value;
}
function toObject(object, result) {
  if (result === void 0) {
    result = {};
  }
  var model = object.model;
  if (model) {
    object.setOptions({
      model: "",
      suffix: "",
      prefix: ""
    });
    var value = object.size() > 1 ? object : object.get(0);
    result[model] = value;
  } else {
    object.forEach(function(obj) {
      toObject(obj, result);
    });
  }
  return result;
}
function getType(value) {
  var type = typeof value;
  if (type === OBJECT) {
    if (isArray$1(value)) {
      return ARRAY;
    } else if (isPropertyObject(value)) {
      return PROPERTY;
    }
  } else if (type === STRING || type === NUMBER) {
    return "value";
  }
  return type;
}
function isPureObject(obj) {
  return isObject$2(obj) && obj.constructor === Object;
}
function getNames(names, stack) {
  var arr2 = [];
  if (isPureObject(names)) {
    for (var name_1 in names) {
      stack.push(name_1);
      arr2 = arr2.concat(getNames(names[name_1], stack));
      stack.pop();
    }
  } else {
    arr2.push(stack.slice());
  }
  return arr2;
}
function updateFrame(names, properties) {
  for (var name_2 in properties) {
    var value = properties[name_2];
    if (!isPureObject(value)) {
      names[name_2] = true;
      continue;
    }
    if (!isObject$2(names[name_2])) {
      names[name_2] = {};
    }
    updateFrame(names[name_2], properties[name_2]);
  }
  return names;
}
function toFixed(num) {
  return Math.round(num * MAXIMUM) / MAXIMUM;
}
function getValueByNames(names, properties, length) {
  if (length === void 0) {
    length = names.length;
  }
  var value = properties;
  for (var i = 0; i < length; ++i) {
    if (!isObject$2(value) || value == null) {
      return void 0;
    }
    value = value[names[i]];
  }
  return value;
}
function isInProperties(roles, args, isLast) {
  var length = args.length;
  var role = roles;
  if (length === 0) {
    return false;
  }
  for (var i = 0; i < length; ++i) {
    if (role === true) {
      return false;
    }
    role = role[args[i]];
    if (!role || !isLast && role === true) {
      return false;
    }
  }
  return true;
}
function isRole(args, isLast) {
  return isInProperties(ROLES, args, isLast);
}
function isFixed(args) {
  return isInProperties(FIXED, args, true);
}
function setPlayCSS(item, isActivate) {
  item.state[PLAY_CSS] = isActivate;
}
function isPausedCSS(item) {
  return item.state[PLAY_CSS] && item.isPaused();
}
function isEndedCSS(item) {
  return !item.isEnded() && item.state[PLAY_CSS];
}
function makeId(selector) {
  for (; ; ) {
    var id = "".concat(Math.floor(Math.random() * 1e7));
    if (!IS_WINDOW || !selector) {
      return id;
    }
    var checkElement = $$1('[data-scene-id="'.concat(id, '"]'));
    if (!checkElement) {
      return id;
    }
  }
}
function getRealId(item) {
  return item.getId() || item.setId(makeId(false)).getId();
}
function toId(text) {
  return "".concat(text).match(/[0-9a-zA-Z]+/g).join("");
}
function playCSS(item, isExportCSS, playClassName, properties) {
  if (properties === void 0) {
    properties = {};
  }
  if (!ANIMATION || item.getPlayState() === RUNNING) {
    return;
  }
  var className = playClassName || START_ANIMATION;
  if (isPausedCSS(item)) {
    item.addPlayClass(true, className, properties);
  } else {
    if (item.isEnded()) {
      item.setTime(0);
    }
    isExportCSS && item.exportCSS({ className });
    var el = item.addPlayClass(false, className, properties);
    if (!el) {
      return;
    }
    addAnimationEvent(item, el);
    setPlayCSS(item, true);
  }
  item.setPlayState(RUNNING);
}
function addAnimationEvent(item, el) {
  var state = item.state;
  var duration2 = item.getDuration();
  var isZeroDuration = !duration2 || !isFinite(duration2);
  var animationend = function() {
    setPlayCSS(item, false);
    item.finish();
  };
  var animationstart = function() {
    item.trigger(PLAY);
    addEvent$1(el, "animationcancel", animationend);
    addEvent$1(el, "animationend", animationend);
    addEvent$1(el, "animationiteration", animationiteration);
  };
  item.once(ENDED, function() {
    removeEvent(el, "animationcancel", animationend);
    removeEvent(el, "animationend", animationend);
    removeEvent(el, "animationiteration", animationiteration);
    removeEvent(el, "animationstart", animationstart);
  });
  var animationiteration = function(_a2) {
    var elapsedTime = _a2.elapsedTime;
    var currentTime = elapsedTime;
    var iterationCount = isZeroDuration ? 0 : currentTime / duration2;
    state[CURRENT_TIME] = currentTime;
    item.setIteration(iterationCount);
  };
  addEvent$1(el, "animationstart", animationstart);
}
function getEasing(curveArray) {
  var easing;
  if (isString$2(curveArray)) {
    if (curveArray in EASINGS) {
      easing = EASINGS[curveArray];
    } else {
      var obj = toPropertyObject(curveArray);
      if (isString$2(obj)) {
        return 0;
      } else {
        if (obj.model === "cubic-bezier") {
          curveArray = obj.value.map(function(v) {
            return parseFloat(v);
          });
          easing = bezier(curveArray[0], curveArray[1], curveArray[2], curveArray[3]);
        } else if (obj.model === "steps") {
          easing = steps(parseFloat(obj.value[0]), obj.value[1]);
        } else {
          return 0;
        }
      }
    }
  } else if (isArray$1(curveArray)) {
    easing = bezier(curveArray[0], curveArray[1], curveArray[2], curveArray[3]);
  } else {
    easing = curveArray;
  }
  return easing;
}
function isPropertyObject(value) {
  if (!value) {
    return false;
  }
  var prototype = value.constructor.prototype;
  return !!(prototype.clone && prototype.get && prototype.setOptions);
}
function isScene(value) {
  return value && !!value.constructor.prototype.getItem;
}
function isSceneItem(value) {
  return value && !!value.constructor.prototype.getFrame;
}
function isFrame(value) {
  return value && !!value.constructor.prototype.toCSSText;
}
function flatSceneObject(obj, seperator) {
  var newObj = {};
  for (var name_3 in obj) {
    var value = obj[name_3];
    if (isFrame(value)) {
      newObj[name_3] = value;
    } else if (isObject$2(value)) {
      var nextObj = flatSceneObject(value, seperator);
      for (var nextName in nextObj) {
        newObj["".concat(name_3).concat(seperator).concat(nextName)] = nextObj[nextName];
      }
    }
  }
  return newObj;
}
function isArrayLike(el) {
  return "length" in el && el.length >= 0;
}
function GetterSetter(getter, setter, parent) {
  return function(constructor) {
    var prototype = constructor.prototype;
    getter.forEach(function(name2) {
      prototype[camelize$1("get ".concat(name2))] = function() {
        return this[parent][name2];
      };
    });
    setter.forEach(function(name2) {
      prototype[camelize$1("set ".concat(name2))] = function(value) {
        this[parent][name2] = value;
        return this;
      };
    });
  };
}
function isDirectionReverse(iteration, iteraiontCount, direction2) {
  if (direction2 === REVERSE) {
    return true;
  } else if (iteraiontCount !== INFINITE && iteration === iteraiontCount && iteraiontCount % 1 === 0) {
    return direction2 === (iteration % 2 >= 1 ? ALTERNATE_REVERSE : ALTERNATE);
  }
  return direction2 === (iteration % 2 >= 1 ? ALTERNATE : ALTERNATE_REVERSE);
}
var ANIMATOR_SETTERS = [
  "id",
  ITERATION_COUNT,
  DELAY,
  FILL_MODE,
  DIRECTION,
  PLAY_SPEED,
  DURATION,
  PLAY_SPEED,
  ITERATION_TIME,
  PLAY_STATE
];
var ANIMATOR_GETTERS = __spreadArray$2(__spreadArray$2([], ANIMATOR_SETTERS, true), [
  EASING,
  EASING_NAME
], false);
var Animator = /* @__PURE__ */ function(_super) {
  __extends$6(Animator2, _super);
  function Animator2(options) {
    var _this = _super.call(this) || this;
    _this.timerId = 0;
    _this.state = reactive({
      id: "",
      easing: 0,
      easingName: "linear",
      iterationCount: 1,
      delay: 0,
      fillMode: "forwards",
      direction: NORMAL,
      playSpeed: 1,
      currentTime: 0,
      iterationTime: -1,
      iteration: 0,
      tickTime: 0,
      prevTime: 0,
      playState: PAUSED,
      duration: 0
    });
    _this.setOptions(options);
    return _this;
  }
  Animator2.prototype.setEasing = function(curveArray) {
    var easing = getEasing(curveArray);
    var easingName = easing && easing[EASING_NAME] || "linear";
    var state = this.state;
    state[EASING] = easing;
    state[EASING_NAME] = easingName;
    return this;
  };
  Animator2.prototype.setOptions = function(options) {
    if (options === void 0) {
      options = {};
    }
    for (var name_1 in options) {
      var value = options[name_1];
      if (name_1 === EASING) {
        this.setEasing(value);
        continue;
      } else if (name_1 === DURATION) {
        value && this.setDuration(value);
        continue;
      }
      if (OPTIONS.indexOf(name_1) > -1) {
        this.state[name_1] = value;
      }
    }
    return this;
  };
  Animator2.prototype.getTotalDuration = function() {
    return this.getActiveDuration(true);
  };
  Animator2.prototype.getActiveDuration = function(delay) {
    var state = this.state;
    var count = state[ITERATION_COUNT];
    if (count === INFINITE) {
      return Infinity;
    }
    return (delay ? state[DELAY] : 0) + this.getDuration() * count;
  };
  Animator2.prototype.isEnded = function() {
    if (this.state[TICK_TIME] === 0 && this.state[PLAY_STATE] === PAUSED) {
      return true;
    } else if (this.getTime() < this.getActiveDuration()) {
      return false;
    }
    return true;
  };
  Animator2.prototype.isPaused = function() {
    return this.state[PLAY_STATE] === PAUSED;
  };
  Animator2.prototype.start = function(delay) {
    if (delay === void 0) {
      delay = this.state[DELAY];
    }
    var state = this.state;
    state[PLAY_STATE] = RUNNING;
    if (state[TICK_TIME] >= delay) {
      this.trigger(PLAY);
      return true;
    }
    return false;
  };
  Animator2.prototype.play = function(toTime) {
    var _this = this;
    var state = this.state;
    var delay = state[DELAY];
    var currentTime = this.getTime();
    state[PLAY_STATE] = RUNNING;
    if (this.isEnded() && (currentTime === 0 || currentTime >= this.getActiveDuration())) {
      this.setTime(-delay, true);
    }
    this.timerId = requestAnimationFrame$1(function(time2) {
      state[PREV_TIME] = time2;
      _this.tick(time2, toTime);
    });
    this.start();
    return this;
  };
  Animator2.prototype.pause = function() {
    var state = this.state;
    if (state[PLAY_STATE] !== PAUSED) {
      state[PLAY_STATE] = PAUSED;
      this.trigger(PAUSED);
    }
    cancelAnimationFrame(this.timerId);
    return this;
  };
  Animator2.prototype.finish = function() {
    this.setTime(0);
    this.state[TICK_TIME] = 0;
    this.end();
    return this;
  };
  Animator2.prototype.end = function() {
    this.pause();
    this.trigger(ENDED);
    return this;
  };
  Animator2.prototype.setTime = function(time2, isTick, isParent, exec) {
    var activeDuration = this.getActiveDuration();
    var state = this.state;
    var prevTime = state[TICK_TIME];
    var delay = state[DELAY];
    var currentTime = isTick ? time2 : this.getUnitTime(time2);
    state[TICK_TIME] = delay + currentTime;
    if (currentTime < 0) {
      currentTime = 0;
    } else if (currentTime > activeDuration) {
      currentTime = activeDuration;
    }
    state[CURRENT_TIME] = currentTime;
    this.calculate();
    var isSelfTick = isTick && !isParent;
    var tickTime = state[TICK_TIME];
    var numericTime = isString$2(time2) ? parseFloat(time2) : time2;
    if (isSelfTick && prevTime < delay && numericTime >= 0) {
      this.start(0);
    }
    exec === null || exec === void 0 ? void 0 : exec();
    if (isSelfTick && (tickTime < prevTime || this.isEnded())) {
      this.end();
      return this;
    }
    if (this.isDelay()) {
      return this;
    }
    this.trigger(TIMEUPDATE, {
      currentTime,
      time: this.getIterationTime(),
      iterationCount: state[ITERATION]
    });
    return this;
  };
  Animator2.prototype.getTime = function() {
    return this.state[CURRENT_TIME];
  };
  Animator2.prototype.getUnitTime = function(time2) {
    if (isString$2(time2)) {
      var duration2 = this.getDuration() || 100;
      if (time2 === "from") {
        return 0;
      } else if (time2 === "to") {
        return duration2;
      }
      var _a2 = splitUnit(time2), unit = _a2.unit, value = _a2.value;
      if (unit === "%") {
        !this.getDuration() && this.setDuration(duration2);
        return toFixed(parseFloat(time2) / 100 * duration2);
      } else if (unit === ">") {
        return value + THRESHOLD;
      } else {
        return value;
      }
    } else {
      return toFixed(time2);
    }
  };
  Animator2.prototype.isDelay = function() {
    var state = this.state;
    var delay = state[DELAY];
    var tickTime = state[TICK_TIME];
    return delay > 0 && tickTime < delay;
  };
  Animator2.prototype.setIteration = function(iterationCount) {
    var state = this.state;
    var passIterationCount = Math.floor(iterationCount);
    var maxIterationCount = state[ITERATION_COUNT] === INFINITE ? Infinity : state[ITERATION_COUNT];
    if (state[ITERATION] < passIterationCount && passIterationCount < maxIterationCount) {
      this.trigger(ITERATION, {
        currentTime: state[CURRENT_TIME],
        iterationCount: passIterationCount
      });
    }
    state[ITERATION] = iterationCount;
    return this;
  };
  Animator2.prototype.calculate = function() {
    var state = this.state;
    var iterationCount = state[ITERATION_COUNT];
    var fillMode = state[FILL_MODE];
    var direction2 = state[DIRECTION];
    var duration2 = this.getDuration();
    var time2 = this.getTime();
    var iteration = duration2 === 0 ? 0 : time2 / duration2;
    var currentIterationTime = duration2 ? time2 % duration2 : 0;
    if (!duration2) {
      this.setIterationTime(0);
      return this;
    }
    this.setIteration(iteration);
    var isReverse = isDirectionReverse(iteration, iterationCount, direction2);
    var isFiniteDuration = isFinite(duration2);
    if (isFiniteDuration && isReverse) {
      currentIterationTime = duration2 - currentIterationTime;
    }
    if (isFiniteDuration && iterationCount !== INFINITE) {
      var isForwards = fillMode === "both" || fillMode === "forwards";
      if (iteration >= iterationCount) {
        currentIterationTime = duration2 * (isForwards ? iterationCount % 1 || 1 : 0);
        isReverse && (currentIterationTime = duration2 - currentIterationTime);
      }
    }
    this.setIterationTime(currentIterationTime);
    return this;
  };
  Animator2.prototype.tick = function(now2, to) {
    var _this = this;
    if (this.isPaused()) {
      return;
    }
    var state = this.state;
    var playSpeed = state[PLAY_SPEED];
    var prevTime = state[PREV_TIME];
    var delay = state[DELAY];
    var tickTime = state[TICK_TIME];
    var currentTime = tickTime + Math.min(1e3, now2 - prevTime) / 1e3 * playSpeed;
    state[PREV_TIME] = now2;
    if (to && to >= currentTime) {
      this.setTime(to - delay, true);
      this.pause();
    } else {
      this.setTime(currentTime - delay, true);
    }
    if (state[PLAY_STATE] === PAUSED) {
      return;
    }
    this.timerId = requestAnimationFrame$1(function(time2) {
      _this.tick(time2, to);
    });
  };
  Animator2 = __decorate$2([
    GetterSetter(ANIMATOR_GETTERS, ANIMATOR_SETTERS, "state")
  ], Animator2);
  return Animator2;
}(EventEmitter$3);
function toInnerProperties(obj, orders) {
  if (orders === void 0) {
    orders = [];
  }
  if (!obj) {
    return "";
  }
  var arrObj = [];
  var keys2 = getKeys(obj);
  sortOrders(keys2, orders);
  keys2.forEach(function(name2) {
    arrObj.push("".concat(name2.replace(/\d$/g, ""), "(").concat(obj[name2], ")"));
  });
  return arrObj.join(" ");
}
function clone$1(target, toValue) {
  if (toValue === void 0) {
    toValue = false;
  }
  return merge$1({}, target, toValue);
}
function merge$1(to, from, toValue) {
  if (toValue === void 0) {
    toValue = false;
  }
  for (var name_1 in from) {
    var value = from[name_1];
    var type = getType(value);
    if (type === PROPERTY) {
      to[name_1] = toValue ? value.toValue() : value.clone();
    } else if (type === FUNCTION) {
      to[name_1] = toValue ? getValue([name_1], value) : value;
    } else if (type === ARRAY) {
      to[name_1] = value.slice();
    } else if (type === OBJECT) {
      if (isObject$2(to[name_1]) && !isPropertyObject(to[name_1])) {
        merge$1(to[name_1], value, toValue);
      } else {
        to[name_1] = clone$1(value, toValue);
      }
    } else {
      to[name_1] = from[name_1];
    }
  }
  return to;
}
function getPropertyName(args) {
  return args[0] in ALIAS ? ALIAS[args[0]] : args;
}
function getValue(names, value) {
  var type = getType(value);
  if (type === PROPERTY) {
    return value.toValue();
  } else if (type === FUNCTION) {
    if (names[0] !== TIMING_FUNCTION) {
      return getValue(names, value());
    }
  } else if (type === OBJECT) {
    return clone$1(value, true);
  }
  return value;
}
var Frame = /* @__PURE__ */ function(_super) {
  __extends$6(Frame2, _super);
  function Frame2(properties) {
    if (properties === void 0) {
      properties = {};
    }
    var _this = _super.call(this) || this;
    _this.properties = {};
    _this.orderMap = new OrderMap(NAME_SEPARATOR);
    _this.properties = {};
    _this.set(properties);
    return _this;
  }
  Frame2.prototype.get = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var value = this.raw.apply(this, args);
    return getValue(getPropertyName(args), value);
  };
  Frame2.prototype.getOrders = function(names) {
    return this.orderMap.get(names);
  };
  Frame2.prototype.setOrders = function(names, orders) {
    var result = this.orderMap.set(names, orders);
    this._update();
    return result;
  };
  Frame2.prototype.getOrderObject = function() {
    return this.orderMap.getObject();
  };
  Frame2.prototype.setOrderObject = function(obj) {
    this.orderMap.setObject(obj);
    this._update();
  };
  Frame2.prototype.getKeys = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var value = this.raw.apply(this, args);
    var keys2 = getType(value) === OBJECT ? getKeys(value) : [];
    sortOrders(keys2, this.orderMap.get(args));
    return keys2;
  };
  Frame2.prototype.gets = function() {
    var _this = this;
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var values = this.get.apply(this, args);
    var keys2 = this.getKeys.apply(this, args);
    return keys2.map(function(key) {
      var nextValue = values[key];
      return { key, value: nextValue, children: _this.gets.apply(_this, __spreadArray$2(__spreadArray$2([], args, false), [key], false)) };
    });
  };
  Frame2.prototype.raw = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    return getValueByNames(getPropertyName(args), this.properties);
  };
  Frame2.prototype.remove = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var params = getPropertyName(args);
    var length = params.length;
    if (!length) {
      return this;
    }
    this.orderMap.remove(params);
    var value = getValueByNames(params, this.properties, length - 1);
    if (isObject$2(value)) {
      delete value[params[length - 1]];
    }
    this._update();
    return this;
  };
  Frame2.prototype.set = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    this._set.apply(this, args);
    this._update();
    return this;
  };
  Frame2.prototype.getNames = function() {
    return getNames(this.properties, []);
  };
  Frame2.prototype.has = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var params = getPropertyName(args);
    var length = params.length;
    if (!length) {
      return false;
    }
    return !isUndefined$2(getValueByNames(params, this.properties, length));
  };
  Frame2.prototype.clone = function() {
    var frame = new Frame2();
    frame.setOrderObject(this.orderMap.orderMap);
    return frame.merge(this);
  };
  Frame2.prototype.merge = function(frame) {
    var properties = this.properties;
    var frameProperties = frame.properties;
    if (frameProperties) {
      merge$1(properties, frameProperties);
    }
    return this;
  };
  Frame2.prototype.toCSSObject = function(useCamelCase) {
    var properties = this.get();
    var cssObject = {};
    for (var name_2 in properties) {
      if (isRole([name_2], true)) {
        continue;
      }
      var value = properties[name_2];
      if (name_2 === TIMING_FUNCTION) {
        name_2 = TIMING_FUNCTION.replace("animation", ANIMATION);
        value = (isString$2(value) ? value : value[EASING_NAME]) || "initial";
      }
      if (useCamelCase) {
        name_2 = camelize$1(name_2.replace(/^[-]+/g, ""));
      }
      cssObject[name_2] = value;
    }
    var transform2 = toInnerProperties(properties[TRANSFORM_NAME], this.orderMap.get([TRANSFORM_NAME]));
    var filter = toInnerProperties(properties.filter, this.orderMap.get([FILTER]));
    TRANSFORM && transform2 && (cssObject[TRANSFORM] = transform2);
    FILTER && filter && (cssObject[FILTER] = filter);
    return cssObject;
  };
  Frame2.prototype.toCSSText = function() {
    var cssObject = this.toCSSObject();
    var cssArray = [];
    var keys2 = getKeys(cssObject);
    sortOrders(keys2, this.orderMap.get([]));
    keys2.forEach(function(name2) {
      cssArray.push("".concat(decamelize(name2, "-"), ":").concat(cssObject[name2], ";"));
    });
    return cssArray.join("");
  };
  Frame2.prototype.toCSS = function() {
    var cssObject = this.toCSSObject();
    var cssArray = [];
    var keys2 = getKeys(cssObject);
    sortOrders(keys2, this.orderMap.get([]));
    keys2.forEach(function(name2) {
      cssArray.push("".concat(name2, ":").concat(cssObject[name2], ";"));
    });
    return cssArray.join("");
  };
  Frame2.prototype.clear = function() {
    this.properties = {};
    this.orderMap.clear();
    return this;
  };
  Frame2.prototype._set = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var self2 = this;
    var length = args.length;
    var params = args.slice(0, -1);
    var value = args[length - 1];
    var firstParam = params[0];
    if (length === 1 && isFrame(value)) {
      self2.merge(value);
    } else if (firstParam in ALIAS) {
      self2._setByPath(ALIAS[firstParam], value);
    } else if (length === 2 && isArray$1(firstParam)) {
      self2._setByPath(firstParam, value);
    } else if (isPropertyObject(value)) {
      if (isRole(params)) {
        self2._set.apply(self2, __spreadArray$2(__spreadArray$2([], params, false), [toObject(value)], false));
      } else {
        self2._setByPath(params, value);
      }
    } else if (isArray$1(value)) {
      self2._setByPath(params, value);
    } else if (isObject$2(value)) {
      if (!self2.has.apply(self2, params) && isRole(params)) {
        self2._setByPath(params, {});
      }
      for (var name_3 in value) {
        self2._set.apply(self2, __spreadArray$2(__spreadArray$2([], params, false), [name_3, value[name_3]], false));
      }
    } else if (isString$2(value)) {
      if (isRole(params, true)) {
        if (isFixed(params) || !isRole(params)) {
          this._setByPath(params, value);
        } else {
          var obj = toPropertyObject(value);
          if (isObject$2(obj)) {
            self2._set.apply(self2, __spreadArray$2(__spreadArray$2([], params, false), [obj], false));
          }
        }
        return this;
      } else {
        var _a2 = splitStyle(value), styles = _a2.styles, stylesLength = _a2.length;
        for (var name_4 in styles) {
          self2._set.apply(self2, __spreadArray$2(__spreadArray$2([], params, false), [name_4, styles[name_4]], false));
        }
        if (stylesLength) {
          return this;
        }
      }
      self2._setByPath(params, value);
    } else {
      self2._setByPath(params, value);
    }
  };
  Frame2.prototype._setByPath = function(path, value) {
    var properties = this.properties;
    var length = path.length;
    for (var i = 0; i < length - 1; ++i) {
      var name_5 = path[i];
      !(name_5 in properties) && (properties[name_5] = {});
      properties = properties[name_5];
    }
    if (!length) {
      return;
    }
    var lastParam = path[length - 1];
    this.orderMap.add(path);
    if (length === 1 && lastParam === TIMING_FUNCTION) {
      properties[lastParam] = getEasing(value);
    } else {
      properties[lastParam] = isString$2(value) && !isFixed(path) ? toPropertyObject(value, lastParam) : value;
    }
  };
  Frame2.prototype._update = function() {
    this.emit("update");
  };
  return Frame2;
}(EventEmitter$3);
function dotArray(a1, a2, b1, b2) {
  var length = a2.length;
  return a1.map(function(v1, i) {
    if (i >= length) {
      return v1;
    } else {
      return dot(v1, a2[i], b1, b2);
    }
  });
}
function dotColor(color1, color2, b1, b2) {
  var value1 = color1.value;
  var value2 = color2.value;
  var model1 = color1.model;
  var model2 = color2.model;
  if (model1 !== model2) {
    return dot(color1.toValue(), color2.toValue(), b1, b2);
  }
  if (value1.length === 3) {
    value1[3] = 1;
  }
  if (value2.length === 3) {
    value2[3] = 1;
  }
  var v = dotArray(value1, value2, b1, b2);
  var colorModel = model1;
  for (var i = 0; i < 3; ++i) {
    v[i] = parseInt(v[i], 10);
  }
  var object = new PropertyObject(v, {
    type: "color",
    model: colorModel,
    prefix: "".concat(colorModel, "("),
    suffix: ")"
  });
  return object;
}
function dotObject(a1, a2, b1, b2) {
  var a1Type = a1.type;
  if (a1Type === "color") {
    return dotColor(a1, a2, b1, b2);
  }
  var value1 = a1.value;
  var value2 = a2.value;
  var arr2 = dotArray(value1, value2, b1, b2);
  return new PropertyObject(arr2, {
    type: a1Type,
    separator: a1.separator || a2.separator,
    prefix: a1.prefix || a2.prefix,
    suffix: a1.suffix || a2.suffix,
    model: a1.model || a2.model
  });
}
function dot(a1, a2, b1, b2) {
  if (b2 === 0) {
    return a2;
  } else if (b1 === 0 || b1 + b2 === 0) {
    return a1;
  }
  var type1 = getType(a1);
  var type2 = getType(a2);
  var isFunction1 = type1 === FUNCTION;
  var isFunction2 = type2 === FUNCTION;
  if (isFunction1 || isFunction2) {
    return function() {
      return dot(isFunction1 ? toPropertyObject(a1()) : a1, isFunction2 ? toPropertyObject(a2()) : a2, b1, b2);
    };
  } else if (type1 === type2) {
    if (type1 === PROPERTY) {
      return dotObject(a1, a2, b1, b2);
    } else if (type1 === ARRAY) {
      return dotArray(a1, a2, b1, b2);
    } else if (type1 !== "value") {
      return a1;
    }
  } else {
    return a1;
  }
  var v1 = splitUnit("".concat(a1));
  var v2 = splitUnit("".concat(a2));
  var v;
  if (isNaN(v1.value) || isNaN(v2.value)) {
    return a1;
  } else {
    v = dot$1(v1.value, v2.value, b1, b2);
  }
  var prefix2 = v1.prefix || v2.prefix;
  var unit = v1.unit || v2.unit;
  if (!prefix2 && !unit) {
    return v;
  }
  return prefix2 + v + unit;
}
function dotValue(time2, prevTime, nextTime, prevValue, nextValue, easing) {
  if (time2 === prevTime) {
    return prevValue;
  } else if (time2 === nextTime) {
    return nextValue;
  } else if (!easing) {
    return dot(prevValue, nextValue, time2 - prevTime, nextTime - time2);
  }
  var ratio = easing((time2 - prevTime) / (nextTime - prevTime));
  var value = dot(prevValue, nextValue, ratio, 1 - ratio);
  return value;
}
function getNearTimeIndex(times, time2) {
  var length = times.length;
  for (var i = 0; i < length; ++i) {
    if (times[i] === time2) {
      return [i, i];
    } else if (times[i] > time2) {
      return [i > 0 ? i - 1 : 0, i];
    }
  }
  return [length - 1, length - 1];
}
function makeAnimationProperties(properties) {
  var cssArray = [];
  for (var name_1 in properties) {
    cssArray.push("".concat(ANIMATION, "-").concat(decamelize(name_1), ":").concat(properties[name_1], ";"));
  }
  return cssArray.join("");
}
function addTime(times, time2) {
  var length = times.length;
  for (var i = 0; i < length; ++i) {
    if (time2 < times[i]) {
      times.splice(i, 0, time2);
      return;
    }
  }
  times[length] = time2;
}
function addEntry(entries, time2, keytime) {
  var prevEntry = entries[entries.length - 1];
  (!prevEntry || prevEntry[0] !== time2 || prevEntry[1] !== keytime) && entries.push([toFixed(time2), toFixed(keytime)]);
}
function getEntries(times, states) {
  var entries = times.map(function(time2) {
    return [time2, time2];
  });
  var nextEntries = [];
  states.forEach(function(state) {
    var iterationCount = state[ITERATION_COUNT];
    var delay = state[DELAY];
    var playSpeed = state[PLAY_SPEED];
    var direction2 = state[DIRECTION];
    var intCount = Math.ceil(iterationCount);
    var currentDuration = entries[entries.length - 1][0];
    var length = entries.length;
    var lastTime = currentDuration * iterationCount;
    for (var i = 0; i < intCount; ++i) {
      var isReverse = direction2 === REVERSE || direction2 === ALTERNATE && i % 2 || direction2 === ALTERNATE_REVERSE && !(i % 2);
      for (var j2 = 0; j2 < length; ++j2) {
        var entry = entries[isReverse ? length - j2 - 1 : j2];
        var time2 = entry[1];
        var currentTime = currentDuration * i + (isReverse ? currentDuration - entry[0] : entry[0]);
        var prevEntry = entries[isReverse ? length - j2 : j2 - 1];
        if (currentTime > lastTime) {
          if (j2 !== 0) {
            var prevTime = currentDuration * i + (isReverse ? currentDuration - prevEntry[0] : prevEntry[0]);
            var divideTime = dot$1(prevEntry[1], time2, lastTime - prevTime, currentTime - lastTime);
            addEntry(nextEntries, (delay + currentDuration * iterationCount) / playSpeed, divideTime);
          }
          break;
        } else if (currentTime === lastTime && nextEntries.length && nextEntries[nextEntries.length - 1][0] === lastTime + delay) {
          break;
        }
        addEntry(nextEntries, (delay + currentTime) / playSpeed, time2);
      }
    }
    delay && nextEntries.unshift([0, nextEntries[0][1]]);
    entries = nextEntries;
    nextEntries = [];
  });
  return entries;
}
var SceneItem = /* @__PURE__ */ function(_super) {
  __extends$6(SceneItem2, _super);
  function SceneItem2(properties, options) {
    var _this = _super.call(this) || this;
    _this.times = [];
    _this.items = {};
    _this.nameMap = new OrderMap(NAME_SEPARATOR);
    _this.elements = [];
    _this.needUpdate = true;
    _this.registeredElement = false;
    _this.load(properties, options);
    return _this;
  }
  SceneItem2.prototype.getDuration = function() {
    var times = this.times;
    var length = times.length;
    return (length === 0 ? 0 : times[length - 1]) || this.state[DURATION];
  };
  SceneItem2.prototype.size = function() {
    return this.times.length;
  };
  SceneItem2.prototype.setDuration = function(duration2) {
    if (!duration2) {
      return this;
    }
    var originalDuration = this.getDuration();
    if (originalDuration > 0) {
      var ratio_1 = duration2 / originalDuration;
      var _a2 = this, times = _a2.times, items_1 = _a2.items;
      var obj_1 = {};
      this.times = times.map(function(time2) {
        var time22 = toFixed(time2 * ratio_1);
        obj_1[time22] = items_1[time2];
        return time22;
      });
      this.items = obj_1;
    } else {
      this.newFrame(duration2);
    }
    return this;
  };
  SceneItem2.prototype.setId = function(id) {
    var state = this.state;
    var elements = this.elements;
    var length = elements.length;
    state.id = id || makeId(!!length);
    if (length && !state[SELECTOR]) {
      var sceneId_1 = toId(this.getId());
      state[SELECTOR] = "[".concat(DATA_SCENE_ID, '="').concat(sceneId_1, '"]');
      elements.forEach(function(element) {
        element.setAttribute(DATA_SCENE_ID, sceneId_1);
      });
    }
    return this;
  };
  SceneItem2.prototype.set = function(time2) {
    var _this = this;
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (isSceneItem(time2)) {
      return this.set(0, time2);
    } else if (isArray$1(time2)) {
      var length_1 = time2.length;
      for (var i = 0; i < length_1; ++i) {
        var t = length_1 === 1 ? 0 : this.getUnitTime("".concat(i / (length_1 - 1) * 100, "%"));
        this.set(t, time2[i]);
      }
    } else if (isObject$2(time2)) {
      var _loop_1 = function(t2) {
        var value = time2[t2];
        splitComma(t2).forEach(function(eachTime) {
          var realTime = _this.getUnitTime(eachTime);
          if (isNaN(realTime)) {
            getNames(value, [eachTime]).forEach(function(names) {
              var _a2;
              var innerValue = getValueByNames(names.slice(1), value);
              var arr2 = isArray$1(innerValue) ? innerValue : [getValueByNames(names, _this.target), innerValue];
              var length = arr2.length;
              for (var i2 = 0; i2 < length; ++i2) {
                (_a2 = _this.newFrame("".concat(i2 / (length - 1) * 100, "%"))).set.apply(_a2, __spreadArray$2(__spreadArray$2([], names, false), [arr2[i2]], false));
              }
            });
          } else {
            _this.set(realTime, value);
          }
        });
      };
      for (var t in time2) {
        _loop_1(t);
      }
    } else if (!isUndefined$2(time2)) {
      var value_1 = args[0];
      splitComma(time2 + "").forEach(function(eachTime) {
        var realTime = _this.getUnitTime(eachTime);
        if (isSceneItem(value_1)) {
          var delay = value_1.getDelay();
          var frames_1 = value_1.toObject(!_this.hasFrame(realTime + delay));
          var duration2 = value_1.getDuration();
          var direction2 = value_1.getDirection();
          var isReverse = direction2.indexOf("reverse") > -1;
          for (var frameTime in frames_1) {
            var nextTime = isReverse ? duration2 - parseFloat(frameTime) : parseFloat(frameTime);
            _this.set(realTime + nextTime, frames_1[frameTime]);
          }
        } else if (args.length === 1 && isArray$1(value_1)) {
          value_1.forEach(function(item) {
            _this.set(realTime, item);
          });
        } else {
          var frame = _this.newFrame(realTime);
          frame.set.apply(frame, args);
        }
      });
    }
    this.needUpdate = true;
    return this;
  };
  SceneItem2.prototype.get = function(time2) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    var frame = this.getFrame(time2);
    return frame && frame.get.apply(frame, args);
  };
  SceneItem2.prototype.getOrders = function(names) {
    this.needUpdate && this.update();
    return this.nameMap.get(names);
  };
  SceneItem2.prototype.setOrders = function(names, orders) {
    this.needUpdate && this.update();
    var result = this.nameMap.set(names, orders);
    this.updateFrameOrders();
    return result;
  };
  SceneItem2.prototype.getOrderObject = function() {
    return this.nameMap.getObject();
  };
  SceneItem2.prototype.setOrderObject = function(obj) {
    this.nameMap.setObject(obj);
    this.updateFrameOrders();
  };
  SceneItem2.prototype.remove = function(time2) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (args.length) {
      var frame = this.getFrame(time2);
      frame && frame.remove.apply(frame, args);
    } else {
      this.removeFrame(time2);
    }
    this.needUpdate = true;
    return this;
  };
  SceneItem2.prototype.append = function(item) {
    if (isSceneItem(item)) {
      this.set(this.getDuration(), item);
    } else {
      this.append(new SceneItem2(item));
    }
    return this;
  };
  SceneItem2.prototype.prepend = function(item) {
    if (isSceneItem(item)) {
      var unshiftTime = item.getDuration() + item.getDelay();
      var firstFrame = this.getFrame(0);
      this.removeFrame(0);
      this.unshift(unshiftTime);
      this.set(0, item);
      this.set(unshiftTime + THRESHOLD, firstFrame);
    } else {
      this.prepend(new SceneItem2(item));
    }
    return this;
  };
  SceneItem2.prototype.unshift = function(time2) {
    var _a2 = this, times = _a2.times, items = _a2.items;
    var obj = {};
    this.times = times.map(function(t) {
      var time22 = toFixed(time2 + t);
      obj[time22] = items[t];
      return time22;
    });
    this.items = obj;
    return this;
  };
  SceneItem2.prototype.toObject = function(isStartZero) {
    if (isStartZero === void 0) {
      isStartZero = true;
    }
    var obj = {};
    var delay = this.getDelay();
    this.forEach(function(frame, time2) {
      obj[(!time2 && !isStartZero ? THRESHOLD : 0) + delay + time2] = frame.clone();
    });
    return obj;
  };
  SceneItem2.prototype.setSelector = function(target) {
    this.setElement(target);
    return this;
  };
  SceneItem2.prototype.getElements = function() {
    return this.elements;
  };
  SceneItem2.prototype.setElements = function(target) {
    return this.setElement(target);
  };
  SceneItem2.prototype.setElement = function(target) {
    if (target !== true && this.registeredElement !== target) {
      this.registeredElement = target;
    }
    var state = this.state;
    var selectorTarget = this.registeredElement;
    var nextTarget = target;
    var elements = [];
    if (isFunction$2(selectorTarget)) {
      nextTarget = selectorTarget(this.getId(), 0);
    }
    if (!nextTarget) {
      return this;
    } else if (nextTarget === true || isString$2(nextTarget)) {
      var prevSelector = isString$2(state[SELECTOR]) && state[SELECTOR] || "".concat(state.id);
      var selector = nextTarget === true ? prevSelector : nextTarget;
      var matches2 = /([\s\S]+)(:+[a-zA-Z]+)$/g.exec(selector);
      try {
        elements = toArray($$1(matches2 ? matches2[1] : selector, true));
      } catch (e2) {
        elements = [];
      }
      state[SELECTOR] = selector;
    } else if (isArrayLike(nextTarget)) {
      elements = toArray(nextTarget);
    } else if (nextTarget instanceof Element) {
      elements = [nextTarget];
    } else if ("current" in nextTarget || "value" in nextTarget) {
      var currentTarget = nextTarget.current || nextTarget.value;
      if (currentTarget) {
        elements = [currentTarget];
      } else {
        elements = [];
      }
    }
    if (!elements.length) {
      return this;
    }
    this.elements = elements;
    this.setId(this.getId());
    this.target = elements[0].style;
    this.targetFunc = function(frame) {
      var attributes = frame.get("attribute");
      if (attributes) {
        var _loop_2 = function(name_22) {
          elements.forEach(function(el) {
            el.setAttribute(name_22, attributes[name_22]);
          });
        };
        for (var name_2 in attributes) {
          _loop_2(name_2);
        }
      }
      if (frame.has("html")) {
        var html_1 = frame.get("html");
        elements.forEach(function(el) {
          el.innerHTML = html_1;
        });
      }
      var cssText = frame.toCSSText();
      if (state.cssText !== cssText) {
        state.cssText = cssText;
        elements.forEach(function(el) {
          el.style.cssText += cssText;
        });
        return frame;
      }
    };
    return this;
  };
  SceneItem2.prototype.setTarget = function(target) {
    this.target = target;
    this.targetFunc = function(frame) {
      var obj = frame.get();
      for (var name_3 in obj) {
        target[name_3] = obj[name_3];
      }
    };
    return this;
  };
  SceneItem2.prototype.setCSS = function(time2, properties) {
    if (properties === void 0) {
      properties = [];
    }
    this.set(time2, fromCSS(this.elements, properties));
    return this;
  };
  SceneItem2.prototype.setTime = function(time2, isTick, isParent, parentEasing) {
    var _this = this;
    _super.prototype.setTime.call(this, time2, isTick, isParent, function() {
      var iterationTime = _this.getIterationTime();
      var easing = _this.getEasing() || parentEasing;
      var frame = _this.getNowFrame(iterationTime, easing);
      var currentTime = _this.getTime();
      _this.temp = frame;
      _this.trigger("animate", {
        frame,
        currentTime,
        time: iterationTime
      });
      _this.targetFunc && _this.targetFunc(frame);
    });
    return this;
  };
  SceneItem2.prototype.update = function() {
    var prevNameMap = this.nameMap;
    var names = {};
    this.forEach(function(frame) {
      updateFrame(names, frame.properties);
    });
    var nameMap = new OrderMap(NAME_SEPARATOR);
    function pushKeys(map, stack) {
      var keys2 = getKeys(map);
      sortOrders(keys2, prevNameMap.get(stack));
      nameMap.set(stack, keys2);
      keys2.forEach(function(key) {
        var nextMap = map[key];
        if (isObject$2(nextMap)) {
          pushKeys(nextMap, __spreadArray$2(__spreadArray$2([], stack, true), [key], false));
        }
      });
    }
    pushKeys(names, []);
    this.nameMap = nameMap;
    this.forEach(function(frame) {
      frame.setOrderObject(nameMap.orderMap);
    });
    this.needUpdate = false;
    return this;
  };
  SceneItem2.prototype.newFrame = function(time2) {
    var frame = this.getFrame(time2);
    if (frame) {
      return frame;
    }
    frame = new Frame();
    this.setFrame(time2, frame);
    return frame;
  };
  SceneItem2.prototype.setFrame = function(time2, frame) {
    var realTime = this.getUnitTime(time2);
    this.items[realTime] = frame;
    addTime(this.times, realTime);
    this.needUpdate = true;
    return this;
  };
  SceneItem2.prototype.getFrame = function(time2) {
    return this.items[this.getUnitTime(time2)];
  };
  SceneItem2.prototype.removeFrame = function(time2) {
    var realTime = this.getUnitTime(time2);
    var items = this.items;
    var index2 = this.times.indexOf(realTime);
    delete items[realTime];
    if (index2 > -1) {
      this.times.splice(index2, 1);
    }
    this.needUpdate = true;
    return this;
  };
  SceneItem2.prototype.hasFrame = function(time2) {
    return this.getUnitTime(time2) in this.items;
  };
  SceneItem2.prototype.hasName = function(args) {
    this.needUpdate && this.update();
    return !!this.nameMap.hasName(args);
  };
  SceneItem2.prototype.mergeFrame = function(time2, frame) {
    if (frame) {
      var toFrame = this.newFrame(time2);
      toFrame.merge(frame);
    }
    return this;
  };
  SceneItem2.prototype.getNowFrame = function(time2, parentEasing, isAccurate) {
    var _this = this;
    this.needUpdate && this.update();
    var frame = new Frame();
    var _a2 = getNearTimeIndex(this.times, time2), left = _a2[0], right = _a2[1];
    var realEasing = this.getEasing() || parentEasing;
    var nameMap = this.nameMap;
    if (this.hasName([TIMING_FUNCTION])) {
      var nowEasing = this.getNowValue(time2, [TIMING_FUNCTION], left, right, false, 0, true);
      isFunction$2(nowEasing) && (realEasing = nowEasing);
    }
    if (isAccurate) {
      var prevFrame_1 = this.getFrame(time2);
      var prevOrderMap = prevFrame_1.orderMap.filter([], function(orders2) {
        return prevFrame_1.has.apply(prevFrame_1, orders2);
      });
      for (var name_4 in ROLES) {
        var orders = nameMap.get([name_4]);
        if (prevOrderMap.get([name_4]) && orders) {
          prevOrderMap.set([name_4], orders);
        }
      }
      nameMap = prevOrderMap;
    }
    var names = nameMap.gets([]);
    frame.setOrderObject(nameMap.orderMap);
    names.forEach(function(properties) {
      var value = _this.getNowValue(time2, properties, left, right, isAccurate, realEasing, isFixed(properties));
      if (isUndefined$2(value)) {
        return;
      }
      frame.set(properties, value);
    });
    return frame;
  };
  SceneItem2.prototype.getCurrentFrame = function(needUpdate, parentEasing) {
    var iterationTime = this.getIterationTime();
    var frame = needUpdate || this.needUpdate || !this.temp ? this.getComputedFrame(iterationTime, parentEasing) : this.temp;
    this.temp = frame;
    return frame;
  };
  SceneItem2.prototype.getComputedFrame = function(time2, parentEasing, isAccurate) {
    return this.getNowFrame(time2, parentEasing, isAccurate);
  };
  SceneItem2.prototype.load = function(properties, options) {
    var _a2;
    if (properties === void 0) {
      properties = {};
    }
    if (options === void 0) {
      options = properties.options;
    }
    options && this.setOptions(options);
    if (isArray$1(properties)) {
      this.set(properties);
    } else if (properties.keyframes) {
      this.set(properties.keyframes);
    } else {
      for (var time2 in properties) {
        if (time2 !== "options") {
          this.set((_a2 = {}, _a2[time2] = properties[time2], _a2));
        }
      }
    }
    if (options && options[DURATION]) {
      this.setDuration(options[DURATION]);
    }
    return this;
  };
  SceneItem2.prototype.clone = function() {
    var item = new SceneItem2();
    item.setOptions(this.state);
    item.setOrderObject(this.nameMap.orderMap);
    this.forEach(function(frame, time2) {
      item.setFrame(time2, frame.clone());
    });
    return item;
  };
  SceneItem2.prototype.forEach = function(callback) {
    var times = this.times;
    var items = this.items;
    times.forEach(function(time2) {
      callback(items[time2], time2, items);
    });
    return this;
  };
  SceneItem2.prototype.setOptions = function(options) {
    if (options === void 0) {
      options = {};
    }
    _super.prototype.setOptions.call(this, options);
    var id = options.id, selector = options.selector, elements = options.elements, element = options.element, target = options.target;
    id && this.setId(id);
    if (target) {
      this.setTarget(target);
    } else if (selector && !this.state.noRegisterElement) {
      this.setSelector(selector);
    } else if (elements || element) {
      this.setElement(elements || element);
    }
    return this;
  };
  SceneItem2.prototype.toCSS = function(playCondition, parentDuration, states) {
    if (playCondition === void 0) {
      playCondition = { className: START_ANIMATION };
    }
    if (parentDuration === void 0) {
      parentDuration = this.getDuration();
    }
    if (states === void 0) {
      states = [];
    }
    var itemState = this.state;
    var selector = itemState[SELECTOR];
    if (!selector) {
      return "";
    }
    var originalDuration = this.getDuration();
    itemState[DURATION] = originalDuration;
    states.push(itemState);
    var reversedStates = toArray(states).reverse();
    var id = toId(getRealId(this));
    var superParent = states[0];
    var infiniteIndex = findIndex(reversedStates, function(state) {
      return state[ITERATION_COUNT] === INFINITE || !isFinite(state[DURATION]);
    }, states.length - 1);
    var finiteStates = reversedStates.slice(0, infiniteIndex);
    var duration2 = parentDuration || finiteStates.reduce(function(prev, cur) {
      return (cur[DELAY] + prev * cur[ITERATION_COUNT]) / cur[PLAY_SPEED];
    }, originalDuration);
    var delay = reversedStates.slice(infiniteIndex).reduce(function(prev, cur) {
      return (prev + cur[DELAY]) / cur[PLAY_SPEED];
    }, 0);
    var easingName = find$2(reversedStates, function(state) {
      return state[EASING] && state[EASING_NAME];
    }, itemState)[EASING_NAME];
    var iterationCount = reversedStates[infiniteIndex][ITERATION_COUNT];
    var fillMode = superParent[FILL_MODE];
    var direction2 = reversedStates[infiniteIndex][DIRECTION];
    var cssText = makeAnimationProperties({
      fillMode,
      direction: direction2,
      iterationCount,
      delay: "".concat(delay, "s"),
      name: "".concat(PREFIX, "KEYFRAMES_").concat(id),
      duration: "".concat(duration2 / superParent[PLAY_SPEED], "s"),
      timingFunction: easingName
    });
    var selectors = splitComma(selector).map(function(sel) {
      var matches2 = /([\s\S]+)(:+[a-zA-Z]+)$/g.exec(sel);
      if (matches2) {
        return [matches2[1], matches2[2]];
      } else {
        return [sel, ""];
      }
    });
    var className = playCondition.className;
    var selectorCallback = playCondition.selector;
    var preselector = isFunction$2(selectorCallback) ? selectorCallback(this, selector) : selectorCallback;
    return "\n    ".concat(preselector || selectors.map(function(_a2) {
      var sel = _a2[0], peusdo = _a2[1];
      return "".concat(sel, ".").concat(className).concat(peusdo);
    }), " {").concat(cssText, "}\n    ").concat(selectors.map(function(_a2) {
      var sel = _a2[0], peusdo = _a2[1];
      return "".concat(sel, ".").concat(PAUSE_ANIMATION).concat(peusdo);
    }), " {").concat(ANIMATION, "-play-state: paused;}\n    @").concat(KEYFRAMES, " ").concat(PREFIX, "KEYFRAMES_").concat(id, "{").concat(this._toKeyframes(duration2, finiteStates, direction2), "}");
  };
  SceneItem2.prototype.exportCSS = function(playCondition, duration2, options) {
    if (!this.elements.length) {
      return "";
    }
    var css2 = this.toCSS(playCondition, duration2, options);
    var isParent = options && !isUndefined$2(options[ITERATION_COUNT]);
    if (!isParent) {
      if (this.styledInjector) {
        this.styledInjector.destroy();
        this.styledInjector = null;
      }
      this.styled = styled$1(css2);
      this.styledInjector = this.styled.inject(this.getAnimationElement(), { original: true });
    }
    return this;
  };
  SceneItem2.prototype.pause = function() {
    _super.prototype.pause.call(this);
    isPausedCSS(this) && this.pauseCSS();
    return this;
  };
  SceneItem2.prototype.pauseCSS = function() {
    this.elements.forEach(function(element) {
      addClass(element, PAUSE_ANIMATION);
    });
    return this;
  };
  SceneItem2.prototype.endCSS = function() {
    this.elements.forEach(function(element) {
      removeClass(element, PAUSE_ANIMATION);
      removeClass(element, START_ANIMATION);
    });
    setPlayCSS(this, false);
    return this;
  };
  SceneItem2.prototype.end = function() {
    isEndedCSS(this) && this.endCSS();
    _super.prototype.end.call(this);
    return this;
  };
  SceneItem2.prototype.playCSS = function(isExportCSS, playClassName, properties) {
    if (isExportCSS === void 0) {
      isExportCSS = true;
    }
    if (properties === void 0) {
      properties = {};
    }
    playCSS(this, isExportCSS, playClassName, properties);
    return this;
  };
  SceneItem2.prototype.getAnimationElement = function() {
    return this.elements[0];
  };
  SceneItem2.prototype.addPlayClass = function(isPaused, playClassName, properties) {
    if (properties === void 0) {
      properties = {};
    }
    var elements = this.elements;
    var length = elements.length;
    var cssText = makeAnimationProperties(properties);
    if (!length) {
      return;
    }
    if (isPaused) {
      elements.forEach(function(element) {
        removeClass(element, PAUSE_ANIMATION);
      });
    } else {
      elements.forEach(function(element) {
        element.style.cssText += cssText;
        if (hasClass(element, START_ANIMATION)) {
          removeClass(element, START_ANIMATION);
        }
      });
      elements.forEach(function(element) {
        element.clientWidth;
      });
      elements.forEach(function(element) {
        addClass(element, START_ANIMATION);
      });
    }
    return elements[0];
  };
  SceneItem2.prototype.clear = function() {
    this.times = [];
    this.items = {};
    this.nameMap = new OrderMap(NAME_SEPARATOR);
    if (this.styledInjector) {
      this.styledInjector.destroy();
    }
    this.styled = null;
    this.styledInjector = null;
    this.temp = null;
    this.needUpdate = true;
    return this;
  };
  SceneItem2.prototype.getNowValue = function(time2, properties, left, right, isAccurate, easing, usePrevValue) {
    var times = this.times;
    var length = times.length;
    var prevTime;
    var nextTime;
    var prevFrame;
    var nextFrame;
    var isUndefinedLeft = isUndefined$2(left);
    var isUndefinedRight = isUndefined$2(right);
    if (isUndefinedLeft || isUndefinedRight) {
      var indicies = getNearTimeIndex(times, time2);
      isUndefinedLeft && (left = indicies[0]);
      isUndefinedRight && (right = indicies[1]);
    }
    for (var i = left; i >= 0; --i) {
      var frame = this.getFrame(times[i]);
      if (frame.has.apply(frame, properties)) {
        prevTime = times[i];
        prevFrame = frame;
        break;
      }
    }
    var prevValue = prevFrame && prevFrame.raw.apply(prevFrame, properties);
    if (isAccurate && !isRole([properties[0]])) {
      return prevTime === time2 ? prevValue : void 0;
    }
    if (usePrevValue) {
      return prevValue;
    }
    for (var i = right; i < length; ++i) {
      var frame = this.getFrame(times[i]);
      if (frame.has.apply(frame, properties)) {
        nextTime = times[i];
        nextFrame = frame;
        break;
      }
    }
    var nextValue = nextFrame && nextFrame.raw.apply(nextFrame, properties);
    if (!prevFrame || isUndefined$2(prevValue)) {
      return nextValue;
    }
    if (!nextFrame || isUndefined$2(nextValue) || prevValue === nextValue) {
      return prevValue;
    }
    return dotValue(time2, Math.max(prevTime, 0), nextTime, prevValue, nextValue, easing);
  };
  SceneItem2.prototype._toKeyframes = function(duration2, states, direction2) {
    var _this = this;
    var frames = {};
    var times = this.times.slice();
    if (!times.length) {
      return "";
    }
    var originalDuration = this.getDuration();
    !this.getFrame(0) && times.unshift(0);
    !this.getFrame(originalDuration) && times.push(originalDuration);
    var entries = getEntries(times, states);
    var lastEntry = entries[entries.length - 1];
    lastEntry[0] < duration2 && addEntry(entries, duration2, lastEntry[1]);
    var prevTime = -1;
    return entries.map(function(_a2) {
      var time2 = _a2[0], keytime = _a2[1];
      if (!frames[keytime]) {
        frames[keytime] = (!_this.hasFrame(keytime) || keytime === 0 || keytime === originalDuration ? _this.getNowFrame(keytime) : _this.getNowFrame(keytime, 0, true)).toCSSText();
      }
      var frameTime = time2 / duration2 * 100;
      if (frameTime - prevTime < THRESHOLD) {
        frameTime += THRESHOLD;
      }
      prevTime = frameTime;
      return "".concat(Math.min(frameTime, 100), "%{\n                ").concat(time2 === 0 && !isDirectionReverse(0, 1, direction2) ? "" : frames[keytime], "\n            }");
    }).join("");
  };
  SceneItem2.prototype.updateFrameOrders = function() {
    var nameMap = this.nameMap.orderMap;
    this.forEach(function(frame) {
      frame.setOrderObject(nameMap);
    });
  };
  return SceneItem2;
}(Animator);
var Scene = /* @__PURE__ */ function(_super) {
  __extends$6(Scene2, _super);
  function Scene2(properties, options) {
    var _this = _super.call(this) || this;
    _this.items = {};
    _this.orderMap = new OrderMap(NAME_SEPARATOR);
    _this.load(properties, options);
    return _this;
  }
  Scene2.prototype.getDuration = function() {
    var time2 = 0;
    this.forEach(function(item) {
      time2 = Math.max(time2, item.getTotalDuration() / item.getPlaySpeed());
    });
    return time2 || this.state[DURATION];
  };
  Scene2.prototype.setDuration = function(duration2) {
    this.items;
    var sceneDuration = this.getDuration();
    if (duration2 === 0 || !isFinite(sceneDuration)) {
      return this;
    }
    if (sceneDuration === 0) {
      this.forEach(function(item) {
        item.setDuration(duration2);
      });
    } else {
      var ratio_1 = duration2 / sceneDuration;
      this.forEach(function(item) {
        item.setDelay(item.getDelay() * ratio_1);
        item.setDuration(item.getDuration() * ratio_1);
      });
    }
    _super.prototype.setDuration.call(this, duration2);
    return this;
  };
  Scene2.prototype.getItem = function(name2) {
    return this.items[name2];
  };
  Scene2.prototype.newItem = function(name2, options) {
    if (options === void 0) {
      options = {};
    }
    if (this.items[name2]) {
      return this.items[name2];
    }
    var item = new SceneItem();
    this.setItem(name2, item);
    item.setOptions(options);
    return item;
  };
  Scene2.prototype.removeItem = function(name2) {
    delete this.items[name2];
    this.orderMap.remove([name2]);
    return this;
  };
  Scene2.prototype.setItem = function(name2, item) {
    item.setId(name2);
    this.items[name2] = item;
    this.orderMap.add([name2]);
    return this;
  };
  Scene2.prototype.getCurrentFrames = function(needUpdate, parentEasing) {
    var easing = this.getEasing() || parentEasing;
    var frames = {};
    this.forEach(function(item) {
      var id = item.getId();
      if (isScene(item)) {
        frames[id] = item.getCurrentFrames(needUpdate, easing);
      } else {
        frames[id] = item.getCurrentFrame(needUpdate, easing);
      }
    });
    this.temp = frames;
    return frames;
  };
  Scene2.prototype.getCurrentFlattedFrames = function(needUpdate, parentEasing) {
    var frames = this.getCurrentFrames(needUpdate, parentEasing);
    return flatSceneObject(frames, NAME_SEPARATOR);
  };
  Scene2.prototype.setTime = function(time2, isTick, isParent, parentEasing) {
    var _this = this;
    _super.prototype.setTime.call(this, time2, isTick, isParent, function() {
      var iterationTime = _this.getIterationTime();
      var easing = _this.getEasing() || parentEasing;
      _this.forEach(function(item) {
        item.setTime(iterationTime * item.getPlaySpeed() - item.getDelay(), isTick, true, easing);
      });
      var frames = _this.getCurrentFrames(false, parentEasing);
      _this.trigger("animate", {
        frames,
        currentTime: _this.getTime(),
        time: iterationTime
      });
    });
    return this;
  };
  Scene2.prototype.forEach = function(func) {
    var items = this.items;
    this.getOrders().forEach(function(id, index2) {
      func(items[id], id, index2, items);
    });
    return this;
  };
  Scene2.prototype.toCSS = function(playCondition, duration2, parentStates) {
    if (duration2 === void 0) {
      duration2 = this.getDuration();
    }
    if (parentStates === void 0) {
      parentStates = [];
    }
    var totalDuration = !duration2 || !isFinite(duration2) ? 0 : duration2;
    var styles = [];
    var state = this.state;
    state[DURATION] = this.getDuration();
    this.forEach(function(item) {
      styles.push(item.toCSS(playCondition, totalDuration, parentStates.concat(state)));
    });
    return styles.join("");
  };
  Scene2.prototype.exportCSS = function(playCondition, duration2, parentStates) {
    var css2 = this.toCSS(playCondition, duration2, parentStates);
    if (!parentStates || !parentStates.length) {
      if (this.styledInjector) {
        this.styledInjector.destroy();
        this.styledInjector = null;
      }
      this.styled = styled$1(css2);
      this.styledInjector = this.styled.inject(this.getAnimationElement(), { original: true });
    }
    return this;
  };
  Scene2.prototype.append = function(item) {
    item.setDelay(item.getDelay() + this.getDuration());
    this.setItem(getRealId(item), item);
  };
  Scene2.prototype.pauseCSS = function() {
    return this.forEach(function(item) {
      item.pauseCSS();
    });
  };
  Scene2.prototype.pause = function() {
    _super.prototype.pause.call(this);
    isPausedCSS(this) && this.pauseCSS();
    this.forEach(function(item) {
      item.pause();
    });
    return this;
  };
  Scene2.prototype.endCSS = function() {
    this.forEach(function(item) {
      item.endCSS();
    });
    setPlayCSS(this, false);
  };
  Scene2.prototype.end = function() {
    isEndedCSS(this) && this.endCSS();
    _super.prototype.end.call(this);
    return this;
  };
  Scene2.prototype.getOrders = function() {
    return this.orderMap.get([]) || [];
  };
  Scene2.prototype.setOrders = function(orders) {
    return this.orderMap.set([], orders);
  };
  Scene2.prototype.getAnimationElement = function() {
    var animtionElement;
    this.forEach(function(item) {
      var el = item.getAnimationElement();
      !animtionElement && (animtionElement = el);
    });
    return animtionElement;
  };
  Scene2.prototype.addPlayClass = function(isPaused, playClassName, properties) {
    if (properties === void 0) {
      properties = {};
    }
    var animtionElement;
    this.forEach(function(item) {
      var el = item.addPlayClass(isPaused, playClassName, properties);
      !animtionElement && (animtionElement = el);
    });
    return animtionElement;
  };
  Scene2.prototype.playCSS = function(isExportCSS, playClassName, properties) {
    if (isExportCSS === void 0) {
      isExportCSS = true;
    }
    if (properties === void 0) {
      properties = {};
    }
    playCSS(this, isExportCSS, playClassName, properties);
    return this;
  };
  Scene2.prototype.set = function(properties) {
    this.load(properties);
    return this;
  };
  Scene2.prototype.clear = function() {
    this.finish();
    this.items = {};
    this.orderMap = new OrderMap(NAME_SEPARATOR);
    if (this.styledInjector) {
      this.styledInjector.destroy();
    }
    this.styled = null;
    this.styledInjector = null;
  };
  Scene2.prototype.load = function(properties, options) {
    if (properties === void 0) {
      properties = {};
    }
    if (options === void 0) {
      options = properties.options;
    }
    if (!properties) {
      return this;
    }
    this.setOptions(options);
    var selector = options && options[SELECTOR] || this.state[SELECTOR];
    var _loop_1 = function(name_12) {
      if (name_12 === "options") {
        return "continue";
      }
      var object = properties[name_12];
      var item = void 0;
      if (isScene(object) || isSceneItem(object)) {
        this_1.setItem(name_12, object);
        item = object;
      } else if (isFunction$2(object)) {
        var elements = [];
        if (selector && IS_WINDOW) {
          if (!this_1.state.noRegisterElement) {
            elements = $$1("".concat(isFunction$2(selector) ? selector(name_12) : name_12), true);
          }
        }
        var elementsLength = elements.length;
        var length_1 = elementsLength || object.defaultCount || 0;
        var scene = new Scene2();
        var ids_1 = [];
        for (var i = 0; i < length_1; ++i) {
          var element = elements[i];
          var subItem = scene.newItem(i);
          subItem.setId().load(object(i, elements[i]));
          ids_1.push(subItem.getId());
          if (element) {
            subItem.setElement(element);
          }
        }
        if (!elementsLength) {
          var subElements_1 = [];
          scene.state[SELECTOR] = function(id) {
            if (!subElements_1.length) {
              subElements_1 = $$1("".concat(isFunction$2(selector) ? selector(name_12) : name_12), true);
            }
            return subElements_1[ids_1.indexOf(id)];
          };
        }
        this_1.setItem(name_12, scene);
        return "continue";
      } else {
        item = this_1.newItem(name_12, {
          noRegisterElement: true
        });
        item.load(object);
      }
      if (!this_1.state.noRegisterElement) {
        selector && item.setSelector(selector);
      }
    };
    var this_1 = this;
    for (var name_1 in properties) {
      _loop_1(name_1);
    }
  };
  Scene2.prototype.setOptions = function(options) {
    if (options === void 0) {
      options = {};
    }
    _super.prototype.setOptions.call(this, options);
    var selector = options.selector;
    if (selector) {
      this.state[SELECTOR] = selector;
    }
    return this;
  };
  Scene2.prototype.setSelector = function(target) {
    var state = this.state;
    var selector = target === true ? state[SELECTOR] || true : target;
    state[SELECTOR] = selector;
    var isItFunction = isFunction$2(target);
    if (selector) {
      this.forEach(function(item, name2) {
        item.setSelector(isItFunction ? target(name2) : selector);
      });
    }
    return this;
  };
  Scene2.prototype.start = function(delay) {
    if (delay === void 0) {
      delay = this.state[DELAY];
    }
    var result = _super.prototype.start.call(this, delay);
    if (result) {
      this.forEach(function(item) {
        item.start(0);
      });
    } else {
      this.forEach(function(item) {
        item.setPlayState(RUNNING);
      });
    }
    return result;
  };
  Scene2.VERSION = "1.10.3";
  return Scene2;
}(Animator);
function getMethodNames(classConstructor) {
  var prototype = classConstructor.prototype;
  return getKeys(prototype).filter(function(name2) {
    var descriptor = Object.getOwnPropertyDescriptor(prototype, name2);
    if (name2 === "constructor") {
      return false;
    }
    return !descriptor.get && !descriptor.set && isFunction$2(descriptor.value || prototype[name2]);
  });
}
var EMITTER_METHODS = getMethodNames(EventEmitter$3);
var ANIMATOR_METHODS = __spreadArray$2(__spreadArray$2([], EMITTER_METHODS, true), getMethodNames(Animator), true);
__spreadArray$2(__spreadArray$2([], ANIMATOR_METHODS, true), getMethodNames(Scene), true);
__spreadArray$2(__spreadArray$2([], ANIMATOR_METHODS, true), getMethodNames(Scene), true);
var FRAME_METHODS = __spreadArray$2(__spreadArray$2([], ANIMATOR_METHODS, true), getMethodNames(Frame), true);
var FRAME_REACTIVE = {
  methods: FRAME_METHODS,
  created: function(data) {
    var nextObject = isFunction$2(data) ? data() : data;
    var updateCount = observe(0);
    var frame;
    if (isObserver(nextObject)) {
      frame = nextObject;
    } else {
      frame = observe(isFrame(nextObject) ? nextObject : new Frame(nextObject));
    }
    var cssText = computed(function() {
      frame.current;
      updateCount.current;
      return frame.current.toCSSText();
    });
    var cssObject = computed(function() {
      frame.current;
      cssText.current;
      return frame.current.toCSSObject();
    });
    var camelCasedCSSObject = computed(function() {
      frame.current;
      cssText.current;
      return frame.current.toCSSObject(true);
    });
    var onUpdate = function() {
      ++updateCount.current;
    };
    frame.subscribe(function(currentFrame, prevFrame) {
      prevFrame.off("update", onUpdate);
      currentFrame.on("update", onUpdate);
    });
    var nextReactiveObject = partialReactive(__assign$5({ cssText, cssObject, camelCasedCSSObject, onUpdate }, FRAME_METHODS.reduce(function(obj, cur) {
      obj[cur] = function() {
        var _a2;
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var currentFrame = frame.current;
        return currentFrame === null || currentFrame === void 0 ? void 0 : (_a2 = currentFrame[cur]).call.apply(_a2, __spreadArray$2([currentFrame], args, false));
      };
      return obj;
    }, {})));
    return nextReactiveObject;
  },
  destroy: function(inst) {
    inst.off("update", inst.onUpdate);
  }
};
__assign$5(__assign$5({}, FRAME_REACTIVE), { created: function(data) {
  var nextObject = isFunction$2(data) ? data() : data;
  var frame = observe(new Frame());
  nextObject.on("animate", function(e2) {
    frame.current = e2.frame;
  });
  return FRAME_REACTIVE.created(frame);
} });
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$4 = function() {
  __assign$4 = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$4.apply(this, arguments);
};
function getOrderIndex(frame, functionName) {
  var orders = frame.getOrders(["transform"]) || [];
  return orders.indexOf(functionName);
}
var MoveableHelper = /* @__PURE__ */ function() {
  function MoveableHelper2(options) {
    var _this = this;
    if (options === void 0) {
      options = {};
    }
    this.map = /* @__PURE__ */ new Map();
    this.onBeforeRenderStart = function(e2) {
      var frame = _this.testFrame(e2);
      e2.setTransform(frame.toCSSObject().transform || "");
    };
    this.onBeforeRenderGroupStart = function(e2) {
      e2.events.forEach(function(ev) {
        _this.onBeforeRenderStart(ev);
      });
    };
    this.onDragStart = function(e2) {
      var frame = _this.testFrame(e2);
      if (!frame) {
        return false;
      }
      _this.setTranasform(e2, frame, "translate");
    };
    this.onDrag = function(e2) {
      _this.testDrag(e2);
      _this.testRender(e2.target);
    };
    this.onDragGroupStart = function(e2) {
      e2.events.forEach(function(ev) {
        _this.onDragStart(ev);
      });
    };
    this.onDragGroup = function(e2) {
      e2.events.forEach(function(ev) {
        _this.onDrag(ev);
      });
    };
    this.onResizeStart = function(e2) {
      e2.dragStart && _this.onDragStart(e2.dragStart);
      e2.setOrigin(["%", "%"]);
    };
    this.onResize = function(e2) {
      _this.testResize(e2);
      _this.testRender(e2.target);
    };
    this.onResizeGroupStart = function(e2) {
      e2.events.forEach(function(ev) {
        _this.onResizeStart(ev);
      });
    };
    this.onResizeGroup = function(e2) {
      e2.events.forEach(function(ev) {
        _this.onResize(ev);
      });
    };
    this.onScaleStart = function(e2) {
      var frame = _this.testFrame(e2);
      if (!frame) {
        return false;
      }
      _this.setTranasform(e2, frame, "scale");
      e2.dragStart && _this.onDragStart(e2.dragStart);
    };
    this.onScale = function(e2) {
      _this.testScale(e2);
      _this.testRender(e2.target);
    };
    this.onScaleGroupStart = function(e2) {
      e2.events.forEach(function(ev) {
        _this.onScaleStart(ev);
      });
    };
    this.onScaleGroup = function(e2) {
      e2.events.forEach(function(ev) {
        _this.onScale(ev);
      });
    };
    this.onRotateStart = function(e2) {
      var frame = _this.testFrame(e2);
      if (!frame) {
        return false;
      }
      _this.setTranasform(e2, frame, "rotate");
      e2.dragStart && _this.onDragStart(e2.dragStart);
    };
    this.onRotate = function(e2) {
      _this.testRotate(e2);
      _this.testRender(e2.target);
    };
    this.onRotateGroupStart = function(e2) {
      e2.events.forEach(function(ev) {
        _this.onRotateStart(ev);
      });
    };
    this.onRotateGroup = function(e2) {
      e2.events.forEach(function(ev) {
        _this.onRotate(ev);
      });
    };
    this.onClip = function(e2) {
      var frame = _this.testFrame(e2);
      if (e2.clipType === "rect") {
        frame.set("clip", e2.clipStyle);
      } else {
        frame.set("clip-path", e2.clipStyle);
      }
      _this.testRender(e2.target);
    };
    this.onDragOriginStart = function(e2) {
      e2.dragStart && _this.onDragStart(e2.dragStart);
    };
    this.onDragOrigin = function(e2) {
      var frame = _this.testFrame(e2);
      frame.set("transform-origin", e2.transformOrigin);
      _this.testDrag(e2.drag);
      _this.testRender(e2.target);
    };
    this.onRound = function(e2) {
      var frame = _this.testFrame(e2);
      frame.set("border-radius", e2.borderRadius);
      _this.testRender(e2.target);
    };
    this.onWarpStart = function(e2) {
      var frame = _this.testFrame(e2);
      if (!frame) {
        return false;
      }
      _this.setTranasform(e2, frame, "matrix3d");
    };
    this.onWarp = function(e2) {
      var frame = _this.testFrame(e2);
      frame.set("transform", "matrix3d", e2.matrix.join(", "));
      _this.testRender(e2.target);
    };
    this.onRender = function(e2) {
      var target = e2.target;
      var frame = _this.getFrame(target);
      if (!target || !frame) {
        return;
      }
      _this.render(target, frame);
    };
    this.options = __assign$4({
      useBeforeRender: false,
      useRender: false,
      createAuto: true
    }, options);
  }
  var __proto = MoveableHelper2.prototype;
  MoveableHelper2.create = function(options) {
    return new MoveableHelper2(options);
  };
  __proto.render = function(target, frame) {
    if (frame === void 0) {
      frame = this.getFrame(target);
    }
    target.style.cssText += frame.toCSS();
    if ("ownerSVGElement" in target && target.tagName.toLowerCase() !== "svg") {
      var names = frame.getOrders(["transform"]);
      target.setAttribute("transform", names.map(function(name2) {
        var value = frame.get("transform", name2);
        return name2 + "(" + value.split(",").map(function(v) {
          return parseFloat(v);
        }).join(", ") + ")";
      }).join(" "));
    }
  };
  __proto.clear = function() {
    this.map.clear();
  };
  __proto.getTargets = function() {
    return this.map.keys();
  };
  __proto.getFrames = function() {
    return this.map.values();
  };
  __proto.getFrame = function(el) {
    return this.map.get(el);
  };
  __proto.setFrame = function(el, frame) {
    return this.map.set(el, frame);
  };
  __proto.removeFrame = function(el) {
    this.map.delete(el);
  };
  __proto.createFrame = function(el, properites) {
    if (properites === void 0) {
      properites = {};
    }
    var frame = new Frame({
      transform: {
        translate: "0px, 0px",
        rotate: "0deg",
        scale: "1, 1"
      }
    });
    frame.set(properites);
    this.map.set(el, frame);
    return frame;
  };
  __proto.setElements = function(selector) {
    var elements = isString$2(selector) ? document.querySelectorAll(selector) : selector;
    var length = elements.length;
    var map = this.map;
    for (var i = 0; i < length; ++i) {
      var el = elements[i];
      if (map.has(el)) {
        continue;
      }
      this.createFrame(el);
    }
  };
  __proto.testFrame = function(e2) {
    var target = e2.target;
    var frame = this.getFrame(target);
    if (frame) {
      return frame;
    }
    if (!this.options.createAuto) {
      if (e2.stop) {
        e2.stop();
        return;
      }
    }
    return this.createFrame(target);
  };
  __proto.testDrag = function(e2) {
    var target = e2.target;
    var translate = e2.translate;
    var frame = this.getFrame(target);
    var tx = translate[0] + "px";
    var ty = translate[1] + "px";
    if (frame.has("transform", "translate")) {
      frame.set("transform", "translate", tx + "," + ty);
    } else {
      frame.set("transform", "translateX", tx);
      frame.set("transform", "translateY", ty);
    }
  };
  __proto.testResize = function(e2) {
    var target = e2.target;
    var frame = this.getFrame(target);
    frame.set("width", e2.width + "px");
    frame.set("height", e2.height + "px");
    this.testDrag(e2.drag);
  };
  __proto.testScale = function(e2) {
    var frame = this.testFrame(e2);
    var scale = e2.scale;
    this.testDrag(e2.drag);
    frame.set("transform", "scale", scale[0] + "," + scale[1]);
  };
  __proto.testRotate = function(e2) {
    var frame = this.testFrame(e2);
    var rotate2 = e2.rotate;
    this.testDrag(e2.drag);
    frame.set("transform", "rotate", rotate2 + "deg");
  };
  __proto.testRender = function(target, frame) {
    if (frame === void 0) {
      frame = this.getFrame(target);
    }
    if (!this.options.useRender) {
      this.render(target, frame);
    }
  };
  __proto.setTranasform = function(e2, frame, functionName) {
    var orderIndex = getOrderIndex(frame, functionName);
    if (this.options.useBeforeRender) {
      e2.setTransformIndex(orderIndex);
    } else {
      e2.setTransform(frame.toCSSObject().transform || [], orderIndex);
    }
  };
  return MoveableHelper2;
}();
var MoveableHelper$1 = MoveableHelper;
var extendStatics$5 = function(d, b) {
  extendStatics$5 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics$5(d, b);
};
function __extends$5(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics$5(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function createCommonjsModule(fn2, module) {
  return module = {
    exports: {}
  }, fn2(module, module.exports), module.exports;
}
var keycode = createCommonjsModule(function(module, exports) {
  function keyCode(searchInput) {
    if (searchInput && "object" === typeof searchInput) {
      var hasKeyCode = searchInput.which || searchInput.keyCode || searchInput.charCode;
      if (hasKeyCode)
        searchInput = hasKeyCode;
    }
    if ("number" === typeof searchInput)
      return names[searchInput];
    var search = String(searchInput);
    var foundNamedKey = codes[search.toLowerCase()];
    if (foundNamedKey)
      return foundNamedKey;
    var foundNamedKey = aliases[search.toLowerCase()];
    if (foundNamedKey)
      return foundNamedKey;
    if (search.length === 1)
      return search.charCodeAt(0);
    return void 0;
  }
  keyCode.isEventKey = function isEventKey(event, nameOrCode) {
    if (event && "object" === typeof event) {
      var keyCode2 = event.which || event.keyCode || event.charCode;
      if (keyCode2 === null || keyCode2 === void 0) {
        return false;
      }
      if (typeof nameOrCode === "string") {
        var foundNamedKey = codes[nameOrCode.toLowerCase()];
        if (foundNamedKey) {
          return foundNamedKey === keyCode2;
        }
        var foundNamedKey = aliases[nameOrCode.toLowerCase()];
        if (foundNamedKey) {
          return foundNamedKey === keyCode2;
        }
      } else if (typeof nameOrCode === "number") {
        return nameOrCode === keyCode2;
      }
      return false;
    }
  };
  exports = module.exports = keyCode;
  var codes = exports.code = exports.codes = {
    "backspace": 8,
    "tab": 9,
    "enter": 13,
    "shift": 16,
    "ctrl": 17,
    "alt": 18,
    "pause/break": 19,
    "caps lock": 20,
    "esc": 27,
    "space": 32,
    "page up": 33,
    "page down": 34,
    "end": 35,
    "home": 36,
    "left": 37,
    "up": 38,
    "right": 39,
    "down": 40,
    "insert": 45,
    "delete": 46,
    "command": 91,
    "left command": 91,
    "right command": 93,
    "numpad *": 106,
    "numpad +": 107,
    "numpad -": 109,
    "numpad .": 110,
    "numpad /": 111,
    "num lock": 144,
    "scroll lock": 145,
    "my computer": 182,
    "my calculator": 183,
    ";": 186,
    "=": 187,
    ",": 188,
    "-": 189,
    ".": 190,
    "/": 191,
    "`": 192,
    "[": 219,
    "\\": 220,
    "]": 221,
    "'": 222
  };
  var aliases = exports.aliases = {
    "windows": 91,
    "\u21E7": 16,
    "\u2325": 18,
    "\u2303": 17,
    "\u2318": 91,
    "ctl": 17,
    "control": 17,
    "option": 18,
    "pause": 19,
    "break": 19,
    "caps": 20,
    "return": 13,
    "escape": 27,
    "spc": 32,
    "spacebar": 32,
    "pgup": 33,
    "pgdn": 34,
    "ins": 45,
    "del": 46,
    "cmd": 91
  };
  /*!
   * Programatically add the following
   */
  for (i = 97; i < 123; i++)
    codes[String.fromCharCode(i)] = i - 32;
  for (var i = 48; i < 58; i++)
    codes[i - 48] = i;
  for (i = 1; i < 13; i++)
    codes["f" + i] = i + 111;
  for (i = 0; i < 10; i++)
    codes["numpad " + i] = i + 96;
  var names = exports.names = exports.title = {};
  for (i in codes)
    names[codes[i]] = i;
  for (var alias in aliases) {
    codes[alias] = aliases[alias];
  }
});
keycode.code;
keycode.codes;
keycode.aliases;
var keycode_4 = keycode.names;
keycode.title;
var codeData = {
  "+": "plus",
  "left command": "meta",
  "right command": "meta"
};
var keysSort = {
  shift: 1,
  ctrl: 2,
  alt: 3,
  meta: 4
};
function getKey(keyCode, keyName) {
  var key = (keycode_4[keyCode] || keyName || "").toLowerCase();
  for (var name2 in codeData) {
    key = key.replace(name2, codeData[name2]);
  }
  return key.replace(/\s/g, "");
}
function getCombi(e2, key) {
  if (key === void 0) {
    key = getKey(e2.keyCode, e2.key);
  }
  var keys2 = getModifierCombi(e2);
  keys2.indexOf(key) === -1 && keys2.push(key);
  return keys2.filter(Boolean);
}
function getModifierCombi(e2) {
  var keys2 = [e2.shiftKey && "shift", e2.ctrlKey && "ctrl", e2.altKey && "alt", e2.metaKey && "meta"];
  return keys2.filter(Boolean);
}
function getArrangeCombi(keys2) {
  var arrangeKeys = keys2.slice();
  arrangeKeys.sort(function(prev, next) {
    var prevScore = keysSort[prev] || 5;
    var nextScore = keysSort[next] || 5;
    return prevScore - nextScore;
  });
  return arrangeKeys;
}
var globalKeyController;
var KeyController = /* @__PURE__ */ function(_super) {
  __extends$5(KeyController2, _super);
  function KeyController2(container) {
    if (container === void 0) {
      container = window;
    }
    var _this = _super.call(this) || this;
    _this.container = container;
    _this.ctrlKey = false;
    _this.altKey = false;
    _this.shiftKey = false;
    _this.metaKey = false;
    _this.clear = function() {
      _this.ctrlKey = false;
      _this.altKey = false;
      _this.shiftKey = false;
      _this.metaKey = false;
      return _this;
    };
    _this.keydownEvent = function(e2) {
      _this.triggerEvent("keydown", e2);
    };
    _this.keyupEvent = function(e2) {
      _this.triggerEvent("keyup", e2);
    };
    _this.blur = function() {
      _this.clear();
      _this.trigger("blur");
    };
    addEvent$1(container, "blur", _this.blur);
    addEvent$1(container, "keydown", _this.keydownEvent);
    addEvent$1(container, "keyup", _this.keyupEvent);
    return _this;
  }
  var __proto = KeyController2.prototype;
  Object.defineProperty(KeyController2, "global", {
    get: function() {
      return globalKeyController || (globalKeyController = new KeyController2());
    },
    enumerable: false,
    configurable: true
  });
  KeyController2.setGlobal = function() {
    return this.global;
  };
  __proto.destroy = function() {
    var container = this.container;
    this.clear();
    this.off();
    removeEvent(container, "blur", this.blur);
    removeEvent(container, "keydown", this.keydownEvent);
    removeEvent(container, "keyup", this.keyupEvent);
  };
  __proto.keydown = function(comb, callback) {
    return this.addEvent("keydown", comb, callback);
  };
  __proto.offKeydown = function(comb, callback) {
    return this.removeEvent("keydown", comb, callback);
  };
  __proto.offKeyup = function(comb, callback) {
    return this.removeEvent("keyup", comb, callback);
  };
  __proto.keyup = function(comb, callback) {
    return this.addEvent("keyup", comb, callback);
  };
  __proto.addEvent = function(type, comb, callback) {
    if (isArray$1(comb)) {
      this.on("".concat(type, ".").concat(getArrangeCombi(comb).join(".")), callback);
    } else if (isString$2(comb)) {
      this.on("".concat(type, ".").concat(comb), callback);
    } else {
      this.on(type, comb);
    }
    return this;
  };
  __proto.removeEvent = function(type, comb, callback) {
    if (isArray$1(comb)) {
      this.off("".concat(type, ".").concat(getArrangeCombi(comb).join(".")), callback);
    } else if (isString$2(comb)) {
      this.off("".concat(type, ".").concat(comb), callback);
    } else {
      this.off(type, comb);
    }
    return this;
  };
  __proto.triggerEvent = function(type, e2) {
    this.ctrlKey = e2.ctrlKey;
    this.shiftKey = e2.shiftKey;
    this.altKey = e2.altKey;
    this.metaKey = e2.metaKey;
    var key = getKey(e2.keyCode, e2.key);
    var isToggle = key === "ctrl" || key === "shift" || key === "meta" || key === "alt";
    var param = {
      key,
      isToggle,
      inputEvent: e2,
      keyCode: e2.keyCode,
      ctrlKey: e2.ctrlKey,
      altKey: e2.altKey,
      shiftKey: e2.shiftKey,
      metaKey: e2.metaKey
    };
    this.trigger(type, param);
    this.trigger("".concat(type, ".").concat(key), param);
    var combi = getCombi(e2, key);
    combi.length > 1 && this.trigger("".concat(type, ".").concat(combi.join(".")), param);
  };
  return KeyController2;
}(EventEmitter$3);
var KeyController$1 = KeyController;
var extendStatics$4 = function(d, b) {
  extendStatics$4 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics$4(d, b);
};
function __extends$4(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics$4(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$3 = function() {
  __assign$3 = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$3.apply(this, arguments);
};
function __rest$1(s, e2) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate$1(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __spreadArray$1(to, from, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function getClient(e2) {
  if ("touches" in e2) {
    var touch = e2.touches[0] || e2.changedTouches[0];
    return {
      clientX: touch.clientX,
      clientY: touch.clientY
    };
  } else {
    return {
      clientX: e2.clientX,
      clientY: e2.clientY
    };
  }
}
function filterDuplicated(arr2) {
  if (typeof Map === "undefined") {
    return arr2.filter(function(value, index2) {
      return arr2.indexOf(value) === index2;
    });
  }
  var map = /* @__PURE__ */ new Map();
  return arr2.filter(function(value) {
    if (map.has(value)) {
      return false;
    }
    map.set(value, true);
    return true;
  });
}
function elementFromPoint(baseNode, clientX, clientY) {
  var doc2 = getDocument(baseNode);
  return doc2.elementFromPoint && doc2.elementFromPoint(clientX, clientY) || null;
}
function createElement(jsx, prevTarget, container) {
  var tag = jsx.tag, children = jsx.children, attributes = jsx.attributes, className = jsx.className, style = jsx.style;
  var el = prevTarget || getDocument(container).createElement(tag);
  for (var name2 in attributes) {
    el.setAttribute(name2, attributes[name2]);
  }
  var elChildren = el.children;
  children.forEach(function(child, i) {
    createElement(child, elChildren[i], el);
  });
  if (className) {
    className.split(/\s+/g).forEach(function(name3) {
      if (name3 && !hasClass(el, name3)) {
        addClass(el, name3);
      }
    });
  }
  if (style) {
    var elStyle = el.style;
    for (var name2 in style) {
      elStyle[name2] = style[name2];
    }
  }
  if (!prevTarget && container) {
    container.appendChild(el);
  }
  return el;
}
function h(tag, attrs) {
  var children = [];
  for (var _i = 2; _i < arguments.length; _i++) {
    children[_i - 2] = arguments[_i];
  }
  var _a2 = attrs || {}, _b = _a2.className, className = _b === void 0 ? "" : _b, _c = _a2.style, style = _c === void 0 ? {} : _c, attributes = __rest$1(_a2, ["className", "style"]);
  return {
    tag,
    className,
    style,
    attributes,
    children
  };
}
function diffValue(prev, cur, func) {
  if (prev !== cur) {
    func(prev, cur);
  }
}
function getRect$1(e2, ratio, boundArea) {
  var _a2;
  if (boundArea === void 0) {
    boundArea = e2.data.boundArea;
  }
  var _b = e2.distX, distX = _b === void 0 ? 0 : _b, _c = e2.distY, distY = _c === void 0 ? 0 : _c;
  var _d = e2.data, startX = _d.startX, startY = _d.startY;
  if (ratio > 0) {
    var nextHeight = Math.sqrt((distX * distX + distY * distY) / (1 + ratio * ratio));
    var nextWidth = ratio * nextHeight;
    distX = (distX >= 0 ? 1 : -1) * nextWidth;
    distY = (distY >= 0 ? 1 : -1) * nextHeight;
  }
  var width = Math.abs(distX);
  var height = Math.abs(distY);
  var maxWidth = distX < 0 ? startX - boundArea.left : boundArea.right - startX;
  var maxHeight = distY < 0 ? startY - boundArea.top : boundArea.bottom - startY;
  _a2 = calculateBoundSize([width, height], [0, 0], [maxWidth, maxHeight], !!ratio), width = _a2[0], height = _a2[1];
  distX = (distX >= 0 ? 1 : -1) * width;
  distY = (distY >= 0 ? 1 : -1) * height;
  var tx = Math.min(0, distX);
  var ty = Math.min(0, distY);
  var left = startX + tx;
  var top = startY + ty;
  return {
    left,
    top,
    right: left + width,
    bottom: top + height,
    width,
    height
  };
}
function getDefaultElementRect(el) {
  var rect = el.getBoundingClientRect();
  var left = rect.left, top = rect.top, width = rect.width, height = rect.height;
  return {
    pos1: [left, top],
    pos2: [left + width, top],
    pos3: [left, top + height],
    pos4: [left + width, top + height]
  };
}
function passTargets(beforeTargets, afterTargets, continueSelectWithoutDeselect) {
  var _a2 = diff(beforeTargets, afterTargets), list = _a2.list, prevList = _a2.prevList, added = _a2.added, removed = _a2.removed, maintained = _a2.maintained;
  return __spreadArray$1(__spreadArray$1(__spreadArray$1([], added.map(function(index2) {
    return list[index2];
  }), true), removed.map(function(index2) {
    return prevList[index2];
  }), true), continueSelectWithoutDeselect ? maintained.map(function(_a3) {
    var nextIndex = _a3[1];
    return list[nextIndex];
  }) : [], true);
}
function getLineSize(points) {
  var size = 0;
  var length = points.length;
  for (var i = 1; i < length; ++i) {
    size = Math.max(getDist$2(points[i], points[i - 1]), size);
  }
  return size;
}
var injector = styled$1("\n:host {\n    position: fixed;\n    display: none;\n    border: 1px solid #4af;\n    background: rgba(68, 170, 255, 0.5);\n    pointer-events: none;\n    will-change: transform;\n    z-index: 100;\n}\n");
var CLASS_NAME = "selecto-selection ".concat(injector.className);
var PROPERTIES$3 = ["className", "boundContainer", "selectableTargets", "selectByClick", "selectFromInside", "continueSelect", "continueSelectWithoutDeselect", "toggleContinueSelect", "toggleContinueSelectWithoutDeselect", "keyContainer", "hitRate", "scrollOptions", "checkInput", "preventDefault", "ratio", "getElementRect", "preventDragFromInside", "rootContainer", "dragCondition", "clickBySelectEnd", "checkOverflow", "innerScrollOptions"];
__spreadArray$1([
  "dragContainer",
  "cspNonce",
  "preventClickEventOnDrag",
  "preventClickEventOnDragStart",
  "preventRightClick"
], PROPERTIES$3, true);
var Selecto = /* @__PURE__ */ function(_super) {
  __extends$4(Selecto2, _super);
  function Selecto2(options) {
    if (options === void 0) {
      options = {};
    }
    var _this = _super.call(this) || this;
    _this.selectedTargets = [];
    _this.dragScroll = new DragScroll$1();
    _this._onDragStart = function(e2, clickedTarget) {
      var data = e2.data, clientX = e2.clientX, clientY = e2.clientY, inputEvent = e2.inputEvent;
      var _a2 = _this.options, selectFromInside = _a2.selectFromInside, selectByClick = _a2.selectByClick, rootContainer = _a2.rootContainer, boundContainer = _a2.boundContainer, _b = _a2.preventDragFromInside, preventDragFromInside = _b === void 0 ? true : _b, clickBySelectEnd = _a2.clickBySelectEnd, dragCondition = _a2.dragCondition;
      if (dragCondition && !dragCondition(e2)) {
        e2.stop();
        return;
      }
      data.data = {};
      var win = getWindow(_this.container);
      data.innerWidth = win.innerWidth;
      data.innerHeight = win.innerHeight;
      _this.findSelectableTargets(data);
      data.startSelectedTargets = _this.selectedTargets;
      data.scaleMatrix = createMatrix();
      data.containerX = 0;
      data.containerY = 0;
      var container2 = _this.container;
      var boundArea = {
        left: -Infinity,
        top: -Infinity,
        right: Infinity,
        bottom: Infinity
      };
      if (rootContainer) {
        var containerRect = _this.container.getBoundingClientRect();
        data.containerX = containerRect.left;
        data.containerY = containerRect.top;
        data.scaleMatrix = getDistElementMatrix(_this.container, rootContainer);
      }
      if (boundContainer) {
        var boundInfo = isObject$2(boundContainer) && "element" in boundContainer ? __assign$3({
          left: true,
          top: true,
          bottom: true,
          right: true
        }, boundContainer) : {
          element: boundContainer,
          left: true,
          top: true,
          bottom: true,
          right: true
        };
        var boundElement = boundInfo.element;
        var rectElement = void 0;
        if (boundElement) {
          if (isString$2(boundElement)) {
            rectElement = getDocument(container2).querySelector(boundElement);
          } else if (boundElement === true) {
            rectElement = _this.container;
          } else {
            rectElement = boundElement;
          }
          var rect = rectElement.getBoundingClientRect();
          if (boundInfo.left) {
            boundArea.left = rect.left;
          }
          if (boundInfo.top) {
            boundArea.top = rect.top;
          }
          if (boundInfo.right) {
            boundArea.right = rect.right;
          }
          if (boundInfo.bottom) {
            boundArea.bottom = rect.bottom;
          }
        }
      }
      data.boundArea = boundArea;
      var hitRect = {
        left: clientX,
        top: clientY,
        right: clientX,
        bottom: clientY,
        width: 0,
        height: 0
      };
      var firstPassedTargets = [];
      if (!selectFromInside || selectByClick && !clickBySelectEnd) {
        var pointTarget = _this._findElement(
          clickedTarget || inputEvent.target,
          data.selectableTargets
        );
        firstPassedTargets = pointTarget ? [pointTarget] : [];
      }
      var hasInsideTargets = firstPassedTargets.length > 0;
      var isPreventSelect = !selectFromInside && hasInsideTargets;
      if (isPreventSelect && !selectByClick) {
        e2.stop();
        return false;
      }
      var type = inputEvent.type;
      var isTrusted = type === "mousedown" || type === "touchstart";
      var result = !e2.isClick && isTrusted ? _this.emit("dragStart", __assign$3(__assign$3({}, e2), {
        data: data.data
      })) : true;
      if (!result) {
        e2.stop();
        return false;
      }
      if (_this.continueSelect) {
        firstPassedTargets = passTargets(_this.selectedTargets, firstPassedTargets, _this.continueSelectWithoutDeselect);
        data.startPassedTargets = _this.selectedTargets;
      } else {
        data.startPassedTargets = [];
      }
      _this._select(firstPassedTargets, hitRect, e2, true, isPreventSelect && selectByClick && !clickBySelectEnd && preventDragFromInside);
      data.startX = clientX;
      data.startY = clientY;
      data.selectFlag = false;
      data.preventDragFromInside = false;
      if (inputEvent.target) {
        var offsetPos = calculateMatrixDist(data.scaleMatrix, [clientX - data.containerX, clientY - data.containerY]);
        _this.target.style.cssText += "position: ".concat(rootContainer ? "absolute" : "fixed", ";") + "left:0px;top:0px;" + "transform: translate(".concat(offsetPos[0], "px, ").concat(offsetPos[1], "px)");
      }
      if (isPreventSelect && selectByClick && !clickBySelectEnd) {
        inputEvent.preventDefault();
        if (preventDragFromInside) {
          _this._selectEnd(data.startSelectedTargets, data.startPassedTargets, hitRect, e2, true);
          data.preventDragFromInside = true;
        }
      } else {
        data.selectFlag = true;
        var _c = _this.options, scrollOptions = _c.scrollOptions, innerScrollOptions = _c.innerScrollOptions;
        var isInnerScroll = false;
        if (innerScrollOptions) {
          var inputEvent_1 = e2.inputEvent;
          var target = inputEvent_1.target;
          var innerScrollElement = null;
          var parentElement = target;
          while (parentElement && parentElement !== getDocument(container2).body) {
            var overflow2 = getComputedStyle(parentElement).overflow !== "visible";
            if (overflow2) {
              innerScrollElement = parentElement;
              break;
            }
            parentElement = parentElement.parentElement;
          }
          if (innerScrollElement) {
            data.innerScrollOptions = __assign$3({
              container: innerScrollElement,
              checkScrollEvent: true
            }, innerScrollOptions === true ? {} : innerScrollOptions);
            _this.dragScroll.dragStart(e2, data.innerScrollOptions);
            isInnerScroll = true;
          }
        }
        if (!isInnerScroll && scrollOptions && scrollOptions.container) {
          _this.dragScroll.dragStart(e2, scrollOptions);
        }
        if (clickBySelectEnd) {
          data.selectFlag = false;
          e2.preventDrag();
        }
      }
      return true;
    };
    _this._onDrag = function(e2) {
      if (e2.data.selectFlag) {
        var scrollOptions = _this.scrollOptions;
        var innerScrollOptions = e2.data.innerScrollOptions;
        var hasScrollOptions = innerScrollOptions || (scrollOptions === null || scrollOptions === void 0 ? void 0 : scrollOptions.container);
        if (hasScrollOptions && !e2.isScroll && _this.dragScroll.drag(e2, innerScrollOptions || scrollOptions)) {
          return;
        }
      }
      _this._checkSelected(e2);
    };
    _this._onDragEnd = function(e2) {
      var data = e2.data, inputEvent = e2.inputEvent;
      var rect = getRect$1(e2, _this.options.ratio);
      var selectFlag = data.selectFlag;
      var container2 = _this.container;
      if (inputEvent) {
        _this.emit("dragEnd", __assign$3(__assign$3({
          isDouble: !!e2.isDouble,
          isClick: !!e2.isClick,
          isDrag: false,
          isSelect: selectFlag
        }, e2), {
          data: data.data,
          rect
        }));
      }
      _this.target.style.cssText += "display: none;";
      if (selectFlag) {
        data.selectFlag = false;
        _this.dragScroll.dragEnd();
      } else if (_this.selectByClick && _this.clickBySelectEnd) {
        var pointTarget = _this._findElement((inputEvent === null || inputEvent === void 0 ? void 0 : inputEvent.target) || elementFromPoint(container2, e2.clientX, e2.clientY), data.selectableTargets);
        _this._select(pointTarget ? [pointTarget] : [], rect, e2);
      }
      if (!data.preventDragFromInside) {
        _this._selectEnd(data.startSelectedTargets, data.startPassedTargets, rect, e2);
      }
    };
    _this._onKeyDown = function(e2) {
      var options2 = _this.options;
      var isKeyDown = false;
      if (!_this._keydownContinueSelect) {
        var result = _this._sameCombiKey(e2, options2.toggleContinueSelect);
        _this._keydownContinueSelect = result;
        isKeyDown || (isKeyDown = result);
      }
      if (!_this._keydownContinueSelectWithoutDeselection) {
        var result = _this._sameCombiKey(e2, options2.toggleContinueSelectWithoutDeselect);
        _this._keydownContinueSelectWithoutDeselection = result;
        isKeyDown || (isKeyDown = result);
      }
      if (!isKeyDown) {
        return;
      }
      _this.emit("keydown", {
        keydownContinueSelect: _this._keydownContinueSelect,
        keydownContinueSelectWithoutDeselection: _this._keydownContinueSelectWithoutDeselection
      });
    };
    _this._onKeyUp = function(e2) {
      var options2 = _this.options;
      var isKeyUp = false;
      if (_this._keydownContinueSelect) {
        var result = _this._sameCombiKey(e2, options2.toggleContinueSelect, true);
        _this._keydownContinueSelect = !result;
        isKeyUp || (isKeyUp = result);
      }
      if (_this._keydownContinueSelectWithoutDeselection) {
        var result = _this._sameCombiKey(e2, options2.toggleContinueSelectWithoutDeselect, true);
        _this._keydownContinueSelectWithoutDeselection = !result;
        isKeyUp || (isKeyUp = result);
      }
      if (!isKeyUp) {
        return;
      }
      _this.emit("keyup", {
        keydownContinueSelect: _this._keydownContinueSelect,
        keydownContinueSelectWithoutDeselection: _this._keydownContinueSelectWithoutDeselection
      });
    };
    _this._onBlur = function() {
      if (_this._keydownContinueSelect || _this._keydownContinueSelectWithoutDeselection) {
        _this._keydownContinueSelect = false;
        _this._keydownContinueSelectWithoutDeselection = false;
        _this.emit("keyup", {
          keydownContinueSelect: _this._keydownContinueSelect,
          keydownContinueSelectWithoutDeselection: _this._keydownContinueSelectWithoutDeselection
        });
      }
    };
    _this._onDocumentSelectStart = function(e2) {
      var doc2 = getDocument(_this.container);
      if (!_this.gesto.isFlag()) {
        return;
      }
      var dragContainer = _this.dragContainer;
      if (dragContainer === getWindow(_this.container)) {
        dragContainer = doc2.documentElement;
      }
      var containers = isNode(dragContainer) ? [dragContainer] : [].slice.call(dragContainer);
      var target = e2.target;
      containers.some(function(container2) {
        if (container2 === target || container2.contains(target)) {
          e2.preventDefault();
          return true;
        }
      });
    };
    _this.target = options.portalContainer;
    var container = options.container;
    _this.options = __assign$3({
      className: "",
      portalContainer: null,
      container: null,
      dragContainer: null,
      selectableTargets: [],
      selectByClick: true,
      selectFromInside: true,
      clickBySelectEnd: false,
      hitRate: 100,
      continueSelect: false,
      continueSelectWithoutDeselect: false,
      toggleContinueSelect: null,
      toggleContinueSelectWithoutDeselect: null,
      keyContainer: null,
      scrollOptions: void 0,
      checkInput: false,
      preventDefault: false,
      boundContainer: false,
      preventDragFromInside: true,
      dragCondition: null,
      rootContainer: null,
      checkOverflow: false,
      innerScrollOptions: false,
      getElementRect: getDefaultElementRect,
      cspNonce: "",
      ratio: 0
    }, options);
    var portalContainer = _this.options.portalContainer;
    if (portalContainer) {
      container = portalContainer.parentElement;
    }
    _this.container = container || document.body;
    _this.initElement();
    _this.initDragScroll();
    _this.setKeyController();
    return _this;
  }
  var __proto = Selecto2.prototype;
  __proto.setSelectedTargets = function(selectedTargets) {
    var beforeSelected = this.selectedTargets;
    var _a2 = diff(beforeSelected, selectedTargets), added = _a2.added, removed = _a2.removed, prevList = _a2.prevList, list = _a2.list;
    this.selectedTargets = selectedTargets;
    return {
      added: added.map(function(index2) {
        return list[index2];
      }),
      removed: removed.map(function(index2) {
        return prevList[index2];
      }),
      beforeSelected,
      selected: selectedTargets
    };
  };
  __proto.setSelectedTargetsByPoints = function(point1, point2) {
    var left = Math.min(point1[0], point2[0]);
    var top = Math.min(point1[1], point2[1]);
    var right = Math.max(point1[0], point2[0]);
    var bottom = Math.max(point1[1], point2[1]);
    var rect = {
      left,
      top,
      right,
      bottom,
      width: right - left,
      height: bottom - top
    };
    var data = {
      ignoreClick: true
    };
    this.findSelectableTargets(data);
    var selectedElements = this.hitTest(rect, data);
    var result = this.setSelectedTargets(selectedElements);
    return __assign$3(__assign$3({}, result), {
      rect
    });
  };
  __proto.selectTargetsByPoints = function(startPoint2, endPoint) {
    var mousedown = new MouseEvent("mousedown", {
      clientX: startPoint2[0],
      clientY: startPoint2[1],
      cancelable: true,
      bubbles: true
    });
    var mousemove = new MouseEvent("mousemove", {
      clientX: endPoint[0],
      clientY: endPoint[1],
      cancelable: true,
      bubbles: true
    });
    var mouseup = new MouseEvent("mousemove", {
      clientX: endPoint[0],
      clientY: endPoint[1],
      cancelable: true,
      bubbles: true
    });
    var gesto = this.gesto;
    var result = gesto.onDragStart(mousedown);
    if (result !== false) {
      gesto.onDrag(mousemove);
      gesto.onDragEnd(mouseup);
    }
  };
  __proto.getSelectedTargets = function() {
    return this.selectedTargets;
  };
  __proto.triggerDragStart = function(e2) {
    this.gesto.triggerDragStart(e2);
    return this;
  };
  __proto.destroy = function() {
    var _a2;
    this.off();
    this.keycon && this.keycon.destroy();
    this.gesto.unset();
    this.injectResult.destroy();
    this.dragScroll.dragEnd();
    removeEvent(document, "selectstart", this._onDocumentSelectStart);
    if (!this.options.portalContainer) {
      (_a2 = this.target.parentElement) === null || _a2 === void 0 ? void 0 : _a2.removeChild(this.target);
    }
    this.keycon = null;
    this.gesto = null;
    this.injectResult = null;
    this.target = null;
    this.container = null;
    this.options = null;
  };
  __proto.getElementPoints = function(target) {
    var getElementRect = this.getElementRect || getDefaultElementRect;
    var info = getElementRect(target);
    var points = [info.pos1, info.pos2, info.pos4, info.pos3];
    if (getElementRect !== getDefaultElementRect) {
      var rect = target.getBoundingClientRect();
      return fitPoints(points, rect);
    }
    return points;
  };
  __proto.getSelectableElements = function() {
    var container = this.container;
    var selectableElements = [];
    this.options.selectableTargets.forEach(function(target) {
      if (isFunction$2(target)) {
        var result = target();
        if (result) {
          selectableElements.push.apply(selectableElements, [].slice.call(result));
        }
      } else if (isNode(target)) {
        selectableElements.push(target);
      } else if (isObject$2(target)) {
        selectableElements.push(target.value || target.current);
      } else {
        var elements = [].slice.call(getDocument(container).querySelectorAll(target));
        selectableElements.push.apply(selectableElements, elements);
      }
    });
    return selectableElements;
  };
  __proto.checkScroll = function() {
    if (!this.gesto.isFlag()) {
      return;
    }
    var scrollOptions = this.scrollOptions;
    var innerScrollOptions = this.gesto.getEventData().innerScrollOptions;
    var hasScrollOptions = innerScrollOptions || (scrollOptions === null || scrollOptions === void 0 ? void 0 : scrollOptions.container);
    if (hasScrollOptions) {
      this.dragScroll.checkScroll(__assign$3({
        inputEvent: this.gesto.getCurrentEvent()
      }, innerScrollOptions || scrollOptions));
    }
  };
  __proto.findSelectableTargets = function(data) {
    var _this = this;
    if (data === void 0) {
      data = this.gesto.getEventData();
    }
    var selectableTargets = this.getSelectableElements();
    var selectablePoints = selectableTargets.map(function(target) {
      return _this.getElementPoints(target);
    });
    data.selectableTargets = selectableTargets;
    data.selectablePoints = selectablePoints;
    data.selectableParentMap = null;
    var options = this.options;
    var hasIndexesMap = options.checkOverflow || options.innerScrollOptions;
    var doc2 = getDocument(this.container);
    if (hasIndexesMap) {
      var parentMap_1 = /* @__PURE__ */ new Map();
      data.selectableInnerScrollParentMap = parentMap_1;
      data.selectableInnerScrollPathsList = selectableTargets.map(function(target, index2) {
        var parentElement = target.parentElement;
        var parents = [];
        var paths = [];
        var _loop_1 = function() {
          var info = parentMap_1.get(parentElement);
          if (!info) {
            var overflow2 = getComputedStyle(parentElement).overflow !== "visible";
            if (overflow2) {
              var rect = getDefaultElementRect(parentElement);
              info = {
                parentElement,
                indexes: [],
                points: [rect.pos1, rect.pos2, rect.pos4, rect.pos3],
                paths: __spreadArray$1([], paths, true)
              };
              parents.push(parentElement);
              parents.forEach(function(prevParentElement) {
                parentMap_1.set(prevParentElement, info);
              });
              parents = [];
            }
          }
          if (info) {
            parentElement = info.parentElement;
            parentMap_1.get(parentElement).indexes.push(index2);
            paths.push(parentElement);
          } else {
            parents.push(parentElement);
          }
          parentElement = parentElement.parentElement;
        };
        while (parentElement && parentElement !== doc2.body) {
          _loop_1();
        }
        return paths;
      });
    }
    if (!options.checkOverflow) {
      data.selectableInners = selectableTargets.map(function() {
        return true;
      });
    }
    this._refreshGroups(data);
    return selectableTargets;
  };
  __proto.clickTarget = function(e2, clickedTarget) {
    var _a2 = getClient(e2), clientX = _a2.clientX, clientY = _a2.clientY;
    var dragEvent = {
      data: {
        selectFlag: false
      },
      clientX,
      clientY,
      inputEvent: e2,
      isClick: true,
      isTrusted: false,
      stop: function() {
        return false;
      }
    };
    if (this._onDragStart(dragEvent, clickedTarget)) {
      this._onDragEnd(dragEvent);
    }
    return this;
  };
  __proto.setKeyController = function() {
    var _a2 = this.options, keyContainer = _a2.keyContainer, toggleContinueSelect = _a2.toggleContinueSelect, toggleContinueSelectWithoutDeselect = _a2.toggleContinueSelectWithoutDeselect;
    if (this.keycon) {
      this.keycon.destroy();
      this.keycon = null;
    }
    if (toggleContinueSelect || toggleContinueSelectWithoutDeselect) {
      this.keycon = new KeyController$1(keyContainer || getWindow(this.container));
      this.keycon.keydown(this._onKeyDown).keyup(this._onKeyUp).on("blur", this._onBlur);
    }
  };
  __proto.setClassName = function(nextClassName) {
    this.options.className = nextClassName;
    this.target.setAttribute("class", "".concat(CLASS_NAME, " ").concat(nextClassName || ""));
  };
  __proto.setKeyEvent = function() {
    var _a2 = this.options, toggleContinueSelect = _a2.toggleContinueSelect, toggleContinueSelectWithoutDeselect = _a2.toggleContinueSelectWithoutDeselect;
    if (!toggleContinueSelect && !toggleContinueSelectWithoutDeselect || this.keycon) {
      return;
    }
    this.setKeyController();
  };
  __proto.setKeyContainer = function(keyContainer) {
    var _this = this;
    var options = this.options;
    diffValue(options.keyContainer, keyContainer, function() {
      options.keyContainer = keyContainer;
      _this.setKeyController();
    });
  };
  __proto.getContinueSelect = function() {
    var _a2 = this.options, continueSelect = _a2.continueSelect, toggleContinueSelect = _a2.toggleContinueSelect;
    if (!toggleContinueSelect || !this._keydownContinueSelect) {
      return continueSelect;
    }
    return !continueSelect;
  };
  __proto.getContinueSelectWithoutDeselect = function() {
    var _a2 = this.options, continueSelectWithoutDeselect = _a2.continueSelectWithoutDeselect, toggleContinueSelectWithoutDeselect = _a2.toggleContinueSelectWithoutDeselect;
    if (!toggleContinueSelectWithoutDeselect || !this._keydownContinueSelectWithoutDeselection) {
      return continueSelectWithoutDeselect;
    }
    return !continueSelectWithoutDeselect;
  };
  __proto.setToggleContinueSelect = function(toggleContinueSelect) {
    var _this = this;
    var options = this.options;
    diffValue(options.toggleContinueSelect, toggleContinueSelect, function() {
      options.toggleContinueSelect = toggleContinueSelect;
      _this.setKeyEvent();
    });
  };
  __proto.setToggleContinueSelectWithoutDeselect = function(toggleContinueSelectWithoutDeselect) {
    var _this = this;
    var options = this.options;
    diffValue(options.toggleContinueSelectWithoutDeselect, toggleContinueSelectWithoutDeselect, function() {
      options.toggleContinueSelectWithoutDeselect = toggleContinueSelectWithoutDeselect;
      _this.setKeyEvent();
    });
  };
  __proto.setPreventDefault = function(value) {
    this.gesto.options.preventDefault = value;
  };
  __proto.setCheckInput = function(value) {
    this.gesto.options.checkInput = value;
  };
  __proto.initElement = function() {
    var _a2 = this.options, dragContainer = _a2.dragContainer, checkInput = _a2.checkInput, preventDefault = _a2.preventDefault, preventClickEventOnDragStart = _a2.preventClickEventOnDragStart, preventClickEventOnDrag = _a2.preventClickEventOnDrag, preventClickEventByCondition = _a2.preventClickEventByCondition, _b = _a2.preventRightClick, preventRightClick = _b === void 0 ? true : _b, className = _a2.className;
    var container = this.container;
    this.target = createElement(h("div", {
      className: "".concat(CLASS_NAME, " ").concat(className || "")
    }), this.target, container);
    var target = this.target;
    this.dragContainer = typeof dragContainer === "string" ? [].slice.call(getDocument(container).querySelectorAll(dragContainer)) : dragContainer || this.target.parentNode;
    this.gesto = new Gesto(this.dragContainer, {
      checkWindowBlur: true,
      container: getWindow(container),
      checkInput,
      preventDefault,
      preventClickEventOnDragStart,
      preventClickEventOnDrag,
      preventClickEventByCondition,
      preventRightClick
    }).on({
      dragStart: this._onDragStart,
      drag: this._onDrag,
      dragEnd: this._onDragEnd
    });
    addEvent$1(document, "selectstart", this._onDocumentSelectStart);
    this.injectResult = injector.inject(target, {
      nonce: this.options.cspNonce
    });
  };
  __proto.hitTest = function(selectRect, data, gestoEvent) {
    var _a2 = this.options, hitRate = _a2.hitRate, selectByClick = _a2.selectByClick;
    var left = selectRect.left, top = selectRect.top, right = selectRect.right, bottom = selectRect.bottom;
    var innerGroups = data.innerGroups;
    var innerWidth = data.innerWidth;
    var innerHeight = data.innerHeight;
    var clientX = gestoEvent === null || gestoEvent === void 0 ? void 0 : gestoEvent.clientX;
    var clientY = gestoEvent === null || gestoEvent === void 0 ? void 0 : gestoEvent.clientY;
    var ignoreClick = data.ignoreClick;
    var rectPoints = [[left, top], [right, top], [right, bottom], [left, bottom]];
    var isHit = function(points, el) {
      var hitRateValue = typeof hitRate === "function" ? splitUnit("".concat(hitRate(el))) : splitUnit("".concat(hitRate));
      var inArea = ignoreClick ? false : isInside([clientX, clientY], points);
      if (selectByClick && inArea) {
        return true;
      }
      var overlapPoints = getOverlapPoints(rectPoints, points);
      if (!overlapPoints.length) {
        return false;
      }
      var overlapSize = getAreaSize(overlapPoints);
      var targetSize = 0;
      if (overlapSize === 0 && getAreaSize(points) === 0) {
        targetSize = getLineSize(points);
        overlapSize = getLineSize(overlapPoints);
      } else {
        targetSize = getAreaSize(points);
      }
      if (hitRateValue.unit === "px") {
        return overlapSize >= hitRateValue.value;
      } else {
        var rate = between(Math.round(overlapSize / targetSize * 100), 0, 100);
        return rate >= Math.min(100, hitRateValue.value);
      }
    };
    var selectableTargets = data.selectableTargets;
    var selectablePoints = data.selectablePoints;
    var selectableInners = data.selectableInners;
    if (!innerGroups) {
      return selectableTargets.filter(function(_, i) {
        if (!selectableInners[i]) {
          return false;
        }
        return isHit(selectablePoints[i], selectableTargets[i]);
      });
    }
    var selectedTargets = [];
    var minX = Math.floor(left / innerWidth);
    var maxX = Math.floor(right / innerWidth);
    var minY = Math.floor(top / innerHeight);
    var maxY = Math.floor(bottom / innerHeight);
    for (var x = minX; x <= maxX; ++x) {
      var yGroups = innerGroups[x];
      if (!yGroups) {
        continue;
      }
      for (var y = minY; y <= maxY; ++y) {
        var group = yGroups[y];
        if (!group) {
          continue;
        }
        group.forEach(function(index2) {
          var points = selectablePoints[index2];
          var inner = selectableInners[index2];
          var target = selectableTargets[index2];
          if (inner && isHit(points, target)) {
            selectedTargets.push(target);
          }
        });
      }
    }
    return filterDuplicated(selectedTargets);
  };
  __proto.initDragScroll = function() {
    var _this = this;
    this.dragScroll.on("scrollDrag", function(_a2) {
      var next = _a2.next;
      next(_this.gesto.getCurrentEvent());
    }).on("scroll", function(_a2) {
      var container = _a2.container, direction2 = _a2.direction;
      var innerScrollOptions = _this.gesto.getEventData().innerScrollOptions;
      if (innerScrollOptions) {
        _this.emit("innerScroll", {
          container,
          direction: direction2
        });
      } else {
        _this.emit("scroll", {
          container,
          direction: direction2
        });
      }
    }).on("move", function(_a2) {
      var offsetX = _a2.offsetX, offsetY = _a2.offsetY, inputEvent = _a2.inputEvent;
      var gesto = _this.gesto;
      if (!gesto || !gesto.isFlag()) {
        return;
      }
      var data = _this.gesto.getEventData();
      var boundArea = data.boundArea;
      data.startX -= offsetX;
      data.startY -= offsetY;
      var innerScrollOptions = _this.gesto.getEventData().innerScrollOptions;
      var container = innerScrollOptions === null || innerScrollOptions === void 0 ? void 0 : innerScrollOptions.container;
      var isMoveInnerScroll = false;
      if (container) {
        var parentMap_2 = data.selectableInnerScrollParentMap;
        var parentInfo = parentMap_2.get(container);
        if (parentInfo) {
          parentInfo.paths.forEach(function(scrollContainer) {
            var containerInfo = parentMap_2.get(scrollContainer);
            containerInfo.points.forEach(function(pos) {
              pos[0] -= offsetX;
              pos[1] -= offsetY;
            });
          });
          parentInfo.indexes.forEach(function(index2) {
            data.selectablePoints[index2].forEach(function(pos) {
              pos[0] -= offsetX;
              pos[1] -= offsetY;
            });
          });
          isMoveInnerScroll = true;
        }
      }
      if (!isMoveInnerScroll) {
        data.selectablePoints.forEach(function(points) {
          points.forEach(function(pos) {
            pos[0] -= offsetX;
            pos[1] -= offsetY;
          });
        });
      }
      _this._refreshGroups(data);
      boundArea.left -= offsetX;
      boundArea.right -= offsetX;
      boundArea.top -= offsetY;
      boundArea.bottom -= offsetY;
      _this.gesto.scrollBy(offsetX, offsetY, inputEvent.inputEvent);
      _this._checkSelected(_this.gesto.getCurrentEvent());
    });
  };
  __proto._select = function(selectedTargets, rect, e2, isStart, isDragStartEnd) {
    if (isDragStartEnd === void 0) {
      isDragStartEnd = false;
    }
    var inputEvent = e2.inputEvent;
    var data = e2.data;
    var result = this.setSelectedTargets(selectedTargets);
    var _a2 = diff(data.startSelectedTargets, selectedTargets), added = _a2.added, removed = _a2.removed, prevList = _a2.prevList, list = _a2.list;
    var startResult = {
      startSelected: prevList,
      startAdded: added.map(function(i) {
        return list[i];
      }),
      startRemoved: removed.map(function(i) {
        return prevList[i];
      })
    };
    if (isStart) {
      this.emit("selectStart", __assign$3(__assign$3(__assign$3({}, result), startResult), {
        rect,
        inputEvent,
        data: data.data,
        isTrusted: e2.isTrusted,
        isDragStartEnd
      }));
    }
    if (result.added.length || result.removed.length) {
      this.emit("select", __assign$3(__assign$3(__assign$3({}, result), startResult), {
        rect,
        inputEvent,
        data: data.data,
        isTrusted: e2.isTrusted,
        isDragStartEnd
      }));
    }
  };
  __proto._selectEnd = function(startSelectedTargets, startPassedTargets, rect, e2, isDragStartEnd) {
    if (isDragStartEnd === void 0) {
      isDragStartEnd = false;
    }
    var inputEvent = e2.inputEvent, isDouble = e2.isDouble, data = e2.data;
    var type = inputEvent && inputEvent.type;
    var isDragStart = type === "mousedown" || type === "touchstart";
    var _a2 = diff(startSelectedTargets, this.selectedTargets), added = _a2.added, removed = _a2.removed, prevList = _a2.prevList, list = _a2.list;
    var _b = diff(startPassedTargets, this.selectedTargets), afterAdded = _b.added, afterRemoved = _b.removed, afterPrevList = _b.prevList, afterList = _b.list;
    this.emit("selectEnd", {
      startSelected: startSelectedTargets,
      beforeSelected: startPassedTargets,
      selected: this.selectedTargets,
      added: added.map(function(index2) {
        return list[index2];
      }),
      removed: removed.map(function(index2) {
        return prevList[index2];
      }),
      afterAdded: afterAdded.map(function(index2) {
        return afterList[index2];
      }),
      afterRemoved: afterRemoved.map(function(index2) {
        return afterPrevList[index2];
      }),
      isDragStart: isDragStart && isDragStartEnd,
      isDragStartEnd: isDragStart && isDragStartEnd,
      isClick: !!e2.isClick,
      isDouble: !!isDouble,
      rect,
      inputEvent,
      data: data.data,
      isTrusted: e2.isTrusted
    });
  };
  __proto._checkSelected = function(e2, rect) {
    if (rect === void 0) {
      rect = getRect$1(e2, this.options.ratio);
    }
    var data = e2.data;
    var top = rect.top, left = rect.left, width = rect.width, height = rect.height;
    var selectFlag = data.selectFlag;
    var containerX = data.containerX, containerY = data.containerY, scaleMatrix2 = data.scaleMatrix;
    var offsetPos = calculateMatrixDist(scaleMatrix2, [left - containerX, top - containerY]);
    var offsetSize = calculateMatrixDist(scaleMatrix2, [width, height]);
    var selectedTargets = [];
    if (selectFlag) {
      this.target.style.cssText += "display: block;left:0px;top:0px;" + "transform: translate(".concat(offsetPos[0], "px, ").concat(offsetPos[1], "px);") + "width:".concat(offsetSize[0], "px;height:").concat(offsetSize[1], "px;");
      var passedTargets = this.hitTest(rect, data, e2);
      selectedTargets = passTargets(data.startPassedTargets, passedTargets, this.continueSelect && this.continueSelectWithoutDeselect);
    }
    var result = this.emit("drag", __assign$3(__assign$3({}, e2), {
      data: data.data,
      isSelect: selectFlag,
      rect
    }));
    if (result === false) {
      this.target.style.cssText += "display: none;";
      e2.stop();
      return;
    }
    if (selectFlag) {
      this._select(selectedTargets, rect, e2);
    }
  };
  __proto._sameCombiKey = function(e2, keys2, isKeyup) {
    if (!keys2) {
      return false;
    }
    var combi = getCombi(e2.inputEvent, e2.key);
    var nextKeys = [].concat(keys2);
    var toggleKeys = isArray$1(nextKeys[0]) ? nextKeys : [nextKeys];
    if (isKeyup) {
      var singleKey_1 = e2.key;
      return toggleKeys.some(function(keys3) {
        return keys3.some(function(key) {
          return key === singleKey_1;
        });
      });
    }
    return toggleKeys.some(function(keys3) {
      return keys3.every(function(key) {
        return combi.indexOf(key) > -1;
      });
    });
  };
  __proto._findElement = function(clickedTarget, selectableTargets) {
    var pointTarget = clickedTarget;
    while (pointTarget) {
      if (selectableTargets.indexOf(pointTarget) > -1) {
        break;
      }
      pointTarget = pointTarget.parentElement;
    }
    return pointTarget;
  };
  __proto._refreshGroups = function(data) {
    var _a2;
    var innerWidth = data.innerWidth;
    var innerHeight = data.innerHeight;
    var selectablePoints = data.selectablePoints;
    if (this.options.checkOverflow) {
      var innerScrollContainer_1 = (_a2 = this.gesto.getEventData().innerScrollOptions) === null || _a2 === void 0 ? void 0 : _a2.container;
      var parentMap_3 = data.selectableInnerScrollParentMap;
      var innerScrollPathsList = data.selectableInnerScrollPathsList;
      data.selectableInners = innerScrollPathsList.map(function(innerScrollPaths, i) {
        var isAlwaysTrue = false;
        return innerScrollPaths.every(function(target) {
          if (isAlwaysTrue) {
            return true;
          }
          if (target === innerScrollContainer_1) {
            isAlwaysTrue = true;
            return true;
          }
          var rect = parentMap_3.get(target);
          if (rect) {
            var points1 = selectablePoints[i];
            var points2 = rect.points;
            var overlapPoints = getOverlapPoints(points1, points2);
            if (!overlapPoints.length) {
              return false;
            }
          }
          return true;
        });
      });
    }
    if (!innerWidth || !innerHeight) {
      data.innerGroups = null;
    } else {
      var selectablePoints_1 = data.selectablePoints;
      var groups_1 = {};
      selectablePoints_1.forEach(function(points, i) {
        var minX = Infinity;
        var maxX = -Infinity;
        var minY = Infinity;
        var maxY = -Infinity;
        points.forEach(function(pos) {
          var x2 = Math.floor(pos[0] / innerWidth);
          var y2 = Math.floor(pos[1] / innerHeight);
          minX = Math.min(x2, minX);
          maxX = Math.max(x2, maxX);
          minY = Math.min(y2, minY);
          maxY = Math.max(y2, maxY);
        });
        for (var x = minX; x <= maxX; ++x) {
          for (var y = minY; y <= maxY; ++y) {
            groups_1[x] = groups_1[x] || {};
            groups_1[x][y] = groups_1[x][y] || [];
            groups_1[x][y].push(i);
          }
        }
      });
      data.innerGroups = groups_1;
    }
  };
  Selecto2 = __decorate$1([Properties(PROPERTIES$3, function(prototype, property) {
    var attributes = {
      enumerable: true,
      configurable: true,
      get: function() {
        return this.options[property];
      }
    };
    var getter = camelize$1("get ".concat(property));
    if (prototype[getter]) {
      attributes.get = function get() {
        return this[getter]();
      };
    } else {
      attributes.get = function get() {
        return this.options[property];
      };
    }
    var setter = camelize$1("set ".concat(property));
    if (prototype[setter]) {
      attributes.set = function set(value) {
        this[setter](value);
      };
    } else {
      attributes.set = function set(value) {
        this.options[property] = value;
      };
    }
    Object.defineProperty(prototype, property, attributes);
  })], Selecto2);
  return Selecto2;
}(EventEmitter$3);
var Selecto$1 = /* @__PURE__ */ function(_super) {
  __extends$4(Selecto2, _super);
  function Selecto2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return Selecto2;
}(Selecto);
var Selecto$2 = Selecto$1;
function useSelecto(moveable) {
  const selecto = new Selecto$2({
    container: document.getElementById("page-design"),
    selectableTargets: [".layer"],
    selectByClick: false,
    selectFromInside: false,
    continueSelect: false,
    toggleContinueSelect: "shift",
    keyContainer: document.getElementById("page-design"),
    hitRate: 5,
    getElementRect: getElementInfo
  });
  selecto.on("select", (e2) => {
    e2.added.forEach((el) => {
      if (!Array.from(el.classList).includes("layer-lock") && !el.hasAttribute("child")) {
        el.classList.add("widget-selected");
        erpStore.dispatch("selectWidgetsInOut", {
          uuid: el.getAttribute("data-uuid")
        });
      }
    });
    e2.removed.forEach((el) => {
      el.classList.remove("widget-selected");
      erpStore.dispatch("selectWidgetsInOut", {
        uuid: el.getAttribute("data-uuid")
      });
    });
    moveable.renderDirections = [];
    moveable.rotatable = false;
    moveable.target = [].slice.call(document.querySelectorAll(".widget-selected"));
  });
}
var Moveable_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$V = defineComponent({
  setup() {
  },
  computed: mapGetters(["dSelectWidgets", "dActiveElement", "activeMouseEvent", "showMoveable", "showRotatable", "dWidgets", "updateRect", "updateSelect", "guidelines"]),
  watch: {
    async dActiveElement(val) {
      if (!val.record) {
        return;
      }
      if (val.uuid != -1) {
        await nextTick();
        const target = `[id="${val.uuid}"]`;
        this._target = `[id="${val.uuid}"]`;
        this.moveable.rotatable = true;
        switch (val.type) {
          case "w-text":
            this.moveable.renderDirections = ["e", "se"];
            break;
          case "w-image":
            this.moveable.renderDirections = ["nw", "n", "ne", "w", "e", "sw", "s", "se"];
            break;
          case "w-svg":
            this.moveable.renderDirections = ["nw", "n", "ne", "w", "e", "sw", "s", "se"];
            break;
          default:
            this.moveable.renderDirections = ["nw", "ne", "sw", "se"];
            break;
        }
        this.moveable.setState({ target: this._target }, () => {
          if (this.activeMouseEvent) {
            this.moveable.dragStart(this.activeMouseEvent);
            this.$store.commit("setMouseEvent", null);
          }
        });
        this.$store.commit("setShowMoveable", true);
        if (!this.moveable.elementGuidelines.includes(target)) {
          this.moveable.elementGuidelines.push(target);
        }
      } else {
        this.moveable.target = `[id="empty"]`;
        if (this.moveable.target !== `[id="empty"]`) {
          setTimeout(() => {
            this.moveable.target = `[id="empty"]`;
          }, 210);
        }
        this.moveable.elementGuidelines.length = 0;
      }
    },
    showMoveable(val) {
      if (val) {
        this.moveable.target = this._target;
      } else {
        this.moveable.target = `[id="empty"]`;
      }
    },
    showRotatable(val) {
      this.moveable.renderDirections = val ? ["nw", "n", "ne", "w", "e", "sw", "s", "se"] : [];
      this.moveable.resizable = val;
      this.moveable.scalable = val;
      document.getElementsByClassName("moveable-rotation")[0].style.display = val ? "block" : "none";
    },
    updateRect(val) {
      this.moveable.updateRect();
    },
    updateSelect() {
      const items = this.$store.getters.dSelectWidgets;
      setTimeout(async () => {
        var _a2, _b;
        this.moveable.updateRect();
        await this.$nextTick();
        for (let i = 0; i < items.length; i++) {
          (_a2 = document.getElementById(items[i].uuid)) == null ? void 0 : _a2.classList.add("widget-selected");
        }
        this.moveable.renderDirections = [];
        this.moveable.rotatable = false;
        const targetCollector = [].slice.call(document.querySelectorAll(".widget-selected"));
        this.moveable.target = targetCollector;
        for (let i = 0; i < items.length; i++) {
          (_b = document.getElementById(items[i].uuid)) == null ? void 0 : _b.classList.remove("widget-selected");
        }
      }, 400);
    },
    dSelectWidgets: {
      handler(items) {
        var _a2, _b;
        const alt = this.$store.getters.dAltDown;
        if (alt) {
          for (let i = 0; i < items.length; i++) {
            (_a2 = document.getElementById(items[i].uuid)) == null ? void 0 : _a2.classList.add("widget-selected");
          }
          this.moveable.renderDirections = [];
          this.moveable.rotatable = false;
          const targetCollector = [].slice.call(document.querySelectorAll(".widget-selected"));
          this.moveable.target = targetCollector;
          for (let i = 0; i < items.length; i++) {
            (_b = document.getElementById(items[i].uuid)) == null ? void 0 : _b.classList.remove("widget-selected");
          }
        }
      },
      deep: true
    },
    guidelines(lines) {
      this.moveable.verticalGuidelines = lines.verticalGuidelines;
      this.moveable.horizontalGuidelines = lines.horizontalGuidelines;
    }
  },
  mounted() {
    let holdGroupPosition = null;
    const moveableOptions = {
      target: document.querySelector(`[id="empty"]`),
      zoom: 0.8,
      draggable: true,
      clippable: false,
      throttleDrag: 0,
      resizable: true,
      throttleResize: 0,
      scalable: false,
      throttleScale: 0,
      keepRatio: true,
      rotatable: true,
      throttleRotate: 0,
      renderDirections: ["nw", "ne", "sw", "se"],
      pinchable: true,
      origin: false,
      defaultGroupOrigin: "0% 0%",
      rotationPosition: "bottom",
      className: "zk-moveable-style",
      snappable: true,
      elementGuidelines: [],
      verticalGuidelines: [],
      horizontalGuidelines: [],
      snapThreshold: 4,
      isDisplaySnapDigit: true,
      snapGap: false,
      snapElement: true,
      snapVertical: true,
      snapHorizontal: true,
      snapCenter: false,
      snapDigit: 0,
      triggerAblesSimultaneously: true
    };
    const moveable = new Moveable$2(document.body, moveableOptions);
    this.moveable = moveable;
    const helper = new MoveableHelper$1();
    EVENTS$2.forEach((event) => {
      let helperEvent = event.replace(event[0], "on" + event[0].toUpperCase());
      if (["resizeStart", "rotate", "resize"].includes(event)) {
        moveable.on(event, (...args) => {
          helper[helperEvent] && helper[helperEvent](...args);
        });
      }
    });
    let resizeStartWidth = 0;
    moveable.on("dragStart", ({ inputEvent, target, stop }) => {
      if (inputEvent.target.nodeName === "PRE") {
        this.dActiveElement.editable && stop();
      }
      this.dActiveElement.lock && stop();
    }).on("drag", ({ target, transform: transform2, left, top, inputEvent }) => {
      target.style.left = `${left}px`;
      target.style.top = `${top}px`;
      this.holdPosition = { left, top };
    }).on("dragEnd", ({ target, isDrag: isDrag2, inputEvent }) => {
      var _a2, _b;
      this.$store.commit("setMouseEvent", null);
      inputEvent.stopPropagation();
      inputEvent.preventDefault();
      if (this.holdPosition) {
        this.updateWidgetData({
          uuid: this.dActiveElement.uuid,
          key: "left",
          value: Number((_a2 = this.holdPosition) == null ? void 0 : _a2.left)
        });
        this.updateWidgetData({
          uuid: this.dActiveElement.uuid,
          key: "top",
          value: Number((_b = this.holdPosition) == null ? void 0 : _b.top)
        });
        this.holdPosition = null;
        setTimeout(() => {
          this.pushHistory();
        }, 100);
      }
    }).on("rotate", ({ target, beforeDist, dist, transform: transform2 }) => {
    }).on("rotateEnd", (e2) => {
      const tf = e2.target.style.transform;
      const iof = tf.indexOf("rotate");
      let rotate2 = "";
      if (iof != -1) {
        const index2 = iof + "rotate".length;
        const half = tf.substring(index2 + 1);
        rotate2 = half.slice(0, half.indexOf(")"));
      }
      rotate2 && this.updateWidgetData({
        uuid: this.dActiveElement.uuid,
        key: "rotate",
        value: rotate2
      });
    }).on("resizeStart", (args) => {
      this.moveable.snappable = false;
      if (this.dActiveElement.type === "w-text") {
        if (String(args.direction) === "1,0") {
          moveable.keepRatio = false;
          moveable.scalable = false;
        }
        if (String(args.direction) === "1,1") {
          moveable.keepRatio = false;
          resizeStartWidth = args.target.offsetWidth;
          this.startHL = Number(args.target.style.lineHeight.replace("px", ""));
          this.startLS = Number(args.target.style.letterSpacing.replace("px", ""));
          this.resetRatio = 1;
        }
      } else if (this.dActiveElement.type === "w-image" || this.dActiveElement.type === "w-qrcode" || this.dActiveElement.type === "w-svg") {
        const dirs = ["1,0", "0,-1", "-1,0", "0,1"];
        dirs.includes(String(args.direction)) && (moveable.keepRatio = false);
      }
    }).on("resize", (args) => {
      const { target, width, height, dist, delta, clientX, clientY, direction: direction2 } = args;
      if (this.dActiveElement.type === "w-text") {
        if (String(direction2) === "1,1") {
          this.resetRatio = width / resizeStartWidth;
          target.style.fontSize = this.dActiveElement.fontSize * this.resetRatio + "px";
          target.style.letterSpacing = this.startLS * this.resetRatio + "px";
          target.style.lineHeight = this.startHL * this.resetRatio + "px";
        }
        target.style.width = width;
        target.style.height = height;
        this.resizeTempData = { width, height };
        target.style.backgroundImage = "none";
      } else if (this.dActiveElement.type == "w-image" || this.dActiveElement.type === "w-qrcode" || this.dActiveElement.type === "w-svg") {
        this.resizeTempData = { width, height };
      } else if (this.dActiveElement.type == "w-group") {
        this.$store.commit("resize", { width, height });
      } else {
        this.$store.commit("resize", { width, height });
      }
      this.dActiveElement.rotate && (target.style.transform = target.style.transform.replace("(0deg", `(${this.dActiveElement.rotate}`));
    }).on("resizeEnd", (e2) => {
      moveable.resizable = true;
      moveable.snappable = true;
      if (e2.lastEvent) {
        console.log("\u91CD\u7F6Etranslate", this.dActiveElement);
        const left = e2.lastEvent.drag.translate[0];
        const top = e2.lastEvent.drag.translate[1];
        this.updateWidgetMultiple({
          uuid: this.dActiveElement.uuid,
          data: [
            {
              key: "left",
              value: Number(this.dActiveElement.left) + left
            },
            {
              key: "top",
              value: Number(this.dActiveElement.top) + top
            }
          ]
        });
        const tf = e2.target.style.transform;
        const iof = tf.indexOf("translate");
        const FRONT = tf.slice(0, iof + "translate".length + 1);
        const half = tf.substring(iof + "translate".length + 1);
        const END = half.substring(half.indexOf(")"));
        e2.target.style.transform = FRONT + "0, 0" + END;
      }
      if (this.resizeTempData) {
        this.$store.commit("resize", this.resizeTempData);
        this.resizeTempData = null;
        setTimeout(async () => {
          await this.$nextTick();
          this.moveable.updateRect();
        }, 10);
      }
      try {
        if (this.dActiveElement.type === "w-text") {
          const d = e2.direction || e2.lastEvent.direction;
          String(d) === "1,1" && (this.dActiveElement.fontSize = this.dActiveElement.fontSize * this.resetRatio);
        }
      } catch (err) {
      }
      moveable.keepRatio = true;
    }).on("scaleStart", (e2) => {
      if (this.dActiveElement.type === "w-text") {
        this.startHL = Number(e2.target.style.lineHeight.replace("px", ""));
        this.startLS = Number(e2.target.style.letterSpacing.replace("px", ""));
        this.resetRatio = 1;
      } else {
        moveable.scalable = false;
      }
    }).on("scale", (e2) => {
      moveable.resizable = false;
      const { target, scale, transform: transform2 } = e2;
      this.resetRatio = scale[0];
      target.style.transform = transform2;
      this.dActiveElement.rotate && (target.style.transform = target.style.transform.replace("0deg", this.dActiveElement.rotate));
    }).on("scaleEnd", (e2) => {
      moveable.resizable = true;
      moveable.keepRatio = true;
      try {
        if (this.dActiveElement.type === "w-text") {
          const d = e2.direction || e2.lastEvent.direction;
          String(d) === "1,1" && (this.dActiveElement.fontSize = this.dActiveElement.fontSize * this.resetRatio);
        }
      } catch (err) {
      }
    }).on("dragGroup", (e2) => {
      e2.inputEvent.stopPropagation();
      e2.inputEvent.preventDefault();
      holdGroupPosition = {};
      const events2 = e2.events;
      for (let i = 0; i < events2.length; i++) {
        const ev = events2[i];
        const currentWidget = this.dWidgets.find((item) => item.uuid === ev.target.getAttribute("data-uuid"));
        const left = Number(currentWidget.left) + ev.beforeTranslate[0];
        const top = Number(currentWidget.top) + ev.beforeTranslate[1];
        ev.target.style.left = `${left}px`;
        ev.target.style.top = `${top}px`;
        holdGroupPosition[`${ev.target.getAttribute("data-uuid")}`] = { left, top };
      }
    }).on("dragGroupEnd", (e2) => {
      for (const key in holdGroupPosition) {
        if (Object.prototype.hasOwnProperty.call(holdGroupPosition, key)) {
          const item = holdGroupPosition[key];
          this.updateWidgetData({
            uuid: key,
            key: "left",
            value: item.left
          });
          this.updateWidgetData({
            uuid: key,
            key: "top",
            value: item.top
          });
        }
      }
      holdGroupPosition = null;
    }).on("resizeGroupStart", ({ events: events2 }) => {
    }).on("resizeGroup", (e2) => {
    }).on("resizeGroupEnd", ({ targets, isDrag: isDrag2 }) => {
    });
    useSelecto(this.moveable);
  },
  async created() {
    await nextTick();
    const Ele = document.getElementById("page-design");
    Ele == null ? void 0 : Ele.addEventListener("scroll", () => {
      this.moveable.updateRect();
    });
  },
  methods: {
    ...mapActions(["updateWidgetData", "updateWidgetMultiple", "pushHistory"])
  }
});
const _hoisted_1$R = {
  id: "empty",
  class: "moveable__remove-item zk-moveable-style"
};
function _sfc_render$R(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$R);
}
var Moveable = /* @__PURE__ */ _export_sfc(_sfc_main$V, [["render", _sfc_render$R], ["__scopeId", "data-v-7db0b7b3"]]);
const getImage = (imgItem) => {
  const img = new Image();
  const url = window.URL || window.webkitURL;
  img.src = typeof imgItem === "string" ? imgItem : url.createObjectURL(imgItem);
  return new Promise((resolve) => {
    if (img.complete) {
      resolve(img);
    } else {
      img.onload = function() {
        resolve(img);
      };
    }
  });
};
async function setItem2Data(item) {
  const cloneItem = JSON.parse(JSON.stringify(item));
  const { width: screenWidth, height: screenHeight } = erpStore.getters.dPage;
  let { width: imgWidth, height: imgHeight } = item;
  if (!imgWidth || !imgHeight) {
    const actual = await getImage(item.url);
    cloneItem.width = imgWidth = actual.width;
    cloneItem.height = imgHeight = actual.height;
  }
  let ratio = 1;
  if (imgWidth > screenWidth || imgHeight > screenHeight) {
    ratio = Math.min(screenWidth / imgWidth, screenHeight / imgHeight);
  }
  if (ratio < 1) {
    cloneItem.width = cloneItem.width * ratio * (erpStore.getters.dZoom / 100);
    cloneItem.height = cloneItem.height * ratio * (erpStore.getters.dZoom / 100);
  }
  cloneItem.canvasWidth = cloneItem.width * (erpStore.getters.dZoom / 100);
  return cloneItem;
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
var axios$2 = { exports: {} };
var bind$2 = function bind(fn2, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn2.apply(thisArg, args);
  };
};
var bind$1 = bind$2;
var toString = Object.prototype.toString;
function isArray(val) {
  return toString.call(val) === "[object Array]";
}
function isUndefined(val) {
  return typeof val === "undefined";
}
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === "function" && val.constructor.isBuffer(val);
}
function isArrayBuffer(val) {
  return toString.call(val) === "[object ArrayBuffer]";
}
function isFormData(val) {
  return typeof FormData !== "undefined" && val instanceof FormData;
}
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}
function isString$1(val) {
  return typeof val === "string";
}
function isNumber(val) {
  return typeof val === "number";
}
function isObject(val) {
  return val !== null && typeof val === "object";
}
function isPlainObject(val) {
  if (toString.call(val) !== "[object Object]") {
    return false;
  }
  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
function isDate(val) {
  return toString.call(val) === "[object Date]";
}
function isFile(val) {
  return toString.call(val) === "[object File]";
}
function isBlob(val) {
  return toString.call(val) === "[object Blob]";
}
function isFunction(val) {
  return toString.call(val) === "[object Function]";
}
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}
function isURLSearchParams(val) {
  return typeof URLSearchParams !== "undefined" && val instanceof URLSearchParams;
}
function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, "");
}
function isStandardBrowserEnv() {
  if (typeof navigator !== "undefined" && (navigator.product === "ReactNative" || navigator.product === "NativeScript" || navigator.product === "NS")) {
    return false;
  }
  return typeof window !== "undefined" && typeof document !== "undefined";
}
function forEach(obj, fn2) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      fn2.call(null, obj[i], i, obj);
    }
  } else {
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn2.call(null, obj[key], key, obj);
      }
    }
  }
}
function merge() {
  var result = {};
  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }
  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}
function extend$1(a2, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === "function") {
      a2[key] = bind$1(val, thisArg);
    } else {
      a2[key] = val;
    }
  });
  return a2;
}
function stripBOM(content2) {
  if (content2.charCodeAt(0) === 65279) {
    content2 = content2.slice(1);
  }
  return content2;
}
var utils$g = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber,
  isObject,
  isPlainObject,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isFunction,
  isStream,
  isURLSearchParams,
  isStandardBrowserEnv,
  forEach,
  merge,
  extend: extend$1,
  trim,
  stripBOM
};
var utils$f = utils$g;
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
var buildURL$2 = function buildURL(url, params, paramsSerializer) {
  if (!params) {
    return url;
  }
  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils$f.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils$f.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === "undefined") {
        return;
      }
      if (utils$f.isArray(val)) {
        key = key + "[]";
      } else {
        val = [val];
      }
      utils$f.forEach(val, function parseValue(v) {
        if (utils$f.isDate(v)) {
          v = v.toISOString();
        } else if (utils$f.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + "=" + encode(v));
      });
    });
    serializedParams = parts.join("&");
  }
  if (serializedParams) {
    var hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
};
var utils$e = utils$g;
function InterceptorManager$1() {
  this.handlers = [];
}
InterceptorManager$1.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled,
    rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
InterceptorManager$1.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
InterceptorManager$1.prototype.forEach = function forEach2(fn2) {
  utils$e.forEach(this.handlers, function forEachHandler(h2) {
    if (h2 !== null) {
      fn2(h2);
    }
  });
};
var InterceptorManager_1 = InterceptorManager$1;
var utils$d = utils$g;
var normalizeHeaderName$1 = function normalizeHeaderName(headers, normalizedName) {
  utils$d.forEach(headers, function processHeader(value, name2) {
    if (name2 !== normalizedName && name2.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name2];
    }
  });
};
var enhanceError$2 = function enhanceError(error, config2, code, request2, response) {
  error.config = config2;
  if (code) {
    error.code = code;
  }
  error.request = request2;
  error.response = response;
  error.isAxiosError = true;
  error.toJSON = function toJSON() {
    return {
      message: this.message,
      name: this.name,
      description: this.description,
      number: this.number,
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      config: this.config,
      code: this.code
    };
  };
  return error;
};
var enhanceError$1 = enhanceError$2;
var createError$2 = function createError(message, config2, code, request2, response) {
  var error = new Error(message);
  return enhanceError$1(error, config2, code, request2, response);
};
var createError$1 = createError$2;
var settle$1 = function settle(resolve, reject, response) {
  var validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(createError$1(
      "Request failed with status code " + response.status,
      response.config,
      null,
      response.request,
      response
    ));
  }
};
var utils$c = utils$g;
var cookies$1 = utils$c.isStandardBrowserEnv() ? function standardBrowserEnv() {
  return {
    write: function write(name2, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name2 + "=" + encodeURIComponent(value));
      if (utils$c.isNumber(expires)) {
        cookie.push("expires=" + new Date(expires).toGMTString());
      }
      if (utils$c.isString(path)) {
        cookie.push("path=" + path);
      }
      if (utils$c.isString(domain)) {
        cookie.push("domain=" + domain);
      }
      if (secure === true) {
        cookie.push("secure");
      }
      document.cookie = cookie.join("; ");
    },
    read: function read(name2) {
      var match = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name2) {
      this.write(name2, "", Date.now() - 864e5);
    }
  };
}() : function nonStandardBrowserEnv() {
  return {
    write: function write() {
    },
    read: function read() {
      return null;
    },
    remove: function remove() {
    }
  };
}();
var isAbsoluteURL$1 = function isAbsoluteURL(url) {
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};
var combineURLs$1 = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
};
var isAbsoluteURL2 = isAbsoluteURL$1;
var combineURLs2 = combineURLs$1;
var buildFullPath$1 = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL2(requestedURL)) {
    return combineURLs2(baseURL, requestedURL);
  }
  return requestedURL;
};
var utils$b = utils$g;
var ignoreDuplicateOf = [
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
];
var parseHeaders$1 = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;
  if (!headers) {
    return parsed;
  }
  utils$b.forEach(headers.split("\n"), function parser(line) {
    i = line.indexOf(":");
    key = utils$b.trim(line.substr(0, i)).toLowerCase();
    val = utils$b.trim(line.substr(i + 1));
    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === "set-cookie") {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
      }
    }
  });
  return parsed;
};
var utils$a = utils$g;
var isURLSameOrigin$1 = utils$a.isStandardBrowserEnv() ? function standardBrowserEnv2() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement("a");
  var originURL;
  function resolveURL(url) {
    var href = url;
    if (msie) {
      urlParsingNode.setAttribute("href", href);
      href = urlParsingNode.href;
    }
    urlParsingNode.setAttribute("href", href);
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
    };
  }
  originURL = resolveURL(window.location.href);
  return function isURLSameOrigin2(requestURL) {
    var parsed = utils$a.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : function nonStandardBrowserEnv2() {
  return function isURLSameOrigin2() {
    return true;
  };
}();
var utils$9 = utils$g;
var settle2 = settle$1;
var cookies = cookies$1;
var buildURL$1 = buildURL$2;
var buildFullPath2 = buildFullPath$1;
var parseHeaders2 = parseHeaders$1;
var isURLSameOrigin = isURLSameOrigin$1;
var createError2 = createError$2;
var xhr = function xhrAdapter(config2) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config2.data;
    var requestHeaders = config2.headers;
    var responseType = config2.responseType;
    if (utils$9.isFormData(requestData)) {
      delete requestHeaders["Content-Type"];
    }
    var request2 = new XMLHttpRequest();
    if (config2.auth) {
      var username = config2.auth.username || "";
      var password = config2.auth.password ? unescape(encodeURIComponent(config2.auth.password)) : "";
      requestHeaders.Authorization = "Basic " + btoa(username + ":" + password);
    }
    var fullPath = buildFullPath2(config2.baseURL, config2.url);
    request2.open(config2.method.toUpperCase(), buildURL$1(fullPath, config2.params, config2.paramsSerializer), true);
    request2.timeout = config2.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      var responseHeaders = "getAllResponseHeaders" in request2 ? parseHeaders2(request2.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      var response = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config: config2,
        request: request2
      };
      settle2(resolve, reject, response);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(createError2("Request aborted", config2, "ECONNABORTED", request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject(createError2("Network Error", config2, null, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = "timeout of " + config2.timeout + "ms exceeded";
      if (config2.timeoutErrorMessage) {
        timeoutErrorMessage = config2.timeoutErrorMessage;
      }
      reject(createError2(
        timeoutErrorMessage,
        config2,
        config2.transitional && config2.transitional.clarifyTimeoutError ? "ETIMEDOUT" : "ECONNABORTED",
        request2
      ));
      request2 = null;
    };
    if (utils$9.isStandardBrowserEnv()) {
      var xsrfValue = (config2.withCredentials || isURLSameOrigin(fullPath)) && config2.xsrfCookieName ? cookies.read(config2.xsrfCookieName) : void 0;
      if (xsrfValue) {
        requestHeaders[config2.xsrfHeaderName] = xsrfValue;
      }
    }
    if ("setRequestHeader" in request2) {
      utils$9.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === "undefined" && key.toLowerCase() === "content-type") {
          delete requestHeaders[key];
        } else {
          request2.setRequestHeader(key, val);
        }
      });
    }
    if (!utils$9.isUndefined(config2.withCredentials)) {
      request2.withCredentials = !!config2.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = config2.responseType;
    }
    if (typeof config2.onDownloadProgress === "function") {
      request2.addEventListener("progress", config2.onDownloadProgress);
    }
    if (typeof config2.onUploadProgress === "function" && request2.upload) {
      request2.upload.addEventListener("progress", config2.onUploadProgress);
    }
    if (config2.cancelToken) {
      config2.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request2) {
          return;
        }
        request2.abort();
        reject(cancel);
        request2 = null;
      });
    }
    if (!requestData) {
      requestData = null;
    }
    request2.send(requestData);
  });
};
var utils$8 = utils$g;
var normalizeHeaderName2 = normalizeHeaderName$1;
var enhanceError2 = enhanceError$2;
var DEFAULT_CONTENT_TYPE = {
  "Content-Type": "application/x-www-form-urlencoded"
};
function setContentTypeIfUnset(headers, value) {
  if (!utils$8.isUndefined(headers) && utils$8.isUndefined(headers["Content-Type"])) {
    headers["Content-Type"] = value;
  }
}
function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== "undefined") {
    adapter = xhr;
  } else if (typeof process !== "undefined" && Object.prototype.toString.call(process) === "[object process]") {
    adapter = xhr;
  }
  return adapter;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$8.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$8.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults$4 = {
  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName2(headers, "Accept");
    normalizeHeaderName2(headers, "Content-Type");
    if (utils$8.isFormData(data) || utils$8.isArrayBuffer(data) || utils$8.isBuffer(data) || utils$8.isStream(data) || utils$8.isFile(data) || utils$8.isBlob(data)) {
      return data;
    }
    if (utils$8.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils$8.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, "application/x-www-form-urlencoded;charset=utf-8");
      return data.toString();
    }
    if (utils$8.isObject(data) || headers && headers["Content-Type"] === "application/json") {
      setContentTypeIfUnset(headers, "application/json");
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    var transitional2 = this.transitional;
    var silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
    var forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === "json";
    if (strictJSONParsing || forcedJSONParsing && utils$8.isString(data) && data.length) {
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw enhanceError2(e2, this, "E_JSON_PARSE");
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults$4.headers = {
  common: {
    "Accept": "application/json, text/plain, */*"
  }
};
utils$8.forEach(["delete", "get", "head"], function forEachMethodNoData(method) {
  defaults$4.headers[method] = {};
});
utils$8.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  defaults$4.headers[method] = utils$8.merge(DEFAULT_CONTENT_TYPE);
});
var defaults_1 = defaults$4;
var utils$7 = utils$g;
var defaults$3 = defaults_1;
var transformData$1 = function transformData(data, headers, fns) {
  var context = this || defaults$3;
  utils$7.forEach(fns, function transform2(fn2) {
    data = fn2.call(context, data, headers);
  });
  return data;
};
var isCancel$1 = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};
var utils$6 = utils$g;
var transformData2 = transformData$1;
var isCancel2 = isCancel$1;
var defaults$2 = defaults_1;
function throwIfCancellationRequested(config2) {
  if (config2.cancelToken) {
    config2.cancelToken.throwIfRequested();
  }
}
var dispatchRequest$1 = function dispatchRequest(config2) {
  throwIfCancellationRequested(config2);
  config2.headers = config2.headers || {};
  config2.data = transformData2.call(
    config2,
    config2.data,
    config2.headers,
    config2.transformRequest
  );
  config2.headers = utils$6.merge(
    config2.headers.common || {},
    config2.headers[config2.method] || {},
    config2.headers
  );
  utils$6.forEach(
    ["delete", "get", "head", "post", "put", "patch", "common"],
    function cleanHeaderConfig(method) {
      delete config2.headers[method];
    }
  );
  var adapter = config2.adapter || defaults$2.adapter;
  return adapter(config2).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config2);
    response.data = transformData2.call(
      config2,
      response.data,
      response.headers,
      config2.transformResponse
    );
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel2(reason)) {
      throwIfCancellationRequested(config2);
      if (reason && reason.response) {
        reason.response.data = transformData2.call(
          config2,
          reason.response.data,
          reason.response.headers,
          config2.transformResponse
        );
      }
    }
    return Promise.reject(reason);
  });
};
var utils$5 = utils$g;
var mergeConfig$2 = function mergeConfig(config1, config2) {
  config2 = config2 || {};
  var config3 = {};
  var valueFromConfig2Keys = ["url", "method", "data"];
  var mergeDeepPropertiesKeys = ["headers", "auth", "proxy", "params"];
  var defaultToConfig2Keys = [
    "baseURL",
    "transformRequest",
    "transformResponse",
    "paramsSerializer",
    "timeout",
    "timeoutMessage",
    "withCredentials",
    "adapter",
    "responseType",
    "xsrfCookieName",
    "xsrfHeaderName",
    "onUploadProgress",
    "onDownloadProgress",
    "decompress",
    "maxContentLength",
    "maxBodyLength",
    "maxRedirects",
    "transport",
    "httpAgent",
    "httpsAgent",
    "cancelToken",
    "socketPath",
    "responseEncoding"
  ];
  var directMergeKeys = ["validateStatus"];
  function getMergedValue(target, source2) {
    if (utils$5.isPlainObject(target) && utils$5.isPlainObject(source2)) {
      return utils$5.merge(target, source2);
    } else if (utils$5.isPlainObject(source2)) {
      return utils$5.merge({}, source2);
    } else if (utils$5.isArray(source2)) {
      return source2.slice();
    }
    return source2;
  }
  function mergeDeepProperties(prop) {
    if (!utils$5.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils$5.isUndefined(config1[prop])) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  }
  utils$5.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils$5.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(void 0, config2[prop]);
    }
  });
  utils$5.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
  utils$5.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils$5.isUndefined(config2[prop])) {
      config3[prop] = getMergedValue(void 0, config2[prop]);
    } else if (!utils$5.isUndefined(config1[prop])) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  });
  utils$5.forEach(directMergeKeys, function merge2(prop) {
    if (prop in config2) {
      config3[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config3[prop] = getMergedValue(void 0, config1[prop]);
    }
  });
  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
  var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
    return axiosKeys.indexOf(key) === -1;
  });
  utils$5.forEach(otherKeys, mergeDeepProperties);
  return config3;
};
const name = "axios";
const version$1 = "0.21.4";
const description = "Promise based HTTP client for the browser and node.js";
const main = "index.js";
const scripts = {
  test: "grunt test",
  start: "node ./sandbox/server.js",
  build: "NODE_ENV=production grunt build",
  preversion: "npm test",
  version: "npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json",
  postversion: "git push && git push --tags",
  examples: "node ./examples/server.js",
  coveralls: "cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js",
  fix: "eslint --fix lib/**/*.js"
};
const repository = {
  type: "git",
  url: "https://github.com/axios/axios.git"
};
const keywords = [
  "xhr",
  "http",
  "ajax",
  "promise",
  "node"
];
const author = "Matt Zabriskie";
const license = "MIT";
const bugs = {
  url: "https://github.com/axios/axios/issues"
};
const homepage = "https://axios-http.com";
const devDependencies = {
  coveralls: "^3.0.0",
  "es6-promise": "^4.2.4",
  grunt: "^1.3.0",
  "grunt-banner": "^0.6.0",
  "grunt-cli": "^1.2.0",
  "grunt-contrib-clean": "^1.1.0",
  "grunt-contrib-watch": "^1.0.0",
  "grunt-eslint": "^23.0.0",
  "grunt-karma": "^4.0.0",
  "grunt-mocha-test": "^0.13.3",
  "grunt-ts": "^6.0.0-beta.19",
  "grunt-webpack": "^4.0.2",
  "istanbul-instrumenter-loader": "^1.0.0",
  "jasmine-core": "^2.4.1",
  karma: "^6.3.2",
  "karma-chrome-launcher": "^3.1.0",
  "karma-firefox-launcher": "^2.1.0",
  "karma-jasmine": "^1.1.1",
  "karma-jasmine-ajax": "^0.1.13",
  "karma-safari-launcher": "^1.0.0",
  "karma-sauce-launcher": "^4.3.6",
  "karma-sinon": "^1.0.5",
  "karma-sourcemap-loader": "^0.3.8",
  "karma-webpack": "^4.0.2",
  "load-grunt-tasks": "^3.5.2",
  minimist: "^1.2.0",
  mocha: "^8.2.1",
  sinon: "^4.5.0",
  "terser-webpack-plugin": "^4.2.3",
  typescript: "^4.0.5",
  "url-search-params": "^0.10.0",
  webpack: "^4.44.2",
  "webpack-dev-server": "^3.11.0"
};
const browser = {
  "./lib/adapters/http.js": "./lib/adapters/xhr.js"
};
const jsdelivr = "dist/axios.min.js";
const unpkg = "dist/axios.min.js";
const typings = "./index.d.ts";
const dependencies = {
  "follow-redirects": "^1.14.0"
};
const bundlesize = [
  {
    path: "./dist/axios.min.js",
    threshold: "5kB"
  }
];
var require$$0 = {
  name,
  version: version$1,
  description,
  main,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  browser,
  jsdelivr,
  unpkg,
  typings,
  dependencies,
  bundlesize
};
var pkg = require$$0;
var validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach(function(type, i) {
  validators$1[type] = function validator2(thing) {
    return typeof thing === type || "a" + (i < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
var currentVerArr = pkg.version.split(".");
function isOlderVersion(version2, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split(".") : currentVerArr;
  var destVer = version2.split(".");
  for (var i = 0; i < 3; i++) {
    if (pkgVersionArr[i] > destVer[i]) {
      return true;
    } else if (pkgVersionArr[i] < destVer[i]) {
      return false;
    }
  }
  return false;
}
validators$1.transitional = function transitional(validator2, version2, message) {
  var isDeprecated = version2 && isOlderVersion(version2);
  function formatMessage(opt, desc) {
    return "[Axios v" + pkg.version + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return function(value, opt, opts) {
    if (validator2 === false) {
      throw new Error(formatMessage(opt, " has been removed in " + version2));
    }
    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new TypeError("options must be an object");
  }
  var keys2 = Object.keys(options);
  var i = keys2.length;
  while (i-- > 0) {
    var opt = keys2[i];
    var validator2 = schema[opt];
    if (validator2) {
      var value = options[opt];
      var result = value === void 0 || validator2(value, opt, options);
      if (result !== true) {
        throw new TypeError("option " + opt + " must be " + result);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw Error("Unknown option " + opt);
    }
  }
}
var validator$1 = {
  isOlderVersion,
  assertOptions,
  validators: validators$1
};
var utils$4 = utils$g;
var buildURL2 = buildURL$2;
var InterceptorManager = InterceptorManager_1;
var dispatchRequest2 = dispatchRequest$1;
var mergeConfig$1 = mergeConfig$2;
var validator = validator$1;
var validators = validator.validators;
function Axios$1(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
Axios$1.prototype.request = function request(config2) {
  if (typeof config2 === "string") {
    config2 = arguments[1] || {};
    config2.url = arguments[0];
  } else {
    config2 = config2 || {};
  }
  config2 = mergeConfig$1(this.defaults, config2);
  if (config2.method) {
    config2.method = config2.method.toLowerCase();
  } else if (this.defaults.method) {
    config2.method = this.defaults.method.toLowerCase();
  } else {
    config2.method = "get";
  }
  var transitional2 = config2.transitional;
  if (transitional2 !== void 0) {
    validator.assertOptions(transitional2, {
      silentJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
      forcedJSONParsing: validators.transitional(validators.boolean, "1.0.0"),
      clarifyTimeoutError: validators.transitional(validators.boolean, "1.0.0")
    }, false);
  }
  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config2) === false) {
      return;
    }
    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;
  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest2, void 0];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config2);
    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }
    return promise;
  }
  var newConfig = config2;
  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();
    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }
  try {
    promise = dispatchRequest2(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }
  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }
  return promise;
};
Axios$1.prototype.getUri = function getUri(config2) {
  config2 = mergeConfig$1(this.defaults, config2);
  return buildURL2(config2.url, config2.params, config2.paramsSerializer).replace(/^\?/, "");
};
utils$4.forEach(["delete", "get", "head", "options"], function forEachMethodNoData2(method) {
  Axios$1.prototype[method] = function(url, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url,
      data: (config2 || {}).data
    }));
  };
});
utils$4.forEach(["post", "put", "patch"], function forEachMethodWithData2(method) {
  Axios$1.prototype[method] = function(url, data, config2) {
    return this.request(mergeConfig$1(config2 || {}, {
      method,
      url,
      data
    }));
  };
});
var Axios_1 = Axios$1;
function Cancel$1(message) {
  this.message = message;
}
Cancel$1.prototype.toString = function toString2() {
  return "Cancel" + (this.message ? ": " + this.message : "");
};
Cancel$1.prototype.__CANCEL__ = true;
var Cancel_1 = Cancel$1;
var Cancel = Cancel_1;
function CancelToken(executor) {
  if (typeof executor !== "function") {
    throw new TypeError("executor must be a function.");
  }
  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      return;
    }
    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token,
    cancel
  };
};
var CancelToken_1 = CancelToken;
var spread = function spread2(callback) {
  return function wrap(arr2) {
    return callback.apply(null, arr2);
  };
};
var isAxiosError = function isAxiosError2(payload) {
  return typeof payload === "object" && payload.isAxiosError === true;
};
var utils$3 = utils$g;
var bind2 = bind$2;
var Axios = Axios_1;
var mergeConfig2 = mergeConfig$2;
var defaults$1 = defaults_1;
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind2(Axios.prototype.request, context);
  utils$3.extend(instance, Axios.prototype, context);
  utils$3.extend(instance, context);
  return instance;
}
var axios$1 = createInstance(defaults$1);
axios$1.Axios = Axios;
axios$1.create = function create(instanceConfig) {
  return createInstance(mergeConfig2(axios$1.defaults, instanceConfig));
};
axios$1.Cancel = Cancel_1;
axios$1.CancelToken = CancelToken_1;
axios$1.isCancel = isCancel$1;
axios$1.all = function all2(promises) {
  return Promise.all(promises);
};
axios$1.spread = spread;
axios$1.isAxiosError = isAxiosError;
axios$2.exports = axios$1;
axios$2.exports.default = axios$1;
var axios = axios$2.exports;
axios.defaults.timeout = 3e4;
axios.defaults.headers.authorization = "eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpZCI6MTAwMDEsImV4cCI6MTc4ODU3NDc1MDU4NX0.L_t6DFD48Dm6rUPfgIgOWJkz18En1m_-hhMHcpbxliY";
const baseUrl = _config.API_URL;
axios.interceptors.request.use(
  (config2) => {
    const url = config2.url;
    const values = {};
    if (url.indexOf("http://") !== 0 && url.indexOf("https://") !== 0) {
      url.indexOf("/") === 0 ? config2.url = baseUrl + url : config2.url = baseUrl + "/" + url;
    }
    if (config2.method === "get") {
      config2.params = Object.assign(config2.params, values);
    } else {
      config2.data = Object.assign(config2.data, values);
    }
    return config2;
  },
  (error) => {
    return Promise.reject(error);
  }
);
axios.interceptors.response.use(
  (res) => {
    if (!res.data) {
      return Promise.reject(res);
    }
    if (res.data.code === 401) {
      console.log("\u767B\u5F55\u5931\u6548");
      erpStore.commit("changeOnline", false);
    }
    if (res.data.result && res.data.code === 200) {
      return Promise.resolve(res.data.result);
    } else if (res.data.data && res.data.stat == 1) {
      return Promise.resolve(res.data.data);
    } else {
      return Promise.resolve(res.data);
    }
  },
  (error) => {
    erpStore.dispatch("hideLoading");
    return Promise.reject(error);
  }
);
const fetch$1 = (url, params, type = "get", exheaders = {}, extra = {}) => {
  if (params && params._noLoading) {
    delete params._noLoading;
  }
  const token = localStorage.getItem("xp_token");
  const headerObject = {};
  token && (headerObject.authorization = token);
  headerObject.CompanyId = localStorage.getItem("CompanyId") || "hg8fa286ab8f434d8f";
  if (type === "get") {
    return axios.get(url, {
      headers: Object.assign(headerObject, exheaders),
      params,
      ...extra
    });
  } else {
    return axios[type](url, params, {
      headers: Object.assign(headerObject, exheaders),
      ...extra
    });
  }
};
const download = (params = {}) => `${_config.SCREEN_URL}/api/screenshots?id=${params.id}&width=${params.width}&height=${params.height}`;
const getTempList = (params = {}) => fetch$1("design/list", params, "get");
const getTempDetail = (params = {}) => fetch$1("design/temp", params, "get");
const getCategories = (params = {}) => fetch$1("design/cate", params, "get");
const saveTemp = (params = {}) => fetch$1("design/edit", params, "post");
const getCompList = (params = {}) => fetch$1("design/list", params, "get");
const removeComp = (params = {}) => fetch$1("design/del", params, "post");
const saveWorks = (params = {}) => fetch$1("design/save", params, "post");
const saveMyTemp = (params = {}) => fetch$1("design/user/temp", params, "post");
const getWorks = (params = {}) => fetch$1("design/poster", params, "get");
const getVars = (params = {}) => fetch$1("product/fields", params, "get");
const getMyDesign = (params = {}) => fetch$1("design/my", params, "get");
const base64ToImg = (params = {}) => fetch$1("common/uploadByBase64", params, "post");
var home = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  download,
  getTempList,
  getTempDetail,
  getCategories,
  saveTemp,
  getCompList,
  removeComp,
  saveWorks,
  saveMyTemp,
  getWorks,
  getVars,
  getMyDesign,
  base64ToImg
}, Symbol.toStringTag, { value: "Module" }));
const getKinds = (params = {}) => fetch$1("design/cate", params);
const getList = (params = {}) => fetch$1("design/material", params);
const getFonts = (params = {}) => fetch$1("design/fonts", params);
const getFontSub = (params = {}, extra = {}) => fetch$1("design/font_sub", params, "get", {}, extra);
const getImagesList = (params = {}) => fetch$1("design/imgs", params, "get");
const getMyPhoto = (params = {}) => fetch$1("design/user/image", params);
const deleteMyPhoto = (params = {}) => fetch$1("design/user/image/del", params, "post");
const deleteMyWorks = (params = {}) => fetch$1("design/poster/del", params, "post");
const addMyPhoto = (params = {}) => fetch$1("design/user/add_image", params);
var material = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  getKinds,
  getList,
  getFonts,
  getFontSub,
  getImagesList,
  getMyPhoto,
  deleteMyPhoto,
  deleteMyWorks,
  addMyPhoto
}, Symbol.toStringTag, { value: "Module" }));
const upload = (file, cb) => {
  const formData = new FormData();
  formData.append("file", file);
  const extra = {
    responseType: "blob",
    onUploadProgress: (progress) => {
      cb(Math.floor(progress.loaded / progress.total * 100), 0);
    },
    onDownloadProgress: (progress) => {
      cb(100, Math.floor(progress.loaded / progress.total * 100));
    }
  };
  return fetch$1("http://42.193.3.250:16050/api/remove", formData, "post", {}, extra);
};
const uploadByBase64 = (base64Image, cb) => {
  const blobData = fetch(base64Image).then((res) => res.blob());
  return fetch$1("http://42.193.3.250:16050/api/remove", {
    method: "POST",
    headers: {
      "Content-Type": "application/octet-stream"
    },
    body: blobData
  });
};
const uploadByUrl = (url, cb) => {
  return fetch$1(
    "http://42.193.3.250:16050/api/remove",
    {
      url
    },
    "get",
    {},
    {
      responseType: "blob"
    }
  );
};
var ai = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  upload,
  uploadByBase64,
  uploadByUrl
}, Symbol.toStringTag, { value: "Module" }));
var api$1 = {
  home,
  material,
  ai
};
var services = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": api$1
}, Symbol.toStringTag, { value: "Module" }));
_config.supportSubFont;
var getGradientOrImg = (effect) => {
  let result = "";
  switch (Number(effect.filling.type)) {
    case 2:
      {
        const { angle: angle2, stops } = effect.filling.gradient;
        const gradients = stops.map((x) => `${x.color} ${Number(x.offset) * 100}%`);
        result = `linear-gradient(${angle2}deg, ${gradients.toString()})`;
      }
      break;
    case 1:
      result = `url(${effect.filling.imageContent.image})`;
      break;
    default:
      result = effect.filling.color;
      break;
  }
  return result;
};
var wText_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$q = "w-text";
const _sfc_main$U = {
  name: NAME$q,
  setting: {
    name: "\u6587\u672C",
    type: NAME$q,
    uuid: -1,
    editable: false,
    left: 0,
    top: 0,
    transform: "",
    lineHeight: 1.5,
    letterSpacing: 0,
    fontSize: 24,
    zoom: 1,
    fontClass: {
      alias: "\u7AD9\u9177\u5FEB\u4E50\u4F53",
      id: 543,
      value: "zcool-kuaile-regular",
      url: "https://lib.baomitu.com/fonts/zcool-kuaile/zcool-kuaile-regular.woff2"
    },
    fontFamily: "SourceHanSansSC-Regular",
    fontWeight: "normal",
    fontStyle: "normal",
    writingMode: "horizontal-tb",
    textDecoration: "none",
    color: "#000000ff",
    textAlign: "left",
    text: "",
    opacity: 1,
    backgroundColor: "",
    parent: "-1",
    record: {
      width: 0,
      height: 0,
      minWidth: 0,
      minHeight: 0,
      dir: "horizontal"
    }
  },
  props: ["params", "parent"],
  data() {
    return {
      loading: false,
      editable: false,
      loadFontDone: false,
      editFont: false
    };
  },
  computed: {
    ...mapGetters(["dActiveElement"]),
    isDraw() {
      return false;
    }
  },
  watch: {
    params: {
      async handler(nval) {
        this.updateText();
        if (this.loading) {
          return;
        }
        let font = nval.fontClass;
        const isDone = font.value === this.loadFontDone;
        if (font.url && !isDone) {
          if (font.id && this.isDraw) {
            this.loading = false;
            return;
          }
          this.loading = true;
          const loadFont = new window.FontFace(font.value, `url(${font.url})`);
          await loadFont.load();
          document.fonts.add(loadFont);
          this.loadFontDone = font.value;
          this.loading = false;
        } else {
          this.loading = false;
        }
      },
      immediate: true,
      deep: true
    },
    editable(value) {
      this.updateWidgetData({
        uuid: this.params.uuid,
        key: "editable",
        value,
        pushHistory: false
      });
    }
  },
  updated() {
    this.updateRecord();
  },
  async mounted() {
    this.updateRecord();
    this.params.transform && (this.$refs.widget.style.transform = this.params.transform);
    this.params.rotate && (this.$refs.widget.style.transform += `translate(0px, 0px) rotate(${this.params.rotate}) scale(1, 1)`);
  },
  methods: {
    ...mapActions(["updateWidgetData", "pushHistory"]),
    getGradientOrImg,
    renderText(text) {
      return text.replace(/<wise id="[^"]+">([^<]+)<\/wise>/g, "$1");
    },
    updateRecord() {
      if (this.dActiveElement.uuid === this.params.uuid) {
        let record = this.dActiveElement.record;
        record.width = this.$refs.widget.offsetWidth;
        record.height = this.$refs.widget.offsetHeight;
        record.minWidth = this.params.fontSize;
        record.minHeight = this.params.fontSize * this.params.lineHeight;
        this.writingText();
      }
    },
    updateText(e2) {
      const value = e2 ? e2.target.innerHTML : this.params.text.replace(/\n/g, "<br/>");
      if (value !== this.params.text) {
        this.updateWidgetData({
          uuid: this.params.uuid,
          key: "text",
          value,
          pushHistory: false
        });
      }
    },
    writingText(e2) {
      const el = this.$refs.editWrap || this.$refs.widget;
      this.updateWidgetData({
        uuid: this.params.uuid,
        key: "height",
        value: el.offsetHeight,
        pushHistory: false
      });
      this.$store.commit("updateRect");
    },
    writeDone(e2) {
      this.editable = false;
      setTimeout(() => {
        this.pushHistory("\u6587\u5B57\u4FEE\u6539");
      }, 100);
      this.updateText(e2);
    },
    dblclickText(e2) {
      this.editable = true;
      this.editFont = true;
      const el = this.$refs.editWrap || this.$refs.widget;
      setTimeout(() => {
        el.focus();
        if (document.selection) {
          const range = document.body.createTextRange();
          range.moveToElementText(el);
          range.select();
        } else if (window.getSelection) {
          const range = document.createRange();
          range.selectNodeContents(el);
          window.getSelection().removeAllRanges();
          window.getSelection().addRange(range);
        }
      }, 100);
    }
  }
};
const _hoisted_1$Q = ["id"];
const _hoisted_2$F = ["innerHTML"];
const _hoisted_3$B = ["contenteditable", "innerHTML"];
function _sfc_render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  const _directive_loading = resolveDirective("loading");
  return withDirectives((openBlock(), createElementBlock("div", {
    id: $props.params.uuid,
    ref: "widget",
    class: normalizeClass(["w-text", { editing: $data.editable, "layer-lock": $props.params.lock }, $props.params.uuid]),
    style: normalizeStyle({
      position: "absolute",
      left: $props.params.left - $props.parent.left + "px",
      top: $props.params.top - $props.parent.top + "px",
      width: $props.params.width + "px",
      minWidth: $props.params.fontSize + "px",
      minHeight: $props.params.fontSize * $props.params.lineHeight + "px",
      height: $props.params.height + "px",
      lineHeight: $props.params.fontSize * $props.params.lineHeight + "px",
      letterSpacing: $props.params.fontSize * $props.params.letterSpacing / 100 + "px",
      fontSize: $props.params.fontSize + "px",
      color: $props.params.color,
      textAlign: $props.params.textAlign,
      fontWeight: $props.params.fontWeight,
      fontStyle: $props.params.fontStyle,
      textDecoration: $props.params.textDecoration,
      opacity: $props.params.opacity,
      backgroundColor: $props.params.backgroundColor,
      writingMode: $props.params.writingMode,
      fontFamily: `'${$props.params.fontClass.value}'`
    }),
    onDblclick: _cache[2] || (_cache[2] = (e2) => $options.dblclickText(e2))
  }, [
    $props.params.textEffects && !$data.editable ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList($props.params.textEffects, (ef, efi) => {
      return openBlock(), createElementBlock("div", {
        key: efi + "effect",
        style: normalizeStyle({
          fontFamily: `'${$props.params.fontClass.value}'`,
          color: ef.filling && ef.filling.enable && ef.filling.type === 0 ? ef.filling.color : "transparent",
          webkitTextStroke: ef.stroke && ef.stroke.enable ? `${ef.stroke.width}px ${ef.stroke.color}` : void 0,
          textShadow: ef.shadow && ef.shadow.enable ? `${ef.shadow.offsetX}px ${ef.shadow.offsetY}px ${ef.shadow.blur}px ${ef.shadow.color}` : void 0,
          backgroundImage: ef.filling && ef.filling.enable ? ef.filling.type === 0 ? void 0 : $options.getGradientOrImg(ef) : void 0,
          webkitBackgroundClip: ef.filling && ef.filling.enable ? ef.filling.type === 0 ? void 0 : "text" : void 0,
          transform: ef.offset && ef.offset.enable ? `translate(${ef.offset.x}px, ${ef.offset.y}px)` : void 0
        }),
        class: "edit-text effect-text",
        spellcheck: "false",
        innerHTML: $props.params.text
      }, null, 12, _hoisted_2$F);
    }), 128)) : createCommentVNode("", true),
    createElementVNode("div", {
      ref: "editWrap",
      style: normalizeStyle({ fontFamily: `'${$props.params.fontClass.value}'` }),
      class: "edit-text",
      spellcheck: "false",
      contenteditable: $data.editable ? "plaintext-only" : false,
      onInput: _cache[0] || (_cache[0] = ($event) => $options.writingText($event)),
      onBlur: _cache[1] || (_cache[1] = ($event) => $options.writeDone($event)),
      innerHTML: $props.params.text
    }, null, 44, _hoisted_3$B)
  ], 46, _hoisted_1$Q)), [
    [_directive_loading, $data.loading]
  ]);
}
var wText = /* @__PURE__ */ _export_sfc(_sfc_main$U, [["render", _sfc_render$Q], ["__scopeId", "data-v-7f8596cc"]]);
var __glob_0_33 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": wText
}, Symbol.toStringTag, { value: "Module" }));
class PointImg {
  constructor(img) {
    if (img.src) {
      try {
        this.canvas = document.createElement("canvas");
        this.canvas.width = img.width;
        this.canvas.height = img.height;
        img.crossOrigin = "Anonymous";
        this.cvs = this.canvas.getContext("2d");
        this.cvs.drawImage(img, 0, 0, img.width, img.height);
      } catch (error) {
        console.log(error);
      }
    }
  }
  getColorXY(x, y) {
    const color2 = {};
    try {
      const obj = this.cvs.getImageData(x, y, 1, 1);
      const arr2 = obj.data.toString().split(",");
      let first = parseInt(arr2[0], 10).toString(16);
      first = first.length === 2 ? first : first + first;
      let second = parseInt(arr2[1], 10).toString(16);
      second = second.length === 2 ? second : second + second;
      let third = parseInt(arr2[2], 10).toString(16);
      third = third.length === 2 ? third : third + third;
      let last = parseInt(arr2.pop(), 10) / 255;
      last = Number(last.toFixed(0));
      color2["rgba"] = "rgba(" + arr2.join(",") + "," + last + ")";
      color2["#"] = "#" + first + second + third;
    } catch (error) {
    }
    return color2;
  }
}
var wImage_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$p = "w-image";
const _sfc_main$T = {
  name: NAME$p,
  setting: {
    name: "\u56FE\u7247",
    type: NAME$p,
    uuid: -1,
    width: 300,
    height: 300,
    left: 0,
    top: 0,
    zoom: 1,
    transform: "",
    radius: 0,
    opacity: 1,
    parent: "-1",
    imgUrl: "",
    mask: "",
    setting: [],
    record: {
      width: 0,
      height: 0,
      minWidth: 10,
      minHeight: 10,
      dir: "all"
    }
  },
  props: ["params", "parent"],
  data() {
    return {
      position: "absolute",
      editBoxStyle: {
        transformOrigin: "center",
        transform: ""
      }
    };
  },
  computed: {
    ...mapGetters(["dActiveElement", "dWidgets", "dZoom", "dMouseXY", "dDropOverUuid", "dCropUuid"]),
    cropEdit() {
      return this.params.uuid === this.dCropUuid;
    },
    tZoom() {
      return this.params.zoom;
    },
    isMask() {
      return this.params.mask && this.dDropOverUuid === this.params.uuid;
    },
    isDraw() {
    }
  },
  watch: {
    cropEdit(val) {
      if (val) {
        document.getElementById(this.params.uuid).addEventListener("mousedown", this.touchstart, false);
      } else {
        document.getElementById(this.params.uuid).removeEventListener("mousedown", this.touchstart, false);
      }
      this.fixRotate();
      this.lockOthers();
    },
    async tZoom() {
      await this.$nextTick();
      this.updateRecord();
    }
  },
  updated() {
    this.updateRecord();
    this.$store.commit("updateRect");
  },
  async mounted() {
    this.updateRecord();
    await this.$nextTick();
    document.addEventListener("mouseup", this.touchend, false);
    this.$refs.widget.style.transform += this.params.rotate && (this.$refs.widget.style.transform += `rotate(${this.params.rotate})`);
  },
  beforeUnmount() {
    document.removeEventListener("mouseup", this.touchend, false);
  },
  methods: {
    ...mapActions(["updateWidgetData"]),
    touchstart(e2) {
      const editBox = this.$refs[this.params.uuid + "_ebox"];
      this.cropWidgetXY = {
        x: Number(editBox.style.left.replace("px", "")) || 0,
        y: Number(editBox.style.top.replace("px", "")) || 0
      };
      document.addEventListener("mousemove", this.handlemousemove, true);
    },
    touchend() {
      document.removeEventListener("mousemove", this.handlemousemove, true);
    },
    handlemousemove(e2) {
      if (!this.move(e2)) {
        return;
      }
      e2 && e2.stopPropagation();
      e2 && e2.preventDefault();
      const { left, top } = this.move(e2);
      this.holdPosition = { left, top };
      this.editBoxStyle.left = left + "px";
      this.editBoxStyle.top = top + "px";
      this.changeFinish(left / this.params.zoom, top / this.params.zoom);
    },
    changeFinish(x, y) {
      this.setTransform("translate", `${x}px, ${y}px`);
    },
    move(payload) {
      if (payload) {
        const widgetXY = { x: this.cropWidgetXY.x, y: this.cropWidgetXY.y };
        const dx = Number(payload.pageX) - this.dMouseXY.x;
        const dy = Number(payload.pageY) - this.dMouseXY.y;
        let left = Number(widgetXY.x) + Math.floor(dx * 100 / this.dZoom);
        let top = Number(widgetXY.y) + Math.floor(dy * 100 / this.dZoom);
        return { left, top };
      } else {
        return this.holdPosition;
      }
    },
    updateRecord() {
      if (this.dActiveElement.uuid === this.params.uuid) {
        let record = this.dActiveElement.record;
        record.width = this.$refs.widget.offsetWidth;
        record.height = this.$refs.widget.offsetHeight;
      }
      this.updateZoom();
      if (!this.isDraw) {
        new PointImg(this.$refs.target);
      }
    },
    setTransform(attrName, value) {
      const iof = this.params.transform.indexOf(attrName);
      let setValue = "";
      if (iof != -1) {
        const index2 = iof + attrName.length;
        const tf = this.params.transform;
        const FRONT = tf.slice(0, index2 + 1);
        const half = tf.substring(index2 + 1);
        const END = half.substring(half.indexOf(")"));
        setValue = FRONT + value + END;
      } else {
        setValue = this.params.transform + ` ${attrName}(${value})`;
      }
      this.updateWidgetData({
        uuid: this.params.uuid,
        key: "transform",
        value: setValue,
        pushHistory: false
      });
      this.params.transform && (this.$refs.target.style.transform = this.params.transform);
    },
    setEditBox(attrName, value) {
      const iof = this.editBoxStyle.transform.indexOf(attrName);
      let setValue = "";
      if (iof != -1) {
        const index2 = iof + attrName.length;
        const tf = this.editBoxStyle.transform;
        const FRONT = tf.slice(0, index2 + 1);
        const half = tf.substring(index2 + 1);
        const END = half.substring(half.indexOf(")"));
        setValue = FRONT + value + END;
      } else {
        setValue = this.editBoxStyle.transform + ` ${attrName}(${value})`;
      }
      this.editBoxStyle.transform = setValue;
    },
    updateZoom() {
      this.setEditBox("scale", this.params.zoom);
      this.setTransform("scale", this.params.zoom);
      this.handlemousemove();
    },
    fixRotate() {
      if (this.rotateTemp) {
        this.$refs.widget.style.transform = `rotate(${this.rotateTemp})`;
        this.params.flip = this.flipTemp;
        this.rotateTemp = null;
      } else {
        this.rotateTemp = this.params.rotate;
        this.$refs.widget.style.transform = `rotate(0deg)`;
        this.flipTemp = this.params.flip;
        this.params.flip = null;
      }
      this.$store.commit("setShowMoveable", false);
      setTimeout(() => {
        this.$store.commit("setShowMoveable", true);
      }, 100);
    },
    lockOthers() {
      if (this.locksTemp && this.locksTemp.length > 0) {
        for (let i = 0; i < this.locksTemp.length; i++) {
          this.dWidgets[i].lock = this.locksTemp[i];
        }
        this.locksTemp = [];
      } else {
        this.locksTemp = [];
        for (const widget of this.dWidgets) {
          this.locksTemp.push(widget.lock);
        }
        this.dWidgets.forEach((widget) => {
          widget.uuid != this.params.uuid && (widget.lock = true);
        });
      }
    }
  }
};
const _hoisted_1$P = ["id"];
const _hoisted_2$E = ["src"];
const _hoisted_3$A = ["src"];
const _hoisted_4$v = {
  key: 1,
  class: "drop__mask"
};
function _sfc_render$P(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    id: $props.params.uuid,
    ref: "widget",
    class: normalizeClass(["w-image", { "layer-lock": $props.params.lock }]),
    style: normalizeStyle({
      position: $data.position,
      left: $props.params.left - $props.parent.left + "px",
      top: $props.params.top - $props.parent.top + "px",
      width: $props.params.width + "px",
      height: $props.params.height + "px",
      opacity: $props.params.opacity
    })
  }, [
    $options.cropEdit ? (openBlock(), createElementBlock("div", {
      key: 0,
      ref: $props.params.uuid + "_ebox",
      style: normalizeStyle($data.editBoxStyle),
      class: "svg__edit__wrap"
    }, [
      createElementVNode("img", {
        class: "edit__model",
        src: $props.params.imgUrl
      }, null, 8, _hoisted_2$E)
    ], 4)) : createCommentVNode("", true),
    createElementVNode("div", {
      style: normalizeStyle({ transform: $props.params.flip ? `rotate${$props.params.flip}(180deg)` : void 0, borderRadius: $props.params.radius + "px", "-webkit-mask-image": `${$props.params.mask ? `url('${$props.params.mask}')` : void 0}` }),
      class: normalizeClass(["img__box", { mask: $props.params.mask }])
    }, [
      $props.params.isNinePatch ? (openBlock(), createElementBlock("div", {
        key: 0,
        ref: "target",
        class: "target",
        style: normalizeStyle({ border: `${$props.params.height * $props.params.sliceData.ratio / 2}px solid transparent`, borderImage: `url('${$props.params.imgUrl}') ${$props.params.sliceData.left} round` })
      }, null, 4)) : (openBlock(), createElementBlock("img", {
        key: 1,
        ref: "target",
        class: "target",
        style: { "transform-origin": "center" },
        src: $props.params.imgUrl
      }, null, 8, _hoisted_3$A))
    ], 6),
    $options.isMask ? (openBlock(), createElementBlock("div", _hoisted_4$v, [
      createElementVNode("div", {
        putIn: "true",
        style: normalizeStyle({ fontSize: $props.params.width / 12 + "px" }),
        class: "drop__btn"
      }, "\u62D6\u5165", 4)
    ])) : createCommentVNode("", true)
  ], 14, _hoisted_1$P);
}
var wImage = /* @__PURE__ */ _export_sfc(_sfc_main$T, [["render", _sfc_render$P], ["__scopeId", "data-v-5736d8e5"]]);
var __glob_0_27 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": wImage
}, Symbol.toStringTag, { value: "Module" }));
var wSvg_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$o = "w-svg";
const _sfc_main$S = {
  name: NAME$o,
  setting: {
    name: "\u77E2\u91CF\u56FE\u5F62",
    type: NAME$o,
    uuid: -1,
    width: 100,
    height: 100,
    colors: [],
    left: 0,
    top: 0,
    transform: "",
    radius: 0,
    opacity: 1,
    parent: "-1",
    svgUrl: "",
    setting: [],
    record: {
      width: 0,
      height: 0,
      minWidth: 10,
      minHeight: 10
    }
  },
  props: ["params", "parent"],
  data() {
    return {
      position: "absolute",
      editBoxStyle: {
        transformOrigin: "center"
      },
      editBoxs: {},
      editingKey: "",
      cropWidgetXY: {},
      attrRecord: {}
    };
  },
  computed: {
    ...mapGetters(["dActiveElement", "dZoom", "dMouseXY"]),
    tZoom() {
      return this.params.zoom;
    },
    cropEdit() {
      return this.params.cropEdit;
    },
    imgChange() {
      return this.params.imgUrl;
    }
  },
  watch: {
    params: {
      async handler(nval) {
        this.attrsChange();
      },
      immediate: true,
      deep: true
    },
    async tZoom() {
      await this.$nextTick();
      this.updateRecord();
    },
    imgChange() {
      this.svgImg.attr({
        "xlink:href": this.params.imgUrl
      });
    },
    cropEdit(val) {
      if (val) {
        document.getElementById(this.params.uuid).addEventListener("mousedown", this.touchstart, false);
      } else {
        document.getElementById(this.params.uuid).removeEventListener("mousedown", this.touchstart, false);
      }
    }
  },
  updated() {
    this.updateRecord();
    this.$store.commit("updateRect");
  },
  async mounted() {
    await this.$nextTick();
    await this.loadSvg();
    this.updateRecord();
    document.addEventListener("mouseup", this.touchend, false);
    this.params.transform && (this.$refs.widget.style.transform = this.params.transform);
    this.params.rotate && (this.$refs.widget.style.transform += `rotate(${this.params.rotate})`);
  },
  beforeUnmount() {
    document.removeEventListener("mouseup", this.touchend, false);
  },
  methods: {
    ...mapActions(["updateWidgetData"]),
    touchstart(e2) {
      const editBox = this.$refs[this.params.uuid + "_ebox"];
      this.cropWidgetXY = {
        x: Number(editBox.style.left.replace("px", "")) || 0,
        y: Number(editBox.style.top.replace("px", "")) || 0
      };
      document.addEventListener("mousemove", this.handlemousemove, true);
    },
    touchend() {
      document.removeEventListener("mousemove", this.handlemousemove, true);
    },
    handlemousemove(e2) {
      e2.stopPropagation();
      e2.preventDefault();
      const { left, top } = this.move(e2);
      this.editBoxStyle.left = left + "px";
      this.editBoxStyle.top = top + "px";
      const { width, height } = this.params;
      const { width: vWidth, height: vHeight } = this.viewBox;
      const params = {
        x: left / (width / vWidth) / this.params.zoom,
        y: top / (height / vHeight) / this.params.zoom
      };
      this.changeFinish("x", params.x);
      this.changeFinish("y", params.y);
    },
    loadSvg() {
      const _this = this;
      const Snap = window.Snap;
      return new Promise((resolve) => {
        Snap.load(
          this.params.svgUrl,
          function(svg) {
            let svg2 = Snap(svg.node);
            let items = svg2.node.childNodes;
            svg2.node.removeAttribute("width");
            svg2.node.removeAttribute("height");
            svg2.node.setAttribute("style", "height: inherit;width: inherit;");
            _this.svgElements = [];
            const colorsObj = _this.color2obj();
            deepElement(items);
            function deepElement(els) {
              if (els.item) {
                els.forEach((element) => {
                  elementFactory(element);
                  if (element.childNodes.length > 0) {
                    element.childNodes.forEach((element2) => {
                      deepElement(element2);
                    });
                  }
                });
              } else {
                elementFactory(els);
              }
            }
            function elementFactory(element) {
              const attrsColor = {};
              try {
                element.attributes.forEach((attr) => {
                  if (colorsObj[attr.value]) {
                    attr.value = colorsObj[attr.value];
                    attrsColor[attr.name] = _this.params.colors.findIndex((x) => x == attr.value);
                  }
                });
              } catch (e2) {
              }
              if (JSON.stringify(attrsColor) !== "{}") {
                _this.svgElements.push({
                  item: element,
                  attrsColor
                });
              }
            }
            const el = this || _this.$refs.widget;
            el.appendChild(svg.node);
            resolve();
          },
          document.getElementById(this.params.uuid)
        );
      });
    },
    color2obj() {
      const obj = {};
      for (let i = 0; i < this.params.colors.length; i++) {
        obj[`{{colors[${i}]}}`] = this.params.colors[i];
      }
      return obj;
    },
    updateRecord() {
      if (this.dActiveElement.uuid === this.params.uuid) {
        let record = this.dActiveElement.record;
        record.width = this.$refs.widget.offsetWidth;
        record.height = this.$refs.widget.offsetHeight;
      }
      this.updateZoom();
    },
    updateZoom() {
      this.editBoxStyle.transform = `scale(${this.params.zoom})`;
      if (this.svgImg) {
        const { x, y } = this.params;
        this.svgImg.attr({
          x: x || 0,
          y: y || 0,
          style: `transform-origin: center;transform: scale(${this.params.zoom})`
        });
        const { width, height } = this.params;
        const { width: vWidth, height: vHeight } = this.viewBox;
        const params = {
          left: x * (width / vWidth) * this.params.zoom,
          top: y * (height / vHeight) * this.params.zoom
        };
        this.editBoxStyle.left = params.left + "px";
        this.editBoxStyle.top = params.top + "px";
      }
    },
    changeFinish(key, value) {
      this.updateWidgetData({
        uuid: this.params.uuid,
        key,
        value,
        pushHistory: true
      });
    },
    move(payload) {
      const widgetXY = { x: this.cropWidgetXY.x, y: this.cropWidgetXY.y };
      const dx = Number(payload.pageX) - this.dMouseXY.x;
      const dy = Number(payload.pageY) - this.dMouseXY.y;
      let left = Number(widgetXY.x) + Math.floor(dx * 100 / this.dZoom);
      let top = Number(widgetXY.y) + Math.floor(dy * 100 / this.dZoom);
      return { left, top };
    },
    attrsChange() {
      if (this.dActiveElement.uuid === this.params.uuid && this.svgElements) {
        for (const element of this.svgElements) {
          const { item, attrsColor } = element;
          for (const key in attrsColor) {
            if (Object.hasOwnProperty.call(attrsColor, key)) {
              const color2 = this.params.colors[attrsColor[key]];
              item.setAttribute(key, color2);
            }
          }
        }
      }
    }
  }
};
const _hoisted_1$O = ["id"];
function _sfc_render$O(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    id: $props.params.uuid,
    ref: "widget",
    class: "w-svg",
    style: normalizeStyle({
      position: $data.position,
      left: $props.params.left - $props.parent.left + "px",
      top: $props.params.top - $props.parent.top + "px",
      width: $props.params.width + "px",
      height: $props.params.height + "px",
      opacity: $props.params.opacity
    })
  }, null, 12, _hoisted_1$O);
}
var wSvg = /* @__PURE__ */ _export_sfc(_sfc_main$S, [["render", _sfc_render$O], ["__scopeId", "data-v-29e26ff8"]]);
var __glob_0_31 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": wSvg
}, Symbol.toStringTag, { value: "Module" }));
async function setWidgetData(type, item, data) {
  let setting = data;
  if (type === "text") {
    !item.fontFamily && !item.color ? setting = JSON.parse(JSON.stringify(wText.setting)) : setting = item;
    !setting.text ? setting.text = "\u53CC\u51FB\u7F16\u8F91\u6587\u5B57" : setting.text = decodeURIComponent(setting.text);
    setting.fontSize = item.fontSize;
    setting.width = item.width || item.fontSize * setting.text.length;
    setting.fontWeight = item.fontWeight;
  }
  if (type === "image" || type === "mask") {
    setting = JSON.parse(JSON.stringify(wImage.setting));
    const img = await setItem2Data(item.value);
    setting.width = img.width;
    setting.height = img.height;
    setting.imgUrl = item.value.url;
  }
  if (type === "mask") {
    setting.mask = item.value.url;
  }
  if (type === "svg") {
    setting = JSON.parse(JSON.stringify(wSvg.setting));
    const img = await setItem2Data(item.value);
    setting.width = img.width;
    setting.height = img.height;
    setting.svgUrl = item.value.url;
    const models = JSON.parse(item.value.model);
    for (const key in models) {
      if (Object.hasOwnProperty.call(models, key)) {
        setting[key] = models[key];
      }
    }
  }
  return setting;
}
async function setCompData(item) {
  const group = typeof item === "string" ? JSON.parse(item) : JSON.parse(JSON.stringify(item));
  let parent = {};
  Array.isArray(group) && group.forEach((element) => {
    element.type === "w-group" && (parent = element);
  });
  const { width: screenWidth, height: screenHeight } = erpStore.getters.dPage;
  const { width: imgWidth, height: imgHeight } = parent;
  let ratio = 1;
  if (imgWidth > screenWidth || imgHeight > screenHeight) {
    ratio = Math.min(screenWidth / imgWidth, screenHeight / imgHeight);
  }
  if (ratio < 1) {
    ratio *= erpStore.getters.dZoom / 100;
    group.forEach((element) => {
      element.fontSize && (element.fontSize *= ratio);
      element.width *= ratio;
      element.height *= ratio;
      element.left *= ratio;
      element.top *= ratio;
    });
  }
  return group;
}
function throttle$2(delay, noTrailing, callback, debounceMode) {
  var timeoutID;
  var cancelled = false;
  var lastExec = 0;
  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  }
  function cancel() {
    clearExistingTimeout();
    cancelled = true;
  }
  if (typeof noTrailing !== "boolean") {
    debounceMode = callback;
    callback = noTrailing;
    noTrailing = void 0;
  }
  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }
    var self2 = this;
    var elapsed = Date.now() - lastExec;
    if (cancelled) {
      return;
    }
    function exec() {
      lastExec = Date.now();
      callback.apply(self2, arguments_);
    }
    function clear() {
      timeoutID = void 0;
    }
    if (debounceMode && !timeoutID) {
      exec();
    }
    clearExistingTimeout();
    if (debounceMode === void 0 && elapsed > delay) {
      exec();
    } else if (noTrailing !== true) {
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
    }
  }
  wrapper.cancel = cancel;
  return wrapper;
}
function debounce$1(delay, atBegin, callback) {
  return callback === void 0 ? throttle$2(delay, atBegin, false) : throttle$2(delay, callback, atBegin !== false);
}
function setTransformAttribute(target, attr, value = 0) {
  const tf = target == null ? void 0 : target.style.transform;
  if (!tf) {
    return;
  }
  const iof = tf.indexOf(attr);
  const FRONT = tf.slice(0, iof + attr.length + 1);
  const half = tf.substring(iof + attr.length + 1);
  const END = half.substring(half.indexOf(")"));
  target.style.transform = FRONT + value + END;
}
var wGroup_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$n = "w-group";
const _sfc_main$R = {
  name: NAME$n,
  setting: {
    name: "\u7EC4\u5408",
    type: NAME$n,
    uuid: -1,
    width: 0,
    height: 0,
    left: 0,
    top: 0,
    transform: "",
    opacity: 1,
    parent: "-1",
    isContainer: true,
    record: {
      width: 0,
      height: 0,
      minWidth: 0,
      minHeight: 0,
      dir: "none"
    }
  },
  props: ["params", "parent"],
  data() {
    return {
      timer: null
    };
  },
  computed: {
    ...mapGetters(["dActiveElement", "dWidgets"])
  },
  updated() {
    this.updateRecord();
  },
  async mounted() {
    await this.$nextTick();
    this.touchstart();
    this.updateRecord();
    document.addEventListener("mousedown", this.touchstart, false);
    document.addEventListener("mouseup", this.touchend, false);
    this.params.rotate && (this.$refs.widget.style.transform += `rotate(${this.params.rotate})`);
  },
  beforeUnmount() {
    document.removeEventListener("mousedown", this.touchstart, false);
    document.removeEventListener("mouseup", this.touchend, false);
  },
  methods: {
    ...mapActions(["updateWidgetData"]),
    updateRecord(tempScale) {
      if (this.dActiveElement.uuid === this.params.uuid) {
        let record = this.dActiveElement.record;
        if (record.width <= 0) {
          this.touchend();
        }
        this.ratio = tempScale || this.params.width / record.width;
        if (this.ratio != 1) {
          this.temp = {};
          if (record.width != 0) {
            for (let i = this.dWidgets.length - 1; i >= 0; --i) {
              if (this.dWidgets[i].parent === this.params.uuid) {
                this.temp[this.dWidgets[i].uuid] = { width: this.dWidgets[i].width * this.ratio, height: this.dWidgets[i].height * this.ratio, raw: this.dWidgets[i] };
              }
            }
          }
          this.$refs.widget.style.transformOrigin = "left top";
          setTransformAttribute(this.$refs.widget, "scale", this.ratio);
        }
      }
    },
    touchstart() {
      var _a2;
      if (this.dActiveElement.uuid !== this.params.uuid) {
        return;
      }
      this.tempRecord = {
        width: this.params.width,
        height: this.params.height
      };
      this.compWidgetsRecord = {};
      for (let i = this.dWidgets.length - 1; i >= 0; --i) {
        if (this.dWidgets[i].parent === this.params.uuid) {
          this.compWidgetsRecord[this.dWidgets[i].uuid] = {
            left: Number(document.getElementById(this.dWidgets[i].uuid).style.left.replace("px", "")),
            top: Number(document.getElementById(this.dWidgets[i].uuid).style.top.replace("px", "")),
            fontSize: Number((_a2 = document.getElementById(this.dWidgets[i].uuid).style.fontSize) == null ? void 0 : _a2.replace("px", ""))
          };
        }
      }
    },
    touchend() {
      if (this.dActiveElement.uuid !== this.params.uuid) {
        return;
      }
      setTimeout(() => {
        var _a2, _b, _c, _d;
        if (!this.temp) {
          return;
        }
        this.$refs.widget.style.opacity = 0;
        setTransformAttribute(this.$refs.widget, "scale", 1);
        setTimeout(() => {
          this.$refs.widget.style.opacity = this.params.opacity;
        }, 100);
        for (const key in this.temp) {
          if (Object.hasOwnProperty.call(this.temp, key)) {
            this.keyChange(key, "width", this.temp[key].width);
            this.keyChange(key, "height", this.temp[key].height);
            this.keySetValue(key, "left", this.compWidgetsRecord[key].left * this.ratio);
            this.keySetValue(key, "top", this.compWidgetsRecord[key].top * this.ratio);
            if (this.temp[key].raw.type === "w-text") {
              this.keyChange(key, "fontSize", this.compWidgetsRecord[key].fontSize * this.ratio);
            }
          }
        }
        this.temp = null;
        if (this.dActiveElement.uuid === this.params.uuid) {
          let record = this.dActiveElement.record;
          record.width = (_a2 = this.$refs.widget) == null ? void 0 : _a2.offsetWidth;
          record.height = (_b = this.$refs.widget) == null ? void 0 : _b.offsetHeight;
          this.dActiveElement.width = (_c = this.$refs.widget) == null ? void 0 : _c.offsetWidth;
          this.dActiveElement.height = (_d = this.$refs.widget) == null ? void 0 : _d.offsetHeight;
        }
      }, 10);
    },
    keyChange(uuid, key, value) {
      this.updateWidgetData({
        uuid,
        key,
        value,
        pushHistory: false
      });
    },
    keySetValue(uuid, key, value) {
      setTimeout(() => {
        const widget = this.dWidgets.find((item) => item.uuid === uuid);
        widget[key] = value + Number(this.params[key]);
      }, 10);
    }
  }
};
function _sfc_render$N(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "widget",
    class: normalizeClass(["w-group", { "layer-lock": $props.params.lock }]),
    style: normalizeStyle({
      position: "absolute",
      left: $props.params.left - $props.parent.left + "px",
      top: $props.params.top - $props.parent.top + "px",
      width: $props.params.width + "px",
      height: $props.params.height + "px",
      opacity: $props.params.opacity
    })
  }, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ], 6);
}
var wGroup = /* @__PURE__ */ _export_sfc(_sfc_main$R, [["render", _sfc_render$N], ["__scopeId", "data-v-677b28f1"]]);
var __glob_0_25 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": wGroup
}, Symbol.toStringTag, { value: "Module" }));
var qrCodeStyling = { exports: {} };
(function(module, exports) {
  !function(t, e2) {
    module.exports = e2();
  }(self, function() {
    return (() => {
      var t = { 192: (t2, e3) => {
        var r2, n, o = function() {
          var t3 = function(t4, e5) {
            var r4 = t4, n3 = a2[e5], o3 = null, i2 = 0, u3 = null, v2 = [], w2 = {}, m = function(t5, e6) {
              o3 = function(t6) {
                for (var e7 = new Array(t6), r5 = 0; r5 < t6; r5 += 1) {
                  e7[r5] = new Array(t6);
                  for (var n4 = 0; n4 < t6; n4 += 1)
                    e7[r5][n4] = null;
                }
                return e7;
              }(i2 = 4 * r4 + 17), b(0, 0), b(i2 - 7, 0), b(0, i2 - 7), x(), _(), M(t5, e6), r4 >= 7 && S(t5), null == u3 && (u3 = A2(r4, n3, v2)), C(u3, e6);
            }, b = function(t5, e6) {
              for (var r5 = -1; r5 <= 7; r5 += 1)
                if (!(t5 + r5 <= -1 || i2 <= t5 + r5))
                  for (var n4 = -1; n4 <= 7; n4 += 1)
                    e6 + n4 <= -1 || i2 <= e6 + n4 || (o3[t5 + r5][e6 + n4] = 0 <= r5 && r5 <= 6 && (0 == n4 || 6 == n4) || 0 <= n4 && n4 <= 6 && (0 == r5 || 6 == r5) || 2 <= r5 && r5 <= 4 && 2 <= n4 && n4 <= 4);
            }, _ = function() {
              for (var t5 = 8; t5 < i2 - 8; t5 += 1)
                null == o3[t5][6] && (o3[t5][6] = t5 % 2 == 0);
              for (var e6 = 8; e6 < i2 - 8; e6 += 1)
                null == o3[6][e6] && (o3[6][e6] = e6 % 2 == 0);
            }, x = function() {
              for (var t5 = s.getPatternPosition(r4), e6 = 0; e6 < t5.length; e6 += 1)
                for (var n4 = 0; n4 < t5.length; n4 += 1) {
                  var i3 = t5[e6], a3 = t5[n4];
                  if (null == o3[i3][a3])
                    for (var u4 = -2; u4 <= 2; u4 += 1)
                      for (var h3 = -2; h3 <= 2; h3 += 1)
                        o3[i3 + u4][a3 + h3] = -2 == u4 || 2 == u4 || -2 == h3 || 2 == h3 || 0 == u4 && 0 == h3;
                }
            }, S = function(t5) {
              for (var e6 = s.getBCHTypeNumber(r4), n4 = 0; n4 < 18; n4 += 1) {
                var a3 = !t5 && 1 == (e6 >> n4 & 1);
                o3[Math.floor(n4 / 3)][n4 % 3 + i2 - 8 - 3] = a3;
              }
              for (n4 = 0; n4 < 18; n4 += 1)
                a3 = !t5 && 1 == (e6 >> n4 & 1), o3[n4 % 3 + i2 - 8 - 3][Math.floor(n4 / 3)] = a3;
            }, M = function(t5, e6) {
              for (var r5 = n3 << 3 | e6, a3 = s.getBCHTypeInfo(r5), u4 = 0; u4 < 15; u4 += 1) {
                var h3 = !t5 && 1 == (a3 >> u4 & 1);
                u4 < 6 ? o3[u4][8] = h3 : u4 < 8 ? o3[u4 + 1][8] = h3 : o3[i2 - 15 + u4][8] = h3;
              }
              for (u4 = 0; u4 < 15; u4 += 1)
                h3 = !t5 && 1 == (a3 >> u4 & 1), u4 < 8 ? o3[8][i2 - u4 - 1] = h3 : u4 < 9 ? o3[8][15 - u4 - 1 + 1] = h3 : o3[8][15 - u4 - 1] = h3;
              o3[i2 - 8][8] = !t5;
            }, C = function(t5, e6) {
              for (var r5 = -1, n4 = i2 - 1, a3 = 7, u4 = 0, h3 = s.getMaskFunction(e6), c2 = i2 - 1; c2 > 0; c2 -= 2)
                for (6 == c2 && (c2 -= 1); ; ) {
                  for (var l2 = 0; l2 < 2; l2 += 1)
                    if (null == o3[n4][c2 - l2]) {
                      var d2 = false;
                      u4 < t5.length && (d2 = 1 == (t5[u4] >>> a3 & 1)), h3(n4, c2 - l2) && (d2 = !d2), o3[n4][c2 - l2] = d2, -1 == (a3 -= 1) && (u4 += 1, a3 = 7);
                    }
                  if ((n4 += r5) < 0 || i2 <= n4) {
                    n4 -= r5, r5 = -r5;
                    break;
                  }
                }
            }, A2 = function(t5, e6, r5) {
              for (var n4 = c.getRSBlocks(t5, e6), o4 = l(), i3 = 0; i3 < r5.length; i3 += 1) {
                var a3 = r5[i3];
                o4.put(a3.getMode(), 4), o4.put(a3.getLength(), s.getLengthInBits(a3.getMode(), t5)), a3.write(o4);
              }
              var u4 = 0;
              for (i3 = 0; i3 < n4.length; i3 += 1)
                u4 += n4[i3].dataCount;
              if (o4.getLengthInBits() > 8 * u4)
                throw "code length overflow. (" + o4.getLengthInBits() + ">" + 8 * u4 + ")";
              for (o4.getLengthInBits() + 4 <= 8 * u4 && o4.put(0, 4); o4.getLengthInBits() % 8 != 0; )
                o4.putBit(false);
              for (; !(o4.getLengthInBits() >= 8 * u4 || (o4.put(236, 8), o4.getLengthInBits() >= 8 * u4)); )
                o4.put(17, 8);
              return function(t6, e7) {
                for (var r6 = 0, n5 = 0, o5 = 0, i4 = new Array(e7.length), a4 = new Array(e7.length), u5 = 0; u5 < e7.length; u5 += 1) {
                  var c2 = e7[u5].dataCount, l2 = e7[u5].totalCount - c2;
                  n5 = Math.max(n5, c2), o5 = Math.max(o5, l2), i4[u5] = new Array(c2);
                  for (var d2 = 0; d2 < i4[u5].length; d2 += 1)
                    i4[u5][d2] = 255 & t6.getBuffer()[d2 + r6];
                  r6 += c2;
                  var f3 = s.getErrorCorrectPolynomial(l2), g2 = h2(i4[u5], f3.getLength() - 1).mod(f3);
                  for (a4[u5] = new Array(f3.getLength() - 1), d2 = 0; d2 < a4[u5].length; d2 += 1) {
                    var p2 = d2 + g2.getLength() - a4[u5].length;
                    a4[u5][d2] = p2 >= 0 ? g2.getAt(p2) : 0;
                  }
                }
                var v3 = 0;
                for (d2 = 0; d2 < e7.length; d2 += 1)
                  v3 += e7[d2].totalCount;
                var w3 = new Array(v3), y2 = 0;
                for (d2 = 0; d2 < n5; d2 += 1)
                  for (u5 = 0; u5 < e7.length; u5 += 1)
                    d2 < i4[u5].length && (w3[y2] = i4[u5][d2], y2 += 1);
                for (d2 = 0; d2 < o5; d2 += 1)
                  for (u5 = 0; u5 < e7.length; u5 += 1)
                    d2 < a4[u5].length && (w3[y2] = a4[u5][d2], y2 += 1);
                return w3;
              }(o4, n4);
            };
            w2.addData = function(t5, e6) {
              var r5 = null;
              switch (e6 = e6 || "Byte") {
                case "Numeric":
                  r5 = d(t5);
                  break;
                case "Alphanumeric":
                  r5 = f2(t5);
                  break;
                case "Byte":
                  r5 = g(t5);
                  break;
                case "Kanji":
                  r5 = p(t5);
                  break;
                default:
                  throw "mode:" + e6;
              }
              v2.push(r5), u3 = null;
            }, w2.isDark = function(t5, e6) {
              if (t5 < 0 || i2 <= t5 || e6 < 0 || i2 <= e6)
                throw t5 + "," + e6;
              return o3[t5][e6];
            }, w2.getModuleCount = function() {
              return i2;
            }, w2.make = function() {
              if (r4 < 1) {
                for (var t5 = 1; t5 < 40; t5++) {
                  for (var e6 = c.getRSBlocks(t5, n3), o4 = l(), i3 = 0; i3 < v2.length; i3++) {
                    var a3 = v2[i3];
                    o4.put(a3.getMode(), 4), o4.put(a3.getLength(), s.getLengthInBits(a3.getMode(), t5)), a3.write(o4);
                  }
                  var u4 = 0;
                  for (i3 = 0; i3 < e6.length; i3++)
                    u4 += e6[i3].dataCount;
                  if (o4.getLengthInBits() <= 8 * u4)
                    break;
                }
                r4 = t5;
              }
              m(false, function() {
                for (var t6 = 0, e7 = 0, r5 = 0; r5 < 8; r5 += 1) {
                  m(true, r5);
                  var n4 = s.getLostPoint(w2);
                  (0 == r5 || t6 > n4) && (t6 = n4, e7 = r5);
                }
                return e7;
              }());
            }, w2.createTableTag = function(t5, e6) {
              t5 = t5 || 2;
              var r5 = "";
              r5 += '<table style="', r5 += " border-width: 0px; border-style: none;", r5 += " border-collapse: collapse;", r5 += " padding: 0px; margin: " + (e6 = void 0 === e6 ? 4 * t5 : e6) + "px;", r5 += '">', r5 += "<tbody>";
              for (var n4 = 0; n4 < w2.getModuleCount(); n4 += 1) {
                r5 += "<tr>";
                for (var o4 = 0; o4 < w2.getModuleCount(); o4 += 1)
                  r5 += '<td style="', r5 += " border-width: 0px; border-style: none;", r5 += " border-collapse: collapse;", r5 += " padding: 0px; margin: 0px;", r5 += " width: " + t5 + "px;", r5 += " height: " + t5 + "px;", r5 += " background-color: ", r5 += w2.isDark(n4, o4) ? "#000000" : "#ffffff", r5 += ";", r5 += '"/>';
                r5 += "</tr>";
              }
              return (r5 += "</tbody>") + "</table>";
            }, w2.createSvgTag = function(t5, e6, r5, n4) {
              var o4 = {};
              "object" == typeof arguments[0] && (t5 = (o4 = arguments[0]).cellSize, e6 = o4.margin, r5 = o4.alt, n4 = o4.title), t5 = t5 || 2, e6 = void 0 === e6 ? 4 * t5 : e6, (r5 = "string" == typeof r5 ? { text: r5 } : r5 || {}).text = r5.text || null, r5.id = r5.text ? r5.id || "qrcode-description" : null, (n4 = "string" == typeof n4 ? { text: n4 } : n4 || {}).text = n4.text || null, n4.id = n4.text ? n4.id || "qrcode-title" : null;
              var i3, a3, s2, u4, h3 = w2.getModuleCount() * t5 + 2 * e6, c2 = "";
              for (u4 = "l" + t5 + ",0 0," + t5 + " -" + t5 + ",0 0,-" + t5 + "z ", c2 += '<svg version="1.1" xmlns="http://www.w3.org/2000/svg"', c2 += o4.scalable ? "" : ' width="' + h3 + 'px" height="' + h3 + 'px"', c2 += ' viewBox="0 0 ' + h3 + " " + h3 + '" ', c2 += ' preserveAspectRatio="xMinYMin meet"', c2 += n4.text || r5.text ? ' role="img" aria-labelledby="' + k([n4.id, r5.id].join(" ").trim()) + '"' : "", c2 += ">", c2 += n4.text ? '<title id="' + k(n4.id) + '">' + k(n4.text) + "</title>" : "", c2 += r5.text ? '<description id="' + k(r5.id) + '">' + k(r5.text) + "</description>" : "", c2 += '<rect width="100%" height="100%" fill="white" cx="0" cy="0"/>', c2 += '<path d="', a3 = 0; a3 < w2.getModuleCount(); a3 += 1)
                for (s2 = a3 * t5 + e6, i3 = 0; i3 < w2.getModuleCount(); i3 += 1)
                  w2.isDark(a3, i3) && (c2 += "M" + (i3 * t5 + e6) + "," + s2 + u4);
              return (c2 += '" stroke="transparent" fill="black"/>') + "</svg>";
            }, w2.createDataURL = function(t5, e6) {
              t5 = t5 || 2, e6 = void 0 === e6 ? 4 * t5 : e6;
              var r5 = w2.getModuleCount() * t5 + 2 * e6, n4 = e6, o4 = r5 - e6;
              return y(r5, r5, function(e7, r6) {
                if (n4 <= e7 && e7 < o4 && n4 <= r6 && r6 < o4) {
                  var i3 = Math.floor((e7 - n4) / t5), a3 = Math.floor((r6 - n4) / t5);
                  return w2.isDark(a3, i3) ? 0 : 1;
                }
                return 1;
              });
            }, w2.createImgTag = function(t5, e6, r5) {
              t5 = t5 || 2, e6 = void 0 === e6 ? 4 * t5 : e6;
              var n4 = w2.getModuleCount() * t5 + 2 * e6, o4 = "";
              return o4 += "<img", o4 += ' src="', o4 += w2.createDataURL(t5, e6), o4 += '"', o4 += ' width="', o4 += n4, o4 += '"', o4 += ' height="', o4 += n4, o4 += '"', r5 && (o4 += ' alt="', o4 += k(r5), o4 += '"'), o4 + "/>";
            };
            var k = function(t5) {
              for (var e6 = "", r5 = 0; r5 < t5.length; r5 += 1) {
                var n4 = t5.charAt(r5);
                switch (n4) {
                  case "<":
                    e6 += "&lt;";
                    break;
                  case ">":
                    e6 += "&gt;";
                    break;
                  case "&":
                    e6 += "&amp;";
                    break;
                  case '"':
                    e6 += "&quot;";
                    break;
                  default:
                    e6 += n4;
                }
              }
              return e6;
            };
            return w2.createASCII = function(t5, e6) {
              if ((t5 = t5 || 1) < 2)
                return function(t6) {
                  t6 = void 0 === t6 ? 2 : t6;
                  var e7, r6, n5, o5, i4, a4 = 1 * w2.getModuleCount() + 2 * t6, s3 = t6, u5 = a4 - t6, h4 = { "\u2588\u2588": "\u2588", "\u2588 ": "\u2580", " \u2588": "\u2584", "  ": " " }, c3 = { "\u2588\u2588": "\u2580", "\u2588 ": "\u2580", " \u2588": " ", "  ": " " }, l3 = "";
                  for (e7 = 0; e7 < a4; e7 += 2) {
                    for (n5 = Math.floor((e7 - s3) / 1), o5 = Math.floor((e7 + 1 - s3) / 1), r6 = 0; r6 < a4; r6 += 1)
                      i4 = "\u2588", s3 <= r6 && r6 < u5 && s3 <= e7 && e7 < u5 && w2.isDark(n5, Math.floor((r6 - s3) / 1)) && (i4 = " "), s3 <= r6 && r6 < u5 && s3 <= e7 + 1 && e7 + 1 < u5 && w2.isDark(o5, Math.floor((r6 - s3) / 1)) ? i4 += " " : i4 += "\u2588", l3 += t6 < 1 && e7 + 1 >= u5 ? c3[i4] : h4[i4];
                    l3 += "\n";
                  }
                  return a4 % 2 && t6 > 0 ? l3.substring(0, l3.length - a4 - 1) + Array(a4 + 1).join("\u2580") : l3.substring(0, l3.length - 1);
                }(e6);
              t5 -= 1, e6 = void 0 === e6 ? 2 * t5 : e6;
              var r5, n4, o4, i3, a3 = w2.getModuleCount() * t5 + 2 * e6, s2 = e6, u4 = a3 - e6, h3 = Array(t5 + 1).join("\u2588\u2588"), c2 = Array(t5 + 1).join("  "), l2 = "", d2 = "";
              for (r5 = 0; r5 < a3; r5 += 1) {
                for (o4 = Math.floor((r5 - s2) / t5), d2 = "", n4 = 0; n4 < a3; n4 += 1)
                  i3 = 1, s2 <= n4 && n4 < u4 && s2 <= r5 && r5 < u4 && w2.isDark(o4, Math.floor((n4 - s2) / t5)) && (i3 = 0), d2 += i3 ? h3 : c2;
                for (o4 = 0; o4 < t5; o4 += 1)
                  l2 += d2 + "\n";
              }
              return l2.substring(0, l2.length - 1);
            }, w2.renderTo2dContext = function(t5, e6) {
              e6 = e6 || 2;
              for (var r5 = w2.getModuleCount(), n4 = 0; n4 < r5; n4++)
                for (var o4 = 0; o4 < r5; o4++)
                  t5.fillStyle = w2.isDark(n4, o4) ? "black" : "white", t5.fillRect(n4 * e6, o4 * e6, e6, e6);
            }, w2;
          };
          t3.stringToBytes = (t3.stringToBytesFuncs = { default: function(t4) {
            for (var e5 = [], r4 = 0; r4 < t4.length; r4 += 1) {
              var n3 = t4.charCodeAt(r4);
              e5.push(255 & n3);
            }
            return e5;
          } }).default, t3.createStringToBytes = function(t4, e5) {
            var r4 = function() {
              for (var r5 = w(t4), n4 = function() {
                var t5 = r5.read();
                if (-1 == t5)
                  throw "eof";
                return t5;
              }, o3 = 0, i2 = {}; ; ) {
                var a3 = r5.read();
                if (-1 == a3)
                  break;
                var s2 = n4(), u3 = n4() << 8 | n4();
                i2[String.fromCharCode(a3 << 8 | s2)] = u3, o3 += 1;
              }
              if (o3 != e5)
                throw o3 + " != " + e5;
              return i2;
            }(), n3 = "?".charCodeAt(0);
            return function(t5) {
              for (var e6 = [], o3 = 0; o3 < t5.length; o3 += 1) {
                var i2 = t5.charCodeAt(o3);
                if (i2 < 128)
                  e6.push(i2);
                else {
                  var a3 = r4[t5.charAt(o3)];
                  "number" == typeof a3 ? (255 & a3) == a3 ? e6.push(a3) : (e6.push(a3 >>> 8), e6.push(255 & a3)) : e6.push(n3);
                }
              }
              return e6;
            };
          };
          var e4, r3, n2, o2, i, a2 = { L: 1, M: 0, Q: 3, H: 2 }, s = (e4 = [[], [6, 18], [6, 22], [6, 26], [6, 30], [6, 34], [6, 22, 38], [6, 24, 42], [6, 26, 46], [6, 28, 50], [6, 30, 54], [6, 32, 58], [6, 34, 62], [6, 26, 46, 66], [6, 26, 48, 70], [6, 26, 50, 74], [6, 30, 54, 78], [6, 30, 56, 82], [6, 30, 58, 86], [6, 34, 62, 90], [6, 28, 50, 72, 94], [6, 26, 50, 74, 98], [6, 30, 54, 78, 102], [6, 28, 54, 80, 106], [6, 32, 58, 84, 110], [6, 30, 58, 86, 114], [6, 34, 62, 90, 118], [6, 26, 50, 74, 98, 122], [6, 30, 54, 78, 102, 126], [6, 26, 52, 78, 104, 130], [6, 30, 56, 82, 108, 134], [6, 34, 60, 86, 112, 138], [6, 30, 58, 86, 114, 142], [6, 34, 62, 90, 118, 146], [6, 30, 54, 78, 102, 126, 150], [6, 24, 50, 76, 102, 128, 154], [6, 28, 54, 80, 106, 132, 158], [6, 32, 58, 84, 110, 136, 162], [6, 26, 54, 82, 110, 138, 166], [6, 30, 58, 86, 114, 142, 170]], r3 = 1335, n2 = 7973, i = function(t4) {
            for (var e5 = 0; 0 != t4; )
              e5 += 1, t4 >>>= 1;
            return e5;
          }, (o2 = {}).getBCHTypeInfo = function(t4) {
            for (var e5 = t4 << 10; i(e5) - i(r3) >= 0; )
              e5 ^= r3 << i(e5) - i(r3);
            return 21522 ^ (t4 << 10 | e5);
          }, o2.getBCHTypeNumber = function(t4) {
            for (var e5 = t4 << 12; i(e5) - i(n2) >= 0; )
              e5 ^= n2 << i(e5) - i(n2);
            return t4 << 12 | e5;
          }, o2.getPatternPosition = function(t4) {
            return e4[t4 - 1];
          }, o2.getMaskFunction = function(t4) {
            switch (t4) {
              case 0:
                return function(t5, e5) {
                  return (t5 + e5) % 2 == 0;
                };
              case 1:
                return function(t5, e5) {
                  return t5 % 2 == 0;
                };
              case 2:
                return function(t5, e5) {
                  return e5 % 3 == 0;
                };
              case 3:
                return function(t5, e5) {
                  return (t5 + e5) % 3 == 0;
                };
              case 4:
                return function(t5, e5) {
                  return (Math.floor(t5 / 2) + Math.floor(e5 / 3)) % 2 == 0;
                };
              case 5:
                return function(t5, e5) {
                  return t5 * e5 % 2 + t5 * e5 % 3 == 0;
                };
              case 6:
                return function(t5, e5) {
                  return (t5 * e5 % 2 + t5 * e5 % 3) % 2 == 0;
                };
              case 7:
                return function(t5, e5) {
                  return (t5 * e5 % 3 + (t5 + e5) % 2) % 2 == 0;
                };
              default:
                throw "bad maskPattern:" + t4;
            }
          }, o2.getErrorCorrectPolynomial = function(t4) {
            for (var e5 = h2([1], 0), r4 = 0; r4 < t4; r4 += 1)
              e5 = e5.multiply(h2([1, u2.gexp(r4)], 0));
            return e5;
          }, o2.getLengthInBits = function(t4, e5) {
            if (1 <= e5 && e5 < 10)
              switch (t4) {
                case 1:
                  return 10;
                case 2:
                  return 9;
                case 4:
                case 8:
                  return 8;
                default:
                  throw "mode:" + t4;
              }
            else if (e5 < 27)
              switch (t4) {
                case 1:
                  return 12;
                case 2:
                  return 11;
                case 4:
                  return 16;
                case 8:
                  return 10;
                default:
                  throw "mode:" + t4;
              }
            else {
              if (!(e5 < 41))
                throw "type:" + e5;
              switch (t4) {
                case 1:
                  return 14;
                case 2:
                  return 13;
                case 4:
                  return 16;
                case 8:
                  return 12;
                default:
                  throw "mode:" + t4;
              }
            }
          }, o2.getLostPoint = function(t4) {
            for (var e5 = t4.getModuleCount(), r4 = 0, n3 = 0; n3 < e5; n3 += 1)
              for (var o3 = 0; o3 < e5; o3 += 1) {
                for (var i2 = 0, a3 = t4.isDark(n3, o3), s2 = -1; s2 <= 1; s2 += 1)
                  if (!(n3 + s2 < 0 || e5 <= n3 + s2))
                    for (var u3 = -1; u3 <= 1; u3 += 1)
                      o3 + u3 < 0 || e5 <= o3 + u3 || 0 == s2 && 0 == u3 || a3 == t4.isDark(n3 + s2, o3 + u3) && (i2 += 1);
                i2 > 5 && (r4 += 3 + i2 - 5);
              }
            for (n3 = 0; n3 < e5 - 1; n3 += 1)
              for (o3 = 0; o3 < e5 - 1; o3 += 1) {
                var h3 = 0;
                t4.isDark(n3, o3) && (h3 += 1), t4.isDark(n3 + 1, o3) && (h3 += 1), t4.isDark(n3, o3 + 1) && (h3 += 1), t4.isDark(n3 + 1, o3 + 1) && (h3 += 1), 0 != h3 && 4 != h3 || (r4 += 3);
              }
            for (n3 = 0; n3 < e5; n3 += 1)
              for (o3 = 0; o3 < e5 - 6; o3 += 1)
                t4.isDark(n3, o3) && !t4.isDark(n3, o3 + 1) && t4.isDark(n3, o3 + 2) && t4.isDark(n3, o3 + 3) && t4.isDark(n3, o3 + 4) && !t4.isDark(n3, o3 + 5) && t4.isDark(n3, o3 + 6) && (r4 += 40);
            for (o3 = 0; o3 < e5; o3 += 1)
              for (n3 = 0; n3 < e5 - 6; n3 += 1)
                t4.isDark(n3, o3) && !t4.isDark(n3 + 1, o3) && t4.isDark(n3 + 2, o3) && t4.isDark(n3 + 3, o3) && t4.isDark(n3 + 4, o3) && !t4.isDark(n3 + 5, o3) && t4.isDark(n3 + 6, o3) && (r4 += 40);
            var c2 = 0;
            for (o3 = 0; o3 < e5; o3 += 1)
              for (n3 = 0; n3 < e5; n3 += 1)
                t4.isDark(n3, o3) && (c2 += 1);
            return r4 + Math.abs(100 * c2 / e5 / e5 - 50) / 5 * 10;
          }, o2), u2 = function() {
            for (var t4 = new Array(256), e5 = new Array(256), r4 = 0; r4 < 8; r4 += 1)
              t4[r4] = 1 << r4;
            for (r4 = 8; r4 < 256; r4 += 1)
              t4[r4] = t4[r4 - 4] ^ t4[r4 - 5] ^ t4[r4 - 6] ^ t4[r4 - 8];
            for (r4 = 0; r4 < 255; r4 += 1)
              e5[t4[r4]] = r4;
            return { glog: function(t5) {
              if (t5 < 1)
                throw "glog(" + t5 + ")";
              return e5[t5];
            }, gexp: function(e6) {
              for (; e6 < 0; )
                e6 += 255;
              for (; e6 >= 256; )
                e6 -= 255;
              return t4[e6];
            } };
          }();
          function h2(t4, e5) {
            if (void 0 === t4.length)
              throw t4.length + "/" + e5;
            var r4 = function() {
              for (var r5 = 0; r5 < t4.length && 0 == t4[r5]; )
                r5 += 1;
              for (var n4 = new Array(t4.length - r5 + e5), o3 = 0; o3 < t4.length - r5; o3 += 1)
                n4[o3] = t4[o3 + r5];
              return n4;
            }(), n3 = { getAt: function(t5) {
              return r4[t5];
            }, getLength: function() {
              return r4.length;
            }, multiply: function(t5) {
              for (var e6 = new Array(n3.getLength() + t5.getLength() - 1), r5 = 0; r5 < n3.getLength(); r5 += 1)
                for (var o3 = 0; o3 < t5.getLength(); o3 += 1)
                  e6[r5 + o3] ^= u2.gexp(u2.glog(n3.getAt(r5)) + u2.glog(t5.getAt(o3)));
              return h2(e6, 0);
            }, mod: function(t5) {
              if (n3.getLength() - t5.getLength() < 0)
                return n3;
              for (var e6 = u2.glog(n3.getAt(0)) - u2.glog(t5.getAt(0)), r5 = new Array(n3.getLength()), o3 = 0; o3 < n3.getLength(); o3 += 1)
                r5[o3] = n3.getAt(o3);
              for (o3 = 0; o3 < t5.getLength(); o3 += 1)
                r5[o3] ^= u2.gexp(u2.glog(t5.getAt(o3)) + e6);
              return h2(r5, 0).mod(t5);
            } };
            return n3;
          }
          var c = function() {
            var t4 = [[1, 26, 19], [1, 26, 16], [1, 26, 13], [1, 26, 9], [1, 44, 34], [1, 44, 28], [1, 44, 22], [1, 44, 16], [1, 70, 55], [1, 70, 44], [2, 35, 17], [2, 35, 13], [1, 100, 80], [2, 50, 32], [2, 50, 24], [4, 25, 9], [1, 134, 108], [2, 67, 43], [2, 33, 15, 2, 34, 16], [2, 33, 11, 2, 34, 12], [2, 86, 68], [4, 43, 27], [4, 43, 19], [4, 43, 15], [2, 98, 78], [4, 49, 31], [2, 32, 14, 4, 33, 15], [4, 39, 13, 1, 40, 14], [2, 121, 97], [2, 60, 38, 2, 61, 39], [4, 40, 18, 2, 41, 19], [4, 40, 14, 2, 41, 15], [2, 146, 116], [3, 58, 36, 2, 59, 37], [4, 36, 16, 4, 37, 17], [4, 36, 12, 4, 37, 13], [2, 86, 68, 2, 87, 69], [4, 69, 43, 1, 70, 44], [6, 43, 19, 2, 44, 20], [6, 43, 15, 2, 44, 16], [4, 101, 81], [1, 80, 50, 4, 81, 51], [4, 50, 22, 4, 51, 23], [3, 36, 12, 8, 37, 13], [2, 116, 92, 2, 117, 93], [6, 58, 36, 2, 59, 37], [4, 46, 20, 6, 47, 21], [7, 42, 14, 4, 43, 15], [4, 133, 107], [8, 59, 37, 1, 60, 38], [8, 44, 20, 4, 45, 21], [12, 33, 11, 4, 34, 12], [3, 145, 115, 1, 146, 116], [4, 64, 40, 5, 65, 41], [11, 36, 16, 5, 37, 17], [11, 36, 12, 5, 37, 13], [5, 109, 87, 1, 110, 88], [5, 65, 41, 5, 66, 42], [5, 54, 24, 7, 55, 25], [11, 36, 12, 7, 37, 13], [5, 122, 98, 1, 123, 99], [7, 73, 45, 3, 74, 46], [15, 43, 19, 2, 44, 20], [3, 45, 15, 13, 46, 16], [1, 135, 107, 5, 136, 108], [10, 74, 46, 1, 75, 47], [1, 50, 22, 15, 51, 23], [2, 42, 14, 17, 43, 15], [5, 150, 120, 1, 151, 121], [9, 69, 43, 4, 70, 44], [17, 50, 22, 1, 51, 23], [2, 42, 14, 19, 43, 15], [3, 141, 113, 4, 142, 114], [3, 70, 44, 11, 71, 45], [17, 47, 21, 4, 48, 22], [9, 39, 13, 16, 40, 14], [3, 135, 107, 5, 136, 108], [3, 67, 41, 13, 68, 42], [15, 54, 24, 5, 55, 25], [15, 43, 15, 10, 44, 16], [4, 144, 116, 4, 145, 117], [17, 68, 42], [17, 50, 22, 6, 51, 23], [19, 46, 16, 6, 47, 17], [2, 139, 111, 7, 140, 112], [17, 74, 46], [7, 54, 24, 16, 55, 25], [34, 37, 13], [4, 151, 121, 5, 152, 122], [4, 75, 47, 14, 76, 48], [11, 54, 24, 14, 55, 25], [16, 45, 15, 14, 46, 16], [6, 147, 117, 4, 148, 118], [6, 73, 45, 14, 74, 46], [11, 54, 24, 16, 55, 25], [30, 46, 16, 2, 47, 17], [8, 132, 106, 4, 133, 107], [8, 75, 47, 13, 76, 48], [7, 54, 24, 22, 55, 25], [22, 45, 15, 13, 46, 16], [10, 142, 114, 2, 143, 115], [19, 74, 46, 4, 75, 47], [28, 50, 22, 6, 51, 23], [33, 46, 16, 4, 47, 17], [8, 152, 122, 4, 153, 123], [22, 73, 45, 3, 74, 46], [8, 53, 23, 26, 54, 24], [12, 45, 15, 28, 46, 16], [3, 147, 117, 10, 148, 118], [3, 73, 45, 23, 74, 46], [4, 54, 24, 31, 55, 25], [11, 45, 15, 31, 46, 16], [7, 146, 116, 7, 147, 117], [21, 73, 45, 7, 74, 46], [1, 53, 23, 37, 54, 24], [19, 45, 15, 26, 46, 16], [5, 145, 115, 10, 146, 116], [19, 75, 47, 10, 76, 48], [15, 54, 24, 25, 55, 25], [23, 45, 15, 25, 46, 16], [13, 145, 115, 3, 146, 116], [2, 74, 46, 29, 75, 47], [42, 54, 24, 1, 55, 25], [23, 45, 15, 28, 46, 16], [17, 145, 115], [10, 74, 46, 23, 75, 47], [10, 54, 24, 35, 55, 25], [19, 45, 15, 35, 46, 16], [17, 145, 115, 1, 146, 116], [14, 74, 46, 21, 75, 47], [29, 54, 24, 19, 55, 25], [11, 45, 15, 46, 46, 16], [13, 145, 115, 6, 146, 116], [14, 74, 46, 23, 75, 47], [44, 54, 24, 7, 55, 25], [59, 46, 16, 1, 47, 17], [12, 151, 121, 7, 152, 122], [12, 75, 47, 26, 76, 48], [39, 54, 24, 14, 55, 25], [22, 45, 15, 41, 46, 16], [6, 151, 121, 14, 152, 122], [6, 75, 47, 34, 76, 48], [46, 54, 24, 10, 55, 25], [2, 45, 15, 64, 46, 16], [17, 152, 122, 4, 153, 123], [29, 74, 46, 14, 75, 47], [49, 54, 24, 10, 55, 25], [24, 45, 15, 46, 46, 16], [4, 152, 122, 18, 153, 123], [13, 74, 46, 32, 75, 47], [48, 54, 24, 14, 55, 25], [42, 45, 15, 32, 46, 16], [20, 147, 117, 4, 148, 118], [40, 75, 47, 7, 76, 48], [43, 54, 24, 22, 55, 25], [10, 45, 15, 67, 46, 16], [19, 148, 118, 6, 149, 119], [18, 75, 47, 31, 76, 48], [34, 54, 24, 34, 55, 25], [20, 45, 15, 61, 46, 16]], e5 = function(t5, e6) {
              var r5 = {};
              return r5.totalCount = t5, r5.dataCount = e6, r5;
            }, r4 = { getRSBlocks: function(r5, n3) {
              var o3 = function(e6, r6) {
                switch (r6) {
                  case a2.L:
                    return t4[4 * (e6 - 1) + 0];
                  case a2.M:
                    return t4[4 * (e6 - 1) + 1];
                  case a2.Q:
                    return t4[4 * (e6 - 1) + 2];
                  case a2.H:
                    return t4[4 * (e6 - 1) + 3];
                  default:
                    return;
                }
              }(r5, n3);
              if (void 0 === o3)
                throw "bad rs block @ typeNumber:" + r5 + "/errorCorrectionLevel:" + n3;
              for (var i2 = o3.length / 3, s2 = [], u3 = 0; u3 < i2; u3 += 1)
                for (var h3 = o3[3 * u3 + 0], c2 = o3[3 * u3 + 1], l2 = o3[3 * u3 + 2], d2 = 0; d2 < h3; d2 += 1)
                  s2.push(e5(c2, l2));
              return s2;
            } };
            return r4;
          }(), l = function() {
            var t4 = [], e5 = 0, r4 = { getBuffer: function() {
              return t4;
            }, getAt: function(e6) {
              var r5 = Math.floor(e6 / 8);
              return 1 == (t4[r5] >>> 7 - e6 % 8 & 1);
            }, put: function(t5, e6) {
              for (var n3 = 0; n3 < e6; n3 += 1)
                r4.putBit(1 == (t5 >>> e6 - n3 - 1 & 1));
            }, getLengthInBits: function() {
              return e5;
            }, putBit: function(r5) {
              var n3 = Math.floor(e5 / 8);
              t4.length <= n3 && t4.push(0), r5 && (t4[n3] |= 128 >>> e5 % 8), e5 += 1;
            } };
            return r4;
          }, d = function(t4) {
            var e5 = t4, r4 = { getMode: function() {
              return 1;
            }, getLength: function(t5) {
              return e5.length;
            }, write: function(t5) {
              for (var r5 = e5, o4 = 0; o4 + 2 < r5.length; )
                t5.put(n3(r5.substring(o4, o4 + 3)), 10), o4 += 3;
              o4 < r5.length && (r5.length - o4 == 1 ? t5.put(n3(r5.substring(o4, o4 + 1)), 4) : r5.length - o4 == 2 && t5.put(n3(r5.substring(o4, o4 + 2)), 7));
            } }, n3 = function(t5) {
              for (var e6 = 0, r5 = 0; r5 < t5.length; r5 += 1)
                e6 = 10 * e6 + o3(t5.charAt(r5));
              return e6;
            }, o3 = function(t5) {
              if ("0" <= t5 && t5 <= "9")
                return t5.charCodeAt(0) - "0".charCodeAt(0);
              throw "illegal char :" + t5;
            };
            return r4;
          }, f2 = function(t4) {
            var e5 = t4, r4 = { getMode: function() {
              return 2;
            }, getLength: function(t5) {
              return e5.length;
            }, write: function(t5) {
              for (var r5 = e5, o3 = 0; o3 + 1 < r5.length; )
                t5.put(45 * n3(r5.charAt(o3)) + n3(r5.charAt(o3 + 1)), 11), o3 += 2;
              o3 < r5.length && t5.put(n3(r5.charAt(o3)), 6);
            } }, n3 = function(t5) {
              if ("0" <= t5 && t5 <= "9")
                return t5.charCodeAt(0) - "0".charCodeAt(0);
              if ("A" <= t5 && t5 <= "Z")
                return t5.charCodeAt(0) - "A".charCodeAt(0) + 10;
              switch (t5) {
                case " ":
                  return 36;
                case "$":
                  return 37;
                case "%":
                  return 38;
                case "*":
                  return 39;
                case "+":
                  return 40;
                case "-":
                  return 41;
                case ".":
                  return 42;
                case "/":
                  return 43;
                case ":":
                  return 44;
                default:
                  throw "illegal char :" + t5;
              }
            };
            return r4;
          }, g = function(e5) {
            var r4 = t3.stringToBytes(e5);
            return { getMode: function() {
              return 4;
            }, getLength: function(t4) {
              return r4.length;
            }, write: function(t4) {
              for (var e6 = 0; e6 < r4.length; e6 += 1)
                t4.put(r4[e6], 8);
            } };
          }, p = function(e5) {
            var r4 = t3.stringToBytesFuncs.SJIS;
            if (!r4)
              throw "sjis not supported.";
            !function(t4, e6) {
              var n4 = r4("\u53CB");
              if (2 != n4.length || 38726 != (n4[0] << 8 | n4[1]))
                throw "sjis not supported.";
            }();
            var n3 = r4(e5);
            return { getMode: function() {
              return 8;
            }, getLength: function(t4) {
              return ~~(n3.length / 2);
            }, write: function(t4) {
              for (var e6 = n3, r5 = 0; r5 + 1 < e6.length; ) {
                var o3 = (255 & e6[r5]) << 8 | 255 & e6[r5 + 1];
                if (33088 <= o3 && o3 <= 40956)
                  o3 -= 33088;
                else {
                  if (!(57408 <= o3 && o3 <= 60351))
                    throw "illegal char at " + (r5 + 1) + "/" + o3;
                  o3 -= 49472;
                }
                o3 = 192 * (o3 >>> 8 & 255) + (255 & o3), t4.put(o3, 13), r5 += 2;
              }
              if (r5 < e6.length)
                throw "illegal char at " + (r5 + 1);
            } };
          }, v = function() {
            var t4 = [], e5 = { writeByte: function(e6) {
              t4.push(255 & e6);
            }, writeShort: function(t5) {
              e5.writeByte(t5), e5.writeByte(t5 >>> 8);
            }, writeBytes: function(t5, r4, n3) {
              r4 = r4 || 0, n3 = n3 || t5.length;
              for (var o3 = 0; o3 < n3; o3 += 1)
                e5.writeByte(t5[o3 + r4]);
            }, writeString: function(t5) {
              for (var r4 = 0; r4 < t5.length; r4 += 1)
                e5.writeByte(t5.charCodeAt(r4));
            }, toByteArray: function() {
              return t4;
            }, toString: function() {
              var e6 = "";
              e6 += "[";
              for (var r4 = 0; r4 < t4.length; r4 += 1)
                r4 > 0 && (e6 += ","), e6 += t4[r4];
              return e6 + "]";
            } };
            return e5;
          }, w = function(t4) {
            var e5 = t4, r4 = 0, n3 = 0, o3 = 0, i2 = { read: function() {
              for (; o3 < 8; ) {
                if (r4 >= e5.length) {
                  if (0 == o3)
                    return -1;
                  throw "unexpected end of file./" + o3;
                }
                var t5 = e5.charAt(r4);
                if (r4 += 1, "=" == t5)
                  return o3 = 0, -1;
                t5.match(/^\s$/) || (n3 = n3 << 6 | a3(t5.charCodeAt(0)), o3 += 6);
              }
              var i3 = n3 >>> o3 - 8 & 255;
              return o3 -= 8, i3;
            } }, a3 = function(t5) {
              if (65 <= t5 && t5 <= 90)
                return t5 - 65;
              if (97 <= t5 && t5 <= 122)
                return t5 - 97 + 26;
              if (48 <= t5 && t5 <= 57)
                return t5 - 48 + 52;
              if (43 == t5)
                return 62;
              if (47 == t5)
                return 63;
              throw "c:" + t5;
            };
            return i2;
          }, y = function(t4, e5, r4) {
            for (var n3 = function(t5, e6) {
              var r5 = t5, n4 = e6, o4 = new Array(t5 * e6), i3 = { setPixel: function(t6, e7, n5) {
                o4[e7 * r5 + t6] = n5;
              }, write: function(t6) {
                t6.writeString("GIF87a"), t6.writeShort(r5), t6.writeShort(n4), t6.writeByte(128), t6.writeByte(0), t6.writeByte(0), t6.writeByte(0), t6.writeByte(0), t6.writeByte(0), t6.writeByte(255), t6.writeByte(255), t6.writeByte(255), t6.writeString(","), t6.writeShort(0), t6.writeShort(0), t6.writeShort(r5), t6.writeShort(n4), t6.writeByte(0);
                var e7 = a4(2);
                t6.writeByte(2);
                for (var o5 = 0; e7.length - o5 > 255; )
                  t6.writeByte(255), t6.writeBytes(e7, o5, 255), o5 += 255;
                t6.writeByte(e7.length - o5), t6.writeBytes(e7, o5, e7.length - o5), t6.writeByte(0), t6.writeString(";");
              } }, a4 = function(t6) {
                for (var e7 = 1 << t6, r6 = 1 + (1 << t6), n5 = t6 + 1, i4 = s3(), a5 = 0; a5 < e7; a5 += 1)
                  i4.add(String.fromCharCode(a5));
                i4.add(String.fromCharCode(e7)), i4.add(String.fromCharCode(r6));
                var u4, h4, c2, l2 = v(), d2 = (u4 = l2, h4 = 0, c2 = 0, { write: function(t7, e8) {
                  if (t7 >>> e8 != 0)
                    throw "length over";
                  for (; h4 + e8 >= 8; )
                    u4.writeByte(255 & (t7 << h4 | c2)), e8 -= 8 - h4, t7 >>>= 8 - h4, c2 = 0, h4 = 0;
                  c2 |= t7 << h4, h4 += e8;
                }, flush: function() {
                  h4 > 0 && u4.writeByte(c2);
                } });
                d2.write(e7, n5);
                var f3 = 0, g2 = String.fromCharCode(o4[f3]);
                for (f3 += 1; f3 < o4.length; ) {
                  var p2 = String.fromCharCode(o4[f3]);
                  f3 += 1, i4.contains(g2 + p2) ? g2 += p2 : (d2.write(i4.indexOf(g2), n5), i4.size() < 4095 && (i4.size() == 1 << n5 && (n5 += 1), i4.add(g2 + p2)), g2 = p2);
                }
                return d2.write(i4.indexOf(g2), n5), d2.write(r6, n5), d2.flush(), l2.toByteArray();
              }, s3 = function() {
                var t6 = {}, e7 = 0, r6 = { add: function(n5) {
                  if (r6.contains(n5))
                    throw "dup key:" + n5;
                  t6[n5] = e7, e7 += 1;
                }, size: function() {
                  return e7;
                }, indexOf: function(e8) {
                  return t6[e8];
                }, contains: function(e8) {
                  return void 0 !== t6[e8];
                } };
                return r6;
              };
              return i3;
            }(t4, e5), o3 = 0; o3 < e5; o3 += 1)
              for (var i2 = 0; i2 < t4; i2 += 1)
                n3.setPixel(i2, o3, r4(i2, o3));
            var a3 = v();
            n3.write(a3);
            for (var s2 = function() {
              var t5 = 0, e6 = 0, r5 = 0, n4 = "", o4 = {}, i3 = function(t6) {
                n4 += String.fromCharCode(a4(63 & t6));
              }, a4 = function(t6) {
                if (t6 < 0)
                  ;
                else {
                  if (t6 < 26)
                    return 65 + t6;
                  if (t6 < 52)
                    return t6 - 26 + 97;
                  if (t6 < 62)
                    return t6 - 52 + 48;
                  if (62 == t6)
                    return 43;
                  if (63 == t6)
                    return 47;
                }
                throw "n:" + t6;
              };
              return o4.writeByte = function(n5) {
                for (t5 = t5 << 8 | 255 & n5, e6 += 8, r5 += 1; e6 >= 6; )
                  i3(t5 >>> e6 - 6), e6 -= 6;
              }, o4.flush = function() {
                if (e6 > 0 && (i3(t5 << 6 - e6), t5 = 0, e6 = 0), r5 % 3 != 0)
                  for (var o5 = 3 - r5 % 3, a5 = 0; a5 < o5; a5 += 1)
                    n4 += "=";
              }, o4.toString = function() {
                return n4;
              }, o4;
            }(), u3 = a3.toByteArray(), h3 = 0; h3 < u3.length; h3 += 1)
              s2.writeByte(u3[h3]);
            return s2.flush(), "data:image/gif;base64," + s2;
          };
          return t3;
        }();
        o.stringToBytesFuncs["UTF-8"] = function(t3) {
          return function(t4) {
            for (var e4 = [], r3 = 0; r3 < t4.length; r3++) {
              var n2 = t4.charCodeAt(r3);
              n2 < 128 ? e4.push(n2) : n2 < 2048 ? e4.push(192 | n2 >> 6, 128 | 63 & n2) : n2 < 55296 || n2 >= 57344 ? e4.push(224 | n2 >> 12, 128 | n2 >> 6 & 63, 128 | 63 & n2) : (r3++, n2 = 65536 + ((1023 & n2) << 10 | 1023 & t4.charCodeAt(r3)), e4.push(240 | n2 >> 18, 128 | n2 >> 12 & 63, 128 | n2 >> 6 & 63, 128 | 63 & n2));
            }
            return e4;
          }(t3);
        }, void 0 === (n = "function" == typeof (r2 = function() {
          return o;
        }) ? r2.apply(e3, []) : r2) || (t2.exports = n);
      }, 676: (t2, e3, r2) => {
        r2.d(e3, { default: () => q2 });
        var n = function() {
          return (n = Object.assign || function(t3) {
            for (var e4, r3 = 1, n2 = arguments.length; r3 < n2; r3++)
              for (var o2 in e4 = arguments[r3])
                Object.prototype.hasOwnProperty.call(e4, o2) && (t3[o2] = e4[o2]);
            return t3;
          }).apply(this, arguments);
        }, o = function() {
          for (var t3 = 0, e4 = 0, r3 = arguments.length; e4 < r3; e4++)
            t3 += arguments[e4].length;
          var n2 = Array(t3), o2 = 0;
          for (e4 = 0; e4 < r3; e4++)
            for (var i2 = arguments[e4], a3 = 0, s2 = i2.length; a3 < s2; a3++, o2++)
              n2[o2] = i2[a3];
          return n2;
        }, i = function(t3) {
          return !!t3 && "object" == typeof t3 && !Array.isArray(t3);
        };
        function a2(t3) {
          for (var e4 = [], r3 = 1; r3 < arguments.length; r3++)
            e4[r3 - 1] = arguments[r3];
          if (!e4.length)
            return t3;
          var s2 = e4.shift();
          return void 0 !== s2 && i(t3) && i(s2) ? (t3 = n({}, t3), Object.keys(s2).forEach(function(e5) {
            var r4 = t3[e5], n2 = s2[e5];
            Array.isArray(r4) && Array.isArray(n2) ? t3[e5] = n2 : i(r4) && i(n2) ? t3[e5] = a2(Object.assign({}, r4), n2) : t3[e5] = n2;
          }), a2.apply(void 0, o([t3], e4))) : t3;
        }
        function s(t3, e4) {
          var r3 = document.createElement("a");
          r3.download = e4, r3.href = t3, document.body.appendChild(r3), r3.click(), document.body.removeChild(r3);
        }
        function u2(t3) {
          return e4 = this, r3 = void 0, o2 = function() {
            return function(t4, e5) {
              var r4, n3, o3, i2, a3 = { label: 0, sent: function() {
                if (1 & o3[0])
                  throw o3[1];
                return o3[1];
              }, trys: [], ops: [] };
              return i2 = { next: s2(0), throw: s2(1), return: s2(2) }, "function" == typeof Symbol && (i2[Symbol.iterator] = function() {
                return this;
              }), i2;
              function s2(i3) {
                return function(s3) {
                  return function(i4) {
                    if (r4)
                      throw new TypeError("Generator is already executing.");
                    for (; a3; )
                      try {
                        if (r4 = 1, n3 && (o3 = 2 & i4[0] ? n3.return : i4[0] ? n3.throw || ((o3 = n3.return) && o3.call(n3), 0) : n3.next) && !(o3 = o3.call(n3, i4[1])).done)
                          return o3;
                        switch (n3 = 0, o3 && (i4 = [2 & i4[0], o3.value]), i4[0]) {
                          case 0:
                          case 1:
                            o3 = i4;
                            break;
                          case 4:
                            return a3.label++, { value: i4[1], done: false };
                          case 5:
                            a3.label++, n3 = i4[1], i4 = [0];
                            continue;
                          case 7:
                            i4 = a3.ops.pop(), a3.trys.pop();
                            continue;
                          default:
                            if (!((o3 = (o3 = a3.trys).length > 0 && o3[o3.length - 1]) || 6 !== i4[0] && 2 !== i4[0])) {
                              a3 = 0;
                              continue;
                            }
                            if (3 === i4[0] && (!o3 || i4[1] > o3[0] && i4[1] < o3[3])) {
                              a3.label = i4[1];
                              break;
                            }
                            if (6 === i4[0] && a3.label < o3[1]) {
                              a3.label = o3[1], o3 = i4;
                              break;
                            }
                            if (o3 && a3.label < o3[2]) {
                              a3.label = o3[2], a3.ops.push(i4);
                              break;
                            }
                            o3[2] && a3.ops.pop(), a3.trys.pop();
                            continue;
                        }
                        i4 = e5.call(t4, a3);
                      } catch (t5) {
                        i4 = [6, t5], n3 = 0;
                      } finally {
                        r4 = o3 = 0;
                      }
                    if (5 & i4[0])
                      throw i4[1];
                    return { value: i4[0] ? i4[1] : void 0, done: true };
                  }([i3, s3]);
                };
              }
            }(this, function(e5) {
              return [2, new Promise(function(e6) {
                var r4 = new XMLHttpRequest();
                r4.onload = function() {
                  var t4 = new FileReader();
                  t4.onloadend = function() {
                    e6(t4.result);
                  }, t4.readAsDataURL(r4.response);
                }, r4.open("GET", t3), r4.responseType = "blob", r4.send();
              })];
            });
          }, new ((n2 = void 0) || (n2 = Promise))(function(t4, i2) {
            function a3(t5) {
              try {
                u3(o2.next(t5));
              } catch (t6) {
                i2(t6);
              }
            }
            function s2(t5) {
              try {
                u3(o2.throw(t5));
              } catch (t6) {
                i2(t6);
              }
            }
            function u3(e5) {
              var r4;
              e5.done ? t4(e5.value) : (r4 = e5.value, r4 instanceof n2 ? r4 : new n2(function(t5) {
                t5(r4);
              })).then(a3, s2);
            }
            u3((o2 = o2.apply(e4, r3 || [])).next());
          });
          var e4, r3, n2, o2;
        }
        const h2 = { L: 0.07, M: 0.15, Q: 0.25, H: 0.3 };
        var c = function() {
          return (c = Object.assign || function(t3) {
            for (var e4, r3 = 1, n2 = arguments.length; r3 < n2; r3++)
              for (var o2 in e4 = arguments[r3])
                Object.prototype.hasOwnProperty.call(e4, o2) && (t3[o2] = e4[o2]);
            return t3;
          }).apply(this, arguments);
        };
        const l = function() {
          function t3(t4) {
            var e4 = t4.svg, r3 = t4.type;
            this._svg = e4, this._type = r3;
          }
          return t3.prototype.draw = function(t4, e4, r3, n2) {
            var o2;
            switch (this._type) {
              case "dots":
                o2 = this._drawDot;
                break;
              case "classy":
                o2 = this._drawClassy;
                break;
              case "classy-rounded":
                o2 = this._drawClassyRounded;
                break;
              case "rounded":
                o2 = this._drawRounded;
                break;
              case "extra-rounded":
                o2 = this._drawExtraRounded;
                break;
              case "square":
              default:
                o2 = this._drawSquare;
            }
            o2.call(this, { x: t4, y: e4, size: r3, getNeighbor: n2 });
          }, t3.prototype._rotateFigure = function(t4) {
            var e4, r3 = t4.x, n2 = t4.y, o2 = t4.size, i2 = t4.rotation, a3 = void 0 === i2 ? 0 : i2, s2 = r3 + o2 / 2, u3 = n2 + o2 / 2;
            (0, t4.draw)(), null === (e4 = this._element) || void 0 === e4 || e4.setAttribute("transform", "rotate(" + 180 * a3 / Math.PI + "," + s2 + "," + u3 + ")");
          }, t3.prototype._basicDot = function(t4) {
            var e4 = this, r3 = t4.size, n2 = t4.x, o2 = t4.y;
            this._rotateFigure(c(c({}, t4), { draw: function() {
              e4._element = document.createElementNS("http://www.w3.org/2000/svg", "circle"), e4._element.setAttribute("cx", String(n2 + r3 / 2)), e4._element.setAttribute("cy", String(o2 + r3 / 2)), e4._element.setAttribute("r", String(r3 / 2));
            } }));
          }, t3.prototype._basicSquare = function(t4) {
            var e4 = this, r3 = t4.size, n2 = t4.x, o2 = t4.y;
            this._rotateFigure(c(c({}, t4), { draw: function() {
              e4._element = document.createElementNS("http://www.w3.org/2000/svg", "rect"), e4._element.setAttribute("x", String(n2)), e4._element.setAttribute("y", String(o2)), e4._element.setAttribute("width", String(r3)), e4._element.setAttribute("height", String(r3));
            } }));
          }, t3.prototype._basicSideRounded = function(t4) {
            var e4 = this, r3 = t4.size, n2 = t4.x, o2 = t4.y;
            this._rotateFigure(c(c({}, t4), { draw: function() {
              e4._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e4._element.setAttribute("d", "M " + n2 + " " + o2 + "v " + r3 + "h " + r3 / 2 + "a " + r3 / 2 + " " + r3 / 2 + ", 0, 0, 0, 0 " + -r3);
            } }));
          }, t3.prototype._basicCornerRounded = function(t4) {
            var e4 = this, r3 = t4.size, n2 = t4.x, o2 = t4.y;
            this._rotateFigure(c(c({}, t4), { draw: function() {
              e4._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e4._element.setAttribute("d", "M " + n2 + " " + o2 + "v " + r3 + "h " + r3 + "v " + -r3 / 2 + "a " + r3 / 2 + " " + r3 / 2 + ", 0, 0, 0, " + -r3 / 2 + " " + -r3 / 2);
            } }));
          }, t3.prototype._basicCornerExtraRounded = function(t4) {
            var e4 = this, r3 = t4.size, n2 = t4.x, o2 = t4.y;
            this._rotateFigure(c(c({}, t4), { draw: function() {
              e4._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e4._element.setAttribute("d", "M " + n2 + " " + o2 + "v " + r3 + "h " + r3 + "a " + r3 + " " + r3 + ", 0, 0, 0, " + -r3 + " " + -r3);
            } }));
          }, t3.prototype._basicCornersRounded = function(t4) {
            var e4 = this, r3 = t4.size, n2 = t4.x, o2 = t4.y;
            this._rotateFigure(c(c({}, t4), { draw: function() {
              e4._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e4._element.setAttribute("d", "M " + n2 + " " + o2 + "v " + r3 / 2 + "a " + r3 / 2 + " " + r3 / 2 + ", 0, 0, 0, " + r3 / 2 + " " + r3 / 2 + "h " + r3 / 2 + "v " + -r3 / 2 + "a " + r3 / 2 + " " + r3 / 2 + ", 0, 0, 0, " + -r3 / 2 + " " + -r3 / 2);
            } }));
          }, t3.prototype._drawDot = function(t4) {
            var e4 = t4.x, r3 = t4.y, n2 = t4.size;
            this._basicDot({ x: e4, y: r3, size: n2, rotation: 0 });
          }, t3.prototype._drawSquare = function(t4) {
            var e4 = t4.x, r3 = t4.y, n2 = t4.size;
            this._basicSquare({ x: e4, y: r3, size: n2, rotation: 0 });
          }, t3.prototype._drawRounded = function(t4) {
            var e4 = t4.x, r3 = t4.y, n2 = t4.size, o2 = t4.getNeighbor, i2 = o2 ? +o2(-1, 0) : 0, a3 = o2 ? +o2(1, 0) : 0, s2 = o2 ? +o2(0, -1) : 0, u3 = o2 ? +o2(0, 1) : 0, h3 = i2 + a3 + s2 + u3;
            if (0 !== h3)
              if (h3 > 2 || i2 && a3 || s2 && u3)
                this._basicSquare({ x: e4, y: r3, size: n2, rotation: 0 });
              else {
                if (2 === h3) {
                  var c2 = 0;
                  return i2 && s2 ? c2 = Math.PI / 2 : s2 && a3 ? c2 = Math.PI : a3 && u3 && (c2 = -Math.PI / 2), void this._basicCornerRounded({ x: e4, y: r3, size: n2, rotation: c2 });
                }
                if (1 === h3)
                  return c2 = 0, s2 ? c2 = Math.PI / 2 : a3 ? c2 = Math.PI : u3 && (c2 = -Math.PI / 2), void this._basicSideRounded({ x: e4, y: r3, size: n2, rotation: c2 });
              }
            else
              this._basicDot({ x: e4, y: r3, size: n2, rotation: 0 });
          }, t3.prototype._drawExtraRounded = function(t4) {
            var e4 = t4.x, r3 = t4.y, n2 = t4.size, o2 = t4.getNeighbor, i2 = o2 ? +o2(-1, 0) : 0, a3 = o2 ? +o2(1, 0) : 0, s2 = o2 ? +o2(0, -1) : 0, u3 = o2 ? +o2(0, 1) : 0, h3 = i2 + a3 + s2 + u3;
            if (0 !== h3)
              if (h3 > 2 || i2 && a3 || s2 && u3)
                this._basicSquare({ x: e4, y: r3, size: n2, rotation: 0 });
              else {
                if (2 === h3) {
                  var c2 = 0;
                  return i2 && s2 ? c2 = Math.PI / 2 : s2 && a3 ? c2 = Math.PI : a3 && u3 && (c2 = -Math.PI / 2), void this._basicCornerExtraRounded({ x: e4, y: r3, size: n2, rotation: c2 });
                }
                if (1 === h3)
                  return c2 = 0, s2 ? c2 = Math.PI / 2 : a3 ? c2 = Math.PI : u3 && (c2 = -Math.PI / 2), void this._basicSideRounded({ x: e4, y: r3, size: n2, rotation: c2 });
              }
            else
              this._basicDot({ x: e4, y: r3, size: n2, rotation: 0 });
          }, t3.prototype._drawClassy = function(t4) {
            var e4 = t4.x, r3 = t4.y, n2 = t4.size, o2 = t4.getNeighbor, i2 = o2 ? +o2(-1, 0) : 0, a3 = o2 ? +o2(1, 0) : 0, s2 = o2 ? +o2(0, -1) : 0, u3 = o2 ? +o2(0, 1) : 0;
            0 !== i2 + a3 + s2 + u3 ? i2 || s2 ? a3 || u3 ? this._basicSquare({ x: e4, y: r3, size: n2, rotation: 0 }) : this._basicCornerRounded({ x: e4, y: r3, size: n2, rotation: Math.PI / 2 }) : this._basicCornerRounded({ x: e4, y: r3, size: n2, rotation: -Math.PI / 2 }) : this._basicCornersRounded({ x: e4, y: r3, size: n2, rotation: Math.PI / 2 });
          }, t3.prototype._drawClassyRounded = function(t4) {
            var e4 = t4.x, r3 = t4.y, n2 = t4.size, o2 = t4.getNeighbor, i2 = o2 ? +o2(-1, 0) : 0, a3 = o2 ? +o2(1, 0) : 0, s2 = o2 ? +o2(0, -1) : 0, u3 = o2 ? +o2(0, 1) : 0;
            0 !== i2 + a3 + s2 + u3 ? i2 || s2 ? a3 || u3 ? this._basicSquare({ x: e4, y: r3, size: n2, rotation: 0 }) : this._basicCornerExtraRounded({ x: e4, y: r3, size: n2, rotation: Math.PI / 2 }) : this._basicCornerExtraRounded({ x: e4, y: r3, size: n2, rotation: -Math.PI / 2 }) : this._basicCornersRounded({ x: e4, y: r3, size: n2, rotation: Math.PI / 2 });
          }, t3;
        }();
        var d = function() {
          return (d = Object.assign || function(t3) {
            for (var e4, r3 = 1, n2 = arguments.length; r3 < n2; r3++)
              for (var o2 in e4 = arguments[r3])
                Object.prototype.hasOwnProperty.call(e4, o2) && (t3[o2] = e4[o2]);
            return t3;
          }).apply(this, arguments);
        };
        const f2 = function() {
          function t3(t4) {
            var e4 = t4.svg, r3 = t4.type;
            this._svg = e4, this._type = r3;
          }
          return t3.prototype.draw = function(t4, e4, r3, n2) {
            var o2;
            switch (this._type) {
              case "square":
                o2 = this._drawSquare;
                break;
              case "extra-rounded":
                o2 = this._drawExtraRounded;
                break;
              case "dot":
              default:
                o2 = this._drawDot;
            }
            o2.call(this, { x: t4, y: e4, size: r3, rotation: n2 });
          }, t3.prototype._rotateFigure = function(t4) {
            var e4, r3 = t4.x, n2 = t4.y, o2 = t4.size, i2 = t4.rotation, a3 = void 0 === i2 ? 0 : i2, s2 = r3 + o2 / 2, u3 = n2 + o2 / 2;
            (0, t4.draw)(), null === (e4 = this._element) || void 0 === e4 || e4.setAttribute("transform", "rotate(" + 180 * a3 / Math.PI + "," + s2 + "," + u3 + ")");
          }, t3.prototype._basicDot = function(t4) {
            var e4 = this, r3 = t4.size, n2 = t4.x, o2 = t4.y, i2 = r3 / 7;
            this._rotateFigure(d(d({}, t4), { draw: function() {
              e4._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e4._element.setAttribute("clip-rule", "evenodd"), e4._element.setAttribute("d", "M " + (n2 + r3 / 2) + " " + o2 + "a " + r3 / 2 + " " + r3 / 2 + " 0 1 0 0.1 0zm 0 " + i2 + "a " + (r3 / 2 - i2) + " " + (r3 / 2 - i2) + " 0 1 1 -0.1 0Z");
            } }));
          }, t3.prototype._basicSquare = function(t4) {
            var e4 = this, r3 = t4.size, n2 = t4.x, o2 = t4.y, i2 = r3 / 7;
            this._rotateFigure(d(d({}, t4), { draw: function() {
              e4._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e4._element.setAttribute("clip-rule", "evenodd"), e4._element.setAttribute("d", "M " + n2 + " " + o2 + "v " + r3 + "h " + r3 + "v " + -r3 + "zM " + (n2 + i2) + " " + (o2 + i2) + "h " + (r3 - 2 * i2) + "v " + (r3 - 2 * i2) + "h " + (2 * i2 - r3) + "z");
            } }));
          }, t3.prototype._basicExtraRounded = function(t4) {
            var e4 = this, r3 = t4.size, n2 = t4.x, o2 = t4.y, i2 = r3 / 7;
            this._rotateFigure(d(d({}, t4), { draw: function() {
              e4._element = document.createElementNS("http://www.w3.org/2000/svg", "path"), e4._element.setAttribute("clip-rule", "evenodd"), e4._element.setAttribute("d", "M " + n2 + " " + (o2 + 2.5 * i2) + "v " + 2 * i2 + "a " + 2.5 * i2 + " " + 2.5 * i2 + ", 0, 0, 0, " + 2.5 * i2 + " " + 2.5 * i2 + "h " + 2 * i2 + "a " + 2.5 * i2 + " " + 2.5 * i2 + ", 0, 0, 0, " + 2.5 * i2 + " " + 2.5 * -i2 + "v " + -2 * i2 + "a " + 2.5 * i2 + " " + 2.5 * i2 + ", 0, 0, 0, " + 2.5 * -i2 + " " + 2.5 * -i2 + "h " + -2 * i2 + "a " + 2.5 * i2 + " " + 2.5 * i2 + ", 0, 0, 0, " + 2.5 * -i2 + " " + 2.5 * i2 + "M " + (n2 + 2.5 * i2) + " " + (o2 + i2) + "h " + 2 * i2 + "a " + 1.5 * i2 + " " + 1.5 * i2 + ", 0, 0, 1, " + 1.5 * i2 + " " + 1.5 * i2 + "v " + 2 * i2 + "a " + 1.5 * i2 + " " + 1.5 * i2 + ", 0, 0, 1, " + 1.5 * -i2 + " " + 1.5 * i2 + "h " + -2 * i2 + "a " + 1.5 * i2 + " " + 1.5 * i2 + ", 0, 0, 1, " + 1.5 * -i2 + " " + 1.5 * -i2 + "v " + -2 * i2 + "a " + 1.5 * i2 + " " + 1.5 * i2 + ", 0, 0, 1, " + 1.5 * i2 + " " + 1.5 * -i2);
            } }));
          }, t3.prototype._drawDot = function(t4) {
            var e4 = t4.x, r3 = t4.y, n2 = t4.size, o2 = t4.rotation;
            this._basicDot({ x: e4, y: r3, size: n2, rotation: o2 });
          }, t3.prototype._drawSquare = function(t4) {
            var e4 = t4.x, r3 = t4.y, n2 = t4.size, o2 = t4.rotation;
            this._basicSquare({ x: e4, y: r3, size: n2, rotation: o2 });
          }, t3.prototype._drawExtraRounded = function(t4) {
            var e4 = t4.x, r3 = t4.y, n2 = t4.size, o2 = t4.rotation;
            this._basicExtraRounded({ x: e4, y: r3, size: n2, rotation: o2 });
          }, t3;
        }();
        var g = function() {
          return (g = Object.assign || function(t3) {
            for (var e4, r3 = 1, n2 = arguments.length; r3 < n2; r3++)
              for (var o2 in e4 = arguments[r3])
                Object.prototype.hasOwnProperty.call(e4, o2) && (t3[o2] = e4[o2]);
            return t3;
          }).apply(this, arguments);
        };
        const p = function() {
          function t3(t4) {
            var e4 = t4.svg, r3 = t4.type;
            this._svg = e4, this._type = r3;
          }
          return t3.prototype.draw = function(t4, e4, r3, n2) {
            var o2;
            switch (this._type) {
              case "square":
                o2 = this._drawSquare;
                break;
              case "dot":
              default:
                o2 = this._drawDot;
            }
            o2.call(this, { x: t4, y: e4, size: r3, rotation: n2 });
          }, t3.prototype._rotateFigure = function(t4) {
            var e4, r3 = t4.x, n2 = t4.y, o2 = t4.size, i2 = t4.rotation, a3 = void 0 === i2 ? 0 : i2, s2 = r3 + o2 / 2, u3 = n2 + o2 / 2;
            (0, t4.draw)(), null === (e4 = this._element) || void 0 === e4 || e4.setAttribute("transform", "rotate(" + 180 * a3 / Math.PI + "," + s2 + "," + u3 + ")");
          }, t3.prototype._basicDot = function(t4) {
            var e4 = this, r3 = t4.size, n2 = t4.x, o2 = t4.y;
            this._rotateFigure(g(g({}, t4), { draw: function() {
              e4._element = document.createElementNS("http://www.w3.org/2000/svg", "circle"), e4._element.setAttribute("cx", String(n2 + r3 / 2)), e4._element.setAttribute("cy", String(o2 + r3 / 2)), e4._element.setAttribute("r", String(r3 / 2));
            } }));
          }, t3.prototype._basicSquare = function(t4) {
            var e4 = this, r3 = t4.size, n2 = t4.x, o2 = t4.y;
            this._rotateFigure(g(g({}, t4), { draw: function() {
              e4._element = document.createElementNS("http://www.w3.org/2000/svg", "rect"), e4._element.setAttribute("x", String(n2)), e4._element.setAttribute("y", String(o2)), e4._element.setAttribute("width", String(r3)), e4._element.setAttribute("height", String(r3));
            } }));
          }, t3.prototype._drawDot = function(t4) {
            var e4 = t4.x, r3 = t4.y, n2 = t4.size, o2 = t4.rotation;
            this._basicDot({ x: e4, y: r3, size: n2, rotation: o2 });
          }, t3.prototype._drawSquare = function(t4) {
            var e4 = t4.x, r3 = t4.y, n2 = t4.size, o2 = t4.rotation;
            this._basicSquare({ x: e4, y: r3, size: n2, rotation: o2 });
          }, t3;
        }(), v = "circle";
        var w = function(t3, e4, r3, n2) {
          return new (r3 || (r3 = Promise))(function(o2, i2) {
            function a3(t4) {
              try {
                u3(n2.next(t4));
              } catch (t5) {
                i2(t5);
              }
            }
            function s2(t4) {
              try {
                u3(n2.throw(t4));
              } catch (t5) {
                i2(t5);
              }
            }
            function u3(t4) {
              var e5;
              t4.done ? o2(t4.value) : (e5 = t4.value, e5 instanceof r3 ? e5 : new r3(function(t5) {
                t5(e5);
              })).then(a3, s2);
            }
            u3((n2 = n2.apply(t3, e4 || [])).next());
          });
        }, y = function(t3, e4) {
          var r3, n2, o2, i2, a3 = { label: 0, sent: function() {
            if (1 & o2[0])
              throw o2[1];
            return o2[1];
          }, trys: [], ops: [] };
          return i2 = { next: s2(0), throw: s2(1), return: s2(2) }, "function" == typeof Symbol && (i2[Symbol.iterator] = function() {
            return this;
          }), i2;
          function s2(i3) {
            return function(s3) {
              return function(i4) {
                if (r3)
                  throw new TypeError("Generator is already executing.");
                for (; a3; )
                  try {
                    if (r3 = 1, n2 && (o2 = 2 & i4[0] ? n2.return : i4[0] ? n2.throw || ((o2 = n2.return) && o2.call(n2), 0) : n2.next) && !(o2 = o2.call(n2, i4[1])).done)
                      return o2;
                    switch (n2 = 0, o2 && (i4 = [2 & i4[0], o2.value]), i4[0]) {
                      case 0:
                      case 1:
                        o2 = i4;
                        break;
                      case 4:
                        return a3.label++, { value: i4[1], done: false };
                      case 5:
                        a3.label++, n2 = i4[1], i4 = [0];
                        continue;
                      case 7:
                        i4 = a3.ops.pop(), a3.trys.pop();
                        continue;
                      default:
                        if (!((o2 = (o2 = a3.trys).length > 0 && o2[o2.length - 1]) || 6 !== i4[0] && 2 !== i4[0])) {
                          a3 = 0;
                          continue;
                        }
                        if (3 === i4[0] && (!o2 || i4[1] > o2[0] && i4[1] < o2[3])) {
                          a3.label = i4[1];
                          break;
                        }
                        if (6 === i4[0] && a3.label < o2[1]) {
                          a3.label = o2[1], o2 = i4;
                          break;
                        }
                        if (o2 && a3.label < o2[2]) {
                          a3.label = o2[2], a3.ops.push(i4);
                          break;
                        }
                        o2[2] && a3.ops.pop(), a3.trys.pop();
                        continue;
                    }
                    i4 = e4.call(t3, a3);
                  } catch (t4) {
                    i4 = [6, t4], n2 = 0;
                  } finally {
                    r3 = o2 = 0;
                  }
                if (5 & i4[0])
                  throw i4[1];
                return { value: i4[0] ? i4[1] : void 0, done: true };
              }([i3, s3]);
            };
          }
        }, m = [[1, 1, 1, 1, 1, 1, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1]], b = [[0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 1, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0]];
        const _ = function() {
          function t3(t4) {
            this._element = document.createElementNS("http://www.w3.org/2000/svg", "svg"), this._element.setAttribute("width", String(t4.width)), this._element.setAttribute("height", String(t4.height)), this._defs = document.createElementNS("http://www.w3.org/2000/svg", "defs"), this._element.appendChild(this._defs), this._options = t4;
          }
          return Object.defineProperty(t3.prototype, "width", { get: function() {
            return this._options.width;
          }, enumerable: false, configurable: true }), Object.defineProperty(t3.prototype, "height", { get: function() {
            return this._options.height;
          }, enumerable: false, configurable: true }), t3.prototype.getElement = function() {
            return this._element;
          }, t3.prototype.drawQR = function(t4) {
            return w(this, void 0, void 0, function() {
              var e4, r3, n2, o2, i2, a3, s2, u3, c2, l2, d2 = this;
              return y(this, function(f3) {
                switch (f3.label) {
                  case 0:
                    return e4 = t4.getModuleCount(), r3 = Math.min(this._options.width, this._options.height) - 2 * this._options.margin, n2 = this._options.shape === v ? r3 / Math.sqrt(2) : r3, o2 = Math.floor(n2 / e4), i2 = { hideXDots: 0, hideYDots: 0, width: 0, height: 0 }, this._qr = t4, this._options.image ? [4, this.loadImage()] : [3, 2];
                  case 1:
                    if (f3.sent(), !this._image)
                      return [2];
                    a3 = this._options, s2 = a3.imageOptions, u3 = a3.qrOptions, c2 = s2.imageSize * h2[u3.errorCorrectionLevel], l2 = Math.floor(c2 * e4 * e4), i2 = function(t5) {
                      var e5 = t5.originalHeight, r4 = t5.originalWidth, n3 = t5.maxHiddenDots, o3 = t5.maxHiddenAxisDots, i3 = t5.dotSize, a4 = { x: 0, y: 0 }, s3 = { x: 0, y: 0 };
                      if (e5 <= 0 || r4 <= 0 || n3 <= 0 || i3 <= 0)
                        return { height: 0, width: 0, hideYDots: 0, hideXDots: 0 };
                      var u4 = e5 / r4;
                      return a4.x = Math.floor(Math.sqrt(n3 / u4)), a4.x <= 0 && (a4.x = 1), o3 && o3 < a4.x && (a4.x = o3), a4.x % 2 == 0 && a4.x--, s3.x = a4.x * i3, a4.y = 1 + 2 * Math.ceil((a4.x * u4 - 1) / 2), s3.y = Math.round(s3.x * u4), (a4.y * a4.x > n3 || o3 && o3 < a4.y) && (o3 && o3 < a4.y ? (a4.y = o3, a4.y % 2 == 0 && a4.x--) : a4.y -= 2, s3.y = a4.y * i3, a4.x = 1 + 2 * Math.ceil((a4.y / u4 - 1) / 2), s3.x = Math.round(s3.y / u4)), { height: s3.y, width: s3.x, hideYDots: a4.y, hideXDots: a4.x };
                    }({ originalWidth: this._image.width, originalHeight: this._image.height, maxHiddenDots: l2, maxHiddenAxisDots: e4 - 14, dotSize: o2 }), f3.label = 2;
                  case 2:
                    return this.drawBackground(), this.drawDots(function(t5, r4) {
                      var n3, o3, a4, s3, u4, h3;
                      return !(d2._options.imageOptions.hideBackgroundDots && t5 >= (e4 - i2.hideXDots) / 2 && t5 < (e4 + i2.hideXDots) / 2 && r4 >= (e4 - i2.hideYDots) / 2 && r4 < (e4 + i2.hideYDots) / 2 || (null === (n3 = m[t5]) || void 0 === n3 ? void 0 : n3[r4]) || (null === (o3 = m[t5 - e4 + 7]) || void 0 === o3 ? void 0 : o3[r4]) || (null === (a4 = m[t5]) || void 0 === a4 ? void 0 : a4[r4 - e4 + 7]) || (null === (s3 = b[t5]) || void 0 === s3 ? void 0 : s3[r4]) || (null === (u4 = b[t5 - e4 + 7]) || void 0 === u4 ? void 0 : u4[r4]) || (null === (h3 = b[t5]) || void 0 === h3 ? void 0 : h3[r4 - e4 + 7]));
                    }), this.drawCorners(), this._options.image ? [4, this.drawImage({ width: i2.width, height: i2.height, count: e4, dotSize: o2 })] : [3, 4];
                  case 3:
                    f3.sent(), f3.label = 4;
                  case 4:
                    return [2];
                }
              });
            });
          }, t3.prototype.drawBackground = function() {
            var t4, e4, r3, n2 = this._element, o2 = this._options;
            if (n2) {
              var i2 = null === (t4 = o2.backgroundOptions) || void 0 === t4 ? void 0 : t4.gradient, a3 = null === (e4 = o2.backgroundOptions) || void 0 === e4 ? void 0 : e4.color;
              if ((i2 || a3) && this._createColor({ options: i2, color: a3, additionalRotation: 0, x: 0, y: 0, height: o2.height, width: o2.width, name: "background-color" }), null === (r3 = o2.backgroundOptions) || void 0 === r3 ? void 0 : r3.round) {
                var s2 = Math.min(o2.width, o2.height), u3 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                this._backgroundClipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._backgroundClipPath.setAttribute("id", "clip-path-background-color"), this._defs.appendChild(this._backgroundClipPath), u3.setAttribute("x", String((o2.width - s2) / 2)), u3.setAttribute("y", String((o2.height - s2) / 2)), u3.setAttribute("width", String(s2)), u3.setAttribute("height", String(s2)), u3.setAttribute("rx", String(s2 / 2 * o2.backgroundOptions.round)), this._backgroundClipPath.appendChild(u3);
              }
            }
          }, t3.prototype.drawDots = function(t4) {
            var e4, r3, n2 = this;
            if (!this._qr)
              throw "QR code is not defined";
            var o2 = this._options, i2 = this._qr.getModuleCount();
            if (i2 > o2.width || i2 > o2.height)
              throw "The canvas is too small.";
            var a3 = Math.min(o2.width, o2.height) - 2 * o2.margin, s2 = o2.shape === v ? a3 / Math.sqrt(2) : a3, u3 = Math.floor(s2 / i2), h3 = Math.floor((o2.width - i2 * u3) / 2), c2 = Math.floor((o2.height - i2 * u3) / 2), d2 = new l({ svg: this._element, type: o2.dotsOptions.type });
            this._dotsClipPath = document.createElementNS("http://www.w3.org/2000/svg", "clipPath"), this._dotsClipPath.setAttribute("id", "clip-path-dot-color"), this._defs.appendChild(this._dotsClipPath), this._createColor({ options: null === (e4 = o2.dotsOptions) || void 0 === e4 ? void 0 : e4.gradient, color: o2.dotsOptions.color, additionalRotation: 0, x: 0, y: 0, height: o2.height, width: o2.width, name: "dot-color" });
            for (var f3 = function(e5) {
              for (var o3 = function(o4) {
                return t4 && !t4(e5, o4) ? "continue" : (null === (r3 = g2._qr) || void 0 === r3 ? void 0 : r3.isDark(e5, o4)) ? (d2.draw(h3 + e5 * u3, c2 + o4 * u3, u3, function(r4, a5) {
                  return !(e5 + r4 < 0 || o4 + a5 < 0 || e5 + r4 >= i2 || o4 + a5 >= i2) && !(t4 && !t4(e5 + r4, o4 + a5)) && !!n2._qr && n2._qr.isDark(e5 + r4, o4 + a5);
                }), void (d2._element && g2._dotsClipPath && g2._dotsClipPath.appendChild(d2._element))) : "continue";
              }, a4 = 0; a4 < i2; a4++)
                o3(a4);
            }, g2 = this, p2 = 0; p2 < i2; p2++)
              f3(p2);
            if (o2.shape === v) {
              var w2 = Math.floor((a3 / u3 - i2) / 2), y2 = i2 + 2 * w2, m2 = h3 - w2 * u3, b2 = c2 - w2 * u3, _2 = [], x2 = Math.floor(y2 / 2);
              for (p2 = 0; p2 < y2; p2++) {
                _2[p2] = [];
                for (var S2 = 0; S2 < y2; S2++)
                  p2 >= w2 - 1 && p2 <= y2 - w2 && S2 >= w2 - 1 && S2 <= y2 - w2 || Math.sqrt((p2 - x2) * (p2 - x2) + (S2 - x2) * (S2 - x2)) > x2 ? _2[p2][S2] = 0 : _2[p2][S2] = this._qr.isDark(S2 - 2 * w2 < 0 ? S2 : S2 >= i2 ? S2 - 2 * w2 : S2 - w2, p2 - 2 * w2 < 0 ? p2 : p2 >= i2 ? p2 - 2 * w2 : p2 - w2) ? 1 : 0;
              }
              var M2 = function(t5) {
                for (var e5 = function(e6) {
                  if (!_2[t5][e6])
                    return "continue";
                  d2.draw(m2 + t5 * u3, b2 + e6 * u3, u3, function(r5, n3) {
                    var o3;
                    return !!(null === (o3 = _2[t5 + r5]) || void 0 === o3 ? void 0 : o3[e6 + n3]);
                  }), d2._element && C2._dotsClipPath && C2._dotsClipPath.appendChild(d2._element);
                }, r4 = 0; r4 < y2; r4++)
                  e5(r4);
              }, C2 = this;
              for (p2 = 0; p2 < y2; p2++)
                M2(p2);
            }
          }, t3.prototype.drawCorners = function() {
            var t4 = this;
            if (!this._qr)
              throw "QR code is not defined";
            var e4 = this._element, r3 = this._options;
            if (!e4)
              throw "Element code is not defined";
            var n2 = this._qr.getModuleCount(), o2 = Math.min(r3.width, r3.height) - 2 * r3.margin, i2 = r3.shape === v ? o2 / Math.sqrt(2) : o2, a3 = Math.floor(i2 / n2), s2 = 7 * a3, u3 = 3 * a3, h3 = Math.floor((r3.width - n2 * a3) / 2), c2 = Math.floor((r3.height - n2 * a3) / 2);
            [[0, 0, 0], [1, 0, Math.PI / 2], [0, 1, -Math.PI / 2]].forEach(function(e5) {
              var o3, i3, d2, g2, v2, w2, y2, _2, x2, S2, M2, C2, A3 = e5[0], k2 = e5[1], O3 = e5[2], D3 = h3 + A3 * a3 * (n2 - 7), P3 = c2 + k2 * a3 * (n2 - 7), z3 = t4._dotsClipPath, B4 = t4._dotsClipPath;
              if (((null === (o3 = r3.cornersSquareOptions) || void 0 === o3 ? void 0 : o3.gradient) || (null === (i3 = r3.cornersSquareOptions) || void 0 === i3 ? void 0 : i3.color)) && ((z3 = document.createElementNS("http://www.w3.org/2000/svg", "clipPath")).setAttribute("id", "clip-path-corners-square-color-" + A3 + "-" + k2), t4._defs.appendChild(z3), t4._cornersSquareClipPath = t4._cornersDotClipPath = B4 = z3, t4._createColor({ options: null === (d2 = r3.cornersSquareOptions) || void 0 === d2 ? void 0 : d2.gradient, color: null === (g2 = r3.cornersSquareOptions) || void 0 === g2 ? void 0 : g2.color, additionalRotation: O3, x: D3, y: P3, height: s2, width: s2, name: "corners-square-color-" + A3 + "-" + k2 })), null === (v2 = r3.cornersSquareOptions) || void 0 === v2 ? void 0 : v2.type) {
                var q3 = new f2({ svg: t4._element, type: r3.cornersSquareOptions.type });
                q3.draw(D3, P3, s2, O3), q3._element && z3 && z3.appendChild(q3._element);
              } else
                for (var I2 = new l({ svg: t4._element, type: r3.dotsOptions.type }), E2 = function(t5) {
                  for (var e6 = function(e7) {
                    if (!(null === (w2 = m[t5]) || void 0 === w2 ? void 0 : w2[e7]))
                      return "continue";
                    I2.draw(D3 + t5 * a3, P3 + e7 * a3, a3, function(r5, n3) {
                      var o4;
                      return !!(null === (o4 = m[t5 + r5]) || void 0 === o4 ? void 0 : o4[e7 + n3]);
                    }), I2._element && z3 && z3.appendChild(I2._element);
                  }, r4 = 0; r4 < m[t5].length; r4++)
                    e6(r4);
                }, L2 = 0; L2 < m.length; L2++)
                  E2(L2);
              if (((null === (y2 = r3.cornersDotOptions) || void 0 === y2 ? void 0 : y2.gradient) || (null === (_2 = r3.cornersDotOptions) || void 0 === _2 ? void 0 : _2.color)) && ((B4 = document.createElementNS("http://www.w3.org/2000/svg", "clipPath")).setAttribute("id", "clip-path-corners-dot-color-" + A3 + "-" + k2), t4._defs.appendChild(B4), t4._cornersDotClipPath = B4, t4._createColor({ options: null === (x2 = r3.cornersDotOptions) || void 0 === x2 ? void 0 : x2.gradient, color: null === (S2 = r3.cornersDotOptions) || void 0 === S2 ? void 0 : S2.color, additionalRotation: O3, x: D3 + 2 * a3, y: P3 + 2 * a3, height: u3, width: u3, name: "corners-dot-color-" + A3 + "-" + k2 })), null === (M2 = r3.cornersDotOptions) || void 0 === M2 ? void 0 : M2.type) {
                var R2 = new p({ svg: t4._element, type: r3.cornersDotOptions.type });
                R2.draw(D3 + 2 * a3, P3 + 2 * a3, u3, O3), R2._element && B4 && B4.appendChild(R2._element);
              } else {
                I2 = new l({ svg: t4._element, type: r3.dotsOptions.type });
                var N2 = function(t5) {
                  for (var e6 = function(e7) {
                    if (!(null === (C2 = b[t5]) || void 0 === C2 ? void 0 : C2[e7]))
                      return "continue";
                    I2.draw(D3 + t5 * a3, P3 + e7 * a3, a3, function(r5, n3) {
                      var o4;
                      return !!(null === (o4 = b[t5 + r5]) || void 0 === o4 ? void 0 : o4[e7 + n3]);
                    }), I2._element && B4 && B4.appendChild(I2._element);
                  }, r4 = 0; r4 < b[t5].length; r4++)
                    e6(r4);
                };
                for (L2 = 0; L2 < b.length; L2++)
                  N2(L2);
              }
            });
          }, t3.prototype.loadImage = function() {
            var t4 = this;
            return new Promise(function(e4, r3) {
              var n2 = t4._options, o2 = new Image();
              if (!n2.image)
                return r3("Image is not defined");
              "string" == typeof n2.imageOptions.crossOrigin && (o2.crossOrigin = n2.imageOptions.crossOrigin), t4._image = o2, o2.onload = function() {
                e4();
              }, o2.src = n2.image;
            });
          }, t3.prototype.drawImage = function(t4) {
            var e4 = t4.width, r3 = t4.height, n2 = t4.count, o2 = t4.dotSize;
            return w(this, void 0, void 0, function() {
              var t5, i2, a3, s2, h3, c2, l2, d2, f3;
              return y(this, function(g2) {
                switch (g2.label) {
                  case 0:
                    return t5 = this._options, i2 = Math.floor((t5.width - n2 * o2) / 2), a3 = Math.floor((t5.height - n2 * o2) / 2), s2 = i2 + t5.imageOptions.margin + (n2 * o2 - e4) / 2, h3 = a3 + t5.imageOptions.margin + (n2 * o2 - r3) / 2, c2 = e4 - 2 * t5.imageOptions.margin, l2 = r3 - 2 * t5.imageOptions.margin, (d2 = document.createElementNS("http://www.w3.org/2000/svg", "image")).setAttribute("x", String(s2)), d2.setAttribute("y", String(h3)), d2.setAttribute("width", c2 + "px"), d2.setAttribute("height", l2 + "px"), [4, u2(t5.image || "")];
                  case 1:
                    return f3 = g2.sent(), d2.setAttribute("href", f3 || ""), this._element.appendChild(d2), [2];
                }
              });
            });
          }, t3.prototype._createColor = function(t4) {
            var e4 = t4.options, r3 = t4.color, n2 = t4.additionalRotation, o2 = t4.x, i2 = t4.y, a3 = t4.height, s2 = t4.width, u3 = t4.name, h3 = s2 > a3 ? s2 : a3, c2 = document.createElementNS("http://www.w3.org/2000/svg", "rect");
            if (c2.setAttribute("x", String(o2)), c2.setAttribute("y", String(i2)), c2.setAttribute("height", String(a3)), c2.setAttribute("width", String(s2)), c2.setAttribute("clip-path", "url('#clip-path-" + u3 + "')"), e4) {
              var l2;
              if ("radial" === e4.type)
                (l2 = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient")).setAttribute("id", u3), l2.setAttribute("gradientUnits", "userSpaceOnUse"), l2.setAttribute("fx", String(o2 + s2 / 2)), l2.setAttribute("fy", String(i2 + a3 / 2)), l2.setAttribute("cx", String(o2 + s2 / 2)), l2.setAttribute("cy", String(i2 + a3 / 2)), l2.setAttribute("r", String(h3 / 2));
              else {
                var d2 = ((e4.rotation || 0) + n2) % (2 * Math.PI), f3 = (d2 + 2 * Math.PI) % (2 * Math.PI), g2 = o2 + s2 / 2, p2 = i2 + a3 / 2, v2 = o2 + s2 / 2, w2 = i2 + a3 / 2;
                f3 >= 0 && f3 <= 0.25 * Math.PI || f3 > 1.75 * Math.PI && f3 <= 2 * Math.PI ? (g2 -= s2 / 2, p2 -= a3 / 2 * Math.tan(d2), v2 += s2 / 2, w2 += a3 / 2 * Math.tan(d2)) : f3 > 0.25 * Math.PI && f3 <= 0.75 * Math.PI ? (p2 -= a3 / 2, g2 -= s2 / 2 / Math.tan(d2), w2 += a3 / 2, v2 += s2 / 2 / Math.tan(d2)) : f3 > 0.75 * Math.PI && f3 <= 1.25 * Math.PI ? (g2 += s2 / 2, p2 += a3 / 2 * Math.tan(d2), v2 -= s2 / 2, w2 -= a3 / 2 * Math.tan(d2)) : f3 > 1.25 * Math.PI && f3 <= 1.75 * Math.PI && (p2 += a3 / 2, g2 += s2 / 2 / Math.tan(d2), w2 -= a3 / 2, v2 -= s2 / 2 / Math.tan(d2)), (l2 = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient")).setAttribute("id", u3), l2.setAttribute("gradientUnits", "userSpaceOnUse"), l2.setAttribute("x1", String(Math.round(g2))), l2.setAttribute("y1", String(Math.round(p2))), l2.setAttribute("x2", String(Math.round(v2))), l2.setAttribute("y2", String(Math.round(w2)));
              }
              e4.colorStops.forEach(function(t5) {
                var e5 = t5.offset, r4 = t5.color, n3 = document.createElementNS("http://www.w3.org/2000/svg", "stop");
                n3.setAttribute("offset", 100 * e5 + "%"), n3.setAttribute("stop-color", r4), l2.appendChild(n3);
              }), c2.setAttribute("fill", "url('#" + u3 + "')"), this._defs.appendChild(l2);
            } else
              r3 && c2.setAttribute("fill", r3);
            this._element.appendChild(c2);
          }, t3;
        }(), x = "canvas";
        for (var S = {}, M = 0; M <= 40; M++)
          S[M] = M;
        const C = { type: x, shape: "square", width: 300, height: 300, data: "", margin: 0, qrOptions: { typeNumber: S[0], mode: void 0, errorCorrectionLevel: "Q" }, imageOptions: { hideBackgroundDots: true, imageSize: 0.4, crossOrigin: void 0, margin: 0 }, dotsOptions: { type: "square", color: "#000" }, backgroundOptions: { round: 0, color: "#fff" } };
        var A2 = function() {
          return (A2 = Object.assign || function(t3) {
            for (var e4, r3 = 1, n2 = arguments.length; r3 < n2; r3++)
              for (var o2 in e4 = arguments[r3])
                Object.prototype.hasOwnProperty.call(e4, o2) && (t3[o2] = e4[o2]);
            return t3;
          }).apply(this, arguments);
        };
        function k(t3) {
          var e4 = A2({}, t3);
          if (!e4.colorStops || !e4.colorStops.length)
            throw "Field 'colorStops' is required in gradient";
          return e4.rotation ? e4.rotation = Number(e4.rotation) : e4.rotation = 0, e4.colorStops = e4.colorStops.map(function(t4) {
            return A2(A2({}, t4), { offset: Number(t4.offset) });
          }), e4;
        }
        function O2(t3) {
          var e4 = A2({}, t3);
          return e4.width = Number(e4.width), e4.height = Number(e4.height), e4.margin = Number(e4.margin), e4.imageOptions = A2(A2({}, e4.imageOptions), { hideBackgroundDots: Boolean(e4.imageOptions.hideBackgroundDots), imageSize: Number(e4.imageOptions.imageSize), margin: Number(e4.imageOptions.margin) }), e4.margin > Math.min(e4.width, e4.height) && (e4.margin = Math.min(e4.width, e4.height)), e4.dotsOptions = A2({}, e4.dotsOptions), e4.dotsOptions.gradient && (e4.dotsOptions.gradient = k(e4.dotsOptions.gradient)), e4.cornersSquareOptions && (e4.cornersSquareOptions = A2({}, e4.cornersSquareOptions), e4.cornersSquareOptions.gradient && (e4.cornersSquareOptions.gradient = k(e4.cornersSquareOptions.gradient))), e4.cornersDotOptions && (e4.cornersDotOptions = A2({}, e4.cornersDotOptions), e4.cornersDotOptions.gradient && (e4.cornersDotOptions.gradient = k(e4.cornersDotOptions.gradient))), e4.backgroundOptions && (e4.backgroundOptions = A2({}, e4.backgroundOptions), e4.backgroundOptions.gradient && (e4.backgroundOptions.gradient = k(e4.backgroundOptions.gradient))), e4;
        }
        var D2 = r2(192), P2 = r2.n(D2), z2 = function(t3, e4, r3, n2) {
          return new (r3 || (r3 = Promise))(function(o2, i2) {
            function a3(t4) {
              try {
                u3(n2.next(t4));
              } catch (t5) {
                i2(t5);
              }
            }
            function s2(t4) {
              try {
                u3(n2.throw(t4));
              } catch (t5) {
                i2(t5);
              }
            }
            function u3(t4) {
              var e5;
              t4.done ? o2(t4.value) : (e5 = t4.value, e5 instanceof r3 ? e5 : new r3(function(t5) {
                t5(e5);
              })).then(a3, s2);
            }
            u3((n2 = n2.apply(t3, e4 || [])).next());
          });
        }, B3 = function(t3, e4) {
          var r3, n2, o2, i2, a3 = { label: 0, sent: function() {
            if (1 & o2[0])
              throw o2[1];
            return o2[1];
          }, trys: [], ops: [] };
          return i2 = { next: s2(0), throw: s2(1), return: s2(2) }, "function" == typeof Symbol && (i2[Symbol.iterator] = function() {
            return this;
          }), i2;
          function s2(i3) {
            return function(s3) {
              return function(i4) {
                if (r3)
                  throw new TypeError("Generator is already executing.");
                for (; a3; )
                  try {
                    if (r3 = 1, n2 && (o2 = 2 & i4[0] ? n2.return : i4[0] ? n2.throw || ((o2 = n2.return) && o2.call(n2), 0) : n2.next) && !(o2 = o2.call(n2, i4[1])).done)
                      return o2;
                    switch (n2 = 0, o2 && (i4 = [2 & i4[0], o2.value]), i4[0]) {
                      case 0:
                      case 1:
                        o2 = i4;
                        break;
                      case 4:
                        return a3.label++, { value: i4[1], done: false };
                      case 5:
                        a3.label++, n2 = i4[1], i4 = [0];
                        continue;
                      case 7:
                        i4 = a3.ops.pop(), a3.trys.pop();
                        continue;
                      default:
                        if (!((o2 = (o2 = a3.trys).length > 0 && o2[o2.length - 1]) || 6 !== i4[0] && 2 !== i4[0])) {
                          a3 = 0;
                          continue;
                        }
                        if (3 === i4[0] && (!o2 || i4[1] > o2[0] && i4[1] < o2[3])) {
                          a3.label = i4[1];
                          break;
                        }
                        if (6 === i4[0] && a3.label < o2[1]) {
                          a3.label = o2[1], o2 = i4;
                          break;
                        }
                        if (o2 && a3.label < o2[2]) {
                          a3.label = o2[2], a3.ops.push(i4);
                          break;
                        }
                        o2[2] && a3.ops.pop(), a3.trys.pop();
                        continue;
                    }
                    i4 = e4.call(t3, a3);
                  } catch (t4) {
                    i4 = [6, t4], n2 = 0;
                  } finally {
                    r3 = o2 = 0;
                  }
                if (5 & i4[0])
                  throw i4[1];
                return { value: i4[0] ? i4[1] : void 0, done: true };
              }([i3, s3]);
            };
          }
        };
        const q2 = function() {
          function t3(t4) {
            this._options = t4 ? O2(a2(C, t4)) : C, this.update();
          }
          return t3._clearContainer = function(t4) {
            t4 && (t4.innerHTML = "");
          }, t3.prototype._setupSvg = function() {
            var t4 = this;
            if (this._qr) {
              var e4 = new _(this._options);
              this._svg = e4.getElement(), this._svgDrawingPromise = e4.drawQR(this._qr).then(function() {
                var r3;
                t4._svg && (null === (r3 = t4._extension) || void 0 === r3 || r3.call(t4, e4.getElement(), t4._options));
              });
            }
          }, t3.prototype._setupCanvas = function() {
            var t4, e4 = this;
            this._qr && (this._canvas = document.createElement("canvas"), this._canvas.width = this._options.width, this._canvas.height = this._options.height, this._setupSvg(), this._canvasDrawingPromise = null === (t4 = this._svgDrawingPromise) || void 0 === t4 ? void 0 : t4.then(function() {
              if (e4._svg) {
                var t5 = e4._svg, r3 = new XMLSerializer().serializeToString(t5), n2 = "data:image/svg+xml;base64," + btoa(r3), o2 = new Image();
                return new Promise(function(t6) {
                  o2.onload = function() {
                    var r4, n3;
                    null === (n3 = null === (r4 = e4._canvas) || void 0 === r4 ? void 0 : r4.getContext("2d")) || void 0 === n3 || n3.drawImage(o2, 0, 0), t6();
                  }, o2.src = n2;
                });
              }
            }));
          }, t3.prototype._getElement = function(t4) {
            return void 0 === t4 && (t4 = "png"), z2(this, void 0, void 0, function() {
              return B3(this, function(e4) {
                switch (e4.label) {
                  case 0:
                    if (!this._qr)
                      throw "QR code is empty";
                    return "svg" !== t4.toLowerCase() ? [3, 2] : (this._svg && this._svgDrawingPromise || this._setupSvg(), [4, this._svgDrawingPromise]);
                  case 1:
                    return e4.sent(), [2, this._svg];
                  case 2:
                    return this._canvas && this._canvasDrawingPromise || this._setupCanvas(), [4, this._canvasDrawingPromise];
                  case 3:
                    return e4.sent(), [2, this._canvas];
                }
              });
            });
          }, t3.prototype.update = function(e4) {
            t3._clearContainer(this._container), this._options = e4 ? O2(a2(this._options, e4)) : this._options, this._options.data && (this._qr = P2()(this._options.qrOptions.typeNumber, this._options.qrOptions.errorCorrectionLevel), this._qr.addData(this._options.data, this._options.qrOptions.mode || function(t4) {
              switch (true) {
                case /^[0-9]*$/.test(t4):
                  return "Numeric";
                case /^[0-9A-Z $%*+\-./:]*$/.test(t4):
                  return "Alphanumeric";
                default:
                  return "Byte";
              }
            }(this._options.data)), this._qr.make(), this._options.type === x ? this._setupCanvas() : this._setupSvg(), this.append(this._container));
          }, t3.prototype.append = function(t4) {
            if (t4) {
              if ("function" != typeof t4.appendChild)
                throw "Container should be a single DOM node";
              this._options.type === x ? this._canvas && t4.appendChild(this._canvas) : this._svg && t4.appendChild(this._svg), this._container = t4;
            }
          }, t3.prototype.applyExtension = function(t4) {
            if (!t4)
              throw "Extension function should be defined.";
            this._extension = t4, this.update();
          }, t3.prototype.deleteExtension = function() {
            this._extension = void 0, this.update();
          }, t3.prototype.getRawData = function(t4) {
            return void 0 === t4 && (t4 = "png"), z2(this, void 0, void 0, function() {
              var e4, r3, n2;
              return B3(this, function(o2) {
                switch (o2.label) {
                  case 0:
                    if (!this._qr)
                      throw "QR code is empty";
                    return [4, this._getElement(t4)];
                  case 1:
                    return (e4 = o2.sent()) ? "svg" === t4.toLowerCase() ? (r3 = new XMLSerializer(), n2 = r3.serializeToString(e4), [2, new Blob(['<?xml version="1.0" standalone="no"?>\r\n' + n2], { type: "image/svg+xml" })]) : [2, new Promise(function(r4) {
                      return e4.toBlob(r4, "image/" + t4, 1);
                    })] : [2, null];
                }
              });
            });
          }, t3.prototype.download = function(t4) {
            return z2(this, void 0, void 0, function() {
              var e4, r3, n2, o2, i2;
              return B3(this, function(a3) {
                switch (a3.label) {
                  case 0:
                    if (!this._qr)
                      throw "QR code is empty";
                    return e4 = "png", r3 = "qr", "string" == typeof t4 ? (e4 = t4, console.warn("Extension is deprecated as argument for 'download' method, please pass object { name: '...', extension: '...' } as argument")) : "object" == typeof t4 && null !== t4 && (t4.name && (r3 = t4.name), t4.extension && (e4 = t4.extension)), [4, this._getElement(e4)];
                  case 1:
                    return (n2 = a3.sent()) ? ("svg" === e4.toLowerCase() ? (o2 = new XMLSerializer(), i2 = '<?xml version="1.0" standalone="no"?>\r\n' + (i2 = o2.serializeToString(n2)), s("data:image/svg+xml;charset=utf-8," + encodeURIComponent(i2), r3 + ".svg")) : s(n2.toDataURL("image/" + e4), r3 + "." + e4), [2]) : [2];
                }
              });
            });
          }, t3;
        }();
      } }, e2 = {};
      function r(n) {
        if (e2[n])
          return e2[n].exports;
        var o = e2[n] = { exports: {} };
        return t[n](o, o.exports, r), o.exports;
      }
      return r.n = (t2) => {
        var e3 = t2 && t2.__esModule ? () => t2.default : () => t2;
        return r.d(e3, { a: e3 }), e3;
      }, r.d = (t2, e3) => {
        for (var n in e3)
          r.o(e3, n) && !r.o(t2, n) && Object.defineProperty(t2, n, { enumerable: true, get: e3[n] });
      }, r.o = (t2, e3) => Object.prototype.hasOwnProperty.call(t2, e3), r(676);
    })().default;
  });
})(qrCodeStyling);
var QRCodeStyling = /* @__PURE__ */ getDefaultExportFromCjs(qrCodeStyling.exports);
const _sfc_main$Q = defineComponent({
  props: {
    width: {
      default: 300
    },
    height: {
      default: 300
    },
    image: {},
    value: {},
    dotsOptions: {
      default: () => {
        return {};
      }
    }
  },
  setup(props2) {
    let options = {};
    watch(
      () => [props2.width, props2.height, props2.dotsOptions],
      () => {
        render2();
      }
    );
    const render2 = debounce$1(300, false, async () => {
      var _a2;
      options = {
        width: props2.width,
        height: props2.height,
        type: "canvas",
        data: props2.value,
        image: props2.image,
        margin: 2,
        qrOptions: {
          typeNumber: 3,
          mode: "Byte",
          errorCorrectionLevel: "M"
        },
        imageOptions: {
          hideBackgroundDots: true,
          imageSize: 0.4,
          margin: 6,
          crossOrigin: "anonymous"
        },
        backgroundOptions: {
          color: "#ffffff"
        },
        dotsOptions: {
          color: "#41b583",
          type: "rounded",
          ...props2.dotsOptions
        },
        cornersSquareOptions: {
          color: props2.dotsOptions.color,
          type: ""
        },
        cornersDotOptions: {
          color: props2.dotsOptions.color,
          type: "square"
        }
      };
      if (props2.value) {
        qrCode.update(options);
        await nextTick();
        if ((_a2 = qrCodeDom == null ? void 0 : qrCodeDom.value) == null ? void 0 : _a2.firstChild) {
          qrCodeDom.value.firstChild.style = "width: 100%;";
        }
      }
    });
    const qrCode = new QRCodeStyling(options);
    const qrCodeDom = ref$1();
    onMounted(() => {
      render2();
      qrCode.append(qrCodeDom.value);
    });
    return {
      qrCodeDom
    };
  }
});
const _hoisted_1$N = {
  ref: "qrCodeDom",
  class: "qrcode__wrap"
};
function _sfc_render$M(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$N, null, 512);
}
var index$4 = /* @__PURE__ */ _export_sfc(_sfc_main$Q, [["render", _sfc_render$M]]);
var wQrcode_vue_vue_type_style_index_0_scoped_true_lang = "";
var wQrcode_vue_vue_type_style_index_1_scoped_true_lang = "";
const NAME$m = "w-qrcode";
const _sfc_main$P = {
  name: NAME$m,
  components: { QRCode: index$4 },
  setting: {
    name: "\u4E8C\u7EF4\u7801",
    type: NAME$m,
    uuid: -1,
    width: 300,
    height: 300,
    left: 0,
    top: 0,
    zoom: 1,
    transform: "",
    radius: 0,
    opacity: 1,
    parent: "-1",
    url: "",
    dotType: "classy",
    dotColorType: "single",
    dotRotation: 270,
    dotColor: "#35495E",
    dotColor2: "#35495E",
    value: "https://xp.palxp.cn",
    setting: [],
    record: {
      width: 0,
      height: 0,
      minWidth: 10,
      minHeight: 10,
      dir: "all"
    }
  },
  props: ["params", "parent"],
  data() {
    return {
      qrCodeOptions: {}
    };
  },
  computed: {
    ...mapGetters(["dActiveElement", "dZoom"]),
    width() {
      return Number(this.params.width);
    }
  },
  watch: {
    params: {
      async handler(nval) {
        this.changeValues();
      },
      immediate: true,
      deep: true
    }
  },
  updated() {
    this.updateRecord();
    this.$store.commit("updateRect");
  },
  async mounted() {
    this.updateRecord();
    await this.$nextTick();
    this.params.rotate && (this.$refs.widget.style.transform += `rotate(${this.params.rotate})`);
  },
  methods: {
    ...mapActions(["updateWidgetData"]),
    updateRecord() {
      if (this.dActiveElement.uuid === this.params.uuid) {
        let record = this.dActiveElement.record;
        record.width = this.$refs.widget.offsetWidth;
        record.height = this.$refs.widget.offsetHeight;
      }
    },
    changeValues() {
      this.qrCodeOptions = {
        qrOptions: { typeNumber: 0, mode: "Byte", errorCorrectionLevel: "H" },
        dotsOptions: {
          type: this.params.dotType,
          color: this.params.dotColor,
          gradient: {
            type: "linear",
            rotation: this.params.dotRotation,
            colorStops: [
              { offset: 0, color: this.params.dotColor },
              { offset: 1, color: this.params.dotColorType === "single" ? this.params.dotColor : this.params.dotColor2 }
            ]
          }
        }
      };
    }
  }
};
const _hoisted_1$M = ["id"];
function _sfc_render$L(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_QRCode = resolveComponent("QRCode");
  return openBlock(), createElementBlock("div", {
    id: $props.params.uuid,
    ref: "widget",
    class: normalizeClass(["w-qrcode", { "layer-lock": $props.params.lock }]),
    style: normalizeStyle({
      position: "absolute",
      left: $props.params.left - $props.parent.left + "px",
      top: $props.params.top - $props.parent.top + "px",
      width: $props.params.width + "px",
      height: $props.params.height + "px",
      opacity: $props.params.opacity
    })
  }, [
    createVNode(_component_QRCode, mergeProps({ ref: "qrcode" }, $data.qrCodeOptions, {
      width: $options.width,
      height: $options.width,
      class: "target",
      image: $props.params.url,
      value: $props.params.value
    }), null, 16, ["width", "height", "image", "value"])
  ], 14, _hoisted_1$M);
}
var wQrcode = /* @__PURE__ */ _export_sfc(_sfc_main$P, [["render", _sfc_render$L], ["__scopeId", "data-v-8eaf4d56"]]);
var __glob_0_29 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": wQrcode
}, Symbol.toStringTag, { value: "Module" }));
const moveInit = {
  methods: {
    initmovement(e2) {
      if (!erpStore.getters.dAltDown) {
        erpStore.commit("setMouseEvent", e2);
      }
      const target = erpStore.getters.dActiveElement;
      erpStore.dispatch("initDMove", {
        startX: e2.pageX,
        startY: e2.pageY,
        originX: target.left,
        originY: target.top
      });
      const handlemouseup = () => {
        erpStore.commit("setMouseEvent", null);
        document.removeEventListener("mouseup", handlemouseup, true);
      };
      document.addEventListener("mouseup", handlemouseup, true);
    }
  }
};
var designBoard_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$l = "page-design";
const _sfc_main$O = defineComponent({
  name: NAME$l,
  components: { wGroup, wImage, wQrcode, wSvg, wText },
  mixins: [moveInit],
  props: ["pageDesignCanvasId"],
  data() {
    return {};
  },
  computed: {
    ...mapGetters(["dPaddingTop", "dPage", "dZoom", "dScreen", "dWidgets", "dActiveElement", "dHoverUuid", "dSelectWidgets", "dAltDown", "dDraging", "showRotatable"])
  },
  mounted() {
    this.getScreen();
    document.getElementById("page-design").addEventListener("mousedown", this.handleSelection, false);
    document.getElementById("page-design").addEventListener("mousemove", debounce$1(100, false, this.handleMouseMove), false);
  },
  beforeUnmount() {
  },
  methods: {
    ...mapActions(["updateScreen", "selectWidget", "deleteWidget", "addWidget", "addGroup"]),
    async dropOver(e2) {
      if (this.dActiveElement.editable || this.dActiveElement.lock) {
        return false;
      }
      e2.preventDefault();
      let { data, type } = this.$store.getters.selectItem;
      if (type !== "image") {
        return;
      }
      const target = await getTarget(e2.target);
      const uuid = target.getAttribute("data-uuid");
      this.$store.dispatch("setDropOver", uuid);
      if (e2.target.getAttribute("putIn")) {
        this._dropIn = uuid;
        const imgUrl = data.value.thumb || data.value.url;
        !this._srcCache && (this._srcCache = target.firstElementChild.firstElementChild.src);
        target.firstElementChild.firstElementChild.src = imgUrl;
      } else {
        this._srcCache && (target.firstElementChild.firstElementChild.src = this._srcCache);
        this._srcCache = "";
        this._dropIn = "";
      }
    },
    async drop(e2) {
      if (!this.dDraging) {
        return;
      }
      this.$store.commit("setDraging", false);
      const dropIn = this._dropIn;
      this._dropIn = "";
      this.$store.dispatch("setDropOver", "-1");
      this.$store.commit("setShowMoveable", false);
      let lost = e2.target.className !== "design-canvas";
      e2.preventDefault();
      let { data: item, type } = JSON.parse(JSON.stringify(this.$store.getters.selectItem));
      this.$store.commit("selectItem", {});
      let setting = {};
      if (!type) {
        return;
      }
      setting = await setWidgetData(type, item, setting);
      const lostX = e2.x - document.getElementById("page-design-canvas").getBoundingClientRect().left;
      const lostY = e2.y - document.getElementById("page-design-canvas").getBoundingClientRect().top;
      if (type === "group") {
        let parent = {};
        item = await setCompData(item);
        item.forEach((element) => {
          if (element.type === "w-group") {
            parent.width = element.width;
            parent.height = element.height;
          }
        });
        const half2 = { x: parent.width ? parent.width * this.$store.getters.dZoom / 100 / 2 : 0, y: parent.height ? parent.height * this.$store.getters.dZoom / 100 / 2 : 0 };
        item.forEach((element) => {
          element.left += (lost ? lostX - half2.x : e2.layerX - half2.x) * (100 / this.$store.getters.dZoom);
          element.top += (lost ? lostY - half2.y : e2.layerY - half2.y) * (100 / this.$store.getters.dZoom);
        });
        this.addGroup(item);
      }
      const half = { x: setting.width ? setting.width * this.$store.getters.dZoom / 100 / 2 : 0, y: setting.height ? setting.height * this.$store.getters.dZoom / 100 / 2 : 0 };
      setting.left = (lost ? lostX - half.x : e2.layerX - half.x) * (100 / this.$store.getters.dZoom);
      setting.top = (lost ? lostY - half.y : e2.layerY - half.y) * (100 / this.$store.getters.dZoom);
      if (lost && type === "image") {
        const target = await getTarget(e2.target);
        const targetType = target.getAttribute("data-type");
        const uuid = target.getAttribute("data-uuid");
        if (targetType === "w-mask") {
          this.$store.commit("setShowMoveable", true);
          const widget = this.dWidgets.find((item2) => item2.uuid === uuid);
          widget.imgUrl = item.value.url;
        } else {
          if (dropIn) {
            const widget = this.dWidgets.find((item2) => item2.uuid == dropIn);
            widget.imgUrl = item.value.url;
            console.log("\u52A0\u5165+", widget);
            this.$store.commit("setShowMoveable", true);
          } else {
            this.addWidget(setting);
          }
        }
      } else if (type === "bg") {
        console.log("\u80CC\u666F\u56FE\u7247\u653E\u7F6E");
      } else if (type !== "group") {
        this.addWidget(setting);
      }
    },
    getScreen() {
      let screen = this.$refs["page-design"];
      this.updateScreen({
        width: screen.offsetWidth,
        height: screen.offsetHeight
      });
    },
    async handleMouseMove(e2) {
      const pImg = new PointImg(e2.target);
      const { rgba } = pImg.getColorXY(e2.offsetX, e2.offsetY);
      if (rgba && rgba === "rgba(0,0,0,0)") {
        console.log("\u89E3\u6790\u70B9\u4F4D\u989C\u8272: ", rgba);
        let target = await getTarget(e2.target);
        target.style.pointerEvents = "none";
        setTimeout(() => {
          target.style.pointerEvents = "auto";
        }, 300);
      }
    },
    async handleSelection(e2) {
      if (e2.which === 3) {
        return;
      }
      let target = await getTarget(e2.target);
      let type = target.getAttribute("data-type");
      if (type) {
        let uuid = target.getAttribute("data-uuid");
        if (uuid !== "-1" && !this.dAltDown) {
          let widget = this.dWidgets.find((item) => item.uuid === uuid);
          if (widget.parent !== "-1" && widget.parent !== this.dActiveElement.uuid && widget.parent !== this.dActiveElement.parent) {
            uuid = widget.parent;
          }
        }
        if (this.showRotatable !== false) {
          this.selectWidget({
            uuid
          });
        }
        if (uuid !== "-1") {
          this.initmovement && this.initmovement(e2);
        }
      } else {
        this.selectWidget({
          uuid: "-1"
        });
      }
    },
    getlayers() {
      return this.dWidgets.filter((item) => item.parent === this.dPage.uuid);
    },
    getChilds(uuid) {
      return this.dWidgets.filter((item) => item.parent === uuid);
    }
  }
});
const _hoisted_1$L = ["id", "data-type", "data-uuid"];
function _sfc_render$K(_ctx, _cache, $props, $setup, $data, $options) {
  var _a2, _b, _c, _d, _e, _f, _g;
  return openBlock(), createElementBlock("div", {
    id: "page-design",
    ref: "page-design",
    style: normalizeStyle({ paddingTop: _ctx.dPaddingTop + "px", minHeight: "81vh" })
  }, [
    createElementVNode("div", {
      id: "out-page",
      class: "out-page",
      style: normalizeStyle({
        width: _ctx.dPage.width * _ctx.dZoom / 100 + 120 + "px",
        height: _ctx.dPage.height * _ctx.dZoom / 100 + 120 + "px",
        opacity: 1 - (_ctx.dZoom < 100 ? _ctx.dPage.tag : 0)
      })
    }, [
      renderSlot(_ctx.$slots, "default", {}, void 0, true),
      createElementVNode("div", {
        id: _ctx.pageDesignCanvasId,
        class: "design-canvas",
        "data-type": _ctx.dPage.type,
        "data-uuid": _ctx.dPage.uuid,
        style: normalizeStyle({
          width: _ctx.dPage.width + "px",
          height: _ctx.dPage.height + "px",
          transform: "scale(" + _ctx.dZoom / 100 + ")",
          transformOrigin: (_ctx.dZoom >= 100 ? "center" : "left") + " top",
          backgroundColor: _ctx.dPage.backgroundColor,
          backgroundImage: `url(${(_a2 = _ctx.dPage) == null ? void 0 : _a2.backgroundImage})`,
          backgroundSize: ((_c = (_b = _ctx.dPage) == null ? void 0 : _b.backgroundTransform) == null ? void 0 : _c.x) ? "auto" : "cover",
          backgroundPositionX: (((_e = (_d = _ctx.dPage) == null ? void 0 : _d.backgroundTransform) == null ? void 0 : _e.x) || 0) + "px",
          backgroundPositionY: (((_g = (_f = _ctx.dPage) == null ? void 0 : _f.backgroundTransform) == null ? void 0 : _g.y) || 0) + "px",
          opacity: _ctx.dPage.opacity + (_ctx.dZoom < 100 ? _ctx.dPage.tag : 0)
        }),
        onMousemove: _cache[0] || (_cache[0] = ($event) => _ctx.dropOver($event)),
        onDrop: _cache[1] || (_cache[1] = ($event) => _ctx.drop($event)),
        onMouseup: _cache[2] || (_cache[2] = ($event) => _ctx.drop($event))
      }, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.getlayers(), (layer) => {
          return openBlock(), createBlock(resolveDynamicComponent(layer.type), {
            id: layer.uuid,
            key: layer.uuid,
            class: normalizeClass(["layer", { "layer-hover": layer.uuid === _ctx.dHoverUuid || _ctx.dActiveElement.parent === layer.uuid, "layer-no-hover": _ctx.dActiveElement.uuid === layer.uuid }]),
            "data-title": layer.type,
            params: layer,
            parent: _ctx.dPage,
            "data-type": layer.type,
            "data-uuid": layer.uuid
          }, {
            default: withCtx(() => [
              layer.isContainer ? (openBlock(true), createElementBlock(Fragment, { key: 0 }, renderList(_ctx.getChilds(layer.uuid), (widget) => {
                return openBlock(), createBlock(resolveDynamicComponent(widget.type), {
                  key: widget.uuid,
                  child: "",
                  class: normalizeClass(["layer", { "layer-no-hover": _ctx.dActiveElement.uuid !== widget.parent && _ctx.dActiveElement.parent !== widget.parent }]),
                  "data-title": widget.type,
                  params: widget,
                  parent: layer,
                  "data-type": widget.type,
                  "data-uuid": widget.uuid
                }, null, 8, ["class", "data-title", "params", "parent", "data-type", "data-uuid"]);
              }), 128)) : createCommentVNode("", true)
            ]),
            _: 2
          }, 1032, ["id", "class", "data-title", "params", "parent", "data-type", "data-uuid"]);
        }), 128))
      ], 44, _hoisted_1$L)
    ], 4)
  ], 4);
}
var designBoard = /* @__PURE__ */ _export_sfc(_sfc_main$O, [["render", _sfc_render$K], ["__scopeId", "data-v-0d933bce"]]);
var __glob_0_0 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": designBoard
}, Symbol.toStringTag, { value: "Module" }));
function addMouseWheel(el, cb, altLimit = true) {
  const box = typeof el === "string" ? document.getElementById(el) : el;
  addEvent(box, "mousewheel", (e2) => {
    const ev = e2 || window.event;
    const down = ev.wheelDelta ? ev.wheelDelta < 0 : ev.detail > 0;
    if (altLimit && erpStore.getters.dAltDown) {
      ev.preventDefault();
      cb(down);
    } else if (!altLimit) {
      ev.preventDefault();
      cb(down);
    }
    return false;
  });
}
function addEvent(obj, xEvent, fn2) {
  if (obj.attachEvent) {
    obj.attachEvent("on" + xEvent, fn2);
  } else {
    obj.addEventListener(xEvent, fn2, false);
  }
}
var zoomControl_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$k = "zoom-control";
let holder = null;
const _sfc_main$N = {
  name: NAME$k,
  data() {
    return {
      hideControl: false,
      activezoomIndex: 0,
      zoomList: [
        {
          text: "25%",
          value: 25
        },
        {
          text: "50%",
          value: 50
        },
        {
          text: "75%",
          value: 75
        },
        {
          text: "100%",
          value: 100
        },
        {
          text: "125%",
          value: 125
        },
        {
          text: "150%",
          value: 150
        },
        {
          text: "200%",
          value: 200
        },
        {
          text: "\u6700\u4F73\u5C3A\u5BF8",
          value: -1
        }
      ],
      show: false,
      zoom: {
        value: 0,
        text: 0
      },
      otherList: [
        {
          text: "250%",
          value: 250
        },
        {
          text: "300%",
          value: 300
        },
        {
          text: "350%",
          value: 350
        },
        {
          text: "400%",
          value: 400
        },
        {
          text: "450%",
          value: 450
        },
        {
          text: "500%",
          value: 500
        }
      ],
      otherIndex: -1,
      bestZoom: 0
    };
  },
  computed: {
    ...mapGetters(["dPage", "dScreen", "zoomScreenChange", "dZoom"])
  },
  watch: {
    activezoomIndex(value) {
      if (value < 0 || value > this.zoomList.length - 1) {
        return;
      }
      this.zoom = JSON.parse(JSON.stringify(this.zoomList[value]));
    },
    otherIndex(value) {
      if (value < 0 || value > this.otherList.length - 1) {
        return;
      }
      this.zoom = JSON.parse(JSON.stringify(this.otherList[value]));
    },
    zoom(value) {
      let realValue = value.value;
      if (realValue === -1) {
        realValue = this.calcZoom();
      }
      this.updateZoom(realValue);
      this.autoFixTop();
    },
    dScreen: {
      handler() {
        this.screenChange();
      },
      deep: true
    },
    zoomScreenChange() {
      this.activezoomIndex = this.zoomList.length - 1;
      this.screenChange();
    },
    dPage: {
      handler(val) {
        this.screenChange();
      },
      deep: true
    }
  },
  async mounted() {
    await this.$nextTick();
    window.addEventListener("click", this.close);
    this.activezoomIndex = this.zoomList.length - 1;
    addMouseWheel("page-design", (isDown) => {
      this.mousewheelZoom(isDown);
    });
    window.addEventListener("resize", (event) => {
      this.changeScreen();
    });
  },
  beforeUnmount() {
    window.removeEventListener("click", this.close);
  },
  methods: {
    ...mapActions(["updateZoom", "updateScreen"]),
    changeScreen() {
      clearTimeout(holder);
      holder = setTimeout(() => {
        const screen = document.getElementById("page-design");
        this.updateScreen({
          width: screen.offsetWidth,
          height: screen.offsetHeight
        });
      }, 300);
    },
    screenChange() {
      if (this.activezoomIndex === this.zoomList.length - 1) {
        this.updateZoom(this.calcZoom() < 0 ? 50 : this.calcZoom());
        this.autoFixTop();
      }
    },
    selectItem(index2) {
      this.activezoomIndex = index2;
      this.otherIndex = -1;
      this.show = false;
    },
    close(e2) {
      this.show = false;
    },
    add() {
      this.curAction = "add";
      this.show = false;
      if (this.activezoomIndex === this.zoomList.length - 2 || this.activezoomIndex === this.zoomList.length - 1) {
        this.activezoomIndex = this.zoomList.length;
        if (this.bestZoom) {
          this.nearZoom(true);
        } else {
          this.otherIndex += 1;
        }
        return;
      }
      if (this.activezoomIndex != this.zoomList.length) {
        this.activezoomIndex++;
        return;
      }
      if (this.otherIndex < this.otherList.length - 1) {
        this.otherIndex++;
      }
    },
    sub() {
      this.curAction = null;
      this.show = false;
      if (this.otherIndex === 0) {
        this.otherIndex = -1;
        this.activezoomIndex = this.zoomList.length - 2;
        return;
      }
      if (this.otherIndex != -1) {
        this.otherIndex--;
        return;
      }
      if (this.activezoomIndex === this.zoomList.length - 1) {
        if (this.bestZoom) {
          this.nearZoom();
        } else {
          this.activezoomIndex = this.zoomList.length - 2;
        }
        return;
      }
      if (this.activezoomIndex != 0) {
        this.activezoomIndex--;
      }
    },
    mousewheelZoom(down) {
      const value = Number(this.dZoom.toFixed(0));
      if (down && value <= 1)
        return;
      this.updateZoom(down ? value - 1 : value + 1);
      this.zoom.text = value + "%";
      this.autoFixTop();
    },
    nearZoom(add2) {
      for (let i = 0; i < this.zoomList.length; i++) {
        this.activezoomIndex = i;
        if (this.zoomList[i].value > this.bestZoom) {
          if (add2)
            break;
        } else if (this.zoomList[i].value < this.bestZoom) {
          if (!add2)
            break;
        }
      }
      this.bestZoom = 0;
    },
    calcZoom() {
      let widthZoom = (this.dScreen.width - 142) * 100 / this.dPage.width;
      let heightZoom = (this.dScreen.height - 122) * 100 / this.dPage.height;
      this.bestZoom = Math.min(widthZoom, heightZoom);
      return this.bestZoom;
    },
    async autoFixTop() {
      await this.$nextTick();
      const presetPadding = 60;
      const el = document.getElementById("out-page");
      const parentHeight = el.offsetParent.offsetHeight - 54;
      let padding = (parentHeight - el.offsetHeight) / 2;
      if (typeof this.curAction === "undefined") {
        padding += presetPadding / 2;
      }
      this.curAction === "add" && (padding -= presetPadding);
      this.$store.commit("updatePaddingTop", padding > 0 ? padding : 0);
    }
  }
};
const _withScopeId$n = (n) => (pushScopeId("data-v-b25ad5c0"), n = n(), popScopeId(), n);
const _hoisted_1$K = { id: "zoom-control" };
const _hoisted_2$D = { class: "zoom-selecter" };
const _hoisted_3$z = ["onClick"];
const _hoisted_4$u = {
  key: 0,
  class: "iconfont icon-selected"
};
const _hoisted_5$o = {
  key: 0,
  class: "zoom-control-wrap"
};
const _hoisted_6$i = /* @__PURE__ */ _withScopeId$n(() => /* @__PURE__ */ createElementVNode("i", { class: "iconfont icon-sub" }, null, -1));
const _hoisted_7$e = [
  _hoisted_6$i
];
const _hoisted_8$b = /* @__PURE__ */ _withScopeId$n(() => /* @__PURE__ */ createElementVNode("i", { class: "iconfont icon-add" }, null, -1));
const _hoisted_9$7 = [
  _hoisted_8$b
];
function _sfc_render$J(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$K, [
    withDirectives(createElementVNode("ul", _hoisted_2$D, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($data.zoomList, (item, index2) => {
        return openBlock(), createElementBlock("li", {
          key: index2,
          class: normalizeClass(["zoom-item", { "zoom-item-active": $data.activezoomIndex === index2 }]),
          onClick: withModifiers(($event) => $options.selectItem(index2), ["stop"])
        }, [
          createElementVNode("span", null, toDisplayString(item.text), 1),
          $data.activezoomIndex === index2 ? (openBlock(), createElementBlock("i", _hoisted_4$u)) : createCommentVNode("", true)
        ], 10, _hoisted_3$z);
      }), 128))
    ], 512), [
      [vShow, $data.show]
    ]),
    !$data.hideControl ? (openBlock(), createElementBlock("div", _hoisted_5$o, [
      createElementVNode("div", {
        class: normalizeClass(["zoom-icon radius-left", { disable: $data.activezoomIndex === 0 }]),
        onClick: _cache[0] || (_cache[0] = withModifiers(($event) => $data.activezoomIndex > 0 ? $options.sub() : "", ["stop"]))
      }, _hoisted_7$e, 2),
      createElementVNode("div", {
        class: normalizeClass(["zoom-text", { "zoom-text-active": $data.show }]),
        onClick: _cache[1] || (_cache[1] = withModifiers(($event) => $data.show = !$data.show, ["stop"]))
      }, toDisplayString($data.zoom.text), 3),
      createElementVNode("div", {
        class: normalizeClass(["zoom-icon radius-right", { disable: $data.otherIndex === $data.otherList.length - 1 }]),
        onClick: _cache[2] || (_cache[2] = withModifiers(($event) => $data.otherIndex < $data.otherList.length - 1 ? $options.add() : "", ["stop"]))
      }, _hoisted_9$7, 2)
    ])) : createCommentVNode("", true)
  ]);
}
var zoomControl = /* @__PURE__ */ _export_sfc(_sfc_main$N, [["render", _sfc_render$J], ["__scopeId", "data-v-b25ad5c0"]]);
var __glob_0_3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": zoomControl
}, Symbol.toStringTag, { value: "Module" }));
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$3 = function(d, b) {
  extendStatics$3 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics$3(d, b);
};
function __extends$3(d, b) {
  extendStatics$3(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var Ruler = /* @__PURE__ */ function(_super) {
  __extends$3(Ruler2, _super);
  function Ruler2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = {
      scrollPos: 0
    };
    _this.width = 0;
    _this.height = 0;
    return _this;
  }
  var __proto = Ruler2.prototype;
  __proto.render = function() {
    return createElement$1("canvas", {
      ref: ref(this, "canvasElement"),
      style: this.props.style
    });
  };
  __proto.componentDidMount = function() {
    var canvas = this.canvasElement;
    var context = canvas.getContext("2d");
    this.canvasContext = context;
    this.resize();
  };
  __proto.componentDidUpdate = function() {
    this.resize();
  };
  __proto.scroll = function(scrollPos) {
    this.draw(scrollPos);
  };
  __proto.resize = function() {
    var canvas = this.canvasElement;
    var _a2 = this.props, width = _a2.width, height = _a2.height, scrollPos = _a2.scrollPos;
    this.width = width || canvas.offsetWidth;
    this.height = height || canvas.offsetHeight;
    canvas.width = this.width * 2;
    canvas.height = this.height * 2;
    this.draw(scrollPos);
  };
  __proto.draw = function(scrollPos) {
    if (scrollPos === void 0) {
      scrollPos = this.state.scrollPos;
    }
    var props2 = this.props;
    var _a2 = props2, unit = _a2.unit, zoom = _a2.zoom, type = _a2.type, backgroundColor2 = _a2.backgroundColor, lineColor = _a2.lineColor, textColor = _a2.textColor, direction2 = _a2.direction, _b = _a2.negativeRuler, negativeRuler = _b === void 0 ? true : _b, _c = _a2.segment, segment = _c === void 0 ? 10 : _c, textFormat = _a2.textFormat, _d = _a2.range, range = _d === void 0 ? [-Infinity, Infinity] : _d;
    var width = this.width;
    var height = this.height;
    var state = this.state;
    state.scrollPos = scrollPos;
    var context = this.canvasContext;
    var isHorizontal = type === "horizontal";
    var isDirectionStart = direction2 === "start";
    var isNegative = negativeRuler !== false;
    var font = props2.font || "10px sans-serif";
    var textAlign2 = props2.textAlign || "left";
    var textOffset = props2.textOffset || [0, 0];
    var containerSize = isHorizontal ? height : width;
    var mainLineSize = convertUnitSize("" + (props2.mainLineSize || "100%"), containerSize);
    var longLineSize = convertUnitSize("" + (props2.longLineSize || 10), containerSize);
    var shortLineSize = convertUnitSize("" + (props2.shortLineSize || 7), containerSize);
    if (backgroundColor2 === "transparent") {
      context.clearRect(0, 0, width * 2, height * 2);
    } else {
      context.rect(0, 0, width * 2, height * 2);
      context.fillStyle = backgroundColor2;
      context.fill();
    }
    context.save();
    context.scale(2, 2);
    context.strokeStyle = lineColor;
    context.lineWidth = 1;
    context.font = font;
    context.fillStyle = textColor;
    if (isDirectionStart) {
      context.textBaseline = "top";
    }
    context.translate(0.5, 0);
    context.beginPath();
    var size = isHorizontal ? width : height;
    var zoomUnit = zoom * unit;
    var minRange = Math.floor(scrollPos * zoom / zoomUnit);
    var maxRange = Math.ceil((scrollPos * zoom + size) / zoomUnit);
    var length = maxRange - minRange;
    var alignOffset = Math.max(["left", "center", "right"].indexOf(textAlign2) - 1, -1);
    for (var i = 0; i <= length; ++i) {
      var value = i + minRange;
      if (!isNegative && value < 0) {
        continue;
      }
      var startValue = value * unit;
      var startPos = (startValue - scrollPos) * zoom;
      for (var j2 = 0; j2 < segment; ++j2) {
        var pos = startPos + j2 / segment * zoomUnit;
        var value_1 = startValue + j2 / segment * unit;
        if (pos < 0 || pos >= size || value_1 < range[0] || value_1 > range[1]) {
          continue;
        }
        var lineSize = j2 === 0 ? mainLineSize : j2 % 2 === 0 ? longLineSize : shortLineSize;
        var _e = isHorizontal ? [pos, isDirectionStart ? 0 : height - lineSize] : [isDirectionStart ? 0 : width - lineSize, pos], x1 = _e[0], y1 = _e[1];
        var _f = isHorizontal ? [x1, y1 + lineSize] : [x1 + lineSize, y1], x2 = _f[0], y2 = _f[1];
        context.moveTo(x1, y1);
        context.lineTo(x2, y2);
      }
      if (startPos < -zoomUnit || startPos >= size + unit * zoom || startValue < range[0] || startValue > range[1]) {
        continue;
      }
      var _g = isHorizontal ? [startPos + alignOffset * -3, isDirectionStart ? 17 : height - 17] : [isDirectionStart ? 17 : width - 17, startPos + alignOffset * 3], startX = _g[0], startY = _g[1];
      var text = "" + startValue;
      if (textFormat) {
        text = textFormat(startValue);
      }
      context.textAlign = textAlign2;
      if (isHorizontal) {
        context.fillText(text, startX + textOffset[0], startY + textOffset[1]);
      } else {
        context.save();
        context.translate(startX + textOffset[0], startY + textOffset[1]);
        context.rotate(-Math.PI / 2);
        context.fillText(text, 0, 0);
        context.restore();
      }
    }
    context.stroke();
    context.restore();
  };
  Ruler2.defaultProps = {
    type: "horizontal",
    zoom: 1,
    width: 0,
    height: 0,
    unit: 50,
    negativeRuler: true,
    mainLineSize: "100%",
    longLineSize: 10,
    shortLineSize: 7,
    segment: 10,
    direction: "end",
    style: {
      width: "100%",
      height: "100%"
    },
    backgroundColor: "#333333",
    font: "10px sans-serif",
    textColor: "#ffffff",
    lineColor: "#777777",
    range: [-Infinity, Infinity]
  };
  return Ruler2;
}(PureComponent);
var PROPERTIES$2 = ["type", "width", "height", "unit", "zoom", "style", "backgroundColor", "lineColor", "textColor", "direction", "textFormat", "scrollPos", "textAlign", "mainLineSize", "longLineSize", "shortLineSize", "negativeRuler", "textOffset", "font", "segment"];
var Ruler$1 = Ruler;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$2 = function(d, b) {
  extendStatics$2 = Object.setPrototypeOf || {
    __proto__: []
  } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics$2(d, b);
};
function __extends$2(d, b) {
  extendStatics$2(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$2 = function() {
  __assign$2 = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$2.apply(this, arguments);
};
function prefix$1() {
  var classNames = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    classNames[_i] = arguments[_i];
  }
  return prefixNames.apply(void 0, ["scena-"].concat(classNames));
}
prefix$1("ruler");
var ADDER = prefix$1("guide", "adder");
var GUIDES = prefix$1("guides");
var GUIDE = prefix$1("guide");
var DRAGGING = prefix$1("dragging");
var DISPLAY_DRAG = prefix$1("display-drag");
var GUIDES_CSS = prefixCSS("scena-", '\n{\n    position: relative;\n    width: 100%;\n    height: 100%;\n}\ncanvas {\n    position: relative;\n}\n.guide-origin {\n    position: absolute;\n    width: 1px;\n    height: 1px;\n    top: 0;\n    left: 0;\n    opacity: 0;\n}\n.guides {\n    position: absolute;\n    bottom: 0;\n    right: 0;\n    will-change: transform;\n    z-index: 2000;\n}\n.guide-pos {\n    position: absolute;\n    font-weight: bold;\n    font-size: 12px;\n    color: #f33;\n}\n.horizontal .guide-pos {\n    bottom: 100%;\n    left: 50%;\n    transform: translate(-50%);\n}\n.vertical .guide-pos {\n    left: calc(100% + 2px);\n    top: 50%;\n    transform: translateY(-50%);\n}\n.display-drag {\n    position: absolute;\n    will-change: transform;\n    z-index: 2000;\n    font-weight: bold;\n    font-size: 12px;\n    display: none;\n    left: 20px;\n    top: -20px;\n    color: #f33;\n}\n:host.horizontal .guides {\n    width: 100%;\n    height: 0;\n}\n:host.vertical .guides {\n    height: 100%;\n    width: 0;\n}\n.guide {\n    position: absolute;\n    background: #f33;\n    z-index: 2;\n}\n.guide.dragging:before {\n    position: absolute;\n    content: "";\n    width: 100%;\n    height: 100%;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n}\n:host.horizontal .guide {\n    width: 100%;\n    height: 1px;\n    cursor: row-resize;\n}\n:host.vertical .guide {\n    width: 1px;\n    height: 100%;\n    cursor: col-resize;\n}\n.mobile :host.horizontal .guide {\n    transform: scale(1, 2);\n}\n.mobile :host.vertical .guide {\n    transform: scale(2, 1);\n}\n:host.horizontal .guide:before {\n    height: 20px;\n}\n:host.vertical .guide:before {\n    width: 20px;\n}\n.adder {\n    display: none;\n}\n.adder.dragging {\n    display: block;\n}\n');
var PROPERTIES$1 = ["className", "rulerStyle", "snapThreshold", "snaps", "displayDragPos", "cspNonce", "dragPosFormat", "defaultGuides", "showGuides"].concat(PROPERTIES$2);
var METHODS$1 = ["getGuides", "loadGuides", "scroll", "scrollGuides", "resize"];
var EVENTS$1 = ["changeGuides", "dragStart", "drag", "dragEnd", "clickRuler"];
var GuidesElement = styled("div", GUIDES_CSS);
var Guides$3 = /* @__PURE__ */ function(_super) {
  __extends$2(Guides2, _super);
  function Guides2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.state = {
      guides: []
    };
    _this.scrollPos = 0;
    _this.guideElements = [];
    _this._isFirstMove = false;
    _this.onDragStart = function(e2) {
      var datas = e2.datas, inputEvent = e2.inputEvent;
      _this._isFirstMove = true;
      _this.movePos(e2);
      _this.props.onDragStart(__assign$2({}, e2, {
        dragElement: datas.target
      }));
      inputEvent.stopPropagation();
      inputEvent.preventDefault();
    };
    _this.onDrag = function(e2) {
      if (_this._isFirstMove) {
        _this._isFirstMove = false;
        addClass(e2.datas.target, DRAGGING);
      }
      var nextPos = _this.movePos(e2);
      _this.props.onDrag(__assign$2({}, e2, {
        dragElement: e2.datas.target
      }));
      return nextPos;
    };
    _this.onDragEnd = function(e2) {
      var datas = e2.datas, isDouble = e2.isDouble, distX = e2.distX, distY = e2.distY;
      var pos = _this.movePos(e2);
      var guides = _this.state.guides;
      var _a2 = _this.props, onChangeGuides = _a2.onChangeGuides, zoom = _a2.zoom, displayDragPos = _a2.displayDragPos, digit = _a2.digit, lockGuides = _a2.lockGuides;
      var guidePos = parseFloat((pos / zoom).toFixed(digit || 0));
      if (displayDragPos) {
        _this.displayElement.style.cssText += "display: none;";
      }
      removeClass(datas.target, DRAGGING);
      _this.props.onDragEnd(__assign$2({}, e2, {
        dragElement: datas.target
      }));
      if (datas.fromRuler) {
        if (_this._isFirstMove) {
          _this.props.onClickRuler(__assign$2({}, e2, {
            pos: 0
          }));
        }
        if (guidePos >= _this.scrollPos && guides.indexOf(guidePos) < 0) {
          _this.setState({
            guides: guides.concat([guidePos])
          }, function() {
            onChangeGuides({
              guides: _this.state.guides,
              distX,
              distY,
              isAdd: true,
              isRemove: false,
              isChange: false
            });
          });
        }
      } else {
        var index2 = datas.target.getAttribute("data-index");
        var isRemove_1 = false;
        var isChange_1 = false;
        guides = guides.slice();
        if (isDouble || guidePos < _this.scrollPos) {
          if (lockGuides && (lockGuides === true || lockGuides.indexOf("remove") > -1)) {
            return;
          }
          guides.splice(index2, 1);
          isRemove_1 = true;
        } else if (guides.indexOf(guidePos) > -1) {
          return;
        } else {
          if (lockGuides && (lockGuides === true || lockGuides.indexOf("change") > -1)) {
            return;
          }
          guides[index2] = guidePos;
          isChange_1 = true;
        }
        _this.setState({
          guides
        }, function() {
          var nextGuides = _this.state.guides;
          onChangeGuides({
            distX,
            distY,
            guides: nextGuides,
            isAdd: false,
            isChange: isChange_1,
            isRemove: isRemove_1
          });
        });
      }
    };
    return _this;
  }
  var __proto = Guides2.prototype;
  __proto.render = function() {
    var _a2 = this.props, className = _a2.className, type = _a2.type, zoom = _a2.zoom, style = _a2.style, rulerStyle = _a2.rulerStyle, displayDragPos = _a2.displayDragPos, cspNonce = _a2.cspNonce, dragGuideStyle = _a2.dragGuideStyle, portalContainer = _a2.portalContainer;
    var props2 = this.props;
    var translateName = this.getTranslateName();
    var rulerProps = {};
    PROPERTIES$2.forEach(function(name2) {
      if (name2 === "style") {
        return;
      }
      rulerProps[name2] = props2[name2];
    });
    return createElement$1(GuidesElement, {
      ref: ref(this, "manager"),
      cspNonce,
      className: prefix$1("manager", type) + " " + className,
      portalContainer,
      style
    }, createElement$1("div", {
      className: prefix$1("guide-origin"),
      ref: ref(this, "originElement")
    }), createElement$1(Ruler$1, __assign$2({
      ref: ref(this, "ruler"),
      style: rulerStyle
    }, rulerProps)), createElement$1("div", {
      className: GUIDES,
      ref: ref(this, "guidesElement"),
      style: {
        transform: translateName + "(" + -this.scrollPos * zoom + "px)"
      }
    }, displayDragPos && createElement$1("div", {
      className: DISPLAY_DRAG,
      ref: ref(this, "displayElement"),
      style: dragGuideStyle
    }), createElement$1("div", {
      className: ADDER,
      ref: ref(this, "adderElement")
    }), this.renderGuides()));
  };
  __proto.renderGuides = function() {
    var _this = this;
    var props2 = this.props;
    var _a2 = props2, type = _a2.type, zoom = _a2.zoom, showGuides = _a2.showGuides, guideStyle = _a2.guideStyle, displayGuidePos = _a2.displayGuidePos, _b = _a2.guidePosStyle, guidePosStyle = _b === void 0 ? {} : _b;
    var translateName = this.getTranslateName();
    var guides = this.state.guides;
    var guidePosFormat = props2.guidePosFormat || props2.dragPosFormat || function(v) {
      return v;
    };
    this.guideElements = [];
    if (showGuides) {
      return guides.map(function(pos, i) {
        return createElement$1("div", {
          className: prefix$1("guide", type),
          ref: refs(_this, "guideElements", i),
          key: i,
          "data-index": i,
          "data-pos": pos,
          style: __assign$2({}, guideStyle, {
            transform: translateName + "(" + pos * zoom + "px) translateZ(0px)"
          })
        }, displayGuidePos && createElement$1("div", {
          className: prefix$1("guide-pos"),
          style: guidePosStyle || {}
        }, guidePosFormat(pos)));
      });
    }
    return;
  };
  __proto.componentDidMount = function() {
    var _this = this;
    this.gesto = new Gesto(this.manager.getElement(), {
      container: document.body
    }).on("dragStart", function(e2) {
      var _a2 = _this.props, type = _a2.type, zoom = _a2.zoom, lockGuides = _a2.lockGuides;
      if (lockGuides === true) {
        e2.stop();
        return;
      }
      var inputEvent = e2.inputEvent;
      var target = inputEvent.target;
      var datas = e2.datas;
      var canvasElement = _this.ruler.canvasElement;
      var guidesElement = _this.guidesElement;
      var isHorizontal = type === "horizontal";
      var originRect = _this.originElement.getBoundingClientRect();
      var matrix2 = getDistElementMatrix(_this.manager.getElement());
      var offsetPos = calculateMatrixDist(matrix2, [e2.clientX - originRect.left, e2.clientY - originRect.top]);
      offsetPos[0] -= guidesElement.offsetLeft;
      offsetPos[1] -= guidesElement.offsetTop;
      offsetPos[isHorizontal ? 1 : 0] += _this.scrollPos * zoom;
      datas.offsetPos = offsetPos;
      datas.matrix = matrix2;
      var isLockAdd = lockGuides && lockGuides.indexOf("add") > -1;
      var isLockRemove = lockGuides && lockGuides.indexOf("remove") > -1;
      var isLockChange = lockGuides && lockGuides.indexOf("change") > -1;
      if (target === canvasElement) {
        if (isLockAdd) {
          e2.stop();
          return;
        }
        datas.fromRuler = true;
        datas.target = _this.adderElement;
      } else if (hasClass(target, GUIDE)) {
        if (isLockRemove && isLockChange) {
          e2.stop();
          return;
        }
        datas.target = target;
      } else {
        e2.stop();
        return false;
      }
      _this.onDragStart(e2);
    }).on("drag", this.onDrag).on("dragEnd", this.onDragEnd);
    this.setState({
      guides: this.props.defaultGuides || []
    });
  };
  __proto.componentWillUnmount = function() {
    this.gesto.unset();
  };
  __proto.componentDidUpdate = function(prevProps) {
    if (prevProps.defaultGuides !== this.props.defaultGuides) {
      this.setState({
        guides: this.props.defaultGuides || []
      });
    }
  };
  __proto.loadGuides = function(guides) {
    this.setState({
      guides
    });
  };
  __proto.getGuides = function() {
    return this.state.guides;
  };
  __proto.scrollGuides = function(pos) {
    var zoom = this.props.zoom;
    var guidesElement = this.guidesElement;
    this.scrollPos = pos;
    guidesElement.style.transform = this.getTranslateName() + "(" + -pos * zoom + "px)";
    var guides = this.state.guides;
    this.guideElements.forEach(function(el, i) {
      if (!el) {
        return;
      }
      el.style.display = -pos + guides[i] < 0 ? "none" : "block";
    });
  };
  __proto.resize = function() {
    this.ruler.resize();
  };
  __proto.scroll = function(pos) {
    this.ruler.scroll(pos);
  };
  __proto.movePos = function(e2) {
    var datas = e2.datas, distX = e2.distX, distY = e2.distY;
    var props2 = this.props;
    var type = props2.type, zoom = props2.zoom, snaps = props2.snaps, snapThreshold = props2.snapThreshold, displayDragPos = props2.displayDragPos, digit = props2.digit;
    var dragPosFormat = props2.dragPosFormat || function(v) {
      return v;
    };
    var isHorizontal = type === "horizontal";
    var matrixPos = calculateMatrixDist(datas.matrix, [distX, distY]);
    var offsetPos = datas.offsetPos;
    var offsetX = matrixPos[0] + offsetPos[0];
    var offsetY = matrixPos[1] + offsetPos[1];
    var nextPos = Math.round(isHorizontal ? offsetY : offsetX);
    var guidePos = parseFloat((nextPos / zoom).toFixed(digit || 0));
    var guideSnaps = snaps.slice().sort(function(a2, b) {
      return Math.abs(guidePos - a2) - Math.abs(guidePos - b);
    });
    if (guideSnaps.length && Math.abs(guideSnaps[0] * zoom - nextPos) < snapThreshold) {
      guidePos = guideSnaps[0];
      nextPos = guidePos * zoom;
    }
    if (!datas.fromRuler || !this._isFirstMove) {
      if (displayDragPos) {
        var displayPos = type === "horizontal" ? [offsetX, nextPos] : [nextPos, offsetY];
        this.displayElement.style.cssText += "display: block;transform: translate(-50%, -50%) " + ("translate(" + displayPos.map(function(v) {
          return v + "px";
        }).join(", ") + ")");
        this.displayElement.innerHTML = "" + dragPosFormat(guidePos);
      }
      var target = datas.target;
      target.setAttribute("data-pos", guidePos);
      target.style.transform = this.getTranslateName() + "(" + nextPos + "px)";
    }
    return nextPos;
  };
  __proto.getTranslateName = function() {
    return this.props.type === "horizontal" ? "translateY" : "translateX";
  };
  Guides2.defaultProps = {
    className: "",
    type: "horizontal",
    zoom: 1,
    style: {},
    snapThreshold: 5,
    snaps: [],
    digit: 0,
    onClickRuler: function() {
    },
    onChangeGuides: function() {
    },
    onDragStart: function() {
    },
    onDrag: function() {
    },
    onDragEnd: function() {
    },
    displayDragPos: false,
    dragPosFormat: function(v) {
      return v;
    },
    defaultGuides: [],
    lockGuides: false,
    showGuides: true,
    guideStyle: {},
    dragGuideStyle: {},
    guidePosStyle: {},
    portalContainer: null
  };
  return Guides2;
}(PureComponent);
var ReactGuides = Guides$3;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
var extendStatics$1 = function(d, b) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (b2.hasOwnProperty(p))
        d2[p] = b2[p];
  };
  return extendStatics$1(d, b);
};
function __extends$1(d, b) {
  extendStatics$1(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
function __rest(s, e2) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e2.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e2.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var PROPERTIES = PROPERTIES$1;
var METHODS = METHODS$1;
var EVENTS = EVENTS$1;
var InnerGuides = /* @__PURE__ */ function(_super) {
  __extends$1(InnerGuides2, _super);
  function InnerGuides2(props2) {
    var _this = _super.call(this, props2) || this;
    _this.state = {};
    _this.state = _this.props;
    return _this;
  }
  var __proto = InnerGuides2.prototype;
  __proto.render = function() {
    var _a2 = this.state, container = _a2.container, state = __rest(_a2, ["container"]);
    return createPortal(createElement$1(ReactGuides, __assign$1({
      ref: ref(this, "guides")
    }, state)), container);
  };
  return InnerGuides2;
}(Component$1);
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var __assign$1$1 = function() {
  __assign$1$1 = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$1$1.apply(this, arguments);
};
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a2 = arguments[i], j2 = 0, jl = a2.length; j2 < jl; j2++, k++)
      r[k] = a2[j2];
  return r;
}
var EventEmitter = /* @__PURE__ */ function() {
  function EventEmitter2() {
    this._events = {};
  }
  var __proto = EventEmitter2.prototype;
  __proto.on = function(eventName, listener) {
    if (isObject$2(eventName)) {
      for (var name2 in eventName) {
        this.on(name2, eventName[name2]);
      }
    } else {
      this._addEvent(eventName, listener, {});
    }
    return this;
  };
  __proto.off = function(eventName, listener) {
    if (!eventName) {
      this._events = {};
    } else if (isObject$2(eventName)) {
      for (var name2 in eventName) {
        this.off(name2);
      }
    } else if (!listener) {
      this._events[eventName] = [];
    } else {
      var events2 = this._events[eventName];
      if (events2) {
        var index2 = findIndex(events2, function(e2) {
          return e2.listener === listener;
        });
        if (index2 > -1) {
          events2.splice(index2, 1);
        }
      }
    }
    return this;
  };
  __proto.once = function(eventName, listener) {
    var _this = this;
    if (listener) {
      this._addEvent(eventName, listener, {
        once: true
      });
    }
    return new Promise(function(resolve) {
      _this._addEvent(eventName, resolve, {
        once: true
      });
    });
  };
  __proto.emit = function(eventName, param) {
    var _this = this;
    if (param === void 0) {
      param = {};
    }
    var events2 = this._events[eventName];
    if (!eventName || !events2) {
      return true;
    }
    var isStop = false;
    param.eventType = eventName;
    param.stop = function() {
      isStop = true;
    };
    param.currentTarget = this;
    __spreadArrays(events2).forEach(function(info) {
      info.listener(param);
      if (info.once) {
        _this.off(eventName, info.listener);
      }
    });
    return !isStop;
  };
  __proto.trigger = function(eventName, param) {
    if (param === void 0) {
      param = {};
    }
    return this.emit(eventName, param);
  };
  __proto._addEvent = function(eventName, listener, options) {
    var events2 = this._events;
    events2[eventName] = events2[eventName] || [];
    var listeners = events2[eventName];
    listeners.push(__assign$1$1({
      listener
    }, options));
  };
  return EventEmitter2;
}();
var Guides = /* @__PURE__ */ function(_super) {
  __extends$1(Guides2, _super);
  function Guides2(container, options) {
    if (options === void 0) {
      options = {};
    }
    var _this = _super.call(this) || this;
    _this.tempElement = document.createElement("div");
    var events2 = {};
    EVENTS.forEach(function(name2) {
      events2[camelize$1("on " + name2)] = function(e2) {
        return _this.trigger(name2, e2);
      };
    });
    render(createElement$1(InnerGuides, __assign$1({}, options, events2, {
      container,
      ref: ref(_this, "innerGuides")
    })), _this.tempElement);
    return _this;
  }
  var __proto = Guides2.prototype;
  __proto.setState = function(state, callback) {
    this.innerGuides.setState(state, callback);
  };
  __proto.destroy = function() {
    render(null, this.tempElement);
    this.tempElement = null;
    this.innerGuides = null;
  };
  __proto.getInnerGuides = function() {
    return this.innerGuides.guides;
  };
  Guides2 = __decorate([
    Properties(METHODS, function(prototype, property) {
      if (prototype[property]) {
        return;
      }
      prototype[property] = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var self2 = this.getInnerGuides();
        if (!self2 || !self2[property]) {
          return;
        }
        return self2[property].apply(self2, args);
      };
    }),
    Properties(PROPERTIES, function(prototype, property) {
      Object.defineProperty(prototype, property, {
        get: function() {
          return this.getInnerGuides().props[property];
        },
        set: function(value) {
          var _a2;
          this.innerGuides.setState((_a2 = {}, _a2[property] = value, _a2));
        },
        enumerable: true,
        configurable: true
      });
    })
  ], Guides2);
  return Guides2;
}(EventEmitter);
var Guides$1 = /* @__PURE__ */ function(_super) {
  __extends$1(Guides2, _super);
  function Guides2() {
    return _super !== null && _super.apply(this, arguments) || this;
  }
  return Guides2;
}(Guides);
var Guides$2 = Guides$1;
var lineGuides_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$M = defineComponent({
  props: ["show"],
  setup(props2) {
    const store = useStore();
    const container = "page-design";
    let guidesTop = null;
    let guidesLeft = null;
    watch(
      () => props2.show,
      (open) => {
        open ? render2() : destroy2();
      }
    );
    watch(
      () => store.getters.dZoom,
      () => {
        changeScroll();
      }
    );
    function destroy2() {
      guidesTop.destroy();
      guidesLeft.destroy();
      guidesTop = null;
      guidesLeft = null;
    }
    function render2() {
      const sameParams = {
        backgroundColor: "#f9f9fa",
        lineColor: "#bec2c7",
        textColor: "#999999",
        displayDragPos: true,
        dragPosFormat: (v) => v + "px"
      };
      guidesTop = new Guides$2(document.getElementById(container), {
        ...sameParams,
        type: "horizontal",
        className: "my-horizontal"
      }).on("changeGuides", (e2) => {
        console.log(e2, e2.guides);
      });
      guidesLeft = new Guides$2(document.getElementById(container), {
        ...sameParams,
        type: "vertical",
        className: "my-vertical"
      }).on("changeGuides", (e2) => {
        console.log(e2, e2.guides);
      });
      changeScroll();
    }
    function changeScroll() {
      if (guidesTop && guidesLeft) {
        const zoom = store.getters.dZoom / 100;
        guidesTop.zoom = zoom;
        guidesLeft.zoom = zoom;
        if (zoom < 0.9) {
          guidesTop.unit = Math.floor(1 / zoom) * 50;
          guidesLeft.unit = Math.floor(1 / zoom) * 50;
        }
        setTimeout(() => {
          const el = document.getElementById("out-page");
          const left = 60 + ((el == null ? void 0 : el.offsetLeft) || 0);
          const top = 30 + ((el == null ? void 0 : el.offsetTop) || 0);
          guidesTop.scroll(-left / zoom);
          guidesTop.scrollGuides(-top / zoom);
          guidesLeft.scroll(-top / zoom);
          guidesLeft.scrollGuides(-(left - 30) / zoom);
        }, 300);
      }
    }
  }
});
function _sfc_render$I(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div");
}
var lineGuides = /* @__PURE__ */ _export_sfc(_sfc_main$M, [["render", _sfc_render$I], ["__scopeId", "data-v-ee1a65c4"]]);
var __glob_0_1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": lineGuides
}, Symbol.toStringTag, { value: "Module" }));
var base = "";
var elProgress = "";
/*! Element Plus Icons Vue v2.1.0 */
var export_helper_default = (sfc, props2) => {
  let target = sfc.__vccOpts || sfc;
  for (let [key, val] of props2)
    target[key] = val;
  return target;
};
var upload_filled_vue_vue_type_script_lang_default = {
  name: "UploadFilled"
};
var _hoisted_1274 = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 1024 1024"
}, _hoisted_2274 = /* @__PURE__ */ createElementVNode(
  "path",
  {
    fill: "currentColor",
    d: "M544 864V672h128L512 480 352 672h128v192H320v-1.6c-5.376.32-10.496 1.6-16 1.6A240 240 0 0 1 64 624c0-123.136 93.12-223.488 212.608-237.248A239.808 239.808 0 0 1 512 192a239.872 239.872 0 0 1 235.456 194.752c119.488 13.76 212.48 114.112 212.48 237.248a240 240 0 0 1-240 240c-5.376 0-10.56-1.28-16-1.6v1.6H544z"
  },
  null,
  -1
), _hoisted_3273 = [
  _hoisted_2274
];
function _sfc_render274(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", _hoisted_1274, _hoisted_3273);
}
var upload_filled_default = /* @__PURE__ */ export_helper_default(upload_filled_vue_vue_type_script_lang_default, [["render", _sfc_render274], ["__file", "upload-filled.vue"]]);
var elUpload = "";
var dayjs_min = { exports: {} };
(function(module, exports) {
  !function(t, e2) {
    module.exports = e2();
  }(commonjsGlobal, function() {
    var t = 1e3, e2 = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u2 = "hour", a2 = "day", o = "week", c = "month", f2 = "quarter", h2 = "year", d = "date", l = "Invalid Date", $2 = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
      var e3 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
      return "[" + t2 + (e3[(n2 - 20) % 10] || e3[n2] || e3[0]) + "]";
    } }, m = function(t2, e3, n2) {
      var r2 = String(t2);
      return !r2 || r2.length >= e3 ? t2 : "" + Array(e3 + 1 - r2.length).join(n2) + t2;
    }, v = { s: m, z: function(t2) {
      var e3 = -t2.utcOffset(), n2 = Math.abs(e3), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
      return (e3 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
    }, m: function t2(e3, n2) {
      if (e3.date() < n2.date())
        return -t2(n2, e3);
      var r2 = 12 * (n2.year() - e3.year()) + (n2.month() - e3.month()), i2 = e3.clone().add(r2, c), s2 = n2 - i2 < 0, u3 = e3.clone().add(r2 + (s2 ? -1 : 1), c);
      return +(-(r2 + (n2 - i2) / (s2 ? i2 - u3 : u3 - i2)) || 0);
    }, a: function(t2) {
      return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
    }, p: function(t2) {
      return { M: c, y: h2, w: o, d: a2, D: d, h: u2, m: s, s: i, ms: r, Q: f2 }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
    }, u: function(t2) {
      return void 0 === t2;
    } }, g = "en", D2 = {};
    D2[g] = M;
    var p = function(t2) {
      return t2 instanceof b;
    }, S = function t2(e3, n2, r2) {
      var i2;
      if (!e3)
        return g;
      if ("string" == typeof e3) {
        var s2 = e3.toLowerCase();
        D2[s2] && (i2 = s2), n2 && (D2[s2] = n2, i2 = s2);
        var u3 = e3.split("-");
        if (!i2 && u3.length > 1)
          return t2(u3[0]);
      } else {
        var a3 = e3.name;
        D2[a3] = e3, i2 = a3;
      }
      return !r2 && i2 && (g = i2), i2 || !r2 && g;
    }, w = function(t2, e3) {
      if (p(t2))
        return t2.clone();
      var n2 = "object" == typeof e3 ? e3 : {};
      return n2.date = t2, n2.args = arguments, new b(n2);
    }, O2 = v;
    O2.l = S, O2.i = p, O2.w = function(t2, e3) {
      return w(t2, { locale: e3.$L, utc: e3.$u, x: e3.$x, $offset: e3.$offset });
    };
    var b = function() {
      function M2(t2) {
        this.$L = S(t2.locale, null, true), this.parse(t2);
      }
      var m2 = M2.prototype;
      return m2.parse = function(t2) {
        this.$d = function(t3) {
          var e3 = t3.date, n2 = t3.utc;
          if (null === e3)
            return new Date(NaN);
          if (O2.u(e3))
            return new Date();
          if (e3 instanceof Date)
            return new Date(e3);
          if ("string" == typeof e3 && !/Z$/i.test(e3)) {
            var r2 = e3.match($2);
            if (r2) {
              var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
              return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
            }
          }
          return new Date(e3);
        }(t2), this.$x = t2.x || {}, this.init();
      }, m2.init = function() {
        var t2 = this.$d;
        this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
      }, m2.$utils = function() {
        return O2;
      }, m2.isValid = function() {
        return !(this.$d.toString() === l);
      }, m2.isSame = function(t2, e3) {
        var n2 = w(t2);
        return this.startOf(e3) <= n2 && n2 <= this.endOf(e3);
      }, m2.isAfter = function(t2, e3) {
        return w(t2) < this.startOf(e3);
      }, m2.isBefore = function(t2, e3) {
        return this.endOf(e3) < w(t2);
      }, m2.$g = function(t2, e3, n2) {
        return O2.u(t2) ? this[e3] : this.set(n2, t2);
      }, m2.unix = function() {
        return Math.floor(this.valueOf() / 1e3);
      }, m2.valueOf = function() {
        return this.$d.getTime();
      }, m2.startOf = function(t2, e3) {
        var n2 = this, r2 = !!O2.u(e3) || e3, f3 = O2.p(t2), l2 = function(t3, e4) {
          var i2 = O2.w(n2.$u ? Date.UTC(n2.$y, e4, t3) : new Date(n2.$y, e4, t3), n2);
          return r2 ? i2 : i2.endOf(a2);
        }, $3 = function(t3, e4) {
          return O2.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e4)), n2);
        }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
        switch (f3) {
          case h2:
            return r2 ? l2(1, 0) : l2(31, 11);
          case c:
            return r2 ? l2(1, M3) : l2(0, M3 + 1);
          case o:
            var g2 = this.$locale().weekStart || 0, D3 = (y2 < g2 ? y2 + 7 : y2) - g2;
            return l2(r2 ? m3 - D3 : m3 + (6 - D3), M3);
          case a2:
          case d:
            return $3(v2 + "Hours", 0);
          case u2:
            return $3(v2 + "Minutes", 1);
          case s:
            return $3(v2 + "Seconds", 2);
          case i:
            return $3(v2 + "Milliseconds", 3);
          default:
            return this.clone();
        }
      }, m2.endOf = function(t2) {
        return this.startOf(t2, false);
      }, m2.$set = function(t2, e3) {
        var n2, o2 = O2.p(t2), f3 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a2] = f3 + "Date", n2[d] = f3 + "Date", n2[c] = f3 + "Month", n2[h2] = f3 + "FullYear", n2[u2] = f3 + "Hours", n2[s] = f3 + "Minutes", n2[i] = f3 + "Seconds", n2[r] = f3 + "Milliseconds", n2)[o2], $3 = o2 === a2 ? this.$D + (e3 - this.$W) : e3;
        if (o2 === c || o2 === h2) {
          var y2 = this.clone().set(d, 1);
          y2.$d[l2]($3), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
        } else
          l2 && this.$d[l2]($3);
        return this.init(), this;
      }, m2.set = function(t2, e3) {
        return this.clone().$set(t2, e3);
      }, m2.get = function(t2) {
        return this[O2.p(t2)]();
      }, m2.add = function(r2, f3) {
        var d2, l2 = this;
        r2 = Number(r2);
        var $3 = O2.p(f3), y2 = function(t2) {
          var e3 = w(l2);
          return O2.w(e3.date(e3.date() + Math.round(t2 * r2)), l2);
        };
        if ($3 === c)
          return this.set(c, this.$M + r2);
        if ($3 === h2)
          return this.set(h2, this.$y + r2);
        if ($3 === a2)
          return y2(1);
        if ($3 === o)
          return y2(7);
        var M3 = (d2 = {}, d2[s] = e2, d2[u2] = n, d2[i] = t, d2)[$3] || 1, m3 = this.$d.getTime() + r2 * M3;
        return O2.w(m3, this);
      }, m2.subtract = function(t2, e3) {
        return this.add(-1 * t2, e3);
      }, m2.format = function(t2) {
        var e3 = this, n2 = this.$locale();
        if (!this.isValid())
          return n2.invalidDate || l;
        var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = O2.z(this), s2 = this.$H, u3 = this.$m, a3 = this.$M, o2 = n2.weekdays, c2 = n2.months, f3 = n2.meridiem, h3 = function(t3, n3, i3, s3) {
          return t3 && (t3[n3] || t3(e3, r2)) || i3[n3].slice(0, s3);
        }, d2 = function(t3) {
          return O2.s(s2 % 12 || 12, t3, "0");
        }, $3 = f3 || function(t3, e4, n3) {
          var r3 = t3 < 12 ? "AM" : "PM";
          return n3 ? r3.toLowerCase() : r3;
        };
        return r2.replace(y, function(t3, r3) {
          return r3 || function(t4) {
            switch (t4) {
              case "YY":
                return String(e3.$y).slice(-2);
              case "YYYY":
                return O2.s(e3.$y, 4, "0");
              case "M":
                return a3 + 1;
              case "MM":
                return O2.s(a3 + 1, 2, "0");
              case "MMM":
                return h3(n2.monthsShort, a3, c2, 3);
              case "MMMM":
                return h3(c2, a3);
              case "D":
                return e3.$D;
              case "DD":
                return O2.s(e3.$D, 2, "0");
              case "d":
                return String(e3.$W);
              case "dd":
                return h3(n2.weekdaysMin, e3.$W, o2, 2);
              case "ddd":
                return h3(n2.weekdaysShort, e3.$W, o2, 3);
              case "dddd":
                return o2[e3.$W];
              case "H":
                return String(s2);
              case "HH":
                return O2.s(s2, 2, "0");
              case "h":
                return d2(1);
              case "hh":
                return d2(2);
              case "a":
                return $3(s2, u3, true);
              case "A":
                return $3(s2, u3, false);
              case "m":
                return String(u3);
              case "mm":
                return O2.s(u3, 2, "0");
              case "s":
                return String(e3.$s);
              case "ss":
                return O2.s(e3.$s, 2, "0");
              case "SSS":
                return O2.s(e3.$ms, 3, "0");
              case "Z":
                return i2;
            }
            return null;
          }(t3) || i2.replace(":", "");
        });
      }, m2.utcOffset = function() {
        return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
      }, m2.diff = function(r2, d2, l2) {
        var $3, y2 = this, M3 = O2.p(d2), m3 = w(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e2, g2 = this - m3, D3 = function() {
          return O2.m(y2, m3);
        };
        switch (M3) {
          case h2:
            $3 = D3() / 12;
            break;
          case c:
            $3 = D3();
            break;
          case f2:
            $3 = D3() / 3;
            break;
          case o:
            $3 = (g2 - v2) / 6048e5;
            break;
          case a2:
            $3 = (g2 - v2) / 864e5;
            break;
          case u2:
            $3 = g2 / n;
            break;
          case s:
            $3 = g2 / e2;
            break;
          case i:
            $3 = g2 / t;
            break;
          default:
            $3 = g2;
        }
        return l2 ? $3 : O2.a($3);
      }, m2.daysInMonth = function() {
        return this.endOf(c).$D;
      }, m2.$locale = function() {
        return D2[this.$L];
      }, m2.locale = function(t2, e3) {
        if (!t2)
          return this.$L;
        var n2 = this.clone(), r2 = S(t2, e3, true);
        return r2 && (n2.$L = r2), n2;
      }, m2.clone = function() {
        return O2.w(this.$d, this);
      }, m2.toDate = function() {
        return new Date(this.valueOf());
      }, m2.toJSON = function() {
        return this.isValid() ? this.toISOString() : null;
      }, m2.toISOString = function() {
        return this.$d.toISOString();
      }, m2.toString = function() {
        return this.$d.toUTCString();
      }, M2;
    }(), _ = b.prototype;
    return w.prototype = _, [["$ms", r], ["$s", i], ["$m", s], ["$H", u2], ["$W", a2], ["$M", c], ["$y", h2], ["$D", d]].forEach(function(t2) {
      _[t2[1]] = function(e3) {
        return this.$g(e3, t2[0], t2[1]);
      };
    }), w.extend = function(t2, e3) {
      return t2.$i || (t2(e3, b, w), t2.$i = true), w;
    }, w.locale = S, w.isDayjs = p, w.unix = function(t2) {
      return w(1e3 * t2);
    }, w.en = D2[g], w.Ls = D2, w.p = {}, w;
  });
})(dayjs_min);
var dayjs = dayjs_min.exports;
const prefix = _config.API_URL + "/";
const API = {
  init: prefix + "pic/init",
  getList: prefix + "pic/list",
  getToken: prefix + "pic/getToken",
  delOne: prefix + "pic/delOne",
  rename: prefix + "pic/rename",
  del: prefix + "pic/del"
};
const init = (params = {}) => fetch$1(API.init, params, "post");
const getPicList = (params = {}) => fetch$1(API.getList, params);
const getToken = (params = {}) => fetch$1(API.getToken, params);
const deletePic = (params = {}) => fetch$1(API.delOne, params, "post");
const delPics = (params = {}) => fetch$1(API.del, params, "post");
const reName = (params = {}) => fetch$1(API.rename, params, "post");
var api = {
  init,
  getPicList,
  getToken,
  deletePic,
  delPics,
  reName
};
var Qiniu = {
  upload: async (file, options, cb) => {
    const win = window;
    let name2 = "";
    const suffix = file.type.split("/")[1] || "png";
    if (!options.fullPath) {
      const DT = new Date();
      const YM = `${dayjs(DT).format("YYYY")}/${dayjs(DT).format("MM")}/`;
      const keyName = YM + new Date(DT).getTime();
      const prePath = options.prePath ? options.prePath + "/" : "";
      name2 = `${prePath}${keyName}.${suffix}`;
    } else
      name2 = options.fullPath + `.${suffix}`;
    const token = await api.getToken({ bucket: options.bucket, name: name2 });
    const exOption = {
      useCdnDomain: true
    };
    const observable = win.qiniu.upload(file, name2, token, {}, exOption);
    return new Promise((resolve, reject) => {
      observable.subscribe({
        next: (result) => {
          cb && cb(result);
        },
        error: (e2) => {
          reject(e2);
        },
        complete: (result) => {
          resolve(result);
        }
      });
    });
  }
};
var elNotification = "";
var useNotification = (title, message = "", extra) => {
  ElNotification({
    title,
    message,
    ...extra
  });
};
var index_vue_vue_type_style_index_0_scoped_true_lang$3 = "";
const _sfc_main$L = defineComponent({
  components: { ElUpload },
  props: {
    modelValue: {},
    options: {
      default: () => {
        return { bucket: "xp-design", prePath: "user" };
      }
    },
    hold: {
      default: false
    }
  },
  emits: ["done", "update:modelValue", "load"],
  setup(props2, context) {
    let uploading = false;
    let timer = null;
    let uploadList = [];
    let index2 = 0;
    let count = 0;
    let tempSimpleRes = null;
    onMounted(async () => {
      await nextTick();
      setTimeout(() => {
        const link_element = document.createElement("script");
        link_element.setAttribute("src", _config.QINIUYUN_PLUGIN);
        document.head.appendChild(link_element);
      }, 1e3);
    });
    const upload2 = ({ file }) => {
      if (props2.hold) {
        context.emit("load", file);
        return;
      }
      uploadList.push(file);
      clearTimeout(timer);
      count++;
      updatePercent(null);
      uploadQueue();
    };
    const uploadQueue = async () => {
      if (!uploading) {
        uploading = true;
        const file = uploadList[0];
        if (file) {
          if (file.size <= 1024 * 1024) {
            tempSimpleRes = await qiNiuUpload(file);
            const { width, height } = await getImage(file);
            useNotification("\u4E0A\u4F20\u6210\u529F", "\u516C\u5171\u6D4B\u8BD5\u8D26\u6237\uFF0C\u4E0A\u4F20\u8BF7\u6CE8\u610F\u4FDD\u62A4\u9690\u79C1\u54E6!", { position: "bottom-left" });
            context.emit("done", { width, height, url: _config.IMG_URL + tempSimpleRes.key });
          } else
            useNotification("\u7231\u62A4\u5C0F\u6C34\u7BA1", "\u8BF7\u4E0A\u4F20\u5C0F\u4E8E 1M \u7684\u56FE\u7247\u54E6!", { type: "error", position: "bottom-left" });
          uploading = false;
          handleRemove();
          index2++;
          updatePercent(null);
          uploadQueue();
        } else {
          uploading = false;
          timer = setTimeout(() => {
            index2 = count = 0;
            updatePercent(0);
          }, 3e3);
        }
      }
    };
    const qiNiuUpload = async (file) => {
      updatePercent(0);
      return new Promise(async (resolve) => {
        if (props2.hold) {
          context.emit("load", file);
          resolve();
        } else {
          const result = await Qiniu.upload(file, props2.options, (res) => {
            updatePercent(res.total.percent);
          });
          resolve(result);
        }
      });
    };
    const updatePercent = (p) => {
      const num = typeof p === "number" ? String(p) : p;
      const percent = { ...props2.modelValue };
      percent.num = num ? Number(num).toFixed(0) : percent.num;
      percent.ratio = count ? `${index2} / ${count}` : "";
      context.emit("update:modelValue", percent);
    };
    const handleRemove = () => {
      uploadList.length > 0 && uploadList.splice(0, 1);
    };
    return {
      upload: upload2
    };
  }
});
const _withScopeId$m = (n) => (pushScopeId("data-v-11fbf335"), n = n(), popScopeId(), n);
const _hoisted_1$J = /* @__PURE__ */ _withScopeId$m(() => /* @__PURE__ */ createElementVNode("i", { class: "el-icon-upload el-icon--right" }, null, -1));
function _sfc_render$H(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_button = resolveComponent("el-button");
  const _component_el_upload = resolveComponent("el-upload");
  return openBlock(), createBlock(_component_el_upload, {
    action: "",
    accept: "image/*",
    "http-request": _ctx.upload,
    "show-file-list": false,
    multiple: ""
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createVNode(_component_el_button, { size: "small" }, {
          default: withCtx(() => [
            createTextVNode("\u4E0A\u4F20\u56FE\u7247"),
            _hoisted_1$J
          ]),
          _: 1
        })
      ], true)
    ]),
    _: 3
  }, 8, ["http-request"]);
}
var uploader = /* @__PURE__ */ _export_sfc(_sfc_main$L, [["render", _sfc_render$H], ["__scopeId", "data-v-11fbf335"]]);
var downloadImg = (src, cb) => {
  return new Promise((resolve) => {
    fetchImageDataFromUrl(src, (progress, xhr2) => {
      cb(progress, xhr2);
    }).then((res) => {
      const reader = new FileReader();
      reader.onload = function(event) {
        var _a2;
        const txt = (_a2 = event == null ? void 0 : event.target) == null ? void 0 : _a2.result;
        const a2 = document.createElement("a");
        const mE = new MouseEvent("click");
        a2.download = String(new Date().getTime()) + ".png";
        a2.href = txt;
        a2.dispatchEvent(mE);
        resolve();
      };
      if (!res) {
        resolve();
        return;
      }
      reader.readAsDataURL(res);
    });
  });
};
function fetchImageDataFromUrl(url, cb) {
  return new Promise((resolve) => {
    const xhr2 = new XMLHttpRequest();
    let totalLength = "";
    xhr2.open("GET", url);
    xhr2.responseType = "blob";
    xhr2.onreadystatechange = function() {
      totalLength = Number(xhr2.getResponseHeader("content-length"));
    };
    xhr2.onprogress = function(event) {
      cb(event.loaded / totalLength * 100, xhr2);
    };
    xhr2.onload = function() {
      if (xhr2.status < 400)
        resolve(this.response);
      else
        resolve(null);
    };
    xhr2.onerror = function(e2) {
      resolve(null);
    };
    xhr2.send();
  });
}
var downloadBase64File = (base64Data, fileName) => {
  const link = document.createElement("a");
  link.href = base64Data;
  link.download = fileName;
  link.click();
};
var _dl = {
  downloadImg,
  downloadBase64File
};
var EventType = /* @__PURE__ */ ((EventType2) => {
  EventType2["Mouseover"] = "mouseover";
  EventType2["Mouseenter"] = "mouseenter";
  EventType2["Mouseout"] = "mouseout";
  EventType2["Mouseleave"] = "mouseleave";
  EventType2["Mouseup"] = "mouseup";
  EventType2["Mousemove"] = "mousemove";
  EventType2["MouseDown"] = "mousedown";
  EventType2["DblClick"] = "dblclick";
  EventType2["Click"] = "click";
  EventType2["ContextMenu"] = "contextmenu";
  EventType2["KeyDown"] = "keydown";
  EventType2["Keyup"] = "keyup";
  EventType2["Keypress"] = "keypress";
  EventType2["Scroll"] = "scroll";
  EventType2["Resize"] = "resize";
  EventType2["Wheel"] = "wheel";
  EventType2["UndoRedoStateChanged"] = "undoRedoStateChanged";
  return EventType2;
})(EventType || {});
const INITIAL_RADIUS = 12.5;
const INITIAL_HARDNESS = 0.5;
const RADIUS_TO_BRUSH_SIZE_RATIO = 4;
const RADIUS_SLIDER_MIN = 0.25;
const RADIUS_SLIDER_STEP = 0.25;
const RADIUS_SLIDER_MAX = 25;
const MIN_RADIUS = 0.5;
const HARDNESS_SLIDER_MIN = 0;
const HARDNESS_SLIDER_STEP = 0.01;
const HARDNESS_SLIDER_MAX = 1;
const HARDNESS_ZOOM_TO_SLIDER_RATIO = 100;
const INITIAL_SCALE_RATIO = 1;
const INITIAL_TRANSFORM_CONFIG = {
  scaleRatio: INITIAL_SCALE_RATIO,
  positionRange: {
    minX: 0,
    maxX: 0,
    minY: 0,
    maxY: 0
  }
};
const INITIAL_GAP_SIZE = {
  horizontal: 40,
  vertical: 80
};
const HIDDEN_BOARD_GAP_SIZE = {
  horizontal: 0,
  vertical: 0
};
const HIDDEN_BOARD_MAX_SIZE = {
  width: 2e3,
  height: 2e3
};
const DEFAULT_IMAGE_SMOOTH_CHOICE = false;
const IMAGE_BORDER_STYLE = "#000000";
const INITIAL_IMAGE_BORDER_WIDTH = 1;
const DEFAULT_MASK_COLOR = [0.47, 0.42, 0.9, 0.5];
const UPDATE_BOARDRECT_DEBOUNCE_TIME = 100;
const DRAWING_STEP_BASE_BASE = 20;
const DRAWING_STEP_BASE = 3.5;
const GLOBAL_COMPOSITE_OPERATION_SOURCE_OVER = "source-over";
const GLOBAL_COMPOSITE_OPERATION_DESTINATION_IN = "destination-in";
const GLOBAL_COMPOSITE_OPERATION_DESTINATION_OUT = "destination-out";
const DRAW_INTERPOLATION_STEP_BASE = 2.5;
const DRAW_INTERPOLATION_RADIUS_THRESHOLD = 1;
const GRADIENT_INNER_RADIUS = 0;
const GRADIENT_BEGIN_OFFSET = 0;
const GRADIENT_END_OFFSET = 1;
const REPAIR_POINT_INNER_COLOR = "rgba(119,106,230,1)";
const REPAIR_POINT_OUTER_COLOR = "rgba(119,106,230,0)";
const ERASE_POINT_INNER_COLOR = "rgba(255,255,255,1)";
const ERASE_POINT_OUTER_COLOR = "rgba(255,255,255,0)";
const ZERO_DEGREES = 0;
const ONE_TURN_DEGREES = Math.PI * 2;
const ZOOM_IN_COEFFICIENT = 1;
const ZOOM_OUT_COEFFICIENT = -1;
const SCALE_STEP = 0.04;
const MIN_SCALE_RATIO = 0.15;
const MAX_SCALE_RATIO = 10;
function isString(value) {
  return typeof value === "string";
}
function resizeCanvas(config2) {
  const { ctx, targetWidth, targetHeight, hiddenCtx, transformConfig, withBorder = false } = config2;
  const { positionRange, scaleRatio } = transformConfig;
  ctx.canvas.width = targetWidth;
  ctx.canvas.height = targetHeight;
  ctx.imageSmoothingEnabled = DEFAULT_IMAGE_SMOOTH_CHOICE;
  transformedDrawImage({ ctx, hiddenCtx, positionRange, scaleRatio, withBorder, clearOld: false });
}
function createContext2D(createConfig = {}) {
  const { targetSize, cloneCanvas } = createConfig;
  const canvas = document.createElement("canvas");
  const context2D = canvas.getContext("2d");
  if (targetSize) {
    canvas.width = targetSize.width;
    canvas.height = targetSize.height;
  }
  if (cloneCanvas) {
    domHelpers.copyImageInCanvas(context2D, cloneCanvas);
  }
  return context2D;
}
function copyImageInCanvas(hiddenContext, cloneCanvas) {
  hiddenContext.canvas.width = cloneCanvas.width;
  hiddenContext.canvas.height = cloneCanvas.height;
  hiddenContext.drawImage(cloneCanvas, 0, 0);
}
async function getLoadedImage(picFile) {
  const img = new Image();
  img.crossOrigin = "anonymous";
  img.src = isString(picFile) ? picFile : URL.createObjectURL(picFile);
  await new Promise((resolve) => {
    img.onload = () => resolve();
  });
  return createImageBitmap(img);
}
function initHiddenBoardWithSource(initConfig) {
  initHiddenBoard(initConfig);
  const {
    hiddenCtx: ctx,
    imageSource,
    targetSize: { width, height }
  } = initConfig;
  return getImageSourceFromCtx({ ctx, imageSource, width, height });
}
function initHiddenBoard(initConfig) {
  const { targetSize, hiddenCtx, drawingCtx } = initConfig;
  const { width, height } = targetSize;
  hiddenCtx.canvas.width = width;
  hiddenCtx.canvas.height = height;
  drawingCtx.canvas.width = width;
  drawingCtx.canvas.height = height;
}
function getImageSourceFromCtx(config2) {
  const { ctx, imageSource, width, height } = config2;
  ctx.drawImage(imageSource, 0, 0, width, height);
  return createImageBitmap(ctx.canvas);
}
function clearCanvas(ctx) {
  const {
    canvas: { width, height }
  } = ctx;
  ctx.clearRect(0, 0, width, height);
}
function drawImageBorder(borderConfig) {
  const { ctx, lineStyle, lineWidth, positionRange } = borderConfig;
  const { minY: top, maxX: right, maxY: bottom, minX: left } = positionRange;
  ctx.imageSmoothingEnabled = !DEFAULT_IMAGE_SMOOTH_CHOICE;
  ctx.fillStyle = lineStyle;
  ctx.fillRect(left, top, right - left + lineWidth, lineWidth);
  ctx.fillRect(left, bottom, right - left + lineWidth, lineWidth);
  ctx.fillRect(left, top + lineWidth, lineWidth, bottom - top - lineWidth);
  ctx.fillRect(right, top + lineWidth, lineWidth, bottom - top - lineWidth);
  ctx.imageSmoothingEnabled = DEFAULT_IMAGE_SMOOTH_CHOICE;
}
function drawBoardImageBorder(ctx, hiddenCtx) {
  const { width, height } = hiddenCtx.canvas;
  const positionRange = { minX: 0, minY: 0, maxX: width, maxY: height };
  drawImageBorder({
    ctx,
    positionRange,
    lineStyle: IMAGE_BORDER_STYLE,
    lineWidth: INITIAL_IMAGE_BORDER_WIDTH
  });
}
function transformedDrawImage(transformedConfig) {
  const { ctx, positionRange, scaleRatio, hiddenCtx } = transformedConfig;
  const { clearOld = true, withBorder } = transformedConfig;
  const { minX: translateX, minY: translateY } = positionRange;
  if (clearOld) {
    clearCanvas(ctx);
  }
  ctx.save();
  ctx.translate(translateX, translateY);
  ctx.scale(scaleRatio, scaleRatio);
  ctx.drawImage(hiddenCtx.canvas, 0, 0);
  if (withBorder) {
    drawBoardImageBorder(ctx, hiddenCtx);
  }
  ctx.restore();
}
function drawBrushPoint(drawingConfig) {
  const { ctx, x, y, radius, hardness } = drawingConfig;
  const { innerColor = REPAIR_POINT_INNER_COLOR, outerColor = REPAIR_POINT_OUTER_COLOR } = drawingConfig;
  ctx.beginPath();
  const gradient = ctx.createRadialGradient(x, y, GRADIENT_INNER_RADIUS, x, y, radius);
  gradient.addColorStop(GRADIENT_BEGIN_OFFSET, innerColor);
  gradient.addColorStop(hardness, innerColor);
  gradient.addColorStop(GRADIENT_END_OFFSET, outerColor);
  ctx.fillStyle = gradient;
  ctx.arc(x, y, radius, ZERO_DEGREES, ONE_TURN_DEGREES);
  ctx.fill();
}
function generateResultImageURL(rawImage, resultCtx) {
  const resultImageCtx = createResultImageContext2D(rawImage, resultCtx);
  return resultImageCtx.canvas.toDataURL();
}
function createResultImageContext2D(imageSource, resultImageCtx) {
  const context2D = createRawImageContext2D(imageSource);
  drawResultImageInContext2D(context2D, resultImageCtx, imageSource);
  return context2D;
}
function createRawImageContext2D(imageSource) {
  const context2D = createContext2D({ targetSize: imageSource });
  context2D.drawImage(imageSource, 0, 0);
  return context2D;
}
function drawResultImageInContext2D(ctx, resultImageCtx, imageSource) {
  ctx.globalCompositeOperation = GLOBAL_COMPOSITE_OPERATION_DESTINATION_IN;
  ctx.drawImage(resultImageCtx.canvas, 0, 0, imageSource.width, imageSource.height);
}
const domHelpers = {
  copyImageInCanvas
};
const { MouseDown, Mouseup, Mousemove } = EventType;
class ListenerManager {
  constructor() {
    this.unbindDownUpCache = /* @__PURE__ */ new WeakMap();
    this.unbindMoveCache = /* @__PURE__ */ new WeakMap();
    this.unbindWheelCache = /* @__PURE__ */ new Set();
  }
  initMouseListeners(ctx) {
    const { mouseTarget } = ctx;
    this.removeMouseListeners(mouseTarget);
    const unbindConfig = this.bindMouseListeners(ctx);
    this.unbindDownUpCache.set(mouseTarget, unbindConfig);
  }
  removeMouseListeners(mouseTarget) {
    const unbindConfig = this.unbindDownUpCache.get(mouseTarget);
    if (unbindConfig) {
      const { unbindDown, unbindUp } = unbindConfig;
      unbindDown();
      unbindUp();
    }
  }
  bindMouseListeners(listenersContext) {
    const { mouseTarget, down, move, up } = listenersContext;
    const moveListener = (ev) => {
      requestAnimationFrame(() => move(ev));
    };
    const downListener = (ev) => {
      const isTarget = ev.target === mouseTarget;
      const extraCondition = down && down(ev);
      const shouldBindMove = extraCondition !== false;
      if (isTarget && shouldBindMove) {
        const removeMove = this.listenEvent({
          eventType: Mousemove,
          listener: moveListener,
          stop: true,
          prevent: true
        });
        this.unbindMoveCache.set(mouseTarget, removeMove);
      }
    };
    const upListener = (ev) => {
      up && up(ev);
      this.unbindMoveListeners(mouseTarget);
    };
    const unbindDown = this.listenEvent({
      eventType: MouseDown,
      listener: downListener
    });
    const unbindUp = this.listenEvent({
      eventType: Mouseup,
      listener: upListener
    });
    return { unbindDown, unbindUp };
  }
  unbindMoveListeners(mouseTarget) {
    const unbindMove = this.unbindMoveCache.get(mouseTarget);
    unbindMove && unbindMove();
    this.unbindMoveCache.delete(mouseTarget);
  }
  initWheelListener(listenersConfig) {
    this.removeWheelListeners();
    const removeWheel = this.bindWheelListener(listenersConfig);
    this.unbindWheelCache.add(removeWheel);
    return removeWheel;
  }
  removeWheelListeners() {
    this.unbindWheelCache.forEach((unbind) => unbind());
    this.unbindWheelCache.clear();
  }
  bindWheelListener(listenersConfig) {
    const { mattingBoards, wheel } = listenersConfig;
    return this.listenEvent(
      {
        eventType: EventType.Wheel,
        listener: (ev) => {
          if (this.canWheel(ev, mattingBoards)) {
            wheel(ev);
          }
        }
      },
      false,
      ...mattingBoards
    );
  }
  canWheel(ev, mattingBoards) {
    return mattingBoards.some((board) => ev.target === board);
  }
  listenEvent(listenerConfig, options = false, ...targets) {
    const { eventType } = listenerConfig;
    const wrapListener = this.genWrapListener(listenerConfig);
    let removeListenerCallback;
    if (!this.isNeedToBindToTargets(targets)) {
      removeListenerCallback = this.bindListener(window, eventType, wrapListener, options);
    } else {
      removeListenerCallback = this.bindListeners(targets, eventType, wrapListener, options);
    }
    return removeListenerCallback;
  }
  genWrapListener(listenerConfig) {
    const { listener, stop, prevent } = listenerConfig;
    return (ev) => {
      if (stop) {
        ev.stopPropagation();
      }
      if (prevent) {
        ev.preventDefault();
      }
      listener(ev);
    };
  }
  isNeedToBindToTargets(targets) {
    return targets.length !== 0;
  }
  bindListener(target, eventType, listener, options) {
    target.addEventListener(eventType, listener, options);
    return () => target.removeEventListener(eventType, listener, options);
  }
  bindListeners(targets, eventType, listener, options) {
    targets.forEach((target) => {
      target.addEventListener(eventType, listener, options);
    });
    return () => targets.forEach((target) => {
      target.removeEventListener(eventType, listener, options);
    });
  }
}
const { sign: sign$1, abs, max: max$1 } = Math;
function isInImageRange(inRangeConfig) {
  const { x, y, minX, maxX, minY, maxY } = inRangeConfig;
  return x >= minX && x <= maxX && y >= minY && y <= maxY;
}
function computeMovements(movements) {
  const { movementX, movementY } = movements;
  const unsignedMovementX = abs(movementX);
  const unsignedMovementY = abs(movementY);
  const maxMovement = max$1(unsignedMovementX, unsignedMovementY);
  return { unsignedMovementX, unsignedMovementY, maxMovement };
}
function needDrawInterpolation(maxMovement, radius) {
  return radius > DRAW_INTERPOLATION_RADIUS_THRESHOLD && maxMovement > radius / DRAW_INTERPOLATION_STEP_BASE;
}
function computeInterpolationStep(interpolationConfig) {
  const { drawingConfig, unsignedMovementX, unsignedMovementY, maxMovement } = interpolationConfig;
  const { movementX, movementY, stepBase } = drawingConfig;
  const rawStepX = computePivotRawStep(movementX, stepBase);
  const rawStepY = computePivotRawStep(movementY, stepBase);
  const movementXIsMaximum = isMaxMovement(unsignedMovementX, maxMovement);
  const stepX = computePivotStep(movementXIsMaximum, rawStepX, unsignedMovementX, unsignedMovementY);
  const stepY = computePivotStep(!movementXIsMaximum, rawStepY, unsignedMovementY, unsignedMovementX);
  return { stepX, stepY };
}
function computePivotRawStep(pivotMovement, stepBase) {
  return -sign$1(pivotMovement) * stepBase;
}
function isMaxMovement(pivotMovement, maxMovement) {
  return pivotMovement === maxMovement;
}
function computePivotStep(isMaxMovement2, rawStepOfPivot, unsignedPivotMovement, unsignedCrossedMovement) {
  return isMaxMovement2 ? rawStepOfPivot : unsignedPivotMovement / unsignedCrossedMovement * rawStepOfPivot;
}
function needDrawInterpolationPoint(movement, moved2, step) {
  return movement - moved2 > step;
}
const { sqrt, max } = Math;
function fixed(num) {
  return num | 0;
}
function getRawDistance(xDistance, yDistance) {
  return sqrt(xDistance ** 2 + yDistance ** 2);
}
function computeStepBase(radius) {
  return radius / DRAWING_STEP_BASE_BASE;
}
function computeRealRadius(rawRadius, scaleRatio) {
  return max(MIN_RADIUS, rawRadius) / scaleRatio;
}
function computeStep(radius) {
  return radius / DRAWING_STEP_BASE;
}
function computeScaledImageSize(imageSize, scaleRatio) {
  return {
    width: imageSize.width * scaleRatio,
    height: imageSize.height * scaleRatio
  };
}
function executeMattingDrawing(drawingConfigs) {
  for (const config2 of drawingConfigs) {
    const { radius } = config2;
    const { maxMovement, unsignedMovementX, unsignedMovementY } = computeMovements(config2);
    if (needDrawInterpolation(maxMovement, radius)) {
      renderMattingInterpolation({ drawingConfig: config2, unsignedMovementX, unsignedMovementY, maxMovement });
    } else {
      drawMattingPoint(config2);
    }
    drawResultArea(config2);
  }
}
const interpolationCtx = createContext2D();
function renderMattingInterpolation(interpolationConfig) {
  const { drawingConfig, maxMovement } = interpolationConfig;
  const { step, stepBase, drawingCtx, radius, hardness } = drawingConfig;
  let { x, y } = drawingConfig;
  const { stepX, stepY } = computeInterpolationStep(interpolationConfig);
  resetInterpolationCtx(drawingCtx);
  for (let movement = 0, moved2 = movement; movement < maxMovement; movement += stepBase, x += stepX, y += stepY) {
    if (needDrawInterpolationPoint(movement, moved2, step)) {
      moved2 = movement;
      drawBrushPoint({ ctx: interpolationCtx, x: fixed(x), y: fixed(y), radius, hardness });
    }
  }
  drawMattingInterpolationTrack(drawingConfig);
}
function drawMattingInterpolationTrack(drawingConfig) {
  const { isErasing, hiddenCtx, drawingCtx } = drawingConfig;
  if (isErasing) {
    hiddenCtx.value.drawImage(interpolationCtx.canvas, 0, 0);
  } else {
    drawMattingTrack(drawingConfig, () => {
      drawingCtx.drawImage(interpolationCtx.canvas, 0, 0);
    });
  }
}
function resetInterpolationCtx(drawingCtx) {
  const { width, height } = drawingCtx.canvas;
  interpolationCtx.canvas.width = width;
  interpolationCtx.canvas.height = height;
  interpolationCtx.clearRect(0, 0, width, height);
}
function drawMattingPoint(drawingConfig) {
  const { isErasing, hiddenCtx, drawingCtx } = drawingConfig;
  const { x, y, radius, hardness } = drawingConfig;
  if (isErasing) {
    drawBrushPoint({ ctx: hiddenCtx.value, x, y, radius, hardness });
  } else {
    drawMattingTrack(drawingConfig, () => {
      drawBrushPoint({ ctx: drawingCtx, x, y, radius, hardness });
    });
  }
}
async function drawMattingTrack(drawingConfig, drawingCallback) {
  const { hiddenCtx, drawingCtx, mattingSource } = drawingConfig;
  drawingCtx.globalCompositeOperation = GLOBAL_COMPOSITE_OPERATION_SOURCE_OVER;
  drawingCtx.drawImage(mattingSource, 0, 0);
  drawingCtx.globalCompositeOperation = GLOBAL_COMPOSITE_OPERATION_DESTINATION_IN;
  drawingCallback();
  hiddenCtx.value.drawImage(drawingCtx.canvas, 0, 0);
}
function drawResultArea(drawingConfig) {
  const { ctx, hiddenCtx, positionRange, scaleRatio, isErasing } = drawingConfig;
  transformedDrawImage({
    ctx: ctx.value,
    hiddenCtx: hiddenCtx.value,
    positionRange,
    scaleRatio,
    withBorder: isInResultBoard(isErasing)
  });
}
function isInResultBoard(isErasing) {
  return isErasing !== void 0;
}
function computeBoardRect(canvas) {
  const inputBoardRect = canvas.getBoundingClientRect();
  const domRect = document.documentElement.getBoundingClientRect();
  return computeBoardRectSize(inputBoardRect, domRect);
}
function computeBoardRectSize(inputBoardRect, domRect) {
  const { width, height, left: boardLeft, top: boardTop } = inputBoardRect;
  const { left: domLeft, top: domTop } = domRect;
  const left = boardLeft - domLeft;
  const top = boardTop - domTop;
  return { left, top, width, height };
}
function computeValidImageSize(imageSource) {
  let { width, height } = imageSource;
  const imageScaleRatio = computeScaleRatio({
    imageSize: { width, height },
    gapSize: HIDDEN_BOARD_GAP_SIZE,
    targetSize: HIDDEN_BOARD_MAX_SIZE
  });
  width *= imageScaleRatio;
  height *= imageScaleRatio;
  return { width, height };
}
function computeScaleRatio(transformParametersConfig) {
  const { imageSize, gapSize, targetSize } = transformParametersConfig;
  const drawingAreaSize = getDrawingAreaSize(targetSize, gapSize);
  return Math.min(Math.min(drawingAreaSize.width / imageSize.width, drawingAreaSize.height / imageSize.height), INITIAL_SCALE_RATIO);
}
function getDrawingAreaSize(boardSize, gapSize) {
  return {
    width: boardSize.width - gapSize.horizontal * 2,
    height: boardSize.height - gapSize.vertical * 2
  };
}
function computeTransformParameters(transformParametersConfig) {
  const scaleRatio = computeScaleRatio(transformParametersConfig);
  const positionRange = computePositionRange(transformParametersConfig, scaleRatio);
  return { scaleRatio, positionRange };
}
function computePositionRange(transformParametersConfig, scaleRatio) {
  const scaledImageSize = computeScaledImageSize(transformParametersConfig.imageSize, scaleRatio);
  return {
    minX: getPositionRangeMinX(transformParametersConfig, scaledImageSize),
    maxX: getPositionRangeMaxX(transformParametersConfig, scaledImageSize),
    minY: getPositionRangeMinY(transformParametersConfig, scaledImageSize),
    maxY: getPositionRangeMaxY(transformParametersConfig, scaledImageSize)
  };
}
function getPositionRangeMinX(transformParametersConfig, scaledImageSize) {
  const { gapSize, targetSize } = transformParametersConfig;
  return fixed((getDrawingAreaSize(targetSize, gapSize).width - scaledImageSize.width) / 2) + gapSize.horizontal;
}
function getPositionRangeMinY(transformParametersConfig, scaledImageSize) {
  const { gapSize, targetSize } = transformParametersConfig;
  return fixed((getDrawingAreaSize(targetSize, gapSize).height - scaledImageSize.height) / 2) + gapSize.vertical;
}
function getPositionRangeMaxX(transformParametersConfig, scaledImageSize) {
  return fixed(getPositionRangeMinX(transformParametersConfig, scaledImageSize) + scaledImageSize.width);
}
function getPositionRangeMaxY(transformParametersConfig, scaledImageSize) {
  return fixed(getPositionRangeMinY(transformParametersConfig, scaledImageSize) + scaledImageSize.height);
}
const computeHelpers = {
  computeBoardRect,
  computeTransformParameters,
  computeScaleRatio,
  computeValidImageSize,
  computePositionRange,
  getPositionRangeMinX,
  getPositionRangeMaxX,
  getPositionRangeMinY,
  getPositionRangeMaxY
};
const { sign } = Math;
function updateRangeByMovements(ev, positionRange) {
  const { movementX: deltaX, movementY: deltaY } = ev;
  positionRange.minX += deltaX;
  positionRange.maxX += deltaX;
  positionRange.minY += deltaY;
  positionRange.maxY += deltaY;
}
function redrawMattingBoardsWhileScaling(ev, scalingConfig) {
  const { transformConfig, inputContexts: inputContext, outputContexts: outputContext } = scalingConfig;
  updateTransformConfigWhileScaling(ev, transformConfig);
}
function updateTransformConfigWhileScaling(ev, transformConfig) {
  const { deltaY, pageX, pageY, target } = ev;
  const { positionRange, scaleRatio } = transformConfig;
  const { left, top } = computeHelpers.computeBoardRect(target);
  const x = transformHelpers.computePivot(pageX, left);
  const y = transformHelpers.computePivot(pageY, top);
  const deltaRatio = transformHelpers.computeDeltaRatio(deltaY);
  const targetScaleRatio = transformHelpers.computeNewScaleRatio(scaleRatio, deltaRatio);
  transformConfig.scaleRatio = transformHelpers.computeClampedTargetScaleRatio(targetScaleRatio);
  const rangeScaleRatio = computeRangeScaleRatio(transformConfig.scaleRatio, scaleRatio);
  transformConfig.positionRange = transformHelpers.computeNewPositionRange(positionRange, { x, y }, rangeScaleRatio);
}
function computePivot(pagePivot, leftOrTop) {
  return pagePivot - leftOrTop;
}
function computeDeltaRatio(deltaY) {
  const scaleCoefficient = transformHelpers.isZoomOut(deltaY) ? ZOOM_OUT_COEFFICIENT : ZOOM_IN_COEFFICIENT;
  return scaleCoefficient * SCALE_STEP;
}
function isZoomOut(deltaY) {
  return -sign(deltaY) === ZOOM_OUT_COEFFICIENT;
}
function computeNewScaleRatio(scaleRatio, deltaRatio) {
  return scaleRatio + scaleRatio * deltaRatio;
}
function computeRangeScaleRatio(newRatio, oldRatio) {
  return (newRatio - oldRatio) / oldRatio;
}
function computeClampedTargetScaleRatio(scaleRatio) {
  return scaleRatio < MIN_SCALE_RATIO ? MIN_SCALE_RATIO : scaleRatio > MAX_SCALE_RATIO ? MAX_SCALE_RATIO : scaleRatio;
}
function computeNewPositionRange(positionRange, position2, deltaRatio) {
  const { x, y } = position2;
  let { minX, maxX, minY, maxY } = positionRange;
  minX = transformHelpers.computeNewSingleRange(minX, x, deltaRatio);
  maxX = transformHelpers.computeNewSingleRange(maxX, x, deltaRatio);
  minY = transformHelpers.computeNewSingleRange(minY, y, deltaRatio);
  maxY = transformHelpers.computeNewSingleRange(maxY, y, deltaRatio);
  return { minX, maxX, minY, maxY };
}
function computeNewSingleRange(singleRange, pivot, deltaRatio) {
  const vectorDistance = singleRange - pivot;
  const deltaRange = vectorDistance * deltaRatio;
  return singleRange + deltaRange;
}
const transformHelpers = {
  updateTransformConfigWhileScaling,
  computePivot,
  computeDeltaRatio,
  isZoomOut,
  computeNewScaleRatio,
  computeClampedTargetScaleRatio,
  computeNewPositionRange,
  computeNewSingleRange
};
function initDrawingListeners(config2) {
  const { listenerManager, initDrawingConfig } = config2;
  const listenerConfig = generateDrawingListenerConfig(config2);
  let spaceDown = false;
  const {
    inputBoardDrawingConfig: { ctx: inputCtx, hiddenCtx: inputHiddenCtx },
    outputBoardDrawingConfig: { hiddenCtx: outputHiddenCtx },
    brushDrawingBaseConfig: { positionRange }
  } = listenerConfig;
  const { boardRect, draggingInputBoard } = listenerConfig;
  resetPivotalOptions(listenerConfig);
  const drawingListener = generateDrawingListener(listenerConfig);
  let canDrawAndBindListener = false;
  document.removeEventListener("keydown", handleKeydown, false);
  function handleKeydown(e2) {
    if (e2.code === "Space") {
      e2.preventDefault();
    }
    spaceDown = e2.code === "Space";
  }
  document.addEventListener("keydown", handleKeydown, false);
  function handleKeyup(e2) {
    spaceDown = false;
  }
  document.removeEventListener("keydown", handleKeyup, false);
  document.addEventListener("keyup", handleKeyup, false);
  listenerManager.initMouseListeners({
    mouseTarget: inputCtx.value.canvas,
    down(ev) {
      if (!spaceDown) {
        canDrawAndBindListener = canDrawAndBindMoveListener({
          ev,
          boardRect,
          positionRange,
          draggingInputBoard
        });
        if (canDrawAndBindListener) {
          drawingListener(ev);
        }
        return canDrawAndBindListener;
      }
    },
    move(ev) {
      const { positionRange: positionRange2 } = initDrawingConfig.transformConfig;
      spaceDown && updateRangeByMovements(ev, positionRange2);
      if (!draggingInputBoard && canDrawAndBindListener) {
        drawingListener(ev);
      }
    },
    up(ev) {
      if (!draggingInputBoard && canDrawAndBindListener) {
        canDrawAndBindListener = false;
        drawingListener(ev);
      }
    }
  });
}
function generateDrawingListenerConfig(config2) {
  const {
    imageSources,
    imageSources: { raw, mask },
    initDrawingConfig,
    boardContexts,
    ...restConfig
  } = config2;
  const { inputCtx, inputHiddenCtx, inputDrawingCtx: inputDrawingCtx2, outputCtx, outputHiddenCtx, outputDrawingCtx: outputDrawingCtx2 } = boardContexts;
  const brushDrawingBaseConfig = generateBrushBaseConfig(initDrawingConfig);
  const inputBoardDrawingConfig = {
    ctx: inputCtx,
    hiddenCtx: inputHiddenCtx,
    drawingCtx: inputDrawingCtx2,
    mattingSource: mask
  };
  const outputBoardDrawingConfig = {
    ctx: outputCtx,
    hiddenCtx: outputHiddenCtx,
    drawingCtx: outputDrawingCtx2,
    mattingSource: raw
  };
  return {
    brushDrawingBaseConfig,
    mattingSources: imageSources,
    inputBoardDrawingConfig,
    outputBoardDrawingConfig,
    ...restConfig
  };
}
function resetPivotalOptions(config2) {
  const { inputBoardDrawingConfig, outputBoardDrawingConfig } = config2;
  const {
    mattingSources: { raw, mask },
    isErasing
  } = config2;
  if (isErasing) {
    inputBoardDrawingConfig.mattingSource = raw;
    outputBoardDrawingConfig.hiddenCtx.value.globalCompositeOperation = GLOBAL_COMPOSITE_OPERATION_DESTINATION_OUT;
  } else {
    inputBoardDrawingConfig.mattingSource = mask;
    outputBoardDrawingConfig.hiddenCtx.value.globalCompositeOperation = GLOBAL_COMPOSITE_OPERATION_SOURCE_OVER;
  }
}
function generateBrushBaseConfig(config2) {
  const {
    radius: rawRadius,
    hardness,
    transformConfig: { scaleRatio, positionRange }
  } = config2;
  const radius = computeRealRadius(rawRadius.value, scaleRatio);
  const stepBase = computeStepBase(radius);
  const step = computeStep(radius);
  return { radius, step, stepBase, scaleRatio, positionRange, hardness: hardness.value };
}
function generateDrawingListener(config2) {
  const {
    brushDrawingBaseConfig,
    brushDrawingBaseConfig: { step, scaleRatio, positionRange },
    boardRect: { left, top }
  } = config2;
  const { inputBoardDrawingConfig, outputBoardDrawingConfig, isErasing } = config2;
  let totalMovement = 0;
  return (ev) => {
    const positionAndMovements = computePositionAndMovements({
      ev,
      scaleRatio,
      positionRange,
      left,
      top
    });
    const { movementX, movementY } = positionAndMovements;
    const commonPointConfig = {
      ...brushDrawingBaseConfig,
      ...positionAndMovements
    };
    totalMovement += getRawDistance(movementX, movementY);
    if (canDrawing(totalMovement, step, ev.type)) {
      totalMovement = 0;
      executeMattingDrawing([
        { ...commonPointConfig, ...inputBoardDrawingConfig },
        { ...commonPointConfig, ...outputBoardDrawingConfig, isErasing }
      ]);
    }
  };
}
function canDrawing(totalMovement, step, eventType) {
  return totalMovement >= step || eventType === EventType.MouseDown;
}
function computePositionAndMovements(config2) {
  const { ev, scaleRatio, positionRange, left, top } = config2;
  const { minX, minY } = positionRange;
  const { movementX, movementY, pageX, pageY } = ev;
  const realPosition = computeRealPosition({ pageX, pageY, left, top, minX, minY, scaleRatio });
  const realMovements = computeRealMovements({ movementX, movementY }, scaleRatio);
  return { ...realPosition, ...realMovements };
}
function computeRealPosition(config2) {
  const { pageX, pageY, left, top, minX, minY, scaleRatio } = config2;
  const x = (pageX - left - minX) / scaleRatio;
  const y = (pageY - top - minY) / scaleRatio;
  return { x, y };
}
function computeRealMovements(rawMovements, scaleRatio) {
  const { movementX: rawMovementX, movementY: rawMovementY } = rawMovements;
  const movementX = rawMovementX / scaleRatio;
  const movementY = rawMovementY / scaleRatio;
  return { movementX, movementY };
}
function canDrawAndBindMoveListener(canDrawAndBindConfig) {
  const { ev, boardRect, positionRange, draggingInputBoard } = canDrawAndBindConfig;
  const { pageX, pageY } = ev;
  const { left, top } = boardRect;
  const { minX, maxX, minY, maxY } = positionRange;
  const x = transformHelpers.computePivot(pageX, left);
  const y = transformHelpers.computePivot(pageY, top);
  const inImageRange = isInImageRange({ x, y, minX, maxX, minY, maxY });
  return inImageRange && !draggingInputBoard;
}
function initDragListener(mattingTransformConfig) {
  const {
    outputContexts: { ctx: outputCtx2D },
    transformConfig,
    listenerManager
  } = mattingTransformConfig;
  listenerManager.initMouseListeners({
    mouseTarget: outputCtx2D.canvas,
    move(ev) {
      const { positionRange } = transformConfig;
      updateRangeByMovements(ev, positionRange);
    }
  });
}
function initScaleListener(mattingTransformConfig) {
  const {
    inputContexts: { ctx: inputCtx },
    outputContexts: { ctx: outputCtx },
    listenerManager
  } = mattingTransformConfig;
  return listenerManager.initWheelListener({
    mattingBoards: [inputCtx.canvas, outputCtx.canvas],
    wheel(ev) {
      ev.preventDefault();
      redrawMattingBoardsWhileScaling(ev, mattingTransformConfig);
    }
  });
}
function useInitDrawingListeners(props2, config2) {
  const { radius, hardness, isErasing } = props2;
  const { boardContexts, transformConfig, mattingSources, draggingInputBoard, initialized, boardRect, listenerManager } = config2;
  const { inputCtx } = boardContexts;
  watchEffect(() => {
    if (initialized.value) {
      initDrawingListeners({
        listenerManager,
        imageSources: mattingSources.value,
        boardContexts,
        initDrawingConfig: { radius, hardness, transformConfig },
        isErasing: isErasing.value,
        draggingInputBoard: draggingInputBoard.value,
        boardRect: boardRect.value
      });
    }
  });
  onBeforeUnmount(() => {
    listenerManager.removeMouseListeners(inputCtx.value.canvas);
  });
}
function useInitTransformListener(config2) {
  const { boardContexts, initialized, draggingInputBoard, transformConfig, isDrawing, listenerManager } = config2;
  const { inputCtx, inputHiddenCtx, outputCtx, outputHiddenCtx } = boardContexts;
  watch(
    [initialized, draggingInputBoard, isDrawing],
    () => {
      if (initialized.value && !isDrawing.value) {
        const initConfig = {
          inputContexts: { ctx: inputCtx.value, hiddenCtx: inputHiddenCtx.value },
          outputContexts: { ctx: outputCtx.value, hiddenCtx: outputHiddenCtx.value },
          draggingInputBoard: draggingInputBoard.value,
          listenerManager,
          transformConfig
        };
        initDragListener(initConfig);
        initScaleListener(initConfig);
        if (!draggingInputBoard.value) {
          transformConfig.positionRange = { ...transformConfig.positionRange };
        }
      }
    },
    { deep: true }
  );
  watch([transformConfig], async () => {
    if (initialized.value) {
      const { positionRange, scaleRatio } = transformConfig;
      const commonConfig = { positionRange, scaleRatio };
      transformedDrawImage({
        ctx: inputCtx.value,
        hiddenCtx: inputHiddenCtx.value,
        ...commonConfig
      });
      transformedDrawImage({
        ctx: outputCtx.value,
        hiddenCtx: outputHiddenCtx.value,
        withBorder: true,
        ...commonConfig
      });
    }
  });
  onBeforeUnmount(() => {
    if (initialized.value) {
      listenerManager.removeMouseListeners(outputCtx.value.canvas);
      listenerManager.removeWheelListeners();
    }
  });
}
const WebGLDebugUtils = function() {
  const log = function(msg) {
    if (window.console && window.console.log) {
      window.console.log(msg);
    }
  };
  const glValidEnumContexts = {
    enable: { 0: true },
    disable: { 0: true },
    getParameter: { 0: true },
    drawArrays: { 0: true },
    drawElements: { 0: true, 2: true },
    createShader: { 0: true },
    getShaderParameter: { 1: true },
    getProgramParameter: { 1: true },
    getVertexAttrib: { 1: true },
    vertexAttribPointer: { 2: true },
    bindTexture: { 0: true },
    activeTexture: { 0: true },
    getTexParameter: { 0: true, 1: true },
    texParameterf: { 0: true, 1: true },
    texParameteri: { 0: true, 1: true, 2: true },
    texImage2D: { 0: true, 2: true, 6: true, 7: true },
    texSubImage2D: { 0: true, 6: true, 7: true },
    copyTexImage2D: { 0: true, 2: true },
    copyTexSubImage2D: { 0: true },
    generateMipmap: { 0: true },
    bindBuffer: { 0: true },
    bufferData: { 0: true, 2: true },
    bufferSubData: { 0: true },
    getBufferParameter: { 0: true, 1: true },
    pixelStorei: { 0: true, 1: true },
    readPixels: { 4: true, 5: true },
    bindRenderbuffer: { 0: true },
    bindFramebuffer: { 0: true },
    checkFramebufferStatus: { 0: true },
    framebufferRenderbuffer: { 0: true, 1: true, 2: true },
    framebufferTexture2D: { 0: true, 1: true, 2: true },
    getFramebufferAttachmentParameter: { 0: true, 1: true, 2: true },
    getRenderbufferParameter: { 0: true, 1: true },
    renderbufferStorage: { 0: true, 1: true },
    clear: { 0: true },
    depthFunc: { 0: true },
    blendFunc: { 0: true, 1: true },
    blendFuncSeparate: { 0: true, 1: true, 2: true, 3: true },
    blendEquation: { 0: true },
    blendEquationSeparate: { 0: true, 1: true },
    stencilFunc: { 0: true },
    stencilFuncSeparate: { 0: true, 1: true },
    stencilMaskSeparate: { 0: true },
    stencilOp: { 0: true, 1: true, 2: true },
    stencilOpSeparate: { 0: true, 1: true, 2: true, 3: true },
    cullFace: { 0: true },
    frontFace: { 0: true }
  };
  let glEnums = null;
  function init2(ctx) {
    if (glEnums == null) {
      glEnums = {};
      for (const propertyName in ctx) {
        if (typeof ctx[propertyName] == "number") {
          glEnums[ctx[propertyName]] = propertyName;
        }
      }
    }
  }
  function checkInit() {
    if (glEnums == null) {
      throw "WebGLDebugUtils.init(ctx) not called";
    }
  }
  function mightBeEnum(glEnumKey) {
    checkInit();
    return !!glEnums && glEnums[glEnumKey] !== void 0;
  }
  function glEnumToString(glEnumKey) {
    checkInit();
    const name2 = glEnums && glEnums[glEnumKey];
    return name2 !== void 0 ? name2 : "*UNKNOWN WebGL ENUM (0x" + glEnumKey.toString(16) + ")";
  }
  function glFunctionArgToString(functionName, argumentIndex, value) {
    const funcInfo = glValidEnumContexts[functionName];
    if (funcInfo !== void 0) {
      if (funcInfo[argumentIndex]) {
        return glEnumToString(value);
      }
    }
    return value.toString();
  }
  function makeDebugContext(ctx, opt_onErrorFunc) {
    init2(ctx);
    opt_onErrorFunc = opt_onErrorFunc || function(err, functionName, args) {
      let argStr = "";
      for (let ii = 0; ii < args.length; ++ii) {
        argStr += (ii == 0 ? "" : ", ") + glFunctionArgToString(functionName, ii, args[ii]);
      }
      log("WebGL error " + glEnumToString(err) + " in " + functionName + "(" + argStr + ")");
    };
    const glErrorShadow = {};
    function makeErrorWrapper(ctx2, functionName) {
      return function() {
        const result = ctx2[functionName].apply(ctx2, arguments);
        const err = ctx2.getError();
        if (err != 0) {
          glErrorShadow[err] = true;
          opt_onErrorFunc(err, functionName, arguments);
        }
        return result;
      };
    }
    const wrapper = {};
    for (const propertyName in ctx) {
      const funcKey = propertyName;
      if (typeof ctx[funcKey] === "function") {
        wrapper[funcKey] = makeErrorWrapper(ctx, funcKey);
      } else {
        wrapper[funcKey] = ctx[funcKey];
      }
    }
    wrapper.getError = function() {
      for (const err in glErrorShadow) {
        if (glErrorShadow[err]) {
          glErrorShadow[err] = false;
          return +err;
        }
      }
      return ctx.NO_ERROR;
    };
    return wrapper;
  }
  function resetToInitialState(ctx) {
    const numAttribs = ctx.getParameter(ctx.MAX_VERTEX_ATTRIBS);
    const tmp = ctx.createBuffer();
    ctx.bindBuffer(ctx.ARRAY_BUFFER, tmp);
    for (let ii = 0; ii < numAttribs; ++ii) {
      ctx.disableVertexAttribArray(ii);
      ctx.vertexAttribPointer(ii, 4, ctx.FLOAT, false, 0, 0);
      ctx.vertexAttrib1f(ii, 0);
    }
    ctx.deleteBuffer(tmp);
    const numTextureUnits = ctx.getParameter(ctx.MAX_TEXTURE_IMAGE_UNITS);
    for (let ii = 0; ii < numTextureUnits; ++ii) {
      ctx.activeTexture(ctx.TEXTURE0 + ii);
      ctx.bindTexture(ctx.TEXTURE_CUBE_MAP, null);
      ctx.bindTexture(ctx.TEXTURE_2D, null);
    }
    ctx.activeTexture(ctx.TEXTURE0);
    ctx.useProgram(null);
    ctx.bindBuffer(ctx.ARRAY_BUFFER, null);
    ctx.bindBuffer(ctx.ELEMENT_ARRAY_BUFFER, null);
    ctx.bindFramebuffer(ctx.FRAMEBUFFER, null);
    ctx.bindRenderbuffer(ctx.RENDERBUFFER, null);
    ctx.disable(ctx.BLEND);
    ctx.disable(ctx.CULL_FACE);
    ctx.disable(ctx.DEPTH_TEST);
    ctx.disable(ctx.DITHER);
    ctx.disable(ctx.SCISSOR_TEST);
    ctx.blendColor(0, 0, 0, 0);
    ctx.blendEquation(ctx.FUNC_ADD);
    ctx.blendFunc(ctx.ONE, ctx.ZERO);
    ctx.clearColor(0, 0, 0, 0);
    ctx.clearDepth(1);
    ctx.clearStencil(-1);
    ctx.colorMask(true, true, true, true);
    ctx.cullFace(ctx.BACK);
    ctx.depthFunc(ctx.LESS);
    ctx.depthMask(true);
    ctx.depthRange(0, 1);
    ctx.frontFace(ctx.CCW);
    ctx.hint(ctx.GENERATE_MIPMAP_HINT, ctx.DONT_CARE);
    ctx.lineWidth(1);
    ctx.pixelStorei(ctx.PACK_ALIGNMENT, 4);
    ctx.pixelStorei(ctx.UNPACK_ALIGNMENT, 4);
    ctx.pixelStorei(ctx.UNPACK_FLIP_Y_WEBGL, false);
    ctx.pixelStorei(ctx.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    if (ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL) {
      ctx.pixelStorei(ctx.UNPACK_COLORSPACE_CONVERSION_WEBGL, ctx.BROWSER_DEFAULT_WEBGL);
    }
    ctx.polygonOffset(0, 0);
    ctx.sampleCoverage(1, false);
    ctx.scissor(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.stencilFunc(ctx.ALWAYS, 0, 4294967295);
    ctx.stencilMask(4294967295);
    ctx.stencilOp(ctx.KEEP, ctx.KEEP, ctx.KEEP);
    ctx.viewport(0, 0, ctx.canvas.clientWidth, ctx.canvas.clientHeight);
    ctx.clear(ctx.COLOR_BUFFER_BIT | ctx.DEPTH_BUFFER_BIT | ctx.STENCIL_BUFFER_BIT);
    while (ctx.getError())
      ;
  }
  function makeLostContextSimulatingContext(ctx) {
    const wrapper_ = {};
    let contextId_ = 1;
    let contextLost_ = false;
    const resourceDb_ = [];
    let onLost_ = void 0;
    let onRestored_ = void 0;
    let nextOnRestored_ = void 0;
    const glErrorShadow_ = {};
    function isWebGLResource(obj) {
      return obj instanceof WebGLBuffer || obj instanceof WebGLFramebuffer || obj instanceof WebGLProgram || obj instanceof WebGLRenderbuffer || obj instanceof WebGLShader || obj instanceof WebGLTexture;
    }
    function checkResources(args) {
      for (let ii = 0; ii < args.length; ++ii) {
        const arg = args[ii];
        if (isWebGLResource(arg)) {
          return arg.__webglDebugContextLostId__ == contextId_;
        }
      }
      return true;
    }
    function clearErrors() {
      const k = Object.keys(glErrorShadow_);
      for (let ii = 0; ii < k.length; ++ii) {
        delete glErrorShadow_[k[ii]];
      }
    }
    function makeLostContextWrapper(ctx2, functionName) {
      const f2 = ctx2[functionName];
      return function() {
        if (!contextLost_) {
          if (!checkResources(arguments)) {
            glErrorShadow_[ctx2.INVALID_OPERATION] = true;
            return;
          }
          const result = f2.apply(
            ctx2,
            arguments
          );
          return result;
        }
      };
    }
    for (const propertyName in ctx) {
      const ctxFuncKey = propertyName;
      if (typeof ctx[propertyName] === "function") {
        wrapper_[ctxFuncKey] = makeLostContextWrapper(ctx, ctxFuncKey);
      } else {
        wrapper_[ctxFuncKey] = ctx[ctxFuncKey];
      }
    }
    function makeWebGLContextEvent(statusMessage) {
      return { statusMessage };
    }
    function freeResources() {
      for (let ii = 0; ii < resourceDb_.length; ++ii) {
        const resource = resourceDb_[ii];
        if (resource instanceof WebGLBuffer) {
          ctx.deleteBuffer(resource);
        } else if (resource instanceof WebGLFramebuffer) {
          ctx.deleteFramebuffer(resource);
        } else if (resource instanceof WebGLProgram) {
          ctx.deleteProgram(resource);
        } else if (resource instanceof WebGLRenderbuffer) {
          ctx.deleteRenderbuffer(resource);
        } else if (resource instanceof WebGLShader) {
          ctx.deleteShader(resource);
        } else if (resource instanceof WebGLTexture) {
          ctx.deleteTexture(resource);
        }
      }
    }
    wrapper_.loseContext = function() {
      if (!contextLost_) {
        contextLost_ = true;
        ++contextId_;
        while (ctx.getError())
          ;
        clearErrors();
        glErrorShadow_[ctx.CONTEXT_LOST_WEBGL] = true;
        setTimeout(function() {
          if (onLost_) {
            onLost_(makeWebGLContextEvent("context lost"));
          }
        }, 0);
      }
    };
    wrapper_.restoreContext = function() {
      if (contextLost_) {
        if (onRestored_) {
          setTimeout(function() {
            freeResources();
            resetToInitialState(ctx);
            contextLost_ = false;
            if (onRestored_) {
              const callback = onRestored_;
              onRestored_ = nextOnRestored_;
              nextOnRestored_ = void 0;
              callback(makeWebGLContextEvent("context restored"));
            }
          }, 0);
        } else {
          throw "You can not restore the context without a listener";
        }
      }
    };
    wrapper_.getError = function() {
      if (!contextLost_) {
        let err;
        while (err = ctx.getError()) {
          glErrorShadow_[err] = true;
        }
      }
      for (const err in glErrorShadow_) {
        if (glErrorShadow_[err]) {
          delete glErrorShadow_[err];
          return +err;
        }
      }
      return ctx.NO_ERROR;
    };
    const creationFunctions = [
      "createBuffer",
      "createFramebuffer",
      "createProgram",
      "createRenderbuffer",
      "createShader",
      "createTexture"
    ];
    for (let ii = 0; ii < creationFunctions.length; ++ii) {
      const functionName = creationFunctions[ii];
      wrapper_[functionName] = function(f2) {
        return function() {
          if (contextLost_) {
            return null;
          }
          const obj = f2.apply(
            ctx,
            arguments
          );
          obj.__webglDebugContextLostId__ = contextId_;
          resourceDb_.push(obj);
          return obj;
        };
      }(ctx[functionName]);
    }
    const functionsThatShouldReturnNull = [
      "getActiveAttrib",
      "getActiveUniform",
      "getBufferParameter",
      "getContextAttributes",
      "getAttachedShaders",
      "getFramebufferAttachmentParameter",
      "getParameter",
      "getProgramParameter",
      "getProgramInfoLog",
      "getRenderbufferParameter",
      "getShaderParameter",
      "getShaderInfoLog",
      "getShaderSource",
      "getTexParameter",
      "getUniform",
      "getUniformLocation",
      "getVertexAttrib"
    ];
    for (let ii = 0; ii < functionsThatShouldReturnNull.length; ++ii) {
      const functionName = functionsThatShouldReturnNull[ii];
      wrapper_[functionName] = function(f2) {
        return function() {
          if (contextLost_) {
            return null;
          }
          return f2.apply(ctx, arguments);
        };
      }(wrapper_[functionName]);
    }
    const isFunctions = [
      "isBuffer",
      "isEnabled",
      "isFramebuffer",
      "isProgram",
      "isRenderbuffer",
      "isShader",
      "isTexture"
    ];
    for (let ii = 0; ii < isFunctions.length; ++ii) {
      const functionName = isFunctions[ii];
      wrapper_[functionName] = function(f2) {
        return function() {
          if (contextLost_) {
            return false;
          }
          return f2.apply(ctx, arguments);
        };
      }(wrapper_[functionName]);
    }
    wrapper_.checkFramebufferStatus = function(f2) {
      return function() {
        if (contextLost_) {
          return ctx.FRAMEBUFFER_UNSUPPORTED;
        }
        return f2.apply(ctx, arguments);
      };
    }(wrapper_.checkFramebufferStatus);
    wrapper_.getAttribLocation = function(f2) {
      return function() {
        if (contextLost_) {
          return -1;
        }
        return f2.apply(ctx, arguments);
      };
    }(wrapper_.getAttribLocation);
    wrapper_.getVertexAttribOffset = function(f2) {
      return function() {
        if (contextLost_) {
          return 0;
        }
        return f2.apply(ctx, arguments);
      };
    }(wrapper_.getVertexAttribOffset);
    wrapper_.isContextLost = function() {
      return contextLost_;
    };
    function wrapEvent(listener) {
      if (typeof listener == "function") {
        return listener;
      } else {
        return function(info) {
          listener.handleEvent(info);
        };
      }
    }
    wrapper_.registerOnContextLostListener = function(listener) {
      onLost_ = wrapEvent(listener);
    };
    wrapper_.registerOnContextRestoredListener = function(listener) {
      if (contextLost_) {
        nextOnRestored_ = wrapEvent(listener);
      } else {
        onRestored_ = wrapEvent(listener);
      }
    };
    return wrapper_;
  }
  return {
    init: init2,
    mightBeEnum,
    glEnumToString,
    glFunctionArgToString,
    makeDebugContext,
    makeLostContextSimulatingContext,
    resetToInitialState
  };
}();
const WebGLUtils = function() {
  const makeFailHTML = function(msg) {
    return '<div style="margin: auto; width:500px;z-index:10000;margin-top:20em;text-align:center;">' + msg + "</div>";
  };
  const GET_A_WEBGL_BROWSER = 'This page requires a browser that supports WebGL.<br/><a href="http://get.webgl.org">Click here to upgrade your browser.</a>';
  const OTHER_PROBLEM = `It doesn't appear your computer can support WebGL.<br/><a href="http://get.webgl.org">Click here for more information.</a>`;
  const setupWebGL = function(canvas, opt_attribs, opt_onError) {
    function handleCreationError(msg) {
      const container = document.getElementsByTagName("body")[0];
      if (container) {
        let str = window.WebGLRenderingContext ? OTHER_PROBLEM : GET_A_WEBGL_BROWSER;
        if (msg) {
          str += "<br/><br/>Status: " + msg;
        }
        container.innerHTML = makeFailHTML(str);
      }
    }
    opt_onError = opt_onError || handleCreationError;
    if (canvas.addEventListener) {
      canvas.addEventListener(
        "webglcontextcreationerror",
        (ev) => {
          opt_onError = opt_onError || handleCreationError;
          opt_onError(ev.statusMessage);
        },
        false
      );
    }
    const context = create3DContext(canvas, opt_attribs);
    if (!context) {
      if (!window.WebGLRenderingContext) {
        opt_onError("");
      } else {
        opt_onError("");
      }
    }
    return context;
  };
  const create3DContext = function(canvas, glAttributes) {
    const names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
    let context = null;
    for (let ii = 0; ii < names.length; ++ii) {
      try {
        context = canvas.getContext(
          names[ii],
          glAttributes
        );
      } catch (e2) {
      }
      if (context) {
        break;
      }
    }
    return context;
  };
  return {
    create3DContext,
    setupWebGL
  };
}();
if (!window.requestAnimationFrame) {
  window.requestAnimationFrame = function() {
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(callback, element) {
      window.setTimeout(callback, 1e3 / 60);
    };
  }();
}
if (!window.cancelAnimationFrame) {
  window.cancelAnimationFrame = window.cancelRequestAnimationFrame || window.webkitCancelAnimationFrame || window.webkitCancelRequestAnimationFrame || window.mozCancelAnimationFrame || window.mozCancelRequestAnimationFrame || window.msCancelAnimationFrame || window.msCancelRequestAnimationFrame || window.oCancelAnimationFrame || window.oCancelRequestAnimationFrame || window.clearTimeout;
}
function initShaders(gl, vshader, fshader) {
  const program = createProgram(gl, vshader, fshader);
  if (!program) {
    console.error("Failed to create program");
    return false;
  }
  gl.useProgram(program);
  gl.program = program;
  return true;
}
function createProgram(gl, vshader, fshader) {
  const vertexShader = loadShader(gl, gl.VERTEX_SHADER, vshader);
  const fragmentShader = loadShader(gl, gl.FRAGMENT_SHADER, fshader);
  if (!vertexShader || !fragmentShader) {
    return null;
  }
  const program = gl.createProgram();
  if (!program) {
    return null;
  }
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  const linked = gl.getProgramParameter(program, gl.LINK_STATUS);
  if (!linked) {
    const error = gl.getProgramInfoLog(program);
    console.error("Failed to link program: " + error);
    gl.deleteProgram(program);
    gl.deleteShader(fragmentShader);
    gl.deleteShader(vertexShader);
    return null;
  }
  return program;
}
function loadShader(gl, type, source2) {
  const shader = gl.createShader(type);
  if (shader == null) {
    console.error("unable to create shader");
    return null;
  }
  gl.shaderSource(shader, source2);
  gl.compileShader(shader);
  const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);
  if (!compiled) {
    const error = gl.getShaderInfoLog(shader);
    console.error("Failed to compile shader: " + error, source2);
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}
function getWebGLContext(canvas, opt_debug) {
  let gl = WebGLUtils.setupWebGL(canvas);
  if (!gl)
    return null;
  if (arguments.length < 2 || opt_debug) {
    gl = WebGLDebugUtils.makeDebugContext(gl);
  }
  return gl;
}
const VSHADER_SOURCE = `
attribute vec4 a_Position;
attribute vec2 a_TexCoord;
varying vec2 v_TexCoord;
void main() {
    gl_Position = a_Position;
    v_TexCoord = a_TexCoord;
}
`;
const FSHADER_SOURCE = `
precision highp float;
uniform sampler2D u_Sampler;
uniform vec4 u_MaskColor;
varying vec2 v_TexCoord;
void main() {
    vec4 color = texture2D(u_Sampler, v_TexCoord);
		vec3 mixRGB = color.a > 0.0 ? mix(color.rgb, u_MaskColor.rgb, u_MaskColor.a) : color.rgb;
    gl_FragColor = vec4(mixRGB, color.a);
}
`;
function initMaskRenderer(cvs, maskColor = DEFAULT_MASK_COLOR) {
  const gl = getWebGLContext(cvs);
  if (!gl) {
    return console.error("\u83B7\u53D6WebGL\u7ED8\u5236\u4E0A\u4E0B\u6587\u5931\u8D25!");
  }
  if (!initShaders(gl, VSHADER_SOURCE, FSHADER_SOURCE)) {
    return console.error("\u7740\u8272\u5668\u521D\u59CB\u5316\u5931\u8D25!");
  }
  if (!initBuffers(gl)) {
    return console.error("\u7F13\u51B2\u533A\u521D\u59CB\u5316\u5931\u8D25!");
  }
  initUniform(gl, "u_MaskColor", maskColor);
  return (image2) => {
    console.time("draw mask image");
    if (!initTexture(gl, image2)) {
      return console.error("\u7EB9\u7406\u521D\u59CB\u5316\u5931\u8D25!");
    }
    gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
    console.timeEnd("draw mask image");
  };
}
function initUniform(gl, location2, val) {
  const u_Location = gl.getUniformLocation(gl.program, location2);
  if (!u_Location) {
    return console.error("\u83B7\u53D6attribute\u53D8\u91CF\u5B58\u50A8\u4F4D\u7F6E\u5931\u8D25!");
  }
  if (Array.isArray(val)) {
    gl.uniform4fv(u_Location, val);
  } else {
    gl.uniform1i(u_Location, val);
  }
}
function initBuffers(gl) {
  const aPosition = gl.getAttribLocation(gl.program, "a_Position");
  const aTexCoord = gl.getAttribLocation(gl.program, "a_TexCoord");
  if (!~aPosition || !~aTexCoord) {
    console.error("\u83B7\u53D6attribute\u53D8\u91CF\u5B58\u50A8\u4F4D\u7F6E\u5931\u8D25!");
    return false;
  }
  const verticesBuffer = gl.createBuffer();
  const coordsBuffer = gl.createBuffer();
  if (!verticesBuffer || !coordsBuffer) {
    console.error("\u521B\u5EFA\u7F13\u51B2\u533A\u5BF9\u8C61\u5931\u8D25!");
    return false;
  }
  bindArrayBuffer(gl, verticesBuffer, aPosition, new Float32Array([-1, 1, 1, 1, -1, -1, 1, -1]));
  bindArrayBuffer(gl, coordsBuffer, aTexCoord, new Float32Array([0, 0, 1, 0, 0, 1, 1, 1]));
  return true;
}
function bindArrayBuffer(gl, buffer, attrib, data, pointNum = 2) {
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW);
  gl.vertexAttribPointer(attrib, pointNum, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(attrib);
}
function initTexture(gl, image2) {
  const texture = gl.createTexture();
  if (!texture) {
    console.error("\u521B\u5EFA\u7EB9\u7406\u5BF9\u8C61\u5931\u8D25!");
    return false;
  }
  const u_Sampler = gl.getUniformLocation(gl.program, "u_Sampler");
  if (!u_Sampler) {
    console.error("\u83B7\u53D6\u53D6\u6837\u5668\u53D8\u91CF\u5B58\u50A8\u4F4D\u7F6E\u5931\u8D25!");
    return false;
  }
  gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, 1);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, texture);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image2);
  gl.uniform1i(u_Sampler, 0);
  return true;
}
async function initMatting(initMattingConfig) {
  const {
    boardContexts: { inputCtx, outputCtx, inputHiddenCtx, inputDrawingCtx: inputDrawingCtx2, outputHiddenCtx, outputDrawingCtx: outputDrawingCtx2 },
    picFile,
    transformConfig,
    targetSize,
    gapSize
  } = initMattingConfig;
  inputCtx.value.imageSmoothingEnabled = DEFAULT_IMAGE_SMOOTH_CHOICE;
  outputCtx.value.imageSmoothingEnabled = DEFAULT_IMAGE_SMOOTH_CHOICE;
  const imageSource = await getLoadedImage(picFile);
  const { scaleRatio, positionRange } = getValidTransformConfig({ imageSource, transformConfig, targetSize, gapSize });
  const validImageSize = computeValidImageSize(imageSource);
  initHiddenBoardWithSource({
    imageSource,
    targetSize: validImageSize,
    hiddenCtx: inputHiddenCtx.value,
    drawingCtx: inputDrawingCtx2
  });
  transformedDrawImage({
    hiddenCtx: inputHiddenCtx.value,
    ctx: inputCtx.value,
    scaleRatio,
    positionRange
  });
  initHiddenBoard({
    targetSize: validImageSize,
    hiddenCtx: outputHiddenCtx.value,
    drawingCtx: outputDrawingCtx2
  });
  const raw = await createImageBitmap(inputHiddenCtx.value.canvas);
  const mask = await generateMaskImageSource({ targetSize: validImageSize, imageSource });
  return { orig: imageSource, raw, mask, positionRange, scaleRatio };
}
function generateMaskImageSource(config2) {
  const {
    targetSize: { width, height },
    imageSource
  } = config2;
  const cvs = document.createElement("canvas");
  cvs.width = width;
  cvs.height = height;
  const render2 = initMaskRenderer(cvs);
  if (render2) {
    render2(imageSource);
  }
  return createImageBitmap(cvs);
}
function getValidTransformConfig(getParametersConfig) {
  const { transformConfig, ...computeConfig } = getParametersConfig;
  if (isInvalidTransformConfig(transformConfig)) {
    const { scaleRatio, positionRange } = computeTransformConfig(computeConfig);
    transformConfig.scaleRatio = scaleRatio;
    transformConfig.positionRange = positionRange;
  }
  return transformConfig;
}
function isInvalidTransformConfig(transformConfig) {
  const { scaleRatio, positionRange } = transformConfig;
  return !scaleRatio || !positionRange;
}
function computeTransformConfig(computeConfig) {
  const { imageSource, targetSize, gapSize = INITIAL_GAP_SIZE } = computeConfig;
  const imageSize = computeValidImageSize(imageSource);
  return computeTransformParameters({
    gapSize,
    imageSize,
    targetSize
  });
}
function throttle$1(delay, callback, options) {
  var _ref = options || {}, _ref$noTrailing = _ref.noTrailing, noTrailing = _ref$noTrailing === void 0 ? false : _ref$noTrailing, _ref$noLeading = _ref.noLeading, noLeading = _ref$noLeading === void 0 ? false : _ref$noLeading, _ref$debounceMode = _ref.debounceMode, debounceMode = _ref$debounceMode === void 0 ? void 0 : _ref$debounceMode;
  var timeoutID;
  var cancelled = false;
  var lastExec = 0;
  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  }
  function cancel(options2) {
    var _ref2 = options2 || {}, _ref2$upcomingOnly = _ref2.upcomingOnly, upcomingOnly = _ref2$upcomingOnly === void 0 ? false : _ref2$upcomingOnly;
    clearExistingTimeout();
    cancelled = !upcomingOnly;
  }
  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }
    var self2 = this;
    var elapsed = Date.now() - lastExec;
    if (cancelled) {
      return;
    }
    function exec() {
      lastExec = Date.now();
      callback.apply(self2, arguments_);
    }
    function clear() {
      timeoutID = void 0;
    }
    if (!noLeading && debounceMode && !timeoutID) {
      exec();
    }
    clearExistingTimeout();
    if (debounceMode === void 0 && elapsed > delay) {
      if (noLeading) {
        lastExec = Date.now();
        if (!noTrailing) {
          timeoutID = setTimeout(debounceMode ? clear : exec, delay);
        }
      } else {
        exec();
      }
    } else if (noTrailing !== true) {
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === void 0 ? delay - elapsed : delay);
    }
  }
  wrapper.cancel = cancel;
  return wrapper;
}
function debounce(delay, callback, options) {
  var _ref = options || {}, _ref$atBegin = _ref.atBegin, atBegin = _ref$atBegin === void 0 ? false : _ref$atBegin;
  return throttle$1(delay, callback, {
    debounceMode: atBegin !== false
  });
}
function useInitMattingBoards(props2, useInitMattingBoardsConfig) {
  const { picFile } = props2;
  const {
    boardContexts,
    boardContexts: { inputCtx, outputCtx, inputHiddenCtx, outputHiddenCtx }
  } = useInitMattingBoardsConfig;
  const { initMattingResult, width, height, initialized } = useInitMattingBoardsConfig;
  const { boardRect, transformConfig, mattingSources } = useInitMattingBoardsConfig;
  const updateBoardRect = () => {
    boardRect.value = computeBoardRect(inputCtx.value.canvas);
  };
  const resizeBoards = () => {
    requestAnimationFrame(() => {
      const commonConfig = { targetHeight: height.value, targetWidth: width.value, transformConfig };
      resizeCanvas({
        ctx: inputCtx.value,
        hiddenCtx: inputHiddenCtx.value,
        ...commonConfig
      });
      resizeCanvas({
        ctx: outputCtx.value,
        hiddenCtx: outputHiddenCtx.value,
        withBorder: true,
        ...commonConfig
      });
    });
  };
  watch([picFile], async () => {
    if (picFile.value && width.value && height.value) {
      initialized.value = false;
      initMattingResult.value = await initMatting({
        boardContexts,
        picFile: picFile.value,
        targetSize: { width: width.value, height: height.value },
        transformConfig: {},
        imageSources: {}
      });
      const { raw, mask, orig, positionRange, scaleRatio } = initMattingResult.value;
      transformConfig.positionRange = positionRange;
      transformConfig.scaleRatio = scaleRatio;
      mattingSources.value = { raw, mask, orig };
      updateBoardRect();
      resizeBoards();
      initialized.value = true;
    }
  });
  onMounted(() => {
    window.addEventListener(EventType.Resize, resizeBoards);
    window.addEventListener("scroll", debounce(UPDATE_BOARDRECT_DEBOUNCE_TIME, updateBoardRect));
  });
  onUnmounted(() => {
    window.removeEventListener(EventType.Resize, resizeBoards);
  });
}
function useMatting() {
  const picFile = ref$1(null);
  const isErasing = ref$1(false);
  const radius = ref$1(INITIAL_RADIUS);
  const hardness = ref$1(INITIAL_HARDNESS);
  const brushSize = computed$1(() => radius.value * RADIUS_TO_BRUSH_SIZE_RATIO);
  const hardnessText = computed$1(() => `${Math.round(hardness.value * HARDNESS_ZOOM_TO_SLIDER_RATIO)}%`);
  return {
    picFile,
    isErasing,
    radius,
    hardness,
    brushSize,
    hardnessText
  };
}
const inputDrawingCtx = createContext2D();
const outputDrawingCtx = createContext2D();
function useMattingBoard(props2) {
  const width = ref$1(0);
  const height = ref$1(0);
  const inputCtx = ref$1(null);
  const outputCtx = ref$1(null);
  const initMattingResult = ref$1(null);
  const draggingInputBoard = ref$1(false);
  const isDrawing = ref$1(false);
  const transformConfig = reactive$1(INITIAL_TRANSFORM_CONFIG);
  const mattingSources = ref$1(null);
  const boardRect = ref$1(null);
  const initialized = ref$1(false);
  const inputHiddenCtx = ref$1(createContext2D());
  const outputHiddenCtx = ref$1(createContext2D());
  const listenerManager = new ListenerManager();
  const initMattingConfig = {
    boardContexts: { inputCtx, outputCtx, inputDrawingCtx, outputDrawingCtx, inputHiddenCtx, outputHiddenCtx },
    initMattingResult,
    transformConfig,
    mattingSources,
    initialized,
    boardRect
  };
  const initListenersConfig = { ...initMattingConfig, draggingInputBoard, isDrawing, listenerManager };
  useInitMattingBoards(props2, { ...initMattingConfig, width, height });
  useInitDrawingListeners(props2, initListenersConfig);
  useInitTransformListener(initListenersConfig);
  return {
    width,
    height,
    inputCtx,
    outputCtx,
    inputHiddenCtx,
    outputHiddenCtx,
    draggingInputBoard,
    transformConfig,
    initialized,
    mattingSources,
    inputDrawingCtx
  };
}
var iconEraser = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAMAAACahl6sAAAAqFBMVEUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAs30iGAAAAN3RSTlMAuWM77dq/k2lBMiPo0K6po0kdF8e0jXteCfvz49XLmYRZVBIDw552cm4p996If04rRjZQDu8uOlnnbwAABJZJREFUeNrt3Ily2jAQBuA15jJgDmMg3DeEq5zNvv+btZ1OJ1VbEtvS2qvOfm/giSOt/x8JhBBCCCGEEEIIIYQQQggh+Mt1sJED6+0d/MG5gN2qPv5UqIDNggn+cryBvdohvhu5YKvlGn9X88BODwdVX1tgo76DfxqewT6rDv5tsADr1PGf5mCZBj7xAlZp4lNWjSsb/EAZrDHFD+3AEiX8xBas0MVP9cACJ4zgC7A3w0hmwNwXjKgLrPUwshIw9or4XzzJDmPZAFNljKkJLOUwtgYw9IIJ1FfAzRwT6fSBlwUm5CyBk/sAkyq2gY/WAZNbB8DFdYg6wirw4OVRj8/jSdwa6hpzCOtvI9TAJ6yvHFEDn7D+UkANfML6/Rg18Anrqz5q4BPWByFq4BPWt9eogU9YvyyiBj5h/cNBDXzC+n4HNfAJ61d11MAorG+gBkZhfRMJvUJqNqiBUVg/RQ2MwvoSkmvB32x8DlwDvS6mIA8aNAopCx/kWZFj26vVwycs+2ff4lNWLb9KITXGBHg0pTslwNn7GBOXnrSshB4VqIYYGaduMadEHi4ABEUkMAVaL0rg4cEPbQcj4NWQKoXU4Qo/LTv4CW79qFpIneGXfh0/wK8dPSuF1ALerRr4BMdutDVUgo4IH4s8m1HvqxJzkH1mOQ8gpRY5ZbIPlOISSLkjJRgg+0RZt4GUWuT0yD5SJgGQeitEmkpnyLwPVYucEzzV492GVv3IU+mWcxcaTGJMpTtMbHQDUu0w1jRXxoRqLpBqF2NOczlMJO8BqaUTe5qbYwLDFpBSTxbVIZLFAeM6nIGUerLI6UM05yG3/rOuTEEPiOqa59V+NhJPQV6NU/fZ1JiC3COf5nOjNQVVClx6z6kyPVwgrsuYR1eofCcdKxBfdYIRbIFW18D0EITZN54nI9NDu5h1UD0zND0sHfzQCUiphdTgTPZblS7QUr/zFmS/VikBrVezu24zq8B9Z3rX3WQTuJfN77rTLAL3HMWuW0o/cH+h2XVPaQfuc6p6eJZu4L4g23V7qR5Eug+odqvXVI8htQ5Uu9VO4xCS7smiKdlKOKkCKS9PtVupK6G/B1JujWq3mquB+xuQuo2oVvnzIM3AvXKkWuVbwzQP7FwKVKu8l0/1uI5DtcqrFWr+CqTU5TEMqN7YYQuINYjqSLV6PNyBGr4b78GYqq8RuGv/RQpvYEgQpn5IJ0ex0i+LGRzRccwfM304WRzQ2Y9N71qrejbHc/a+4aK4kdXhnKpvtCpuZncjWDAxuAdPs7wPrD0xtguXsr1Dqx8aKr67moG7vtDIRDFjcBPY2sBM0WNxe1ZRu8bfJgzcuT3Jjs0dYEWtSa/M6AYwR531NIKfxgoylXzam6uBe+Z3ZnUSPsldDdwfkLlkk2vrwO/mr2aC2dX7yvHer2ns6dWt8bz1qxtzfq2MlMCdx01Z/5iYvsSKKv09MLLFzOTDLRiUwww5YNAd9fC54eWK2ZmASR7q4HS5gIsRcX8QcAcYEetX67tbDRPhdwlSpYBZAPPexpiyfHgCIYQQQgghhBBCCCGEEEIIE74BPoWbxHyLr50AAAAASUVORK5CYII=";
class MattingCursor {
  constructor(inputCtx, isErasing) {
    this.inputCtx = inputCtx;
    this.isErasing = isErasing;
    this.cursorImage = ref$1("");
    this.inputCursorStyle = ref$1(null);
    this.mattingCursorStyle = reactive$1(/* @__PURE__ */ Object.create(null));
    this.radius = ref$1(INITIAL_RADIUS);
    this.hardness = ref$1(INITIAL_HARDNESS);
    this.inputCanvas = computed$1(() => this.inputCtx.value.canvas);
    this.pointInnerColor = computed$1(() => this.isErasing.value ? ERASE_POINT_INNER_COLOR : REPAIR_POINT_INNER_COLOR);
    this.pointOuterColor = computed$1(() => this.isErasing.value ? ERASE_POINT_OUTER_COLOR : REPAIR_POINT_OUTER_COLOR);
    this.ctx = this.creatCursorCanvas();
  }
  creatCursorCanvas() {
    const ctx = document.createElement("canvas").getContext("2d");
    return this.updateCtx(ctx);
  }
  updateCtx(ctx) {
    ctx.canvas.width = this.radius.value * 2;
    ctx.canvas.height = this.radius.value * 2;
    return ctx;
  }
  async createCursorImage() {
    this.ctx = this.updateCtx(this.ctx);
    const drawingConfig = {
      ctx: this.ctx,
      x: this.radius.value,
      y: this.radius.value,
      radius: this.radius.value,
      hardness: this.hardness.value,
      innerColor: this.pointInnerColor.value,
      outerColor: this.pointOuterColor.value
    };
    drawBrushPoint(drawingConfig);
    await this.drawIcon();
    return await this.ctx.canvas.toDataURL();
  }
  async drawIcon() {
    if (this.isErasing.value) {
      const eraser = await getLoadedImage(iconEraser);
      this.ctx.drawImage(eraser, 0, 0, this.radius.value * 2, this.radius.value * 2);
    }
  }
  renderOutputCursor() {
    const target = this.inputCanvas.value;
    target.addEventListener(EventType.Mouseover, this.onShowCursor.bind(this));
    target.addEventListener(EventType.Mousemove, this.onRenderOutputCursor.bind(this));
    target.addEventListener(EventType.Mouseout, this.onHideCursor.bind(this));
  }
  onShowCursor() {
    this.mattingCursorStyle.display = "initial";
  }
  onHideCursor() {
    this.mattingCursorStyle.display = "none";
  }
  onRenderOutputCursor(e2) {
    this.mattingCursorStyle.left = e2.offsetX - this.radius.value + "px";
    this.mattingCursorStyle.top = e2.offsetY - this.radius.value + "px";
  }
  changeOutputCursorByDrag([isDragging]) {
    if (isDragging) {
      this.onHideCursor();
    } else {
      this.onShowCursor();
    }
  }
  updateCursorParams(currHardness, currRadius) {
    this.hardness.value = currHardness;
    this.radius.value = currRadius;
  }
}
function useMattingCursor(config2) {
  const { inputCtx, isDragging, isErasing, hardness, radius } = config2;
  const mattingCursor = new MattingCursor(inputCtx, isErasing);
  const { cursorImage, mattingCursorStyle, renderOutputCursor } = mattingCursor;
  watchEffect(async () => {
    mattingCursor.updateCursorParams(hardness.value, radius.value);
    cursorImage.value = await mattingCursor.createCursorImage();
  });
  watch([isDragging], mattingCursor.changeOutputCursorByDrag.bind(mattingCursor));
  return {
    mattingCursor,
    mattingCursorStyle,
    cursorImage,
    renderOutputCursor: renderOutputCursor.bind(mattingCursor)
  };
}
var ImageExtraction_vue_vue_type_style_index_0_scoped_true_lang$1 = "";
const _sfc_main$K = defineComponent({
  props: {
    hasHeader: {
      type: Boolean,
      default: true
    }
  },
  emits: ["register"],
  setup(props2, { emit: emit2 }) {
    const inputCvs = ref$1(null);
    const outputCvs = ref$1(null);
    const resultURL = ref$1("");
    const resultLink = ref$1(null);
    const generating = ref$1(false);
    const { picFile, isErasing, radius, hardness, brushSize, hardnessText } = useMatting();
    const { width, height, inputCtx, inputHiddenCtx, outputCtx, outputHiddenCtx, draggingInputBoard, initialized, mattingSources, transformConfig, inputDrawingCtx: inputDrawingCtx2 } = useMattingBoard({ picFile, isErasing, radius, hardness });
    const { cursorImage, mattingCursorStyle, renderOutputCursor } = useMattingCursor({
      inputCtx,
      isDragging: draggingInputBoard,
      isErasing,
      radius,
      hardness
    });
    const downloadFileName = computed$1(() => picFile.value ? `matting_${picFile.value.name}` : "null");
    const cantSave = computed$1(() => generating.value || !initialized.value);
    const saveBtnClass = computed$1(() => ({ "save-btn": true, disabled: cantSave.value }));
    const saveBtnText = computed$1(() => generating.value ? "\u4FDD\u5B58\u4E2D..." : "\u4FDD\u5B58");
    const onFileChange = (ev) => {
      const { files } = ev.target;
      if (files && files[0] && /.+\.(jpg|jpeg|png|gif|webp)/.test(files[0].name)) {
        picFile.value = files[0];
      } else {
        alert("\u672A\u9009\u62E9\u56FE\u7247\u6216\u56FE\u7247\u683C\u5F0F\u4E0D\u6B63\u786E(\u53EA\u652F\u6301jpg\u3001png\u3001gif\u3001webp), \u8BF7\u91CD\u65B0\u9009\u62E9");
      }
    };
    const initLoadImages = (source2, result) => {
      nextTick(() => {
        fetch(source2).then((response) => response.blob()).then((blob) => {
          picFile.value = new File([blob], `image_${Math.random()}.jpg`, { type: "image/jpeg" });
        }).catch((error) => {
          console.error("\u83B7\u53D6\u56FE\u7247\u5931\u8D25:", error);
        });
        watch(
          () => initialized.value,
          async () => {
            const image2 = await loadNetImg(result);
            outputHiddenCtx.value.drawImage(image2, 0, 0);
            let canvas = document.createElement("canvas");
            canvas.width = image2.width;
            canvas.height = image2.height;
            let ctx = canvas.getContext("2d");
            ctx.drawImage(image2, 0, 0);
            let imageData = ctx.getImageData(0, 0, image2.width, image2.height);
            let data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
              if (data[i + 3] > 0) {
                data[i] = DEFAULT_MASK_COLOR[0] * 255;
                data[i + 1] = DEFAULT_MASK_COLOR[1] * 255;
                data[i + 2] = DEFAULT_MASK_COLOR[2] * 255;
                data[i + 3] = (DEFAULT_MASK_COLOR[3] - 0.15) * 255;
              }
            }
            await nextTick();
            setTimeout(async () => {
              transformConfig.scaleRatio += 1e-4;
              transformConfig.scaleRatio -= 1e-4;
              setTimeout(() => {
                inputDrawingCtx2.putImageData(imageData, 0, 0);
                inputHiddenCtx.value.drawImage(inputDrawingCtx2.canvas, 0, 0);
                console.log("ok");
                setTimeout(() => {
                  transformConfig.scaleRatio += 1e-4;
                  transformConfig.scaleRatio -= 1e-4;
                }, 100);
              }, 100);
            }, 100);
          }
        );
      });
    };
    function loadNetImg(src) {
      return new Promise((resolve) => {
        let image2 = new Image();
        image2.crossOrigin = "anonymous";
        image2.src = src;
        image2.onload = function() {
          resolve(image2);
        };
      });
    }
    function handlechangeRadius(e2) {
      radius.value = Number(radius.value);
      if (e2.code === "BracketLeft") {
        radius.value > RADIUS_SLIDER_MIN + RADIUS_SLIDER_STEP && (radius.value -= RADIUS_SLIDER_STEP);
      } else if (e2.code === "BracketRight") {
        radius.value < RADIUS_SLIDER_MAX - RADIUS_SLIDER_STEP && (radius.value += RADIUS_SLIDER_STEP);
      }
    }
    function initContextsAndSize() {
      const inputCanvas = inputCvs.value;
      const outputCanvas = outputCvs.value;
      inputCtx.value = inputCanvas.getContext("2d");
      outputCtx.value = outputCanvas.getContext("2d");
      const { clientWidth, clientHeight } = inputCanvas;
      width.value = clientWidth;
      height.value = clientHeight;
    }
    function onDownloadResult() {
      if (mattingSources.value && !generating.value) {
        generating.value = true;
        const url = generateResultImageURL(mattingSources.value.orig, outputHiddenCtx.value);
        generating.value = false;
        resultURL.value = url;
        setTimeout(() => {
          var _a2;
          (_a2 = resultLink.value) == null ? void 0 : _a2.click();
        });
      }
    }
    function getResult() {
      if (mattingSources.value && !generating.value) {
        return generateResultImageURL(mattingSources.value.orig, outputHiddenCtx.value);
      }
    }
    onMounted(() => {
      emit2("register", {
        isErasing,
        onDownloadResult,
        onFileChange,
        initLoadImages,
        radius,
        hardness,
        brushSize,
        hardnessText,
        constants: {
          RADIUS_SLIDER_MIN,
          RADIUS_SLIDER_MAX,
          RADIUS_SLIDER_STEP,
          HARDNESS_SLIDER_MAX,
          HARDNESS_SLIDER_STEP,
          HARDNESS_SLIDER_MIN
        },
        getResult
      });
      initContextsAndSize();
      renderOutputCursor();
      document.addEventListener("keydown", handlechangeRadius, false);
    });
    onUnmounted(() => {
      document.removeEventListener("keydown", handlechangeRadius, false);
    });
    return {
      onDownloadResult,
      onFileChange,
      inputCvs,
      outputCvs,
      resultURL,
      resultLink,
      isErasing,
      radius,
      hardness,
      brushSize,
      hardnessText,
      saveBtnText,
      downloadFileName,
      saveBtnClass,
      cursorImage,
      mattingCursorStyle,
      cantSave,
      RADIUS_SLIDER_MIN,
      RADIUS_SLIDER_MAX,
      RADIUS_SLIDER_STEP,
      HARDNESS_SLIDER_MAX,
      HARDNESS_SLIDER_STEP,
      HARDNESS_SLIDER_MIN
    };
  }
});
const _withScopeId$l = (n) => (pushScopeId("data-v-0e02acde"), n = n(), popScopeId(), n);
const _hoisted_1$I = {
  key: 0,
  class: "options-container"
};
const _hoisted_2$C = { class: "default-wrap" };
const _hoisted_3$y = { class: "option" };
const _hoisted_4$t = /* @__PURE__ */ _withScopeId$l(() => /* @__PURE__ */ createElementVNode("label", { for: "image" }, "\u9009\u62E9\u56FE\u7247\uFF1A", -1));
const _hoisted_5$n = { class: "option" };
const _hoisted_6$h = /* @__PURE__ */ _withScopeId$l(() => /* @__PURE__ */ createElementVNode("span", null, "\u753B\u7B14\u7C7B\u578B\uFF1A", -1));
const _hoisted_7$d = /* @__PURE__ */ _withScopeId$l(() => /* @__PURE__ */ createElementVNode("label", { for: "fix" }, "\u4FEE\u8865", -1));
const _hoisted_8$a = /* @__PURE__ */ _withScopeId$l(() => /* @__PURE__ */ createElementVNode("label", { for: "matting" }, "\u64E6\u9664", -1));
const _hoisted_9$6 = { class: "option" };
const _hoisted_10$5 = /* @__PURE__ */ _withScopeId$l(() => /* @__PURE__ */ createElementVNode("label", { for: "radius" }, "\u753B\u7B14\u5C3A\u5BF8\uFF1A", -1));
const _hoisted_11$4 = ["max", "min", "step"];
const _hoisted_12$2 = { class: "option" };
const _hoisted_13$1 = /* @__PURE__ */ _withScopeId$l(() => /* @__PURE__ */ createElementVNode("label", { for: "hardness" }, "\u753B\u7B14\u786C\u5EA6\uFF1A", -1));
const _hoisted_14$1 = ["max", "min", "step"];
const _hoisted_15$1 = ["disabled"];
const _hoisted_16$1 = { class: "board-container" };
const _hoisted_17$1 = { class: "matting-wrapper" };
const _hoisted_18$1 = {
  ref: "inputCvs",
  class: "matting-board"
};
const _hoisted_19$1 = ["src"];
const _hoisted_20$1 = { class: "matting-wrapper" };
const _hoisted_21$1 = {
  ref: "outputCvs",
  class: "result-board"
};
const _hoisted_22 = ["src"];
const _hoisted_23 = ["href", "download"];
function _sfc_render$G(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment, null, [
    _ctx.hasHeader ? (openBlock(), createElementBlock("div", _hoisted_1$I, [
      renderSlot(_ctx.$slots, "default", {}, () => [
        createElementVNode("div", _hoisted_2$C, [
          createElementVNode("div", _hoisted_3$y, [
            _hoisted_4$t,
            createElementVNode("input", {
              id: "image",
              type: "file",
              accept: ".jpg,.png,.gif,.webp",
              onChange: _cache[0] || (_cache[0] = (...args) => _ctx.onFileChange && _ctx.onFileChange(...args))
            }, null, 32)
          ]),
          createElementVNode("div", _hoisted_5$n, [
            _hoisted_6$h,
            _hoisted_7$d,
            withDirectives(createElementVNode("input", {
              id: "fix",
              "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.isErasing = $event),
              type: "radio",
              value: false
            }, null, 512), [
              [vModelRadio, _ctx.isErasing]
            ]),
            _hoisted_8$a,
            withDirectives(createElementVNode("input", {
              id: "matting",
              "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.isErasing = $event),
              value: true,
              type: "radio"
            }, null, 512), [
              [vModelRadio, _ctx.isErasing]
            ])
          ]),
          createElementVNode("div", _hoisted_9$6, [
            _hoisted_10$5,
            withDirectives(createElementVNode("input", {
              id: "radius",
              "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.radius = $event),
              class: "range-input",
              type: "range",
              max: _ctx.RADIUS_SLIDER_MAX,
              min: _ctx.RADIUS_SLIDER_MIN,
              step: _ctx.RADIUS_SLIDER_STEP
            }, null, 8, _hoisted_11$4), [
              [vModelText, _ctx.radius]
            ]),
            createElementVNode("span", null, toDisplayString(_ctx.brushSize), 1)
          ]),
          createElementVNode("div", _hoisted_12$2, [
            _hoisted_13$1,
            withDirectives(createElementVNode("input", {
              id: "hardness",
              "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => _ctx.hardness = $event),
              class: "range-input",
              type: "range",
              max: _ctx.HARDNESS_SLIDER_MAX,
              min: _ctx.HARDNESS_SLIDER_MIN,
              step: _ctx.HARDNESS_SLIDER_STEP
            }, null, 8, _hoisted_14$1), [
              [vModelText, _ctx.hardness]
            ]),
            createElementVNode("span", null, toDisplayString(_ctx.hardnessText), 1)
          ]),
          createElementVNode("button", {
            class: normalizeClass(_ctx.saveBtnClass),
            disabled: _ctx.cantSave,
            onClick: _cache[5] || (_cache[5] = (...args) => _ctx.onDownloadResult && _ctx.onDownloadResult(...args))
          }, toDisplayString(_ctx.saveBtnText), 11, _hoisted_15$1)
        ])
      ], true)
    ])) : createCommentVNode("", true),
    createElementVNode("div", _hoisted_16$1, [
      createElementVNode("div", _hoisted_17$1, [
        createElementVNode("canvas", _hoisted_18$1, null, 512),
        createElementVNode("img", {
          ref: "inputCursor",
          class: "matting-cursor",
          style: normalizeStyle(_ctx.mattingCursorStyle),
          src: _ctx.cursorImage
        }, null, 12, _hoisted_19$1)
      ]),
      createElementVNode("div", _hoisted_20$1, [
        createElementVNode("canvas", _hoisted_21$1, null, 512),
        createElementVNode("img", {
          class: "matting-cursor",
          style: normalizeStyle(_ctx.mattingCursorStyle),
          src: _ctx.cursorImage
        }, null, 12, _hoisted_22)
      ])
    ]),
    createElementVNode("a", {
      ref: "resultLink",
      href: _ctx.resultURL,
      download: _ctx.downloadFileName
    }, null, 8, _hoisted_23)
  ], 64);
}
var matting = /* @__PURE__ */ _export_sfc(_sfc_main$K, [["render", _sfc_render$G], ["__scopeId", "data-v-0e02acde"]]);
matting.install = (app) => {
  app.component(matting.name, matting);
};
var elRadioGroup = "";
var elRadio = "";
var numberSlider_vue_vue_type_style_index_0_lang = "";
var numberSlider_vue_vue_type_style_index_1_scoped_true_lang = "";
const NAME$j = "number-slider";
const _sfc_main$J = {
  name: NAME$j,
  props: {
    label: {
      default: ""
    },
    labelWidth: {
      default: "71px"
    },
    modelValue: {
      default: 0
    },
    minValue: {
      default: 0
    },
    maxValue: {
      default: 500
    },
    step: {
      default: 1
    },
    showInput: {
      default: true
    }
  },
  emits: ["update:modelValue", "finish"],
  data() {
    return {
      innerValue: 0
    };
  },
  computed: {
    ...mapGetters([])
  },
  watch: {
    innerValue(value) {
      if (this.modelValue !== value) {
        this.$emit("update:modelValue", value);
      }
    },
    modelValue(val) {
      this.innerValue = this.modelValue;
    }
  },
  created() {
    this.innerValue = this.modelValue;
  },
  methods: {
    ...mapActions([]),
    changeValue(value) {
      this.$emit("finish", value);
    }
  }
};
const _hoisted_1$H = { id: "number-slider" };
function _sfc_render$F(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_slider = resolveComponent("el-slider");
  return openBlock(), createElementBlock("div", _hoisted_1$H, [
    createElementVNode("span", {
      style: normalizeStyle({ width: $props.labelWidth }),
      class: "label"
    }, toDisplayString($props.label), 5),
    createVNode(_component_el_slider, {
      modelValue: $data.innerValue,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.innerValue = $event),
      min: $props.minValue,
      max: $props.maxValue,
      step: $props.step,
      "input-size": "small",
      "show-input": $props.showInput,
      "show-tooltip": false,
      "show-input-controls": false,
      onChange: $options.changeValue
    }, null, 8, ["modelValue", "min", "max", "step", "show-input", "onChange"])
  ]);
}
var numberSlider = /* @__PURE__ */ _export_sfc(_sfc_main$J, [["render", _sfc_render$F], ["__scopeId", "data-v-c46bb7cc"]]);
var __glob_0_9 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": numberSlider
}, Symbol.toStringTag, { value: "Module" }));
var ImageExtraction_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$I = defineComponent({
  components: { matting, ElRadioGroup, ElRadio, numberSlider },
  setup() {
    const state = reactive$1({
      show: false,
      showMatting: false,
      isErasing: false,
      radius: 0,
      brushSize: "",
      hardness: 0,
      hardnessText: "",
      constants: {}
    });
    const params = { raw: "", result: "" };
    let matting2 = {};
    let callback = null;
    const mattingStart = (mattingOptions) => {
      mattingOptions.initLoadImages(params.raw, params.result);
      state.isErasing = mattingOptions.isErasing;
      state.radius = mattingOptions.radius;
      state.hardness = mattingOptions.hardness;
      state.constants = mattingOptions.constants;
      matting2 = mattingOptions;
    };
    const open = async (raw, result, cb) => {
      state.show = true;
      params.raw = raw;
      params.result = result;
      await nextTick();
      setTimeout(() => {
        state.showMatting = true;
      }, 300);
      callback = cb;
    };
    const done = () => {
      state.show = false;
      callback(matting2.getResult());
    };
    return {
      ...toRefs(state),
      open,
      done,
      mattingStart
    };
  }
});
const _withScopeId$k = (n) => (pushScopeId("data-v-3127cd30"), n = n(), popScopeId(), n);
const _hoisted_1$G = { class: "tool-wrap" };
const _hoisted_2$B = /* @__PURE__ */ _withScopeId$k(() => /* @__PURE__ */ createElementVNode("b", null, "\u4FEE\u8865\u753B\u7B14", -1));
const _hoisted_3$x = /* @__PURE__ */ _withScopeId$k(() => /* @__PURE__ */ createElementVNode("i", { class: "icon sd-xiubu" }, null, -1));
const _hoisted_4$s = /* @__PURE__ */ _withScopeId$k(() => /* @__PURE__ */ createElementVNode("b", null, "\u64E6\u9664\u753B\u7B14", -1));
const _hoisted_5$m = /* @__PURE__ */ _withScopeId$k(() => /* @__PURE__ */ createElementVNode("i", { class: "icon sd-cachu" }, null, -1));
function _sfc_render$E(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_button = resolveComponent("el-button");
  const _component_el_radio = resolveComponent("el-radio");
  const _component_el_radio_group = resolveComponent("el-radio-group");
  const _component_number_slider = resolveComponent("number-slider");
  const _component_matting = resolveComponent("matting");
  const _component_el_dialog = resolveComponent("el-dialog");
  return openBlock(), createElementBlock("div", null, [
    createVNode(_component_el_dialog, {
      modelValue: _ctx.show,
      "onUpdate:modelValue": _cache[3] || (_cache[3] = ($event) => _ctx.show = $event),
      "align-center": "",
      width: "90%",
      onClose: _cache[4] || (_cache[4] = ($event) => _ctx.showMatting = false)
    }, {
      header: withCtx(() => [
        createElementVNode("div", _hoisted_1$G, [
          createVNode(_component_el_button, {
            type: "primary",
            plain: "",
            onClick: _ctx.done
          }, {
            default: withCtx(() => [
              createTextVNode("\u786E\u8BA4\u5E94\u7528")
            ]),
            _: 1
          }, 8, ["onClick"]),
          createVNode(_component_el_radio_group, {
            modelValue: _ctx.isErasing,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.isErasing = $event),
            style: { "margin-left": "35px" }
          }, {
            default: withCtx(() => [
              createVNode(_component_el_radio, {
                label: false,
                size: "large"
              }, {
                default: withCtx(() => [
                  _hoisted_2$B,
                  createTextVNode(),
                  _hoisted_3$x
                ]),
                _: 1
              }),
              createVNode(_component_el_radio, {
                label: true,
                size: "large"
              }, {
                default: withCtx(() => [
                  _hoisted_4$s,
                  createTextVNode(),
                  _hoisted_5$m
                ]),
                _: 1
              })
            ]),
            _: 1
          }, 8, ["modelValue"]),
          createVNode(_component_number_slider, {
            modelValue: _ctx.radius,
            "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.radius = $event),
            class: "slider-wrap",
            label: "\u753B\u7B14\u5C3A\u5BF8",
            showInput: false,
            labelWidth: "90px",
            maxValue: _ctx.constants.RADIUS_SLIDER_MAX,
            minValue: _ctx.constants.RADIUS_SLIDER_MIN,
            step: _ctx.constants.RADIUS_SLIDER_STEP
          }, null, 8, ["modelValue", "maxValue", "minValue", "step"]),
          createVNode(_component_number_slider, {
            modelValue: _ctx.hardness,
            "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => _ctx.hardness = $event),
            class: "slider-wrap",
            label: "\u753B\u7B14\u786C\u5EA6",
            showInput: false,
            labelWidth: "90px",
            maxValue: _ctx.constants.HARDNESS_SLIDER_MAX,
            minValue: _ctx.constants.HARDNESS_SLIDER_MIN,
            step: _ctx.constants.HARDNESS_SLIDER_STEP
          }, null, 8, ["modelValue", "maxValue", "minValue", "step"])
        ])
      ]),
      default: withCtx(() => [
        _ctx.showMatting ? (openBlock(), createBlock(_component_matting, {
          key: 0,
          hasHeader: false,
          onRegister: _ctx.mattingStart
        }, null, 8, ["onRegister"])) : createCommentVNode("", true)
      ]),
      _: 1
    }, 8, ["modelValue"])
  ]);
}
var ImageExtraction = /* @__PURE__ */ _export_sfc(_sfc_main$I, [["render", _sfc_render$E], ["__scopeId", "data-v-3127cd30"]]);
var ImageCutout_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$H = defineComponent({
  components: { uploader, UploadFilled: upload_filled_default, ElProgress, ImageExtraction },
  emits: ["done"],
  setup(props2, { emit: emit2 }) {
    const store = useStore();
    const state = reactive$1({
      raw: null,
      offsetWidth: 0,
      percent: 0,
      progress: 0,
      progressText: "",
      toolModel: true,
      loading: false,
      matting: null
    });
    let fileName = "unknow";
    let isRuning = false;
    const show = computed$1(() => store.state.imageCutoutVisible);
    const rawImage = computed$1(() => store.state.imageCutoutRaw);
    const cutImage = computed$1(() => store.state.imageCutoutResult);
    const open = (file) => {
      state.loading = false;
      state.show = true;
      store.commit("setShowMoveable", false);
      nextTick(() => {
        if (file) {
          selectFile(file);
          state.toolModel = false;
        }
      });
    };
    const handleClose = () => {
      store.commit("setShowMoveable", true);
      store.commit("setImageCutoutVisible", false);
      store.commit("setImageCutoutResult", null);
      store.commit("setImageCutoutRaw", null);
    };
    const mousemove = (e2) => {
      !isRuning && (state.percent = e2.offsetX / e2.target.width * 100);
    };
    const download2 = () => {
      _dl.downloadBase64File(state.cutImage, fileName);
    };
    const clear = () => {
      URL.revokeObjectURL(state.rawImage);
      state.rawImage = "";
      state.cutImage = "";
      state.percent = 0;
      state.offsetWidth = 0;
    };
    const run = () => {
      state.percent += 1;
      isRuning = true;
      state.percent < 100 ? requestAnimationFrame(run) : isRuning = false;
    };
    const reset = () => {
      const _imgs = [...store.state.imgs];
      const index2 = store.state.imgIndex;
      _imgs[index2] = rawImage.value;
      store.commit("setImg", _imgs);
      handleClose();
    };
    const cutDone = async () => {
      const _imgs = [...store.state.imgs];
      const index2 = store.state.imgIndex;
      _imgs[index2] = cutImage.value;
      store.commit("setImg", _imgs);
      handleClose();
    };
    const edit = () => {
      state.matting.open(rawImage.value, cutImage.value, (base642) => {
        const _imgs = [...store.state.imgs];
        const index2 = store.state.imgIndex;
        _imgs[index2] = base642;
        store.commit("setImageCutoutResult", base642);
        store.commit("setImg", _imgs);
        state.percent = 0;
        requestAnimationFrame(run);
      });
    };
    return {
      clear,
      download: download2,
      mousemove,
      open,
      handleClose,
      ...toRefs(state),
      cutDone,
      edit,
      reset,
      show,
      rawImage,
      cutImage
    };
  }
});
const _hoisted_1$F = { class: "content" };
const _hoisted_2$A = ["src"];
const _hoisted_3$w = ["src"];
const _hoisted_4$r = { class: "dialog-footer" };
function _sfc_render$D(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_button = resolveComponent("el-button");
  const _component_ImageExtraction = resolveComponent("ImageExtraction");
  const _component_el_dialog = resolveComponent("el-dialog");
  const _directive_loading = resolveDirective("loading");
  return openBlock(), createBlock(_component_el_dialog, {
    modelValue: _ctx.show,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.show = $event),
    title: "AI \u667A\u80FD\u62A0\u56FE",
    "align-center": "",
    width: "650",
    onClose: _ctx.handleClose
  }, {
    footer: withCtx(() => [
      createElementVNode("span", _hoisted_4$r, [
        withDirectives(createVNode(_component_el_button, {
          type: "primary",
          plain: "",
          onClick: _ctx.edit
        }, {
          default: withCtx(() => [
            createTextVNode("\u8FDB\u5165\u7F16\u8F91\u6A21\u5F0F")
          ]),
          _: 1
        }, 8, ["onClick"]), [
          [vShow, _ctx.cutImage]
        ]),
        withDirectives(createVNode(_component_el_button, {
          type: "primary",
          plain: "",
          onClick: _ctx.reset
        }, {
          default: withCtx(() => [
            createTextVNode("\u8FD8\u539F")
          ]),
          _: 1
        }, 8, ["onClick"]), [
          [vShow, _ctx.cutImage]
        ]),
        withDirectives((openBlock(), createBlock(_component_el_button, {
          type: "primary",
          plain: "",
          onClick: _ctx.cutDone
        }, {
          default: withCtx(() => [
            createTextVNode("\u5B8C\u6210\u62A0\u56FE")
          ]),
          _: 1
        }, 8, ["onClick"])), [
          [vShow, _ctx.cutImage],
          [_directive_loading, _ctx.loading]
        ])
      ])
    ]),
    default: withCtx(() => [
      createElementVNode("div", _hoisted_1$F, [
        withDirectives((openBlock(), createElementBlock("div", {
          style: normalizeStyle({ width: _ctx.offsetWidth ? _ctx.offsetWidth + "px" : "100%" }),
          class: "scan-effect transparent-bg"
        }, [
          createElementVNode("img", {
            ref: "raw",
            style: normalizeStyle({ "clip-path": "inset(0 0 0 " + _ctx.percent + "%)" }),
            src: _ctx.rawImage,
            alt: ""
          }, null, 12, _hoisted_2$A),
          withDirectives(createElementVNode("img", {
            src: _ctx.cutImage,
            alt: "\u7ED3\u679C\u56FE\u50CF",
            onMousemove: _cache[0] || (_cache[0] = (...args) => _ctx.mousemove && _ctx.mousemove(...args))
          }, null, 40, _hoisted_3$w), [
            [vShow, _ctx.cutImage]
          ]),
          withDirectives(createElementVNode("div", {
            style: normalizeStyle({ left: _ctx.percent + "%" }),
            class: "scan-line"
          }, null, 4), [
            [vShow, _ctx.cutImage]
          ])
        ], 4)), [
          [vShow, _ctx.rawImage],
          [_directive_loading, !_ctx.cutImage]
        ])
      ]),
      createVNode(_component_ImageExtraction, { ref: "matting" }, null, 512)
    ]),
    _: 1
  }, 8, ["modelValue", "onClose"]);
}
var index$3 = /* @__PURE__ */ _export_sfc(_sfc_main$H, [["render", _sfc_render$D], ["__scopeId", "data-v-5cb30f38"]]);
function keyCodeOptions(e2, params) {
  const { f: f2 } = params;
  switch (e2.keyCode) {
    case 38:
      udlr("top", -1 * f2, e2);
      break;
    case 40:
      udlr("top", Number(f2), e2);
      break;
    case 37:
      udlr("left", -1 * f2, e2);
      break;
    case 39:
      udlr("left", Number(f2), e2);
      break;
    case 46:
    case 8:
      {
        if (erpStore.getters.dActiveElement.isContainer) {
          if (checkGroupChild$1(erpStore.getters.dActiveElement.uuid, "editable")) {
            return;
          }
        }
        const { type, editable } = erpStore.getters.dActiveElement;
        if (type === "w-text") {
          !editable && erpStore.getters.showMoveable && erpStore.dispatch("deleteWidget");
        } else
          erpStore.dispatch("deleteWidget");
      }
      break;
  }
}
function checkGroupChild$1(pid, key) {
  let itHas = false;
  const childs = erpStore.getters.dWidgets.filter((x) => x.parent === pid) || [];
  childs.forEach((element) => {
    element[key] && (itHas = true);
  });
  return itHas;
}
function udlr(type, value, event) {
  if (erpStore.getters.dActiveElement.uuid != -1) {
    if (erpStore.getters.dActiveElement.editable) {
      return;
    } else if (erpStore.getters.dActiveElement.isContainer && checkGroupChild$1(erpStore.getters.dActiveElement.uuid, "editable")) {
      return;
    }
    event.preventDefault();
    const result = Number(erpStore.getters.dActiveElement[type]) + value;
    erpStore.dispatch("updateWidgetData", {
      uuid: erpStore.getters.dActiveElement.uuid,
      key: type,
      value: result
    });
  }
}
var handlePaste = () => {
  navigator.clipboard.read().then(async (dataTransfer) => {
    for (let i = 0; i < dataTransfer.length; i++) {
      const item = dataTransfer[i];
      if (item.types.toString().indexOf("image") !== -1) {
        const imageBlob = await item.getType(item.types[0]);
        const file = new File([imageBlob], "screenshot.png", { type: "image/png" });
        const qnOptions = { bucket: "xp-design", prePath: "user" };
        const result = await Qiniu.upload(file, qnOptions);
        const { width, height } = await getImage(file);
        const url = _config.IMG_URL + result.key;
        await api$1.material.addMyPhoto({ width, height, url });
        erpStore.commit("setShowMoveable", false);
        const setting = JSON.parse(JSON.stringify(wImage.setting));
        setting.width = width;
        setting.height = height;
        setting.imgUrl = url;
        const { width: pW, height: pH } = erpStore.getters.dPage;
        setting.left = pW / 2 - width / 2;
        setting.top = pH / 2 - height / 2;
        erpStore.dispatch("addWidget", setting);
        break;
      } else if (item.types.toString().indexOf("text") !== -1) {
        erpStore.commit("setShowMoveable", false);
        const setting = JSON.parse(JSON.stringify(wText.setting));
        setting.text = await navigator.clipboard.readText();
        erpStore.dispatch("addWidget", setting);
        break;
      }
    }
  }).catch((error) => {
    console.error("\u65E0\u6CD5\u8BFB\u53D6\u526A\u8D34\u677F\u5185\u5BB9\uFF1A", error);
  });
};
function dealWithCtrl(e2, _this) {
  switch (e2.keyCode) {
    case 71:
      e2.preventDefault();
      erpStore.dispatch("realCombined");
      break;
    case 67:
      copy();
      break;
    case 86:
      paste();
      break;
    case 90:
      undo(e2.shiftKey);
      break;
    case 83:
      e2.preventDefault();
      _this.save();
      break;
    case 187:
      e2.preventDefault();
      _this.zoomAdd();
      break;
    case 189:
      e2.preventDefault();
      _this.zoomSub();
      break;
  }
}
function checkGroupChild(pid, key) {
  let itHas = false;
  const childs = erpStore.getters.dWidgets.filter((x) => x.parent === pid) || [];
  childs.forEach((element) => {
    element[key] && (itHas = true);
  });
  return itHas;
}
function copy() {
  if (erpStore.getters.dActiveElement.uuid === "-1") {
    return;
  } else if (erpStore.getters.dActiveElement.isContainer && checkGroupChild(erpStore.getters.dActiveElement.uuid, "editable")) {
    return;
  }
  !erpStore.getters.dActiveElement.editable && erpStore.dispatch("copyWidget");
}
function paste() {
  handlePaste();
  if (erpStore.getters.dCopyElement.length === 0) {
    return;
  } else if (erpStore.getters.dActiveElement.isContainer && checkGroupChild(erpStore.getters.dActiveElement.uuid, "editable")) {
    return;
  }
  !erpStore.getters.dActiveElement.editable && erpStore.dispatch("pasteWidget");
}
function undo(shiftKey) {
  if (shiftKey) {
    if (!(erpStore.getters.dHistoryParams.index === erpStore.getters.dHistoryParams.length - 1)) {
      erpStore.dispatch("handleHistory", "redo");
    }
  } else if (!(erpStore.getters.dHistoryParams.index === -1 || erpStore.getters.dHistoryParams === 0 && erpStore.getters.dHistoryParams.length === 10)) {
    erpStore.dispatch("handleHistory", "undo");
  }
}
erpStore.getters.dHistoryParams;
const ignoreNode = ["INPUT", "TEXTAREA"];
const shortcuts = {
  methods: {
    handleKeydowm(e2) {
      const nodeName = e2.target.nodeName;
      if (ignoreNode.indexOf(nodeName) !== -1 || nodeName === "DIV" && e2.target.contentEditable === "true") {
        return;
      }
      const ctrl = e2.key === "Control" || e2.key === "Meta";
      const alt = e2.key === "Alt";
      const shift = e2.key === "Shift";
      if (shift || ctrl) {
        this.$store.dispatch("updateAltDown", true);
        clearInterval(this.checkCtrl);
        this.checkCtrl = setInterval(() => {
          if (!document.hasFocus()) {
            clearInterval(this.checkCtrl);
            this.$store.dispatch("updateAltDown", false);
          }
        }, 500);
      }
      const withCtrl = e2.ctrlKey || e2.metaKey;
      if (withCtrl && !(ctrl || alt || shift)) {
        this.dealCtrl(e2);
        return;
      }
      const withShift = e2.shiftKey;
      const f2 = withShift ? 10 : 1;
      keyCodeOptions(e2, { f: f2 });
    },
    handleKeyup(e2) {
      clearInterval(this.checkCtrl);
      if (e2.key === "Alt" || e2.key === "Shift" || e2.key === "Control" || e2.key === "Meta") {
        this.$store.dispatch("updateAltDown", false);
      }
    },
    dealCtrl(e2) {
      dealWithCtrl(e2, this);
      console.log(e2.key, e2.keyCode);
    }
  }
};
/*!
 * html2canvas 1.4.1 <https://html2canvas.hertzen.com>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
    d2.__proto__ = b2;
  } || function(d2, b2) {
    for (var p in b2)
      if (Object.prototype.hasOwnProperty.call(b2, p))
        d2[p] = b2[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
function __awaiter(thisArg, _arguments, P2, generator) {
  function adopt(value) {
    return value instanceof P2 ? value : new P2(function(resolve) {
      resolve(value);
    });
  }
  return new (P2 || (P2 = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f2, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f2)
      throw new TypeError("Generator is already executing.");
    while (_)
      try {
        if (f2 = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e2) {
        op = [6, e2];
        y = 0;
      } finally {
        f2 = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __spreadArray(to, from, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || from);
}
var Bounds = function() {
  function Bounds2(left, top, width, height) {
    this.left = left;
    this.top = top;
    this.width = width;
    this.height = height;
  }
  Bounds2.prototype.add = function(x, y, w, h2) {
    return new Bounds2(this.left + x, this.top + y, this.width + w, this.height + h2);
  };
  Bounds2.fromClientRect = function(context, clientRect) {
    return new Bounds2(clientRect.left + context.windowBounds.left, clientRect.top + context.windowBounds.top, clientRect.width, clientRect.height);
  };
  Bounds2.fromDOMRectList = function(context, domRectList) {
    var domRect = Array.from(domRectList).find(function(rect) {
      return rect.width !== 0;
    });
    return domRect ? new Bounds2(domRect.left + context.windowBounds.left, domRect.top + context.windowBounds.top, domRect.width, domRect.height) : Bounds2.EMPTY;
  };
  Bounds2.EMPTY = new Bounds2(0, 0, 0, 0);
  return Bounds2;
}();
var parseBounds = function(context, node) {
  return Bounds.fromClientRect(context, node.getBoundingClientRect());
};
var parseDocumentSize = function(document2) {
  var body = document2.body;
  var documentElement = document2.documentElement;
  if (!body || !documentElement) {
    throw new Error("Unable to get document size");
  }
  var width = Math.max(Math.max(body.scrollWidth, documentElement.scrollWidth), Math.max(body.offsetWidth, documentElement.offsetWidth), Math.max(body.clientWidth, documentElement.clientWidth));
  var height = Math.max(Math.max(body.scrollHeight, documentElement.scrollHeight), Math.max(body.offsetHeight, documentElement.offsetHeight), Math.max(body.clientHeight, documentElement.clientHeight));
  return new Bounds(0, 0, width, height);
};
var toCodePoints$1 = function(str) {
  var codePoints = [];
  var i = 0;
  var length = str.length;
  while (i < length) {
    var value = str.charCodeAt(i++);
    if (value >= 55296 && value <= 56319 && i < length) {
      var extra = str.charCodeAt(i++);
      if ((extra & 64512) === 56320) {
        codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        codePoints.push(value);
        i--;
      }
    } else {
      codePoints.push(value);
    }
  }
  return codePoints;
};
var fromCodePoint$1 = function() {
  var codePoints = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    codePoints[_i] = arguments[_i];
  }
  if (String.fromCodePoint) {
    return String.fromCodePoint.apply(String, codePoints);
  }
  var length = codePoints.length;
  if (!length) {
    return "";
  }
  var codeUnits = [];
  var index2 = -1;
  var result = "";
  while (++index2 < length) {
    var codePoint = codePoints[index2];
    if (codePoint <= 65535) {
      codeUnits.push(codePoint);
    } else {
      codePoint -= 65536;
      codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
    }
    if (index2 + 1 === length || codeUnits.length > 16384) {
      result += String.fromCharCode.apply(String, codeUnits);
      codeUnits.length = 0;
    }
  }
  return result;
};
var chars$2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$2 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$2 = 0; i$2 < chars$2.length; i$2++) {
  lookup$2[chars$2.charCodeAt(i$2)] = i$2;
}
var chars$1$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$1$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$1$1 = 0; i$1$1 < chars$1$1.length; i$1$1++) {
  lookup$1$1[chars$1$1.charCodeAt(i$1$1)] = i$1$1;
}
var decode$1 = function(base642) {
  var bufferLength = base642.length * 0.75, len = base642.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
  var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
  for (i = 0; i < len; i += 4) {
    encoded1 = lookup$1$1[base642.charCodeAt(i)];
    encoded2 = lookup$1$1[base642.charCodeAt(i + 1)];
    encoded3 = lookup$1$1[base642.charCodeAt(i + 2)];
    encoded4 = lookup$1$1[base642.charCodeAt(i + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return buffer;
};
var polyUint16Array$1 = function(buffer) {
  var length = buffer.length;
  var bytes = [];
  for (var i = 0; i < length; i += 2) {
    bytes.push(buffer[i + 1] << 8 | buffer[i]);
  }
  return bytes;
};
var polyUint32Array$1 = function(buffer) {
  var length = buffer.length;
  var bytes = [];
  for (var i = 0; i < length; i += 4) {
    bytes.push(buffer[i + 3] << 24 | buffer[i + 2] << 16 | buffer[i + 1] << 8 | buffer[i]);
  }
  return bytes;
};
var UTRIE2_SHIFT_2$1 = 5;
var UTRIE2_SHIFT_1$1 = 6 + 5;
var UTRIE2_INDEX_SHIFT$1 = 2;
var UTRIE2_SHIFT_1_2$1 = UTRIE2_SHIFT_1$1 - UTRIE2_SHIFT_2$1;
var UTRIE2_LSCP_INDEX_2_OFFSET$1 = 65536 >> UTRIE2_SHIFT_2$1;
var UTRIE2_DATA_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_2$1;
var UTRIE2_DATA_MASK$1 = UTRIE2_DATA_BLOCK_LENGTH$1 - 1;
var UTRIE2_LSCP_INDEX_2_LENGTH$1 = 1024 >> UTRIE2_SHIFT_2$1;
var UTRIE2_INDEX_2_BMP_LENGTH$1 = UTRIE2_LSCP_INDEX_2_OFFSET$1 + UTRIE2_LSCP_INDEX_2_LENGTH$1;
var UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 = UTRIE2_INDEX_2_BMP_LENGTH$1;
var UTRIE2_UTF8_2B_INDEX_2_LENGTH$1 = 2048 >> 6;
var UTRIE2_INDEX_1_OFFSET$1 = UTRIE2_UTF8_2B_INDEX_2_OFFSET$1 + UTRIE2_UTF8_2B_INDEX_2_LENGTH$1;
var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 = 65536 >> UTRIE2_SHIFT_1$1;
var UTRIE2_INDEX_2_BLOCK_LENGTH$1 = 1 << UTRIE2_SHIFT_1_2$1;
var UTRIE2_INDEX_2_MASK$1 = UTRIE2_INDEX_2_BLOCK_LENGTH$1 - 1;
var slice16$1 = function(view, start, end) {
  if (view.slice) {
    return view.slice(start, end);
  }
  return new Uint16Array(Array.prototype.slice.call(view, start, end));
};
var slice32$1 = function(view, start, end) {
  if (view.slice) {
    return view.slice(start, end);
  }
  return new Uint32Array(Array.prototype.slice.call(view, start, end));
};
var createTrieFromBase64$1 = function(base642, _byteLength) {
  var buffer = decode$1(base642);
  var view32 = Array.isArray(buffer) ? polyUint32Array$1(buffer) : new Uint32Array(buffer);
  var view16 = Array.isArray(buffer) ? polyUint16Array$1(buffer) : new Uint16Array(buffer);
  var headerLength = 24;
  var index2 = slice16$1(view16, headerLength / 2, view32[4] / 2);
  var data = view32[5] === 2 ? slice16$1(view16, (headerLength + view32[4]) / 2) : slice32$1(view32, Math.ceil((headerLength + view32[4]) / 4));
  return new Trie$1(view32[0], view32[1], view32[2], view32[3], index2, data);
};
var Trie$1 = function() {
  function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data) {
    this.initialValue = initialValue;
    this.errorValue = errorValue;
    this.highStart = highStart;
    this.highValueIndex = highValueIndex;
    this.index = index2;
    this.data = data;
  }
  Trie2.prototype.get = function(codePoint) {
    var ix;
    if (codePoint >= 0) {
      if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
        ix = this.index[codePoint >> UTRIE2_SHIFT_2$1];
        ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
        return this.data[ix];
      }
      if (codePoint <= 65535) {
        ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET$1 + (codePoint - 55296 >> UTRIE2_SHIFT_2$1)];
        ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
        return this.data[ix];
      }
      if (codePoint < this.highStart) {
        ix = UTRIE2_INDEX_1_OFFSET$1 - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH$1 + (codePoint >> UTRIE2_SHIFT_1$1);
        ix = this.index[ix];
        ix += codePoint >> UTRIE2_SHIFT_2$1 & UTRIE2_INDEX_2_MASK$1;
        ix = this.index[ix];
        ix = (ix << UTRIE2_INDEX_SHIFT$1) + (codePoint & UTRIE2_DATA_MASK$1);
        return this.data[ix];
      }
      if (codePoint <= 1114111) {
        return this.data[this.highValueIndex];
      }
    }
    return this.errorValue;
  };
  return Trie2;
}();
var chars$3 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$3 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$3 = 0; i$3 < chars$3.length; i$3++) {
  lookup$3[chars$3.charCodeAt(i$3)] = i$3;
}
var base64$1 = "KwAAAAAAAAAACA4AUD0AADAgAAACAAAAAAAIABAAGABAAEgAUABYAGAAaABgAGgAYgBqAF8AZwBgAGgAcQB5AHUAfQCFAI0AlQCdAKIAqgCyALoAYABoAGAAaABgAGgAwgDKAGAAaADGAM4A0wDbAOEA6QDxAPkAAQEJAQ8BFwF1AH0AHAEkASwBNAE6AUIBQQFJAVEBWQFhAWgBcAF4ATAAgAGGAY4BlQGXAZ8BpwGvAbUBvQHFAc0B0wHbAeMB6wHxAfkBAQIJAvEBEQIZAiECKQIxAjgCQAJGAk4CVgJeAmQCbAJ0AnwCgQKJApECmQKgAqgCsAK4ArwCxAIwAMwC0wLbAjAA4wLrAvMC+AIAAwcDDwMwABcDHQMlAy0DNQN1AD0DQQNJA0kDSQNRA1EDVwNZA1kDdQB1AGEDdQBpA20DdQN1AHsDdQCBA4kDkQN1AHUAmQOhA3UAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AKYDrgN1AHUAtgO+A8YDzgPWAxcD3gPjA+sD8wN1AHUA+wMDBAkEdQANBBUEHQQlBCoEFwMyBDgEYABABBcDSARQBFgEYARoBDAAcAQzAXgEgASIBJAEdQCXBHUAnwSnBK4EtgS6BMIEyAR1AHUAdQB1AHUAdQCVANAEYABgAGAAYABgAGAAYABgANgEYADcBOQEYADsBPQE/AQEBQwFFAUcBSQFLAU0BWQEPAVEBUsFUwVbBWAAYgVgAGoFcgV6BYIFigWRBWAAmQWfBaYFYABgAGAAYABgAKoFYACxBbAFuQW6BcEFwQXHBcEFwQXPBdMF2wXjBeoF8gX6BQIGCgYSBhoGIgYqBjIGOgZgAD4GRgZMBmAAUwZaBmAAYABgAGAAYABgAGAAYABgAGAAYABgAGIGYABpBnAGYABgAGAAYABgAGAAYABgAGAAYAB4Bn8GhQZgAGAAYAB1AHcDFQSLBmAAYABgAJMGdQA9A3UAmwajBqsGqwaVALMGuwbDBjAAywbSBtIG1QbSBtIG0gbSBtIG0gbdBuMG6wbzBvsGAwcLBxMHAwcbByMHJwcsBywHMQcsB9IGOAdAB0gHTgfSBkgHVgfSBtIG0gbSBtIG0gbSBtIG0gbSBiwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdgAGAALAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAdbB2MHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB2kH0gZwB64EdQB1AHUAdQB1AHUAdQB1AHUHfQdgAIUHjQd1AHUAlQedB2AAYAClB6sHYACzB7YHvgfGB3UAzgfWBzMB3gfmB1EB7gf1B/0HlQENAQUIDQh1ABUIHQglCBcDLQg1CD0IRQhNCEEDUwh1AHUAdQBbCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIaQhjCGQIZQhmCGcIaAhpCGMIZAhlCGYIZwhoCGkIYwhkCGUIZghnCGgIcAh3CHoIMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIgggwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAALAcsBywHLAcsBywHLAcsBywHLAcsB4oILAcsB44I0gaWCJ4Ipgh1AHUAqgiyCHUAdQB1AHUAdQB1AHUAdQB1AHUAtwh8AXUAvwh1AMUIyQjRCNkI4AjoCHUAdQB1AO4I9gj+CAYJDgkTCS0HGwkjCYIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiCCIIIggiAAIAAAAFAAYABgAGIAXwBgAHEAdQBFAJUAogCyAKAAYABgAEIA4ABGANMA4QDxAMEBDwE1AFwBLAE6AQEBUQF4QkhCmEKoQrhCgAHIQsAB0MLAAcABwAHAAeDC6ABoAHDCwMMAAcABwAHAAdDDGMMAAcAB6MM4wwjDWMNow3jDaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAGgAaABoAEjDqABWw6bDqABpg6gAaABoAHcDvwOPA+gAaABfA/8DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DvwO/A78DpcPAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcAB9cPKwkyCToJMAB1AHUAdQBCCUoJTQl1AFUJXAljCWcJawkwADAAMAAwAHMJdQB2CX4JdQCECYoJjgmWCXUAngkwAGAAYABxAHUApgn3A64JtAl1ALkJdQDACTAAMAAwADAAdQB1AHUAdQB1AHUAdQB1AHUAowYNBMUIMAAwADAAMADICcsJ0wnZCRUE4QkwAOkJ8An4CTAAMAB1AAAKvwh1AAgKDwoXCh8KdQAwACcKLgp1ADYKqAmICT4KRgowADAAdQB1AE4KMAB1AFYKdQBeCnUAZQowADAAMAAwADAAMAAwADAAMAAVBHUAbQowADAAdQC5CXUKMAAwAHwBxAijBogEMgF9CoQKiASMCpQKmgqIBKIKqgquCogEDQG2Cr4KxgrLCjAAMADTCtsKCgHjCusK8Qr5CgELMAAwADAAMAB1AIsECQsRC3UANAEZCzAAMAAwADAAMAB1ACELKQswAHUANAExCzkLdQBBC0kLMABRC1kLMAAwADAAMAAwADAAdQBhCzAAMAAwAGAAYABpC3ELdwt/CzAAMACHC4sLkwubC58Lpwt1AK4Ltgt1APsDMAAwADAAMAAwADAAMAAwAL4LwwvLC9IL1wvdCzAAMADlC+kL8Qv5C/8LSQswADAAMAAwADAAMAAwADAAMAAHDDAAMAAwADAAMAAODBYMHgx1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1ACYMMAAwADAAdQB1AHUALgx1AHUAdQB1AHUAdQA2DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AD4MdQBGDHUAdQB1AHUAdQB1AEkMdQB1AHUAdQB1AFAMMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQBYDHUAdQB1AF8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUA+wMVBGcMMAAwAHwBbwx1AHcMfwyHDI8MMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAYABgAJcMMAAwADAAdQB1AJ8MlQClDDAAMACtDCwHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsB7UMLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHdQB1AHUAdQB1AHUAdQB1AHUAdQB1AHUAdQB1AA0EMAC9DDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAsBywHLAcsBywHLAcsBywHLQcwAMEMyAwsBywHLAcsBywHLAcsBywHLAcsBywHzAwwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwAHUAdQB1ANQM2QzhDDAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMABgAGAAYABgAGAAYABgAOkMYADxDGAA+AwADQYNYABhCWAAYAAODTAAMAAwADAAFg1gAGAAHg37AzAAMAAwADAAYABgACYNYAAsDTQNPA1gAEMNPg1LDWAAYABgAGAAYABgAGAAYABgAGAAUg1aDYsGVglhDV0NcQBnDW0NdQ15DWAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAlQCBDZUAiA2PDZcNMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAnw2nDTAAMAAwADAAMAAwAHUArw23DTAAMAAwADAAMAAwADAAMAAwADAAMAB1AL8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAB1AHUAdQB1AHUAdQDHDTAAYABgAM8NMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA1w11ANwNMAAwAD0B5A0wADAAMAAwADAAMADsDfQN/A0EDgwOFA4wABsOMAAwADAAMAAwADAAMAAwANIG0gbSBtIG0gbSBtIG0gYjDigOwQUuDsEFMw7SBjoO0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGQg5KDlIOVg7SBtIGXg5lDm0OdQ7SBtIGfQ6EDooOjQ6UDtIGmg6hDtIG0gaoDqwO0ga0DrwO0gZgAGAAYADEDmAAYAAkBtIGzA5gANIOYADaDokO0gbSBt8O5w7SBu8O0gb1DvwO0gZgAGAAxA7SBtIG0gbSBtIGYABgAGAAYAAED2AAsAUMD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHJA8sBywHLAcsBywHLAccDywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywPLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAc0D9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAccD9IG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIGFA8sBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHLAcsBywHPA/SBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gbSBtIG0gYUD0QPlQCVAJUAMAAwADAAMACVAJUAlQCVAJUAlQCVAEwPMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAA//8EAAQABAAEAAQABAAEAAQABAANAAMAAQABAAIABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQACgATABcAHgAbABoAHgAXABYAEgAeABsAGAAPABgAHABLAEsASwBLAEsASwBLAEsASwBLABgAGAAeAB4AHgATAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABYAGwASAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWAA0AEQAeAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAFAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJABYAGgAbABsAGwAeAB0AHQAeAE8AFwAeAA0AHgAeABoAGwBPAE8ADgBQAB0AHQAdAE8ATwAXAE8ATwBPABYAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AHgAeAFAATwBAAE8ATwBPAEAATwBQAFAATwBQAB4AHgAeAB4AHgAeAB0AHQAdAB0AHgAdAB4ADgBQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgBQAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAJAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAkACQAJAAkACQAJAAkABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAFAAHgAeAB4AKwArAFAAUABQAFAAGABQACsAKwArACsAHgAeAFAAHgBQAFAAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUAAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAYAA0AKwArAB4AHgAbACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAB4ABAAEAB4ABAAEABMABAArACsAKwArACsAKwArACsAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAKwArACsAKwBWAFYAVgBWAB4AHgArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AGgAaABoAGAAYAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQAEwAEACsAEwATAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABLAEsASwBLAEsASwBLAEsASwBLABoAGQAZAB4AUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQABMAUAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABABQAFAABAAEAB4ABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUAAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAFAABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQAUABQAB4AHgAYABMAUAArACsABAAbABsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAFAABAAEAAQABAAEAFAABAAEAAQAUAAEAAQABAAEAAQAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArACsAHgArAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAUAAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEAA0ADQBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUAArACsAKwBQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABABQACsAKwArACsAKwArACsAKwAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUAAaABoAUABQAFAAUABQAEwAHgAbAFAAHgAEACsAKwAEAAQABAArAFAAUABQAFAAUABQACsAKwArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQACsAUABQACsAKwAEACsABAAEAAQABAAEACsAKwArACsABAAEACsAKwAEAAQABAArACsAKwAEACsAKwArACsAKwArACsAUABQAFAAUAArAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLAAQABABQAFAAUAAEAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsAKwAEAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAArACsAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AGwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAKwArACsAKwArAAQABAAEACsAKwArACsAUABQACsAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAAQAUAArAFAAUABQAFAAUABQACsAKwArAFAAUABQACsAUABQAFAAUAArACsAKwBQAFAAKwBQACsAUABQACsAKwArAFAAUAArACsAKwBQAFAAUAArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArAAQABAAEAAQABAArACsAKwAEAAQABAArAAQABAAEAAQAKwArAFAAKwArACsAKwArACsABAArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAHgAeAB4AHgAeAB4AGwAeACsAKwArACsAKwAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAUABQAFAAKwArACsAKwArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwAOAFAAUABQAFAAUABQAFAAHgBQAAQABAAEAA4AUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAKwArAAQAUAAEAAQABAAEAAQABAAEACsABAAEAAQAKwAEAAQABAAEACsAKwArACsAKwArACsABAAEACsAKwArACsAKwArACsAUAArAFAAUAAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAFAABAAEAAQABAAEAAQABAArAAQABAAEACsABAAEAAQABABQAB4AKwArACsAKwBQAFAAUAAEAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQABoAUABQAFAAUABQAFAAKwAEAAQABAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQACsAUAArACsAUABQAFAAUABQAFAAUAArACsAKwAEACsAKwArACsABAAEAAQABAAEAAQAKwAEACsABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArAAQABAAeACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAXAAqACoAKgAqACoAKgAqACsAKwArACsAGwBcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAeAEsASwBLAEsASwBLAEsASwBLAEsADQANACsAKwArACsAKwBcAFwAKwBcACsAXABcAFwAXABcACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAXAArAFwAXABcAFwAXABcAFwAXABcAFwAKgBcAFwAKgAqACoAKgAqACoAKgAqACoAXAArACsAXABcAFwAXABcACsAXAArACoAKgAqACoAKgAqACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwBcAFwAXABcAFAADgAOAA4ADgAeAA4ADgAJAA4ADgANAAkAEwATABMAEwATAAkAHgATAB4AHgAeAAQABAAeAB4AHgAeAB4AHgBLAEsASwBLAEsASwBLAEsASwBLAFAAUABQAFAAUABQAFAAUABQAFAADQAEAB4ABAAeAAQAFgARABYAEQAEAAQAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQADQAEAAQABAAEAAQADQAEAAQAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAA0ADQAeAB4AHgAeAB4AHgAEAB4AHgAeAB4AHgAeACsAHgAeAA4ADgANAA4AHgAeAB4AHgAeAAkACQArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgBcAEsASwBLAEsASwBLAEsASwBLAEsADQANAB4AHgAeAB4AXABcAFwAXABcAFwAKgAqACoAKgBcAFwAXABcACoAKgAqAFwAKgAqACoAXABcACoAKgAqACoAKgAqACoAXABcAFwAKgAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKgAqAFwAKgBLAEsASwBLAEsASwBLAEsASwBLACoAKgAqACoAKgAqAFAAUABQAFAAUABQACsAUAArACsAKwArACsAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAKwBQACsAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsABAAEAAQAHgANAB4AHgAeAB4AHgAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUAArACsADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAWABEAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQANAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAANAA0AKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUAArAAQABAArACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqAA0ADQAVAFwADQAeAA0AGwBcACoAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwAeAB4AEwATAA0ADQAOAB4AEwATAB4ABAAEAAQACQArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAHgArACsAKwATABMASwBLAEsASwBLAEsASwBLAEsASwBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAXABcAFwAXABcACsAKwArACsAKwArACsAKwArACsAKwBcAFwAXABcAFwAXABcAFwAXABcAFwAXAArACsAKwArAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAXAArACsAKwAqACoAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAArACsAHgAeAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcACoAKgAqACoAKgAqACoAKgAqACoAKwAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKwArAAQASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACoAKgAqACoAKgAqACoAXAAqACoAKgAqACoAKgArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABABQAFAAUABQAFAAUABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwANAA0AHgANAA0ADQANAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAEAAQABAAEAAQAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwAeAB4AHgAeAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArAA0ADQANAA0ADQBLAEsASwBLAEsASwBLAEsASwBLACsAKwArAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAA0ADQBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUAAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArAAQABAAEAB4ABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAAQAUABQAFAAUABQAFAABABQAFAABAAEAAQAUAArACsAKwArACsABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQACsAUAArAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAFAAUABQACsAHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQACsAKwAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQACsAHgAeAB4AHgAeAB4AHgAOAB4AKwANAA0ADQANAA0ADQANAAkADQANAA0ACAAEAAsABAAEAA0ACQANAA0ADAAdAB0AHgAXABcAFgAXABcAFwAWABcAHQAdAB4AHgAUABQAFAANAAEAAQAEAAQABAAEAAQACQAaABoAGgAaABoAGgAaABoAHgAXABcAHQAVABUAHgAeAB4AHgAeAB4AGAAWABEAFQAVABUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ADQAeAA0ADQANAA0AHgANAA0ADQAHAB4AHgAeAB4AKwAEAAQABAAEAAQABAAEAAQABAAEAFAAUAArACsATwBQAFAAUABQAFAAHgAeAB4AFgARAE8AUABPAE8ATwBPAFAAUABQAFAAUAAeAB4AHgAWABEAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArABsAGwAbABsAGwAbABsAGgAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGgAbABsAGwAbABoAGwAbABoAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbABsAGwAbAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAHgAeAFAAGgAeAB0AHgBQAB4AGgAeAB4AHgAeAB4AHgAeAB4AHgBPAB4AUAAbAB4AHgBQAFAAUABQAFAAHgAeAB4AHQAdAB4AUAAeAFAAHgBQAB4AUABPAFAAUAAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAHgBQAFAAUABQAE8ATwBQAFAAUABQAFAATwBQAFAATwBQAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAUABQAFAATwBPAE8ATwBPAE8ATwBPAE8ATwBQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABPAB4AHgArACsAKwArAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHQAdAB4AHgAeAB0AHQAeAB4AHQAeAB4AHgAdAB4AHQAbABsAHgAdAB4AHgAeAB4AHQAeAB4AHQAdAB0AHQAeAB4AHQAeAB0AHgAdAB0AHQAdAB0AHQAeAB0AHgAeAB4AHgAeAB0AHQAdAB0AHgAeAB4AHgAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB4AHgAeAB0AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAeAB0AHQAdAB0AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAdAB4AHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAWABEAHgAeAB4AHgAeAB4AHQAeAB4AHgAeAB4AHgAeACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAWABEAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAFAAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAeAB4AHQAdAB0AHQAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB0AHQAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB0AHQAeAB4AHQAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AHQAdAB0AHgAeAB0AHgAeAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlAB4AHQAdAB4AHgAdAB4AHgAeAB4AHQAdAB4AHgAeAB4AJQAlAB0AHQAlAB4AJQAlACUAIAAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAeAB4AHgAeAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHgAdAB0AHQAeAB0AJQAdAB0AHgAdAB0AHgAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHQAdAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAdAB0AHQAdACUAHgAlACUAJQAdACUAJQAdAB0AHQAlACUAHQAdACUAHQAdACUAJQAlAB4AHQAeAB4AHgAeAB0AHQAlAB0AHQAdAB0AHQAdACUAJQAlACUAJQAdACUAJQAgACUAHQAdACUAJQAlACUAJQAlACUAJQAeAB4AHgAlACUAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB0AHgAeAB4AFwAXABcAFwAXABcAHgATABMAJQAeAB4AHgAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARABYAEQAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAWABEAFgARABYAEQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAWABEAFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AFgARAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAdAB0AHQAdAB0AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAFAAUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAEAAQABAAeAB4AKwArACsAKwArABMADQANAA0AUAATAA0AUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUAANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAA0ADQANAA0ADQANAA0ADQAeAA0AFgANAB4AHgAXABcAHgAeABcAFwAWABEAFgARABYAEQAWABEADQANAA0ADQATAFAADQANAB4ADQANAB4AHgAeAB4AHgAMAAwADQANAA0AHgANAA0AFgANAA0ADQANAA0ADQANAA0AHgANAB4ADQANAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArACsAKwArACsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArAA0AEQARACUAJQBHAFcAVwAWABEAFgARABYAEQAWABEAFgARACUAJQAWABEAFgARABYAEQAWABEAFQAWABEAEQAlAFcAVwBXAFcAVwBXAFcAVwBXAAQABAAEAAQABAAEACUAVwBXAFcAVwA2ACUAJQBXAFcAVwBHAEcAJQAlACUAKwBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBRAFcAUQBXAFEAVwBXAFcAVwBXAFcAUQBXAFcAVwBXAFcAVwBRAFEAKwArAAQABAAVABUARwBHAFcAFQBRAFcAUQBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFEAVwBRAFcAUQBXAFcAVwBXAFcAVwBRAFcAVwBXAFcAVwBXAFEAUQBXAFcAVwBXABUAUQBHAEcAVwArACsAKwArACsAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwAlACUAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACsAKwArACsAKwArACsAKwArACsAKwArAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAUQBRAFEAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBPAE8ATwBPAE8ATwBPAE8AJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADQATAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABLAEsASwBLAEsASwBLAEsASwBLAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAABAAEAAQABAAeAAQABAAEAAQABAAEAAQABAAEAAQAHgBQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUABQAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAeAA0ADQANAA0ADQArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AUAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAB4AHgAeAB4AHgAeAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AUABQAFAAUABQAFAAUABQAFAAUABQAAQAUABQAFAABABQAFAAUABQAAQAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAeAB4AHgAeAAQAKwArACsAUABQAFAAUABQAFAAHgAeABoAHgArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAADgAOABMAEwArACsAKwArACsAKwArACsABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwANAA0ASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUAAeAB4AHgBQAA4AUABQAAQAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArAB4AWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYAFgAWABYACsAKwArAAQAHgAeAB4AHgAeAB4ADQANAA0AHgAeAB4AHgArAFAASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArAB4AHgBcAFwAXABcAFwAKgBcAFwAXABcAFwAXABcAFwAXABcAEsASwBLAEsASwBLAEsASwBLAEsAXABcAFwAXABcACsAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAFAAUABQAAQAUABQAFAAUABQAFAAUABQAAQABAArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAHgANAA0ADQBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKgAqACoAXAAqACoAKgBcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXAAqAFwAKgAqACoAXABcACoAKgBcAFwAXABcAFwAKgAqAFwAKgBcACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFwAXABcACoAKgBQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAA0ADQBQAFAAUAAEAAQAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQADQAEAAQAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAVABVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBUAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVAFUAVQBVACsAKwArACsAKwArACsAKwArACsAKwArAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAWQBZAFkAKwArACsAKwBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAWgBaAFoAKwArACsAKwAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYABgAGAAYAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAKwArACsAKwArAFYABABWAFYAVgBWAFYAVgBWAFYAVgBWAB4AVgBWAFYAVgBWAFYAVgBWAFYAVgBWAFYAVgArAFYAVgBWAFYAVgArAFYAKwBWAFYAKwBWAFYAKwBWAFYAVgBWAFYAVgBWAFYAVgBWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAEQAWAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAaAB4AKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAGAARABEAGAAYABMAEwAWABEAFAArACsAKwArACsAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACUAJQAlACUAJQAWABEAFgARABYAEQAWABEAFgARABYAEQAlACUAFgARACUAJQAlACUAJQAlACUAEQAlABEAKwAVABUAEwATACUAFgARABYAEQAWABEAJQAlACUAJQAlACUAJQAlACsAJQAbABoAJQArACsAKwArAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAcAKwATACUAJQAbABoAJQAlABYAEQAlACUAEQAlABEAJQBXAFcAVwBXAFcAVwBXAFcAVwBXABUAFQAlACUAJQATACUAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXABYAJQARACUAJQAlAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAWACUAEQAlABYAEQARABYAEQARABUAVwBRAFEAUQBRAFEAUQBRAFEAUQBRAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAEcARwArACsAVwBXAFcAVwBXAFcAKwArAFcAVwBXAFcAVwBXACsAKwBXAFcAVwBXAFcAVwArACsAVwBXAFcAKwArACsAGgAbACUAJQAlABsAGwArAB4AHgAeAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwAEAAQABAAQAB0AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsADQANAA0AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAA0AUABQAFAAUAArACsAKwArAFAAUABQAFAAUABQAFAAUAANAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwArAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwBQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwANAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAB4AUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAUABQAFAAUABQAAQABAAEACsABAAEACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAKwBQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAA0ADQANAA0ADQANAA0ADQAeACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAArACsAKwArAFAAUABQAFAAUAANAA0ADQANAA0ADQAUACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsADQANAA0ADQANAA0ADQBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAB4AHgAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArAAQABAANACsAKwBQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAB4AHgAeAB4AHgArACsAKwArACsAKwAEAAQABAAEAAQABAAEAA0ADQAeAB4AHgAeAB4AKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwAeACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEACsASwBLAEsASwBLAEsASwBLAEsASwANAA0ADQANAFAABAAEAFAAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAeAA4AUAArACsAKwArACsAKwArACsAKwAEAFAAUABQAFAADQANAB4ADQAEAAQABAAEAB4ABAAEAEsASwBLAEsASwBLAEsASwBLAEsAUAAOAFAADQANAA0AKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAANAA0AHgANAA0AHgAEACsAUABQAFAAUABQAFAAUAArAFAAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAA0AKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsABAAEAAQABAArAFAAUABQAFAAUABQAFAAUAArACsAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQACsABAAEAFAABAAEAAQABAAEAAQABAArACsABAAEACsAKwAEAAQABAArACsAUAArACsAKwArACsAKwAEACsAKwArACsAKwBQAFAAUABQAFAABAAEACsAKwAEAAQABAAEAAQABAAEACsAKwArAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsABAAEAAQABAAEAAQABABQAFAAUABQAA0ADQANAA0AHgBLAEsASwBLAEsASwBLAEsASwBLAA0ADQArAB4ABABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAFAAUAAeAFAAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABAAEAAQADgANAA0AEwATAB4AHgAeAA0ADQANAA0ADQANAA0ADQANAA0ADQANAA0ADQANAFAAUABQAFAABAAEACsAKwAEAA0ADQAeAFAAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAFAAKwArACsAKwArACsAKwBLAEsASwBLAEsASwBLAEsASwBLACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAXABcAFwAKwArACoAKgAqACoAKgAqACoAKgAqACoAKgAqACoAKgAqACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBcAFwADQANAA0AKgBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAKwArAFAAKwArAFAAUABQAFAAUABQAFAAUAArAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQAKwAEAAQAKwArAAQABAAEAAQAUAAEAFAABAAEAA0ADQANACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAArACsABAAEAAQABAAEAAQABABQAA4AUAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAABAAEAAQABAAEAAQABAAEAAQABABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAFAABAAEAAQABAAOAB4ADQANAA0ADQAOAB4ABAArACsAKwArACsAKwArACsAUAAEAAQABAAEAAQABAAEAAQABAAEAAQAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAA0ADQANAFAADgAOAA4ADQANACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAEAAQABAAEACsABAAEAAQABAAEAAQABAAEAFAADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAOABMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQACsAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAArACsAKwAEACsABAAEACsABAAEAAQABAAEAAQABABQAAQAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAUABQAFAAUABQAFAAKwBQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAUAArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAABAAEAAQABAAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAaABoAGgAaAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArAA0AUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsADQANAA0ADQANACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABIAEgAQwBDAEMAUABQAFAAUABDAFAAUABQAEgAQwBIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAASABDAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwAJAAkACQAJAAkACQAJABYAEQArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABIAEMAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwANAA0AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArAAQABAAEAAQABAANACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEAA0ADQANAB4AHgAeAB4AHgAeAFAAUABQAFAADQAeACsAKwArACsAKwArACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAANAA0AHgAeACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwAEAFAABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwAEAAQABAAEAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAARwBHABUARwAJACsAKwArACsAKwArACsAKwArACsAKwAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUQBRAFEAKwArACsAKwArACsAKwArACsAKwArACsAKwBRAFEAUQBRACsAKwArACsAKwArACsAKwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUAArACsAHgAEAAQADQAEAAQABAAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAAQABAAEAAQABAAeAB4AHgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAB4AHgAEAAQABAAEAAQABAAEAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4ABAAEAAQAHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwArACsAKwArACsAKwArACsAKwArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAKwArAFAAKwArAFAAUAArACsAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACsAUAArAFAAUABQAFAAUABQAFAAKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwBQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAHgAeAFAAUABQAFAAUAArAFAAKwArACsAUABQAFAAUABQAFAAUAArAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAB4AHgAeAB4AHgAeAB4AHgAeACsAKwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAEsASwBLAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAeAB4AHgAeAB4AHgAeAB4ABAAeAB4AHgAeAB4AHgAeAB4AHgAeAAQAHgAeAA0ADQANAA0AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQAKwAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArAAQABAAEAAQABAAEAAQAKwAEAAQAKwAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwAEAAQABAAEAAQABAAEAFAAUABQAFAAUABQAFAAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwBQAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArABsAUABQAFAAUABQACsAKwBQAFAAUABQAFAAUABQAFAAUAAEAAQABAAEAAQABAAEACsAKwArACsAKwArACsAKwArAB4AHgAeAB4ABAAEAAQABAAEAAQABABQACsAKwArACsASwBLAEsASwBLAEsASwBLAEsASwArACsAKwArABYAFgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAGgBQAFAAUAAaAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAeAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQACsAKwBQAFAAUABQACsAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUAArACsAKwArACsAKwBQACsAKwArACsAUAArAFAAKwBQACsAUABQAFAAKwBQAFAAKwBQACsAKwBQACsAUAArAFAAKwBQACsAUAArAFAAUAArAFAAKwArAFAAUABQAFAAKwBQAFAAUABQAFAAUABQACsAUABQAFAAUAArAFAAUABQAFAAKwBQACsAUABQAFAAUABQAFAAUABQAFAAUAArAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAArACsAKwArACsAUABQAFAAKwBQAFAAUABQAFAAKwBQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwAeAB4AKwArACsAKwArACsAKwArACsAKwArACsAKwArAE8ATwBPAE8ATwBPAE8ATwBPAE8ATwBPAE8AJQAlACUAHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHgAeAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB4AHgAeACUAJQAlAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAdAB0AHQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAKQApACkAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAlACUAJQAlACUAHgAlACUAJQAlACUAIAAgACAAJQAlACAAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACEAIQAhACEAIQAlACUAIAAgACUAJQAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlACUAIAAlACUAJQAlACAAIAAgACUAIAAgACAAJQAlACUAJQAlACUAJQAgACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAlAB4AJQAeACUAJQAlACUAJQAgACUAJQAlACUAHgAlAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAgACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACAAIAAgACAAIAAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeABcAFwAXABUAFQAVAB4AHgAeAB4AJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAgACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlACUAJQAeAB4AHgAeAB4AHgAeAB4AHgAeACUAJQAlACUAJQAlAB4AHgAeAB4AHgAeAB4AHgAlACUAJQAlACUAJQAlACUAHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAgACUAJQAgACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAJQAlACUAJQAlACUAIAAlACUAJQAlACUAJQAlACUAJQAgACAAIAAgACAAIAAgACAAIAAgACUAJQAgACAAIAAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACAAIAAlACAAIAAlACAAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAgACAAIAAlACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAJQAlAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AKwAeAB4AHgAeAB4AHgAeAB4AHgAeAB4AHgArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAEsASwBLAEsASwBLAEsASwBLAEsAKwArACsAKwArACsAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwArAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwAlACUAJQAlACUAJQAlACUAJQAlACUAVwBXACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQBXAFcAVwBXAFcAVwBXAFcAVwBXAFcAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAJQAlACUAKwAEACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArACsAKwArAA==";
var LETTER_NUMBER_MODIFIER = 50;
var BK = 1;
var CR$1 = 2;
var LF$1 = 3;
var CM = 4;
var NL = 5;
var WJ = 7;
var ZW = 8;
var GL = 9;
var SP = 10;
var ZWJ$1 = 11;
var B2 = 12;
var BA = 13;
var BB = 14;
var HY = 15;
var CB = 16;
var CL = 17;
var CP = 18;
var EX = 19;
var IN = 20;
var NS = 21;
var OP = 22;
var QU = 23;
var IS = 24;
var NU = 25;
var PO = 26;
var PR = 27;
var SY = 28;
var AI = 29;
var AL = 30;
var CJ = 31;
var EB = 32;
var EM = 33;
var H2 = 34;
var H3 = 35;
var HL = 36;
var ID = 37;
var JL = 38;
var JV = 39;
var JT = 40;
var RI$1 = 41;
var SA = 42;
var XX = 43;
var ea_OP = [9001, 65288];
var BREAK_MANDATORY = "!";
var BREAK_NOT_ALLOWED$1 = "\xD7";
var BREAK_ALLOWED$1 = "\xF7";
var UnicodeTrie$1 = createTrieFromBase64$1(base64$1);
var ALPHABETICS = [AL, HL];
var HARD_LINE_BREAKS = [BK, CR$1, LF$1, NL];
var SPACE$1 = [SP, ZW];
var PREFIX_POSTFIX = [PR, PO];
var LINE_BREAKS = HARD_LINE_BREAKS.concat(SPACE$1);
var KOREAN_SYLLABLE_BLOCK = [JL, JV, JT, H2, H3];
var HYPHEN = [HY, BA];
var codePointsToCharacterClasses = function(codePoints, lineBreak2) {
  if (lineBreak2 === void 0) {
    lineBreak2 = "strict";
  }
  var types = [];
  var indices = [];
  var categories = [];
  codePoints.forEach(function(codePoint, index2) {
    var classType = UnicodeTrie$1.get(codePoint);
    if (classType > LETTER_NUMBER_MODIFIER) {
      categories.push(true);
      classType -= LETTER_NUMBER_MODIFIER;
    } else {
      categories.push(false);
    }
    if (["normal", "auto", "loose"].indexOf(lineBreak2) !== -1) {
      if ([8208, 8211, 12316, 12448].indexOf(codePoint) !== -1) {
        indices.push(index2);
        return types.push(CB);
      }
    }
    if (classType === CM || classType === ZWJ$1) {
      if (index2 === 0) {
        indices.push(index2);
        return types.push(AL);
      }
      var prev = types[index2 - 1];
      if (LINE_BREAKS.indexOf(prev) === -1) {
        indices.push(indices[index2 - 1]);
        return types.push(prev);
      }
      indices.push(index2);
      return types.push(AL);
    }
    indices.push(index2);
    if (classType === CJ) {
      return types.push(lineBreak2 === "strict" ? NS : ID);
    }
    if (classType === SA) {
      return types.push(AL);
    }
    if (classType === AI) {
      return types.push(AL);
    }
    if (classType === XX) {
      if (codePoint >= 131072 && codePoint <= 196605 || codePoint >= 196608 && codePoint <= 262141) {
        return types.push(ID);
      } else {
        return types.push(AL);
      }
    }
    types.push(classType);
  });
  return [indices, types, categories];
};
var isAdjacentWithSpaceIgnored = function(a2, b, currentIndex, classTypes) {
  var current = classTypes[currentIndex];
  if (Array.isArray(a2) ? a2.indexOf(current) !== -1 : a2 === current) {
    var i = currentIndex;
    while (i <= classTypes.length) {
      i++;
      var next = classTypes[i];
      if (next === b) {
        return true;
      }
      if (next !== SP) {
        break;
      }
    }
  }
  if (current === SP) {
    var i = currentIndex;
    while (i > 0) {
      i--;
      var prev = classTypes[i];
      if (Array.isArray(a2) ? a2.indexOf(prev) !== -1 : a2 === prev) {
        var n = currentIndex;
        while (n <= classTypes.length) {
          n++;
          var next = classTypes[n];
          if (next === b) {
            return true;
          }
          if (next !== SP) {
            break;
          }
        }
      }
      if (prev !== SP) {
        break;
      }
    }
  }
  return false;
};
var previousNonSpaceClassType = function(currentIndex, classTypes) {
  var i = currentIndex;
  while (i >= 0) {
    var type = classTypes[i];
    if (type === SP) {
      i--;
    } else {
      return type;
    }
  }
  return 0;
};
var _lineBreakAtIndex = function(codePoints, classTypes, indicies, index2, forbiddenBreaks) {
  if (indicies[index2] === 0) {
    return BREAK_NOT_ALLOWED$1;
  }
  var currentIndex = index2 - 1;
  if (Array.isArray(forbiddenBreaks) && forbiddenBreaks[currentIndex] === true) {
    return BREAK_NOT_ALLOWED$1;
  }
  var beforeIndex = currentIndex - 1;
  var afterIndex = currentIndex + 1;
  var current = classTypes[currentIndex];
  var before = beforeIndex >= 0 ? classTypes[beforeIndex] : 0;
  var next = classTypes[afterIndex];
  if (current === CR$1 && next === LF$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (HARD_LINE_BREAKS.indexOf(current) !== -1) {
    return BREAK_MANDATORY;
  }
  if (HARD_LINE_BREAKS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (SPACE$1.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (previousNonSpaceClassType(currentIndex, classTypes) === ZW) {
    return BREAK_ALLOWED$1;
  }
  if (UnicodeTrie$1.get(codePoints[currentIndex]) === ZWJ$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ((current === EB || current === EM) && UnicodeTrie$1.get(codePoints[afterIndex]) === ZWJ$1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === WJ || next === WJ) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === GL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([SP, BA, HY].indexOf(current) === -1 && next === GL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([CL, CP, EX, IS, SY].indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (previousNonSpaceClassType(currentIndex, classTypes) === OP) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored(QU, OP, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored([CL, CP], NS, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (isAdjacentWithSpaceIgnored(B2, B2, currentIndex, classTypes)) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === SP) {
    return BREAK_ALLOWED$1;
  }
  if (current === QU || next === QU) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (next === CB || current === CB) {
    return BREAK_ALLOWED$1;
  }
  if ([BA, HY, NS].indexOf(next) !== -1 || current === BB) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (before === HL && HYPHEN.indexOf(current) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === SY && next === HL) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (next === IN) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(next) !== -1 && current === NU || ALPHABETICS.indexOf(current) !== -1 && next === NU) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === PR && [ID, EB, EM].indexOf(next) !== -1 || [ID, EB, EM].indexOf(current) !== -1 && next === PO) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(current) !== -1 && PREFIX_POSTFIX.indexOf(next) !== -1 || PREFIX_POSTFIX.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([PR, PO].indexOf(current) !== -1 && (next === NU || [OP, HY].indexOf(next) !== -1 && classTypes[afterIndex + 1] === NU) || [OP, HY].indexOf(current) !== -1 && next === NU || current === NU && [NU, SY, IS].indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if ([NU, SY, IS, CL, CP].indexOf(next) !== -1) {
    var prevIndex = currentIndex;
    while (prevIndex >= 0) {
      var type = classTypes[prevIndex];
      if (type === NU) {
        return BREAK_NOT_ALLOWED$1;
      } else if ([SY, IS].indexOf(type) !== -1) {
        prevIndex--;
      } else {
        break;
      }
    }
  }
  if ([PR, PO].indexOf(next) !== -1) {
    var prevIndex = [CL, CP].indexOf(current) !== -1 ? beforeIndex : currentIndex;
    while (prevIndex >= 0) {
      var type = classTypes[prevIndex];
      if (type === NU) {
        return BREAK_NOT_ALLOWED$1;
      } else if ([SY, IS].indexOf(type) !== -1) {
        prevIndex--;
      } else {
        break;
      }
    }
  }
  if (JL === current && [JL, JV, H2, H3].indexOf(next) !== -1 || [JV, H2].indexOf(current) !== -1 && [JV, JT].indexOf(next) !== -1 || [JT, H3].indexOf(current) !== -1 && next === JT) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (KOREAN_SYLLABLE_BLOCK.indexOf(current) !== -1 && [IN, PO].indexOf(next) !== -1 || KOREAN_SYLLABLE_BLOCK.indexOf(next) !== -1 && current === PR) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.indexOf(current) !== -1 && ALPHABETICS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === IS && ALPHABETICS.indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (ALPHABETICS.concat(NU).indexOf(current) !== -1 && next === OP && ea_OP.indexOf(codePoints[afterIndex]) === -1 || ALPHABETICS.concat(NU).indexOf(next) !== -1 && current === CP) {
    return BREAK_NOT_ALLOWED$1;
  }
  if (current === RI$1 && next === RI$1) {
    var i = indicies[currentIndex];
    var count = 1;
    while (i > 0) {
      i--;
      if (classTypes[i] === RI$1) {
        count++;
      } else {
        break;
      }
    }
    if (count % 2 !== 0) {
      return BREAK_NOT_ALLOWED$1;
    }
  }
  if (current === EB && next === EM) {
    return BREAK_NOT_ALLOWED$1;
  }
  return BREAK_ALLOWED$1;
};
var cssFormattedClasses = function(codePoints, options) {
  if (!options) {
    options = { lineBreak: "normal", wordBreak: "normal" };
  }
  var _a2 = codePointsToCharacterClasses(codePoints, options.lineBreak), indicies = _a2[0], classTypes = _a2[1], isLetterNumber = _a2[2];
  if (options.wordBreak === "break-all" || options.wordBreak === "break-word") {
    classTypes = classTypes.map(function(type) {
      return [NU, AL, SA].indexOf(type) !== -1 ? ID : type;
    });
  }
  var forbiddenBreakpoints = options.wordBreak === "keep-all" ? isLetterNumber.map(function(letterNumber, i) {
    return letterNumber && codePoints[i] >= 19968 && codePoints[i] <= 40959;
  }) : void 0;
  return [indicies, classTypes, forbiddenBreakpoints];
};
var Break = function() {
  function Break2(codePoints, lineBreak2, start, end) {
    this.codePoints = codePoints;
    this.required = lineBreak2 === BREAK_MANDATORY;
    this.start = start;
    this.end = end;
  }
  Break2.prototype.slice = function() {
    return fromCodePoint$1.apply(void 0, this.codePoints.slice(this.start, this.end));
  };
  return Break2;
}();
var LineBreaker = function(str, options) {
  var codePoints = toCodePoints$1(str);
  var _a2 = cssFormattedClasses(codePoints, options), indicies = _a2[0], classTypes = _a2[1], forbiddenBreakpoints = _a2[2];
  var length = codePoints.length;
  var lastEnd = 0;
  var nextIndex = 0;
  return {
    next: function() {
      if (nextIndex >= length) {
        return { done: true, value: null };
      }
      var lineBreak2 = BREAK_NOT_ALLOWED$1;
      while (nextIndex < length && (lineBreak2 = _lineBreakAtIndex(codePoints, classTypes, indicies, ++nextIndex, forbiddenBreakpoints)) === BREAK_NOT_ALLOWED$1) {
      }
      if (lineBreak2 !== BREAK_NOT_ALLOWED$1 || nextIndex === length) {
        var value = new Break(codePoints, lineBreak2, lastEnd, nextIndex);
        lastEnd = nextIndex;
        return { value, done: false };
      }
      return { done: true, value: null };
    }
  };
};
var FLAG_UNRESTRICTED = 1 << 0;
var FLAG_ID = 1 << 1;
var FLAG_INTEGER = 1 << 2;
var FLAG_NUMBER = 1 << 3;
var LINE_FEED = 10;
var SOLIDUS = 47;
var REVERSE_SOLIDUS = 92;
var CHARACTER_TABULATION = 9;
var SPACE = 32;
var QUOTATION_MARK = 34;
var EQUALS_SIGN = 61;
var NUMBER_SIGN = 35;
var DOLLAR_SIGN = 36;
var PERCENTAGE_SIGN = 37;
var APOSTROPHE = 39;
var LEFT_PARENTHESIS = 40;
var RIGHT_PARENTHESIS = 41;
var LOW_LINE = 95;
var HYPHEN_MINUS = 45;
var EXCLAMATION_MARK = 33;
var LESS_THAN_SIGN = 60;
var GREATER_THAN_SIGN = 62;
var COMMERCIAL_AT = 64;
var LEFT_SQUARE_BRACKET = 91;
var RIGHT_SQUARE_BRACKET = 93;
var CIRCUMFLEX_ACCENT = 61;
var LEFT_CURLY_BRACKET = 123;
var QUESTION_MARK = 63;
var RIGHT_CURLY_BRACKET = 125;
var VERTICAL_LINE = 124;
var TILDE = 126;
var CONTROL = 128;
var REPLACEMENT_CHARACTER = 65533;
var ASTERISK = 42;
var PLUS_SIGN = 43;
var COMMA = 44;
var COLON = 58;
var SEMICOLON = 59;
var FULL_STOP = 46;
var NULL = 0;
var BACKSPACE = 8;
var LINE_TABULATION = 11;
var SHIFT_OUT = 14;
var INFORMATION_SEPARATOR_ONE = 31;
var DELETE = 127;
var EOF = -1;
var ZERO = 48;
var a = 97;
var e = 101;
var f = 102;
var u = 117;
var z = 122;
var A = 65;
var E$1 = 69;
var F$1 = 70;
var U$1 = 85;
var Z$1 = 90;
var isDigit = function(codePoint) {
  return codePoint >= ZERO && codePoint <= 57;
};
var isSurrogateCodePoint = function(codePoint) {
  return codePoint >= 55296 && codePoint <= 57343;
};
var isHex = function(codePoint) {
  return isDigit(codePoint) || codePoint >= A && codePoint <= F$1 || codePoint >= a && codePoint <= f;
};
var isLowerCaseLetter = function(codePoint) {
  return codePoint >= a && codePoint <= z;
};
var isUpperCaseLetter = function(codePoint) {
  return codePoint >= A && codePoint <= Z$1;
};
var isLetter = function(codePoint) {
  return isLowerCaseLetter(codePoint) || isUpperCaseLetter(codePoint);
};
var isNonASCIICodePoint = function(codePoint) {
  return codePoint >= CONTROL;
};
var isWhiteSpace = function(codePoint) {
  return codePoint === LINE_FEED || codePoint === CHARACTER_TABULATION || codePoint === SPACE;
};
var isNameStartCodePoint = function(codePoint) {
  return isLetter(codePoint) || isNonASCIICodePoint(codePoint) || codePoint === LOW_LINE;
};
var isNameCodePoint = function(codePoint) {
  return isNameStartCodePoint(codePoint) || isDigit(codePoint) || codePoint === HYPHEN_MINUS;
};
var isNonPrintableCodePoint = function(codePoint) {
  return codePoint >= NULL && codePoint <= BACKSPACE || codePoint === LINE_TABULATION || codePoint >= SHIFT_OUT && codePoint <= INFORMATION_SEPARATOR_ONE || codePoint === DELETE;
};
var isValidEscape = function(c1, c2) {
  if (c1 !== REVERSE_SOLIDUS) {
    return false;
  }
  return c2 !== LINE_FEED;
};
var isIdentifierStart = function(c1, c2, c3) {
  if (c1 === HYPHEN_MINUS) {
    return isNameStartCodePoint(c2) || isValidEscape(c2, c3);
  } else if (isNameStartCodePoint(c1)) {
    return true;
  } else if (c1 === REVERSE_SOLIDUS && isValidEscape(c1, c2)) {
    return true;
  }
  return false;
};
var isNumberStart = function(c1, c2, c3) {
  if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
    if (isDigit(c2)) {
      return true;
    }
    return c2 === FULL_STOP && isDigit(c3);
  }
  if (c1 === FULL_STOP) {
    return isDigit(c2);
  }
  return isDigit(c1);
};
var stringToNumber = function(codePoints) {
  var c = 0;
  var sign2 = 1;
  if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
    if (codePoints[c] === HYPHEN_MINUS) {
      sign2 = -1;
    }
    c++;
  }
  var integers = [];
  while (isDigit(codePoints[c])) {
    integers.push(codePoints[c++]);
  }
  var int = integers.length ? parseInt(fromCodePoint$1.apply(void 0, integers), 10) : 0;
  if (codePoints[c] === FULL_STOP) {
    c++;
  }
  var fraction = [];
  while (isDigit(codePoints[c])) {
    fraction.push(codePoints[c++]);
  }
  var fracd = fraction.length;
  var frac = fracd ? parseInt(fromCodePoint$1.apply(void 0, fraction), 10) : 0;
  if (codePoints[c] === E$1 || codePoints[c] === e) {
    c++;
  }
  var expsign = 1;
  if (codePoints[c] === PLUS_SIGN || codePoints[c] === HYPHEN_MINUS) {
    if (codePoints[c] === HYPHEN_MINUS) {
      expsign = -1;
    }
    c++;
  }
  var exponent = [];
  while (isDigit(codePoints[c])) {
    exponent.push(codePoints[c++]);
  }
  var exp = exponent.length ? parseInt(fromCodePoint$1.apply(void 0, exponent), 10) : 0;
  return sign2 * (int + frac * Math.pow(10, -fracd)) * Math.pow(10, expsign * exp);
};
var LEFT_PARENTHESIS_TOKEN = {
  type: 2
};
var RIGHT_PARENTHESIS_TOKEN = {
  type: 3
};
var COMMA_TOKEN = { type: 4 };
var SUFFIX_MATCH_TOKEN = { type: 13 };
var PREFIX_MATCH_TOKEN = { type: 8 };
var COLUMN_TOKEN = { type: 21 };
var DASH_MATCH_TOKEN = { type: 9 };
var INCLUDE_MATCH_TOKEN = { type: 10 };
var LEFT_CURLY_BRACKET_TOKEN = {
  type: 11
};
var RIGHT_CURLY_BRACKET_TOKEN = {
  type: 12
};
var SUBSTRING_MATCH_TOKEN = { type: 14 };
var BAD_URL_TOKEN = { type: 23 };
var BAD_STRING_TOKEN = { type: 1 };
var CDO_TOKEN = { type: 25 };
var CDC_TOKEN = { type: 24 };
var COLON_TOKEN = { type: 26 };
var SEMICOLON_TOKEN = { type: 27 };
var LEFT_SQUARE_BRACKET_TOKEN = {
  type: 28
};
var RIGHT_SQUARE_BRACKET_TOKEN = {
  type: 29
};
var WHITESPACE_TOKEN = { type: 31 };
var EOF_TOKEN = { type: 32 };
var Tokenizer = function() {
  function Tokenizer2() {
    this._value = [];
  }
  Tokenizer2.prototype.write = function(chunk) {
    this._value = this._value.concat(toCodePoints$1(chunk));
  };
  Tokenizer2.prototype.read = function() {
    var tokens = [];
    var token = this.consumeToken();
    while (token !== EOF_TOKEN) {
      tokens.push(token);
      token = this.consumeToken();
    }
    return tokens;
  };
  Tokenizer2.prototype.consumeToken = function() {
    var codePoint = this.consumeCodePoint();
    switch (codePoint) {
      case QUOTATION_MARK:
        return this.consumeStringToken(QUOTATION_MARK);
      case NUMBER_SIGN:
        var c1 = this.peekCodePoint(0);
        var c2 = this.peekCodePoint(1);
        var c3 = this.peekCodePoint(2);
        if (isNameCodePoint(c1) || isValidEscape(c2, c3)) {
          var flags = isIdentifierStart(c1, c2, c3) ? FLAG_ID : FLAG_UNRESTRICTED;
          var value = this.consumeName();
          return { type: 5, value, flags };
        }
        break;
      case DOLLAR_SIGN:
        if (this.peekCodePoint(0) === EQUALS_SIGN) {
          this.consumeCodePoint();
          return SUFFIX_MATCH_TOKEN;
        }
        break;
      case APOSTROPHE:
        return this.consumeStringToken(APOSTROPHE);
      case LEFT_PARENTHESIS:
        return LEFT_PARENTHESIS_TOKEN;
      case RIGHT_PARENTHESIS:
        return RIGHT_PARENTHESIS_TOKEN;
      case ASTERISK:
        if (this.peekCodePoint(0) === EQUALS_SIGN) {
          this.consumeCodePoint();
          return SUBSTRING_MATCH_TOKEN;
        }
        break;
      case PLUS_SIGN:
        if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeNumericToken();
        }
        break;
      case COMMA:
        return COMMA_TOKEN;
      case HYPHEN_MINUS:
        var e1 = codePoint;
        var e2 = this.peekCodePoint(0);
        var e3 = this.peekCodePoint(1);
        if (isNumberStart(e1, e2, e3)) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeNumericToken();
        }
        if (isIdentifierStart(e1, e2, e3)) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeIdentLikeToken();
        }
        if (e2 === HYPHEN_MINUS && e3 === GREATER_THAN_SIGN) {
          this.consumeCodePoint();
          this.consumeCodePoint();
          return CDC_TOKEN;
        }
        break;
      case FULL_STOP:
        if (isNumberStart(codePoint, this.peekCodePoint(0), this.peekCodePoint(1))) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeNumericToken();
        }
        break;
      case SOLIDUS:
        if (this.peekCodePoint(0) === ASTERISK) {
          this.consumeCodePoint();
          while (true) {
            var c = this.consumeCodePoint();
            if (c === ASTERISK) {
              c = this.consumeCodePoint();
              if (c === SOLIDUS) {
                return this.consumeToken();
              }
            }
            if (c === EOF) {
              return this.consumeToken();
            }
          }
        }
        break;
      case COLON:
        return COLON_TOKEN;
      case SEMICOLON:
        return SEMICOLON_TOKEN;
      case LESS_THAN_SIGN:
        if (this.peekCodePoint(0) === EXCLAMATION_MARK && this.peekCodePoint(1) === HYPHEN_MINUS && this.peekCodePoint(2) === HYPHEN_MINUS) {
          this.consumeCodePoint();
          this.consumeCodePoint();
          return CDO_TOKEN;
        }
        break;
      case COMMERCIAL_AT:
        var a1 = this.peekCodePoint(0);
        var a2 = this.peekCodePoint(1);
        var a3 = this.peekCodePoint(2);
        if (isIdentifierStart(a1, a2, a3)) {
          var value = this.consumeName();
          return { type: 7, value };
        }
        break;
      case LEFT_SQUARE_BRACKET:
        return LEFT_SQUARE_BRACKET_TOKEN;
      case REVERSE_SOLIDUS:
        if (isValidEscape(codePoint, this.peekCodePoint(0))) {
          this.reconsumeCodePoint(codePoint);
          return this.consumeIdentLikeToken();
        }
        break;
      case RIGHT_SQUARE_BRACKET:
        return RIGHT_SQUARE_BRACKET_TOKEN;
      case CIRCUMFLEX_ACCENT:
        if (this.peekCodePoint(0) === EQUALS_SIGN) {
          this.consumeCodePoint();
          return PREFIX_MATCH_TOKEN;
        }
        break;
      case LEFT_CURLY_BRACKET:
        return LEFT_CURLY_BRACKET_TOKEN;
      case RIGHT_CURLY_BRACKET:
        return RIGHT_CURLY_BRACKET_TOKEN;
      case u:
      case U$1:
        var u1 = this.peekCodePoint(0);
        var u2 = this.peekCodePoint(1);
        if (u1 === PLUS_SIGN && (isHex(u2) || u2 === QUESTION_MARK)) {
          this.consumeCodePoint();
          this.consumeUnicodeRangeToken();
        }
        this.reconsumeCodePoint(codePoint);
        return this.consumeIdentLikeToken();
      case VERTICAL_LINE:
        if (this.peekCodePoint(0) === EQUALS_SIGN) {
          this.consumeCodePoint();
          return DASH_MATCH_TOKEN;
        }
        if (this.peekCodePoint(0) === VERTICAL_LINE) {
          this.consumeCodePoint();
          return COLUMN_TOKEN;
        }
        break;
      case TILDE:
        if (this.peekCodePoint(0) === EQUALS_SIGN) {
          this.consumeCodePoint();
          return INCLUDE_MATCH_TOKEN;
        }
        break;
      case EOF:
        return EOF_TOKEN;
    }
    if (isWhiteSpace(codePoint)) {
      this.consumeWhiteSpace();
      return WHITESPACE_TOKEN;
    }
    if (isDigit(codePoint)) {
      this.reconsumeCodePoint(codePoint);
      return this.consumeNumericToken();
    }
    if (isNameStartCodePoint(codePoint)) {
      this.reconsumeCodePoint(codePoint);
      return this.consumeIdentLikeToken();
    }
    return { type: 6, value: fromCodePoint$1(codePoint) };
  };
  Tokenizer2.prototype.consumeCodePoint = function() {
    var value = this._value.shift();
    return typeof value === "undefined" ? -1 : value;
  };
  Tokenizer2.prototype.reconsumeCodePoint = function(codePoint) {
    this._value.unshift(codePoint);
  };
  Tokenizer2.prototype.peekCodePoint = function(delta) {
    if (delta >= this._value.length) {
      return -1;
    }
    return this._value[delta];
  };
  Tokenizer2.prototype.consumeUnicodeRangeToken = function() {
    var digits = [];
    var codePoint = this.consumeCodePoint();
    while (isHex(codePoint) && digits.length < 6) {
      digits.push(codePoint);
      codePoint = this.consumeCodePoint();
    }
    var questionMarks = false;
    while (codePoint === QUESTION_MARK && digits.length < 6) {
      digits.push(codePoint);
      codePoint = this.consumeCodePoint();
      questionMarks = true;
    }
    if (questionMarks) {
      var start_1 = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
        return digit === QUESTION_MARK ? ZERO : digit;
      })), 16);
      var end = parseInt(fromCodePoint$1.apply(void 0, digits.map(function(digit) {
        return digit === QUESTION_MARK ? F$1 : digit;
      })), 16);
      return { type: 30, start: start_1, end };
    }
    var start = parseInt(fromCodePoint$1.apply(void 0, digits), 16);
    if (this.peekCodePoint(0) === HYPHEN_MINUS && isHex(this.peekCodePoint(1))) {
      this.consumeCodePoint();
      codePoint = this.consumeCodePoint();
      var endDigits = [];
      while (isHex(codePoint) && endDigits.length < 6) {
        endDigits.push(codePoint);
        codePoint = this.consumeCodePoint();
      }
      var end = parseInt(fromCodePoint$1.apply(void 0, endDigits), 16);
      return { type: 30, start, end };
    } else {
      return { type: 30, start, end: start };
    }
  };
  Tokenizer2.prototype.consumeIdentLikeToken = function() {
    var value = this.consumeName();
    if (value.toLowerCase() === "url" && this.peekCodePoint(0) === LEFT_PARENTHESIS) {
      this.consumeCodePoint();
      return this.consumeUrlToken();
    } else if (this.peekCodePoint(0) === LEFT_PARENTHESIS) {
      this.consumeCodePoint();
      return { type: 19, value };
    }
    return { type: 20, value };
  };
  Tokenizer2.prototype.consumeUrlToken = function() {
    var value = [];
    this.consumeWhiteSpace();
    if (this.peekCodePoint(0) === EOF) {
      return { type: 22, value: "" };
    }
    var next = this.peekCodePoint(0);
    if (next === APOSTROPHE || next === QUOTATION_MARK) {
      var stringToken = this.consumeStringToken(this.consumeCodePoint());
      if (stringToken.type === 0) {
        this.consumeWhiteSpace();
        if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
          this.consumeCodePoint();
          return { type: 22, value: stringToken.value };
        }
      }
      this.consumeBadUrlRemnants();
      return BAD_URL_TOKEN;
    }
    while (true) {
      var codePoint = this.consumeCodePoint();
      if (codePoint === EOF || codePoint === RIGHT_PARENTHESIS) {
        return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
      } else if (isWhiteSpace(codePoint)) {
        this.consumeWhiteSpace();
        if (this.peekCodePoint(0) === EOF || this.peekCodePoint(0) === RIGHT_PARENTHESIS) {
          this.consumeCodePoint();
          return { type: 22, value: fromCodePoint$1.apply(void 0, value) };
        }
        this.consumeBadUrlRemnants();
        return BAD_URL_TOKEN;
      } else if (codePoint === QUOTATION_MARK || codePoint === APOSTROPHE || codePoint === LEFT_PARENTHESIS || isNonPrintableCodePoint(codePoint)) {
        this.consumeBadUrlRemnants();
        return BAD_URL_TOKEN;
      } else if (codePoint === REVERSE_SOLIDUS) {
        if (isValidEscape(codePoint, this.peekCodePoint(0))) {
          value.push(this.consumeEscapedCodePoint());
        } else {
          this.consumeBadUrlRemnants();
          return BAD_URL_TOKEN;
        }
      } else {
        value.push(codePoint);
      }
    }
  };
  Tokenizer2.prototype.consumeWhiteSpace = function() {
    while (isWhiteSpace(this.peekCodePoint(0))) {
      this.consumeCodePoint();
    }
  };
  Tokenizer2.prototype.consumeBadUrlRemnants = function() {
    while (true) {
      var codePoint = this.consumeCodePoint();
      if (codePoint === RIGHT_PARENTHESIS || codePoint === EOF) {
        return;
      }
      if (isValidEscape(codePoint, this.peekCodePoint(0))) {
        this.consumeEscapedCodePoint();
      }
    }
  };
  Tokenizer2.prototype.consumeStringSlice = function(count) {
    var SLICE_STACK_SIZE = 5e4;
    var value = "";
    while (count > 0) {
      var amount = Math.min(SLICE_STACK_SIZE, count);
      value += fromCodePoint$1.apply(void 0, this._value.splice(0, amount));
      count -= amount;
    }
    this._value.shift();
    return value;
  };
  Tokenizer2.prototype.consumeStringToken = function(endingCodePoint) {
    var value = "";
    var i = 0;
    do {
      var codePoint = this._value[i];
      if (codePoint === EOF || codePoint === void 0 || codePoint === endingCodePoint) {
        value += this.consumeStringSlice(i);
        return { type: 0, value };
      }
      if (codePoint === LINE_FEED) {
        this._value.splice(0, i);
        return BAD_STRING_TOKEN;
      }
      if (codePoint === REVERSE_SOLIDUS) {
        var next = this._value[i + 1];
        if (next !== EOF && next !== void 0) {
          if (next === LINE_FEED) {
            value += this.consumeStringSlice(i);
            i = -1;
            this._value.shift();
          } else if (isValidEscape(codePoint, next)) {
            value += this.consumeStringSlice(i);
            value += fromCodePoint$1(this.consumeEscapedCodePoint());
            i = -1;
          }
        }
      }
      i++;
    } while (true);
  };
  Tokenizer2.prototype.consumeNumber = function() {
    var repr = [];
    var type = FLAG_INTEGER;
    var c1 = this.peekCodePoint(0);
    if (c1 === PLUS_SIGN || c1 === HYPHEN_MINUS) {
      repr.push(this.consumeCodePoint());
    }
    while (isDigit(this.peekCodePoint(0))) {
      repr.push(this.consumeCodePoint());
    }
    c1 = this.peekCodePoint(0);
    var c2 = this.peekCodePoint(1);
    if (c1 === FULL_STOP && isDigit(c2)) {
      repr.push(this.consumeCodePoint(), this.consumeCodePoint());
      type = FLAG_NUMBER;
      while (isDigit(this.peekCodePoint(0))) {
        repr.push(this.consumeCodePoint());
      }
    }
    c1 = this.peekCodePoint(0);
    c2 = this.peekCodePoint(1);
    var c3 = this.peekCodePoint(2);
    if ((c1 === E$1 || c1 === e) && ((c2 === PLUS_SIGN || c2 === HYPHEN_MINUS) && isDigit(c3) || isDigit(c2))) {
      repr.push(this.consumeCodePoint(), this.consumeCodePoint());
      type = FLAG_NUMBER;
      while (isDigit(this.peekCodePoint(0))) {
        repr.push(this.consumeCodePoint());
      }
    }
    return [stringToNumber(repr), type];
  };
  Tokenizer2.prototype.consumeNumericToken = function() {
    var _a2 = this.consumeNumber(), number = _a2[0], flags = _a2[1];
    var c1 = this.peekCodePoint(0);
    var c2 = this.peekCodePoint(1);
    var c3 = this.peekCodePoint(2);
    if (isIdentifierStart(c1, c2, c3)) {
      var unit = this.consumeName();
      return { type: 15, number, flags, unit };
    }
    if (c1 === PERCENTAGE_SIGN) {
      this.consumeCodePoint();
      return { type: 16, number, flags };
    }
    return { type: 17, number, flags };
  };
  Tokenizer2.prototype.consumeEscapedCodePoint = function() {
    var codePoint = this.consumeCodePoint();
    if (isHex(codePoint)) {
      var hex = fromCodePoint$1(codePoint);
      while (isHex(this.peekCodePoint(0)) && hex.length < 6) {
        hex += fromCodePoint$1(this.consumeCodePoint());
      }
      if (isWhiteSpace(this.peekCodePoint(0))) {
        this.consumeCodePoint();
      }
      var hexCodePoint = parseInt(hex, 16);
      if (hexCodePoint === 0 || isSurrogateCodePoint(hexCodePoint) || hexCodePoint > 1114111) {
        return REPLACEMENT_CHARACTER;
      }
      return hexCodePoint;
    }
    if (codePoint === EOF) {
      return REPLACEMENT_CHARACTER;
    }
    return codePoint;
  };
  Tokenizer2.prototype.consumeName = function() {
    var result = "";
    while (true) {
      var codePoint = this.consumeCodePoint();
      if (isNameCodePoint(codePoint)) {
        result += fromCodePoint$1(codePoint);
      } else if (isValidEscape(codePoint, this.peekCodePoint(0))) {
        result += fromCodePoint$1(this.consumeEscapedCodePoint());
      } else {
        this.reconsumeCodePoint(codePoint);
        return result;
      }
    }
  };
  return Tokenizer2;
}();
var Parser = function() {
  function Parser2(tokens) {
    this._tokens = tokens;
  }
  Parser2.create = function(value) {
    var tokenizer = new Tokenizer();
    tokenizer.write(value);
    return new Parser2(tokenizer.read());
  };
  Parser2.parseValue = function(value) {
    return Parser2.create(value).parseComponentValue();
  };
  Parser2.parseValues = function(value) {
    return Parser2.create(value).parseComponentValues();
  };
  Parser2.prototype.parseComponentValue = function() {
    var token = this.consumeToken();
    while (token.type === 31) {
      token = this.consumeToken();
    }
    if (token.type === 32) {
      throw new SyntaxError("Error parsing CSS component value, unexpected EOF");
    }
    this.reconsumeToken(token);
    var value = this.consumeComponentValue();
    do {
      token = this.consumeToken();
    } while (token.type === 31);
    if (token.type === 32) {
      return value;
    }
    throw new SyntaxError("Error parsing CSS component value, multiple values found when expecting only one");
  };
  Parser2.prototype.parseComponentValues = function() {
    var values = [];
    while (true) {
      var value = this.consumeComponentValue();
      if (value.type === 32) {
        return values;
      }
      values.push(value);
      values.push();
    }
  };
  Parser2.prototype.consumeComponentValue = function() {
    var token = this.consumeToken();
    switch (token.type) {
      case 11:
      case 28:
      case 2:
        return this.consumeSimpleBlock(token.type);
      case 19:
        return this.consumeFunction(token);
    }
    return token;
  };
  Parser2.prototype.consumeSimpleBlock = function(type) {
    var block = { type, values: [] };
    var token = this.consumeToken();
    while (true) {
      if (token.type === 32 || isEndingTokenFor(token, type)) {
        return block;
      }
      this.reconsumeToken(token);
      block.values.push(this.consumeComponentValue());
      token = this.consumeToken();
    }
  };
  Parser2.prototype.consumeFunction = function(functionToken) {
    var cssFunction = {
      name: functionToken.value,
      values: [],
      type: 18
    };
    while (true) {
      var token = this.consumeToken();
      if (token.type === 32 || token.type === 3) {
        return cssFunction;
      }
      this.reconsumeToken(token);
      cssFunction.values.push(this.consumeComponentValue());
    }
  };
  Parser2.prototype.consumeToken = function() {
    var token = this._tokens.shift();
    return typeof token === "undefined" ? EOF_TOKEN : token;
  };
  Parser2.prototype.reconsumeToken = function(token) {
    this._tokens.unshift(token);
  };
  return Parser2;
}();
var isDimensionToken = function(token) {
  return token.type === 15;
};
var isNumberToken = function(token) {
  return token.type === 17;
};
var isIdentToken = function(token) {
  return token.type === 20;
};
var isStringToken = function(token) {
  return token.type === 0;
};
var isIdentWithValue = function(token, value) {
  return isIdentToken(token) && token.value === value;
};
var nonWhiteSpace = function(token) {
  return token.type !== 31;
};
var nonFunctionArgSeparator = function(token) {
  return token.type !== 31 && token.type !== 4;
};
var parseFunctionArgs = function(tokens) {
  var args = [];
  var arg = [];
  tokens.forEach(function(token) {
    if (token.type === 4) {
      if (arg.length === 0) {
        throw new Error("Error parsing function args, zero tokens for arg");
      }
      args.push(arg);
      arg = [];
      return;
    }
    if (token.type !== 31) {
      arg.push(token);
    }
  });
  if (arg.length) {
    args.push(arg);
  }
  return args;
};
var isEndingTokenFor = function(token, type) {
  if (type === 11 && token.type === 12) {
    return true;
  }
  if (type === 28 && token.type === 29) {
    return true;
  }
  return type === 2 && token.type === 3;
};
var isLength = function(token) {
  return token.type === 17 || token.type === 15;
};
var isLengthPercentage = function(token) {
  return token.type === 16 || isLength(token);
};
var parseLengthPercentageTuple = function(tokens) {
  return tokens.length > 1 ? [tokens[0], tokens[1]] : [tokens[0]];
};
var ZERO_LENGTH = {
  type: 17,
  number: 0,
  flags: FLAG_INTEGER
};
var FIFTY_PERCENT = {
  type: 16,
  number: 50,
  flags: FLAG_INTEGER
};
var HUNDRED_PERCENT = {
  type: 16,
  number: 100,
  flags: FLAG_INTEGER
};
var getAbsoluteValueForTuple = function(tuple, width, height) {
  var x = tuple[0], y = tuple[1];
  return [getAbsoluteValue(x, width), getAbsoluteValue(typeof y !== "undefined" ? y : x, height)];
};
var getAbsoluteValue = function(token, parent) {
  if (token.type === 16) {
    return token.number / 100 * parent;
  }
  if (isDimensionToken(token)) {
    switch (token.unit) {
      case "rem":
      case "em":
        return 16 * token.number;
      case "px":
      default:
        return token.number;
    }
  }
  return token.number;
};
var DEG = "deg";
var GRAD = "grad";
var RAD = "rad";
var TURN = "turn";
var angle = {
  name: "angle",
  parse: function(_context, value) {
    if (value.type === 15) {
      switch (value.unit) {
        case DEG:
          return Math.PI * value.number / 180;
        case GRAD:
          return Math.PI / 200 * value.number;
        case RAD:
          return value.number;
        case TURN:
          return Math.PI * 2 * value.number;
      }
    }
    throw new Error("Unsupported angle type");
  }
};
var isAngle = function(value) {
  if (value.type === 15) {
    if (value.unit === DEG || value.unit === GRAD || value.unit === RAD || value.unit === TURN) {
      return true;
    }
  }
  return false;
};
var parseNamedSide = function(tokens) {
  var sideOrCorner = tokens.filter(isIdentToken).map(function(ident) {
    return ident.value;
  }).join(" ");
  switch (sideOrCorner) {
    case "to bottom right":
    case "to right bottom":
    case "left top":
    case "top left":
      return [ZERO_LENGTH, ZERO_LENGTH];
    case "to top":
    case "bottom":
      return deg(0);
    case "to bottom left":
    case "to left bottom":
    case "right top":
    case "top right":
      return [ZERO_LENGTH, HUNDRED_PERCENT];
    case "to right":
    case "left":
      return deg(90);
    case "to top left":
    case "to left top":
    case "right bottom":
    case "bottom right":
      return [HUNDRED_PERCENT, HUNDRED_PERCENT];
    case "to bottom":
    case "top":
      return deg(180);
    case "to top right":
    case "to right top":
    case "left bottom":
    case "bottom left":
      return [HUNDRED_PERCENT, ZERO_LENGTH];
    case "to left":
    case "right":
      return deg(270);
  }
  return 0;
};
var deg = function(deg2) {
  return Math.PI * deg2 / 180;
};
var color$1 = {
  name: "color",
  parse: function(context, value) {
    if (value.type === 18) {
      var colorFunction = SUPPORTED_COLOR_FUNCTIONS[value.name];
      if (typeof colorFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported color function "' + value.name + '"');
      }
      return colorFunction(context, value.values);
    }
    if (value.type === 5) {
      if (value.value.length === 3) {
        var r = value.value.substring(0, 1);
        var g = value.value.substring(1, 2);
        var b = value.value.substring(2, 3);
        return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), 1);
      }
      if (value.value.length === 4) {
        var r = value.value.substring(0, 1);
        var g = value.value.substring(1, 2);
        var b = value.value.substring(2, 3);
        var a2 = value.value.substring(3, 4);
        return pack(parseInt(r + r, 16), parseInt(g + g, 16), parseInt(b + b, 16), parseInt(a2 + a2, 16) / 255);
      }
      if (value.value.length === 6) {
        var r = value.value.substring(0, 2);
        var g = value.value.substring(2, 4);
        var b = value.value.substring(4, 6);
        return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), 1);
      }
      if (value.value.length === 8) {
        var r = value.value.substring(0, 2);
        var g = value.value.substring(2, 4);
        var b = value.value.substring(4, 6);
        var a2 = value.value.substring(6, 8);
        return pack(parseInt(r, 16), parseInt(g, 16), parseInt(b, 16), parseInt(a2, 16) / 255);
      }
    }
    if (value.type === 20) {
      var namedColor = COLORS[value.value.toUpperCase()];
      if (typeof namedColor !== "undefined") {
        return namedColor;
      }
    }
    return COLORS.TRANSPARENT;
  }
};
var isTransparent = function(color2) {
  return (255 & color2) === 0;
};
var asString = function(color2) {
  var alpha = 255 & color2;
  var blue = 255 & color2 >> 8;
  var green = 255 & color2 >> 16;
  var red = 255 & color2 >> 24;
  return alpha < 255 ? "rgba(" + red + "," + green + "," + blue + "," + alpha / 255 + ")" : "rgb(" + red + "," + green + "," + blue + ")";
};
var pack = function(r, g, b, a2) {
  return (r << 24 | g << 16 | b << 8 | Math.round(a2 * 255) << 0) >>> 0;
};
var getTokenColorValue = function(token, i) {
  if (token.type === 17) {
    return token.number;
  }
  if (token.type === 16) {
    var max2 = i === 3 ? 1 : 255;
    return i === 3 ? token.number / 100 * max2 : Math.round(token.number / 100 * max2);
  }
  return 0;
};
var rgb = function(_context, args) {
  var tokens = args.filter(nonFunctionArgSeparator);
  if (tokens.length === 3) {
    var _a2 = tokens.map(getTokenColorValue), r = _a2[0], g = _a2[1], b = _a2[2];
    return pack(r, g, b, 1);
  }
  if (tokens.length === 4) {
    var _b = tokens.map(getTokenColorValue), r = _b[0], g = _b[1], b = _b[2], a2 = _b[3];
    return pack(r, g, b, a2);
  }
  return 0;
};
function hue2rgb(t1, t2, hue) {
  if (hue < 0) {
    hue += 1;
  }
  if (hue >= 1) {
    hue -= 1;
  }
  if (hue < 1 / 6) {
    return (t2 - t1) * hue * 6 + t1;
  } else if (hue < 1 / 2) {
    return t2;
  } else if (hue < 2 / 3) {
    return (t2 - t1) * 6 * (2 / 3 - hue) + t1;
  } else {
    return t1;
  }
}
var hsl = function(context, args) {
  var tokens = args.filter(nonFunctionArgSeparator);
  var hue = tokens[0], saturation = tokens[1], lightness = tokens[2], alpha = tokens[3];
  var h2 = (hue.type === 17 ? deg(hue.number) : angle.parse(context, hue)) / (Math.PI * 2);
  var s = isLengthPercentage(saturation) ? saturation.number / 100 : 0;
  var l = isLengthPercentage(lightness) ? lightness.number / 100 : 0;
  var a2 = typeof alpha !== "undefined" && isLengthPercentage(alpha) ? getAbsoluteValue(alpha, 1) : 1;
  if (s === 0) {
    return pack(l * 255, l * 255, l * 255, 1);
  }
  var t2 = l <= 0.5 ? l * (s + 1) : l + s - l * s;
  var t1 = l * 2 - t2;
  var r = hue2rgb(t1, t2, h2 + 1 / 3);
  var g = hue2rgb(t1, t2, h2);
  var b = hue2rgb(t1, t2, h2 - 1 / 3);
  return pack(r * 255, g * 255, b * 255, a2);
};
var SUPPORTED_COLOR_FUNCTIONS = {
  hsl,
  hsla: hsl,
  rgb,
  rgba: rgb
};
var parseColor = function(context, value) {
  return color$1.parse(context, Parser.create(value).parseComponentValue());
};
var COLORS = {
  ALICEBLUE: 4042850303,
  ANTIQUEWHITE: 4209760255,
  AQUA: 16777215,
  AQUAMARINE: 2147472639,
  AZURE: 4043309055,
  BEIGE: 4126530815,
  BISQUE: 4293182719,
  BLACK: 255,
  BLANCHEDALMOND: 4293643775,
  BLUE: 65535,
  BLUEVIOLET: 2318131967,
  BROWN: 2771004159,
  BURLYWOOD: 3736635391,
  CADETBLUE: 1604231423,
  CHARTREUSE: 2147418367,
  CHOCOLATE: 3530104575,
  CORAL: 4286533887,
  CORNFLOWERBLUE: 1687547391,
  CORNSILK: 4294499583,
  CRIMSON: 3692313855,
  CYAN: 16777215,
  DARKBLUE: 35839,
  DARKCYAN: 9145343,
  DARKGOLDENROD: 3095837695,
  DARKGRAY: 2846468607,
  DARKGREEN: 6553855,
  DARKGREY: 2846468607,
  DARKKHAKI: 3182914559,
  DARKMAGENTA: 2332068863,
  DARKOLIVEGREEN: 1433087999,
  DARKORANGE: 4287365375,
  DARKORCHID: 2570243327,
  DARKRED: 2332033279,
  DARKSALMON: 3918953215,
  DARKSEAGREEN: 2411499519,
  DARKSLATEBLUE: 1211993087,
  DARKSLATEGRAY: 793726975,
  DARKSLATEGREY: 793726975,
  DARKTURQUOISE: 13554175,
  DARKVIOLET: 2483082239,
  DEEPPINK: 4279538687,
  DEEPSKYBLUE: 12582911,
  DIMGRAY: 1768516095,
  DIMGREY: 1768516095,
  DODGERBLUE: 512819199,
  FIREBRICK: 2988581631,
  FLORALWHITE: 4294635775,
  FORESTGREEN: 579543807,
  FUCHSIA: 4278255615,
  GAINSBORO: 3705462015,
  GHOSTWHITE: 4177068031,
  GOLD: 4292280575,
  GOLDENROD: 3668254975,
  GRAY: 2155905279,
  GREEN: 8388863,
  GREENYELLOW: 2919182335,
  GREY: 2155905279,
  HONEYDEW: 4043305215,
  HOTPINK: 4285117695,
  INDIANRED: 3445382399,
  INDIGO: 1258324735,
  IVORY: 4294963455,
  KHAKI: 4041641215,
  LAVENDER: 3873897215,
  LAVENDERBLUSH: 4293981695,
  LAWNGREEN: 2096890111,
  LEMONCHIFFON: 4294626815,
  LIGHTBLUE: 2916673279,
  LIGHTCORAL: 4034953471,
  LIGHTCYAN: 3774873599,
  LIGHTGOLDENRODYELLOW: 4210742015,
  LIGHTGRAY: 3553874943,
  LIGHTGREEN: 2431553791,
  LIGHTGREY: 3553874943,
  LIGHTPINK: 4290167295,
  LIGHTSALMON: 4288707327,
  LIGHTSEAGREEN: 548580095,
  LIGHTSKYBLUE: 2278488831,
  LIGHTSLATEGRAY: 2005441023,
  LIGHTSLATEGREY: 2005441023,
  LIGHTSTEELBLUE: 2965692159,
  LIGHTYELLOW: 4294959359,
  LIME: 16711935,
  LIMEGREEN: 852308735,
  LINEN: 4210091775,
  MAGENTA: 4278255615,
  MAROON: 2147483903,
  MEDIUMAQUAMARINE: 1724754687,
  MEDIUMBLUE: 52735,
  MEDIUMORCHID: 3126187007,
  MEDIUMPURPLE: 2473647103,
  MEDIUMSEAGREEN: 1018393087,
  MEDIUMSLATEBLUE: 2070474495,
  MEDIUMSPRINGGREEN: 16423679,
  MEDIUMTURQUOISE: 1221709055,
  MEDIUMVIOLETRED: 3340076543,
  MIDNIGHTBLUE: 421097727,
  MINTCREAM: 4127193855,
  MISTYROSE: 4293190143,
  MOCCASIN: 4293178879,
  NAVAJOWHITE: 4292783615,
  NAVY: 33023,
  OLDLACE: 4260751103,
  OLIVE: 2155872511,
  OLIVEDRAB: 1804477439,
  ORANGE: 4289003775,
  ORANGERED: 4282712319,
  ORCHID: 3664828159,
  PALEGOLDENROD: 4008225535,
  PALEGREEN: 2566625535,
  PALETURQUOISE: 2951671551,
  PALEVIOLETRED: 3681588223,
  PAPAYAWHIP: 4293907967,
  PEACHPUFF: 4292524543,
  PERU: 3448061951,
  PINK: 4290825215,
  PLUM: 3718307327,
  POWDERBLUE: 2967529215,
  PURPLE: 2147516671,
  REBECCAPURPLE: 1714657791,
  RED: 4278190335,
  ROSYBROWN: 3163525119,
  ROYALBLUE: 1097458175,
  SADDLEBROWN: 2336560127,
  SALMON: 4202722047,
  SANDYBROWN: 4104413439,
  SEAGREEN: 780883967,
  SEASHELL: 4294307583,
  SIENNA: 2689740287,
  SILVER: 3233857791,
  SKYBLUE: 2278484991,
  SLATEBLUE: 1784335871,
  SLATEGRAY: 1887473919,
  SLATEGREY: 1887473919,
  SNOW: 4294638335,
  SPRINGGREEN: 16744447,
  STEELBLUE: 1182971135,
  TAN: 3535047935,
  TEAL: 8421631,
  THISTLE: 3636451583,
  TOMATO: 4284696575,
  TRANSPARENT: 0,
  TURQUOISE: 1088475391,
  VIOLET: 4001558271,
  WHEAT: 4125012991,
  WHITE: 4294967295,
  WHITESMOKE: 4126537215,
  YELLOW: 4294902015,
  YELLOWGREEN: 2597139199
};
var backgroundClip = {
  name: "background-clip",
  initialValue: "border-box",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.map(function(token) {
      if (isIdentToken(token)) {
        switch (token.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      }
      return 0;
    });
  }
};
var backgroundColor = {
  name: "background-color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var parseColorStop = function(context, args) {
  var color2 = color$1.parse(context, args[0]);
  var stop = args[1];
  return stop && isLengthPercentage(stop) ? { color: color2, stop } : { color: color2, stop: null };
};
var processColorStops = function(stops, lineLength) {
  var first = stops[0];
  var last = stops[stops.length - 1];
  if (first.stop === null) {
    first.stop = ZERO_LENGTH;
  }
  if (last.stop === null) {
    last.stop = HUNDRED_PERCENT;
  }
  var processStops = [];
  var previous = 0;
  for (var i = 0; i < stops.length; i++) {
    var stop_1 = stops[i].stop;
    if (stop_1 !== null) {
      var absoluteValue = getAbsoluteValue(stop_1, lineLength);
      if (absoluteValue > previous) {
        processStops.push(absoluteValue);
      } else {
        processStops.push(previous);
      }
      previous = absoluteValue;
    } else {
      processStops.push(null);
    }
  }
  var gapBegin = null;
  for (var i = 0; i < processStops.length; i++) {
    var stop_2 = processStops[i];
    if (stop_2 === null) {
      if (gapBegin === null) {
        gapBegin = i;
      }
    } else if (gapBegin !== null) {
      var gapLength = i - gapBegin;
      var beforeGap = processStops[gapBegin - 1];
      var gapValue = (stop_2 - beforeGap) / (gapLength + 1);
      for (var g = 1; g <= gapLength; g++) {
        processStops[gapBegin + g - 1] = gapValue * g;
      }
      gapBegin = null;
    }
  }
  return stops.map(function(_a2, i2) {
    var color2 = _a2.color;
    return { color: color2, stop: Math.max(Math.min(1, processStops[i2] / lineLength), 0) };
  });
};
var getAngleFromCorner = function(corner, width, height) {
  var centerX = width / 2;
  var centerY = height / 2;
  var x = getAbsoluteValue(corner[0], width) - centerX;
  var y = centerY - getAbsoluteValue(corner[1], height);
  return (Math.atan2(y, x) + Math.PI * 2) % (Math.PI * 2);
};
var calculateGradientDirection = function(angle2, width, height) {
  var radian = typeof angle2 === "number" ? angle2 : getAngleFromCorner(angle2, width, height);
  var lineLength = Math.abs(width * Math.sin(radian)) + Math.abs(height * Math.cos(radian));
  var halfWidth = width / 2;
  var halfHeight = height / 2;
  var halfLineLength = lineLength / 2;
  var yDiff = Math.sin(radian - Math.PI / 2) * halfLineLength;
  var xDiff = Math.cos(radian - Math.PI / 2) * halfLineLength;
  return [lineLength, halfWidth - xDiff, halfWidth + xDiff, halfHeight - yDiff, halfHeight + yDiff];
};
var distance = function(a2, b) {
  return Math.sqrt(a2 * a2 + b * b);
};
var findCorner = function(width, height, x, y, closest2) {
  var corners = [
    [0, 0],
    [0, height],
    [width, 0],
    [width, height]
  ];
  return corners.reduce(function(stat, corner) {
    var cx = corner[0], cy = corner[1];
    var d = distance(x - cx, y - cy);
    if (closest2 ? d < stat.optimumDistance : d > stat.optimumDistance) {
      return {
        optimumCorner: corner,
        optimumDistance: d
      };
    }
    return stat;
  }, {
    optimumDistance: closest2 ? Infinity : -Infinity,
    optimumCorner: null
  }).optimumCorner;
};
var calculateRadius = function(gradient, x, y, width, height) {
  var rx = 0;
  var ry = 0;
  switch (gradient.size) {
    case 0:
      if (gradient.shape === 0) {
        rx = ry = Math.min(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
      } else if (gradient.shape === 1) {
        rx = Math.min(Math.abs(x), Math.abs(x - width));
        ry = Math.min(Math.abs(y), Math.abs(y - height));
      }
      break;
    case 2:
      if (gradient.shape === 0) {
        rx = ry = Math.min(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
      } else if (gradient.shape === 1) {
        var c = Math.min(Math.abs(y), Math.abs(y - height)) / Math.min(Math.abs(x), Math.abs(x - width));
        var _a2 = findCorner(width, height, x, y, true), cx = _a2[0], cy = _a2[1];
        rx = distance(cx - x, (cy - y) / c);
        ry = c * rx;
      }
      break;
    case 1:
      if (gradient.shape === 0) {
        rx = ry = Math.max(Math.abs(x), Math.abs(x - width), Math.abs(y), Math.abs(y - height));
      } else if (gradient.shape === 1) {
        rx = Math.max(Math.abs(x), Math.abs(x - width));
        ry = Math.max(Math.abs(y), Math.abs(y - height));
      }
      break;
    case 3:
      if (gradient.shape === 0) {
        rx = ry = Math.max(distance(x, y), distance(x, y - height), distance(x - width, y), distance(x - width, y - height));
      } else if (gradient.shape === 1) {
        var c = Math.max(Math.abs(y), Math.abs(y - height)) / Math.max(Math.abs(x), Math.abs(x - width));
        var _b = findCorner(width, height, x, y, false), cx = _b[0], cy = _b[1];
        rx = distance(cx - x, (cy - y) / c);
        ry = c * rx;
      }
      break;
  }
  if (Array.isArray(gradient.size)) {
    rx = getAbsoluteValue(gradient.size[0], width);
    ry = gradient.size.length === 2 ? getAbsoluteValue(gradient.size[1], height) : rx;
  }
  return [rx, ry];
};
var linearGradient = function(context, tokens) {
  var angle$1 = deg(180);
  var stops = [];
  parseFunctionArgs(tokens).forEach(function(arg, i) {
    if (i === 0) {
      var firstToken = arg[0];
      if (firstToken.type === 20 && firstToken.value === "to") {
        angle$1 = parseNamedSide(arg);
        return;
      } else if (isAngle(firstToken)) {
        angle$1 = angle.parse(context, firstToken);
        return;
      }
    }
    var colorStop = parseColorStop(context, arg);
    stops.push(colorStop);
  });
  return { angle: angle$1, stops, type: 1 };
};
var prefixLinearGradient = function(context, tokens) {
  var angle$1 = deg(180);
  var stops = [];
  parseFunctionArgs(tokens).forEach(function(arg, i) {
    if (i === 0) {
      var firstToken = arg[0];
      if (firstToken.type === 20 && ["top", "left", "right", "bottom"].indexOf(firstToken.value) !== -1) {
        angle$1 = parseNamedSide(arg);
        return;
      } else if (isAngle(firstToken)) {
        angle$1 = (angle.parse(context, firstToken) + deg(270)) % deg(360);
        return;
      }
    }
    var colorStop = parseColorStop(context, arg);
    stops.push(colorStop);
  });
  return {
    angle: angle$1,
    stops,
    type: 1
  };
};
var webkitGradient = function(context, tokens) {
  var angle2 = deg(180);
  var stops = [];
  var type = 1;
  var shape = 0;
  var size = 3;
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i) {
    var firstToken = arg[0];
    if (i === 0) {
      if (isIdentToken(firstToken) && firstToken.value === "linear") {
        type = 1;
        return;
      } else if (isIdentToken(firstToken) && firstToken.value === "radial") {
        type = 2;
        return;
      }
    }
    if (firstToken.type === 18) {
      if (firstToken.name === "from") {
        var color2 = color$1.parse(context, firstToken.values[0]);
        stops.push({ stop: ZERO_LENGTH, color: color2 });
      } else if (firstToken.name === "to") {
        var color2 = color$1.parse(context, firstToken.values[0]);
        stops.push({ stop: HUNDRED_PERCENT, color: color2 });
      } else if (firstToken.name === "color-stop") {
        var values = firstToken.values.filter(nonFunctionArgSeparator);
        if (values.length === 2) {
          var color2 = color$1.parse(context, values[1]);
          var stop_1 = values[0];
          if (isNumberToken(stop_1)) {
            stops.push({
              stop: { type: 16, number: stop_1.number * 100, flags: stop_1.flags },
              color: color2
            });
          }
        }
      }
    }
  });
  return type === 1 ? {
    angle: (angle2 + deg(180)) % deg(360),
    stops,
    type
  } : { size, shape, stops, position: position2, type };
};
var CLOSEST_SIDE = "closest-side";
var FARTHEST_SIDE = "farthest-side";
var CLOSEST_CORNER = "closest-corner";
var FARTHEST_CORNER = "farthest-corner";
var CIRCLE = "circle";
var ELLIPSE = "ellipse";
var COVER = "cover";
var CONTAIN = "contain";
var radialGradient = function(context, tokens) {
  var shape = 0;
  var size = 3;
  var stops = [];
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i) {
    var isColorStop = true;
    if (i === 0) {
      var isAtPosition_1 = false;
      isColorStop = arg.reduce(function(acc, token) {
        if (isAtPosition_1) {
          if (isIdentToken(token)) {
            switch (token.value) {
              case "center":
                position2.push(FIFTY_PERCENT);
                return acc;
              case "top":
              case "left":
                position2.push(ZERO_LENGTH);
                return acc;
              case "right":
              case "bottom":
                position2.push(HUNDRED_PERCENT);
                return acc;
            }
          } else if (isLengthPercentage(token) || isLength(token)) {
            position2.push(token);
          }
        } else if (isIdentToken(token)) {
          switch (token.value) {
            case CIRCLE:
              shape = 0;
              return false;
            case ELLIPSE:
              shape = 1;
              return false;
            case "at":
              isAtPosition_1 = true;
              return false;
            case CLOSEST_SIDE:
              size = 0;
              return false;
            case COVER:
            case FARTHEST_SIDE:
              size = 1;
              return false;
            case CONTAIN:
            case CLOSEST_CORNER:
              size = 2;
              return false;
            case FARTHEST_CORNER:
              size = 3;
              return false;
          }
        } else if (isLength(token) || isLengthPercentage(token)) {
          if (!Array.isArray(size)) {
            size = [];
          }
          size.push(token);
          return false;
        }
        return acc;
      }, isColorStop);
    }
    if (isColorStop) {
      var colorStop = parseColorStop(context, arg);
      stops.push(colorStop);
    }
  });
  return { size, shape, stops, position: position2, type: 2 };
};
var prefixRadialGradient = function(context, tokens) {
  var shape = 0;
  var size = 3;
  var stops = [];
  var position2 = [];
  parseFunctionArgs(tokens).forEach(function(arg, i) {
    var isColorStop = true;
    if (i === 0) {
      isColorStop = arg.reduce(function(acc, token) {
        if (isIdentToken(token)) {
          switch (token.value) {
            case "center":
              position2.push(FIFTY_PERCENT);
              return false;
            case "top":
            case "left":
              position2.push(ZERO_LENGTH);
              return false;
            case "right":
            case "bottom":
              position2.push(HUNDRED_PERCENT);
              return false;
          }
        } else if (isLengthPercentage(token) || isLength(token)) {
          position2.push(token);
          return false;
        }
        return acc;
      }, isColorStop);
    } else if (i === 1) {
      isColorStop = arg.reduce(function(acc, token) {
        if (isIdentToken(token)) {
          switch (token.value) {
            case CIRCLE:
              shape = 0;
              return false;
            case ELLIPSE:
              shape = 1;
              return false;
            case CONTAIN:
            case CLOSEST_SIDE:
              size = 0;
              return false;
            case FARTHEST_SIDE:
              size = 1;
              return false;
            case CLOSEST_CORNER:
              size = 2;
              return false;
            case COVER:
            case FARTHEST_CORNER:
              size = 3;
              return false;
          }
        } else if (isLength(token) || isLengthPercentage(token)) {
          if (!Array.isArray(size)) {
            size = [];
          }
          size.push(token);
          return false;
        }
        return acc;
      }, isColorStop);
    }
    if (isColorStop) {
      var colorStop = parseColorStop(context, arg);
      stops.push(colorStop);
    }
  });
  return { size, shape, stops, position: position2, type: 2 };
};
var isLinearGradient = function(background) {
  return background.type === 1;
};
var isRadialGradient = function(background) {
  return background.type === 2;
};
var image = {
  name: "image",
  parse: function(context, value) {
    if (value.type === 22) {
      var image_1 = { url: value.value, type: 0 };
      context.cache.addImage(value.value);
      return image_1;
    }
    if (value.type === 18) {
      var imageFunction = SUPPORTED_IMAGE_FUNCTIONS[value.name];
      if (typeof imageFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported image function "' + value.name + '"');
      }
      return imageFunction(context, value.values);
    }
    throw new Error("Unsupported image type " + value.type);
  }
};
function isSupportedImage(value) {
  return !(value.type === 20 && value.value === "none") && (value.type !== 18 || !!SUPPORTED_IMAGE_FUNCTIONS[value.name]);
}
var SUPPORTED_IMAGE_FUNCTIONS = {
  "linear-gradient": linearGradient,
  "-moz-linear-gradient": prefixLinearGradient,
  "-ms-linear-gradient": prefixLinearGradient,
  "-o-linear-gradient": prefixLinearGradient,
  "-webkit-linear-gradient": prefixLinearGradient,
  "radial-gradient": radialGradient,
  "-moz-radial-gradient": prefixRadialGradient,
  "-ms-radial-gradient": prefixRadialGradient,
  "-o-radial-gradient": prefixRadialGradient,
  "-webkit-radial-gradient": prefixRadialGradient,
  "-webkit-gradient": webkitGradient
};
var backgroundImage = {
  name: "background-image",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return [];
    }
    return tokens.filter(function(value) {
      return nonFunctionArgSeparator(value) && isSupportedImage(value);
    }).map(function(value) {
      return image.parse(context, value);
    });
  }
};
var backgroundOrigin = {
  name: "background-origin",
  initialValue: "border-box",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.map(function(token) {
      if (isIdentToken(token)) {
        switch (token.value) {
          case "padding-box":
            return 1;
          case "content-box":
            return 2;
        }
      }
      return 0;
    });
  }
};
var backgroundPosition = {
  name: "background-position",
  initialValue: "0% 0%",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values) {
      return values.filter(isLengthPercentage);
    }).map(parseLengthPercentageTuple);
  }
};
var backgroundRepeat = {
  name: "background-repeat",
  initialValue: "repeat",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values) {
      return values.filter(isIdentToken).map(function(token) {
        return token.value;
      }).join(" ");
    }).map(parseBackgroundRepeat);
  }
};
var parseBackgroundRepeat = function(value) {
  switch (value) {
    case "no-repeat":
      return 1;
    case "repeat-x":
    case "repeat no-repeat":
      return 2;
    case "repeat-y":
    case "no-repeat repeat":
      return 3;
    case "repeat":
    default:
      return 0;
  }
};
var BACKGROUND_SIZE;
(function(BACKGROUND_SIZE2) {
  BACKGROUND_SIZE2["AUTO"] = "auto";
  BACKGROUND_SIZE2["CONTAIN"] = "contain";
  BACKGROUND_SIZE2["COVER"] = "cover";
})(BACKGROUND_SIZE || (BACKGROUND_SIZE = {}));
var backgroundSize = {
  name: "background-size",
  initialValue: "0",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return parseFunctionArgs(tokens).map(function(values) {
      return values.filter(isBackgroundSizeInfoToken);
    });
  }
};
var isBackgroundSizeInfoToken = function(value) {
  return isIdentToken(value) || isLengthPercentage(value);
};
var borderColorForSide = function(side) {
  return {
    name: "border-" + side + "-color",
    initialValue: "transparent",
    prefix: false,
    type: 3,
    format: "color"
  };
};
var borderTopColor = borderColorForSide("top");
var borderRightColor = borderColorForSide("right");
var borderBottomColor = borderColorForSide("bottom");
var borderLeftColor = borderColorForSide("left");
var borderRadiusForSide = function(side) {
  return {
    name: "border-radius-" + side,
    initialValue: "0 0",
    prefix: false,
    type: 1,
    parse: function(_context, tokens) {
      return parseLengthPercentageTuple(tokens.filter(isLengthPercentage));
    }
  };
};
var borderTopLeftRadius = borderRadiusForSide("top-left");
var borderTopRightRadius = borderRadiusForSide("top-right");
var borderBottomRightRadius = borderRadiusForSide("bottom-right");
var borderBottomLeftRadius = borderRadiusForSide("bottom-left");
var borderStyleForSide = function(side) {
  return {
    name: "border-" + side + "-style",
    initialValue: "solid",
    prefix: false,
    type: 2,
    parse: function(_context, style) {
      switch (style) {
        case "none":
          return 0;
        case "dashed":
          return 2;
        case "dotted":
          return 3;
        case "double":
          return 4;
      }
      return 1;
    }
  };
};
var borderTopStyle = borderStyleForSide("top");
var borderRightStyle = borderStyleForSide("right");
var borderBottomStyle = borderStyleForSide("bottom");
var borderLeftStyle = borderStyleForSide("left");
var borderWidthForSide = function(side) {
  return {
    name: "border-" + side + "-width",
    initialValue: "0",
    type: 0,
    prefix: false,
    parse: function(_context, token) {
      if (isDimensionToken(token)) {
        return token.number;
      }
      return 0;
    }
  };
};
var borderTopWidth = borderWidthForSide("top");
var borderRightWidth = borderWidthForSide("right");
var borderBottomWidth = borderWidthForSide("bottom");
var borderLeftWidth = borderWidthForSide("left");
var color = {
  name: "color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var direction = {
  name: "direction",
  initialValue: "ltr",
  prefix: false,
  type: 2,
  parse: function(_context, direction2) {
    switch (direction2) {
      case "rtl":
        return 1;
      case "ltr":
      default:
        return 0;
    }
  }
};
var display = {
  name: "display",
  initialValue: "inline-block",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).reduce(function(bit, token) {
      return bit | parseDisplayValue(token.value);
    }, 0);
  }
};
var parseDisplayValue = function(display2) {
  switch (display2) {
    case "block":
    case "-webkit-box":
      return 2;
    case "inline":
      return 4;
    case "run-in":
      return 8;
    case "flow":
      return 16;
    case "flow-root":
      return 32;
    case "table":
      return 64;
    case "flex":
    case "-webkit-flex":
      return 128;
    case "grid":
    case "-ms-grid":
      return 256;
    case "ruby":
      return 512;
    case "subgrid":
      return 1024;
    case "list-item":
      return 2048;
    case "table-row-group":
      return 4096;
    case "table-header-group":
      return 8192;
    case "table-footer-group":
      return 16384;
    case "table-row":
      return 32768;
    case "table-cell":
      return 65536;
    case "table-column-group":
      return 131072;
    case "table-column":
      return 262144;
    case "table-caption":
      return 524288;
    case "ruby-base":
      return 1048576;
    case "ruby-text":
      return 2097152;
    case "ruby-base-container":
      return 4194304;
    case "ruby-text-container":
      return 8388608;
    case "contents":
      return 16777216;
    case "inline-block":
      return 33554432;
    case "inline-list-item":
      return 67108864;
    case "inline-table":
      return 134217728;
    case "inline-flex":
      return 268435456;
    case "inline-grid":
      return 536870912;
  }
  return 0;
};
var float = {
  name: "float",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, float2) {
    switch (float2) {
      case "left":
        return 1;
      case "right":
        return 2;
      case "inline-start":
        return 3;
      case "inline-end":
        return 4;
    }
    return 0;
  }
};
var letterSpacing = {
  name: "letter-spacing",
  initialValue: "0",
  prefix: false,
  type: 0,
  parse: function(_context, token) {
    if (token.type === 20 && token.value === "normal") {
      return 0;
    }
    if (token.type === 17) {
      return token.number;
    }
    if (token.type === 15) {
      return token.number;
    }
    return 0;
  }
};
var LINE_BREAK;
(function(LINE_BREAK2) {
  LINE_BREAK2["NORMAL"] = "normal";
  LINE_BREAK2["STRICT"] = "strict";
})(LINE_BREAK || (LINE_BREAK = {}));
var lineBreak = {
  name: "line-break",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, lineBreak2) {
    switch (lineBreak2) {
      case "strict":
        return LINE_BREAK.STRICT;
      case "normal":
      default:
        return LINE_BREAK.NORMAL;
    }
  }
};
var lineHeight = {
  name: "line-height",
  initialValue: "normal",
  prefix: false,
  type: 4
};
var computeLineHeight = function(token, fontSize2) {
  if (isIdentToken(token) && token.value === "normal") {
    return 1.2 * fontSize2;
  } else if (token.type === 17) {
    return fontSize2 * token.number;
  } else if (isLengthPercentage(token)) {
    return getAbsoluteValue(token, fontSize2);
  }
  return fontSize2;
};
var listStyleImage = {
  name: "list-style-image",
  initialValue: "none",
  type: 0,
  prefix: false,
  parse: function(context, token) {
    if (token.type === 20 && token.value === "none") {
      return null;
    }
    return image.parse(context, token);
  }
};
var listStylePosition = {
  name: "list-style-position",
  initialValue: "outside",
  prefix: false,
  type: 2,
  parse: function(_context, position2) {
    switch (position2) {
      case "inside":
        return 0;
      case "outside":
      default:
        return 1;
    }
  }
};
var listStyleType = {
  name: "list-style-type",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, type) {
    switch (type) {
      case "disc":
        return 0;
      case "circle":
        return 1;
      case "square":
        return 2;
      case "decimal":
        return 3;
      case "cjk-decimal":
        return 4;
      case "decimal-leading-zero":
        return 5;
      case "lower-roman":
        return 6;
      case "upper-roman":
        return 7;
      case "lower-greek":
        return 8;
      case "lower-alpha":
        return 9;
      case "upper-alpha":
        return 10;
      case "arabic-indic":
        return 11;
      case "armenian":
        return 12;
      case "bengali":
        return 13;
      case "cambodian":
        return 14;
      case "cjk-earthly-branch":
        return 15;
      case "cjk-heavenly-stem":
        return 16;
      case "cjk-ideographic":
        return 17;
      case "devanagari":
        return 18;
      case "ethiopic-numeric":
        return 19;
      case "georgian":
        return 20;
      case "gujarati":
        return 21;
      case "gurmukhi":
        return 22;
      case "hebrew":
        return 22;
      case "hiragana":
        return 23;
      case "hiragana-iroha":
        return 24;
      case "japanese-formal":
        return 25;
      case "japanese-informal":
        return 26;
      case "kannada":
        return 27;
      case "katakana":
        return 28;
      case "katakana-iroha":
        return 29;
      case "khmer":
        return 30;
      case "korean-hangul-formal":
        return 31;
      case "korean-hanja-formal":
        return 32;
      case "korean-hanja-informal":
        return 33;
      case "lao":
        return 34;
      case "lower-armenian":
        return 35;
      case "malayalam":
        return 36;
      case "mongolian":
        return 37;
      case "myanmar":
        return 38;
      case "oriya":
        return 39;
      case "persian":
        return 40;
      case "simp-chinese-formal":
        return 41;
      case "simp-chinese-informal":
        return 42;
      case "tamil":
        return 43;
      case "telugu":
        return 44;
      case "thai":
        return 45;
      case "tibetan":
        return 46;
      case "trad-chinese-formal":
        return 47;
      case "trad-chinese-informal":
        return 48;
      case "upper-armenian":
        return 49;
      case "disclosure-open":
        return 50;
      case "disclosure-closed":
        return 51;
      case "none":
      default:
        return -1;
    }
  }
};
var marginForSide = function(side) {
  return {
    name: "margin-" + side,
    initialValue: "0",
    prefix: false,
    type: 4
  };
};
var marginTop = marginForSide("top");
var marginRight = marginForSide("right");
var marginBottom = marginForSide("bottom");
var marginLeft = marginForSide("left");
var overflow = {
  name: "overflow",
  initialValue: "visible",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(overflow2) {
      switch (overflow2.value) {
        case "hidden":
          return 1;
        case "scroll":
          return 2;
        case "clip":
          return 3;
        case "auto":
          return 4;
        case "visible":
        default:
          return 0;
      }
    });
  }
};
var overflowWrap = {
  name: "overflow-wrap",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, overflow2) {
    switch (overflow2) {
      case "break-word":
        return "break-word";
      case "normal":
      default:
        return "normal";
    }
  }
};
var paddingForSide = function(side) {
  return {
    name: "padding-" + side,
    initialValue: "0",
    prefix: false,
    type: 3,
    format: "length-percentage"
  };
};
var paddingTop = paddingForSide("top");
var paddingRight = paddingForSide("right");
var paddingBottom = paddingForSide("bottom");
var paddingLeft = paddingForSide("left");
var textAlign = {
  name: "text-align",
  initialValue: "left",
  prefix: false,
  type: 2,
  parse: function(_context, textAlign2) {
    switch (textAlign2) {
      case "right":
        return 2;
      case "center":
      case "justify":
        return 1;
      case "left":
      default:
        return 0;
    }
  }
};
var position = {
  name: "position",
  initialValue: "static",
  prefix: false,
  type: 2,
  parse: function(_context, position2) {
    switch (position2) {
      case "relative":
        return 1;
      case "absolute":
        return 2;
      case "fixed":
        return 3;
      case "sticky":
        return 4;
    }
    return 0;
  }
};
var textShadow = {
  name: "text-shadow",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens) {
    if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
      return [];
    }
    return parseFunctionArgs(tokens).map(function(values) {
      var shadow = {
        color: COLORS.TRANSPARENT,
        offsetX: ZERO_LENGTH,
        offsetY: ZERO_LENGTH,
        blur: ZERO_LENGTH
      };
      var c = 0;
      for (var i = 0; i < values.length; i++) {
        var token = values[i];
        if (isLength(token)) {
          if (c === 0) {
            shadow.offsetX = token;
          } else if (c === 1) {
            shadow.offsetY = token;
          } else {
            shadow.blur = token;
          }
          c++;
        } else {
          shadow.color = color$1.parse(context, token);
        }
      }
      return shadow;
    });
  }
};
var textTransform = {
  name: "text-transform",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, textTransform2) {
    switch (textTransform2) {
      case "uppercase":
        return 2;
      case "lowercase":
        return 1;
      case "capitalize":
        return 3;
    }
    return 0;
  }
};
var transform$1 = {
  name: "transform",
  initialValue: "none",
  prefix: true,
  type: 0,
  parse: function(_context, token) {
    if (token.type === 20 && token.value === "none") {
      return null;
    }
    if (token.type === 18) {
      var transformFunction = SUPPORTED_TRANSFORM_FUNCTIONS[token.name];
      if (typeof transformFunction === "undefined") {
        throw new Error('Attempting to parse an unsupported transform function "' + token.name + '"');
      }
      return transformFunction(token.values);
    }
    return null;
  }
};
var matrix$1 = function(args) {
  var values = args.filter(function(arg) {
    return arg.type === 17;
  }).map(function(arg) {
    return arg.number;
  });
  return values.length === 6 ? values : null;
};
var matrix3d = function(args) {
  var values = args.filter(function(arg) {
    return arg.type === 17;
  }).map(function(arg) {
    return arg.number;
  });
  var a1 = values[0], b1 = values[1];
  values[2];
  values[3];
  var a2 = values[4], b2 = values[5];
  values[6];
  values[7];
  values[8];
  values[9];
  values[10];
  values[11];
  var a4 = values[12], b4 = values[13];
  values[14];
  values[15];
  return values.length === 16 ? [a1, b1, a2, b2, a4, b4] : null;
};
var SUPPORTED_TRANSFORM_FUNCTIONS = {
  matrix: matrix$1,
  matrix3d
};
var DEFAULT_VALUE = {
  type: 16,
  number: 50,
  flags: FLAG_INTEGER
};
var DEFAULT = [DEFAULT_VALUE, DEFAULT_VALUE];
var transformOrigin = {
  name: "transform-origin",
  initialValue: "50% 50%",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    var origins = tokens.filter(isLengthPercentage);
    if (origins.length !== 2) {
      return DEFAULT;
    }
    return [origins[0], origins[1]];
  }
};
var visibility = {
  name: "visible",
  initialValue: "none",
  prefix: false,
  type: 2,
  parse: function(_context, visibility2) {
    switch (visibility2) {
      case "hidden":
        return 1;
      case "collapse":
        return 2;
      case "visible":
      default:
        return 0;
    }
  }
};
var WORD_BREAK;
(function(WORD_BREAK2) {
  WORD_BREAK2["NORMAL"] = "normal";
  WORD_BREAK2["BREAK_ALL"] = "break-all";
  WORD_BREAK2["KEEP_ALL"] = "keep-all";
})(WORD_BREAK || (WORD_BREAK = {}));
var wordBreak = {
  name: "word-break",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, wordBreak2) {
    switch (wordBreak2) {
      case "break-all":
        return WORD_BREAK.BREAK_ALL;
      case "keep-all":
        return WORD_BREAK.KEEP_ALL;
      case "normal":
      default:
        return WORD_BREAK.NORMAL;
    }
  }
};
var zIndex = {
  name: "z-index",
  initialValue: "auto",
  prefix: false,
  type: 0,
  parse: function(_context, token) {
    if (token.type === 20) {
      return { auto: true, order: 0 };
    }
    if (isNumberToken(token)) {
      return { auto: false, order: token.number };
    }
    throw new Error("Invalid z-index number parsed");
  }
};
var time = {
  name: "time",
  parse: function(_context, value) {
    if (value.type === 15) {
      switch (value.unit.toLowerCase()) {
        case "s":
          return 1e3 * value.number;
        case "ms":
          return value.number;
      }
    }
    throw new Error("Unsupported time type");
  }
};
var opacity = {
  name: "opacity",
  initialValue: "1",
  type: 0,
  prefix: false,
  parse: function(_context, token) {
    if (isNumberToken(token)) {
      return token.number;
    }
    return 1;
  }
};
var textDecorationColor = {
  name: "text-decoration-color",
  initialValue: "transparent",
  prefix: false,
  type: 3,
  format: "color"
};
var textDecorationLine = {
  name: "text-decoration-line",
  initialValue: "none",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(token) {
      switch (token.value) {
        case "underline":
          return 1;
        case "overline":
          return 2;
        case "line-through":
          return 3;
        case "none":
          return 4;
      }
      return 0;
    }).filter(function(line) {
      return line !== 0;
    });
  }
};
var fontFamily = {
  name: "font-family",
  initialValue: "",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    var accumulator = [];
    var results = [];
    tokens.forEach(function(token) {
      switch (token.type) {
        case 20:
        case 0:
          accumulator.push(token.value);
          break;
        case 17:
          accumulator.push(token.number.toString());
          break;
        case 4:
          results.push(accumulator.join(" "));
          accumulator.length = 0;
          break;
      }
    });
    if (accumulator.length) {
      results.push(accumulator.join(" "));
    }
    return results.map(function(result) {
      return result.indexOf(" ") === -1 ? result : "'" + result + "'";
    });
  }
};
var fontSize = {
  name: "font-size",
  initialValue: "0",
  prefix: false,
  type: 3,
  format: "length"
};
var fontWeight = {
  name: "font-weight",
  initialValue: "normal",
  type: 0,
  prefix: false,
  parse: function(_context, token) {
    if (isNumberToken(token)) {
      return token.number;
    }
    if (isIdentToken(token)) {
      switch (token.value) {
        case "bold":
          return 700;
        case "normal":
        default:
          return 400;
      }
    }
    return 400;
  }
};
var fontVariant = {
  name: "font-variant",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    return tokens.filter(isIdentToken).map(function(token) {
      return token.value;
    });
  }
};
var fontStyle = {
  name: "font-style",
  initialValue: "normal",
  prefix: false,
  type: 2,
  parse: function(_context, overflow2) {
    switch (overflow2) {
      case "oblique":
        return "oblique";
      case "italic":
        return "italic";
      case "normal":
      default:
        return "normal";
    }
  }
};
var contains = function(bit, value) {
  return (bit & value) !== 0;
};
var content = {
  name: "content",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return [];
    }
    return tokens;
  }
};
var counterIncrement = {
  name: "counter-increment",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return null;
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return null;
    }
    var increments = [];
    var filtered = tokens.filter(nonWhiteSpace);
    for (var i = 0; i < filtered.length; i++) {
      var counter = filtered[i];
      var next = filtered[i + 1];
      if (counter.type === 20) {
        var increment = next && isNumberToken(next) ? next.number : 1;
        increments.push({ counter: counter.value, increment });
      }
    }
    return increments;
  }
};
var counterReset = {
  name: "counter-reset",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return [];
    }
    var resets = [];
    var filtered = tokens.filter(nonWhiteSpace);
    for (var i = 0; i < filtered.length; i++) {
      var counter = filtered[i];
      var next = filtered[i + 1];
      if (isIdentToken(counter) && counter.value !== "none") {
        var reset = next && isNumberToken(next) ? next.number : 0;
        resets.push({ counter: counter.value, reset });
      }
    }
    return resets;
  }
};
var duration = {
  name: "duration",
  initialValue: "0s",
  prefix: false,
  type: 1,
  parse: function(context, tokens) {
    return tokens.filter(isDimensionToken).map(function(token) {
      return time.parse(context, token);
    });
  }
};
var quotes = {
  name: "quotes",
  initialValue: "none",
  prefix: true,
  type: 1,
  parse: function(_context, tokens) {
    if (tokens.length === 0) {
      return null;
    }
    var first = tokens[0];
    if (first.type === 20 && first.value === "none") {
      return null;
    }
    var quotes2 = [];
    var filtered = tokens.filter(isStringToken);
    if (filtered.length % 2 !== 0) {
      return null;
    }
    for (var i = 0; i < filtered.length; i += 2) {
      var open_1 = filtered[i].value;
      var close_1 = filtered[i + 1].value;
      quotes2.push({ open: open_1, close: close_1 });
    }
    return quotes2;
  }
};
var getQuote = function(quotes2, depth, open) {
  if (!quotes2) {
    return "";
  }
  var quote = quotes2[Math.min(depth, quotes2.length - 1)];
  if (!quote) {
    return "";
  }
  return open ? quote.open : quote.close;
};
var boxShadow = {
  name: "box-shadow",
  initialValue: "none",
  type: 1,
  prefix: false,
  parse: function(context, tokens) {
    if (tokens.length === 1 && isIdentWithValue(tokens[0], "none")) {
      return [];
    }
    return parseFunctionArgs(tokens).map(function(values) {
      var shadow = {
        color: 255,
        offsetX: ZERO_LENGTH,
        offsetY: ZERO_LENGTH,
        blur: ZERO_LENGTH,
        spread: ZERO_LENGTH,
        inset: false
      };
      var c = 0;
      for (var i = 0; i < values.length; i++) {
        var token = values[i];
        if (isIdentWithValue(token, "inset")) {
          shadow.inset = true;
        } else if (isLength(token)) {
          if (c === 0) {
            shadow.offsetX = token;
          } else if (c === 1) {
            shadow.offsetY = token;
          } else if (c === 2) {
            shadow.blur = token;
          } else {
            shadow.spread = token;
          }
          c++;
        } else {
          shadow.color = color$1.parse(context, token);
        }
      }
      return shadow;
    });
  }
};
var paintOrder = {
  name: "paint-order",
  initialValue: "normal",
  prefix: false,
  type: 1,
  parse: function(_context, tokens) {
    var DEFAULT_VALUE2 = [0, 1, 2];
    var layers = [];
    tokens.filter(isIdentToken).forEach(function(token) {
      switch (token.value) {
        case "stroke":
          layers.push(1);
          break;
        case "fill":
          layers.push(0);
          break;
        case "markers":
          layers.push(2);
          break;
      }
    });
    DEFAULT_VALUE2.forEach(function(value) {
      if (layers.indexOf(value) === -1) {
        layers.push(value);
      }
    });
    return layers;
  }
};
var webkitTextStrokeColor = {
  name: "-webkit-text-stroke-color",
  initialValue: "currentcolor",
  prefix: false,
  type: 3,
  format: "color"
};
var webkitTextStrokeWidth = {
  name: "-webkit-text-stroke-width",
  initialValue: "0",
  type: 0,
  prefix: false,
  parse: function(_context, token) {
    if (isDimensionToken(token)) {
      return token.number;
    }
    return 0;
  }
};
var CSSParsedDeclaration = function() {
  function CSSParsedDeclaration2(context, declaration) {
    var _a2, _b;
    this.animationDuration = parse(context, duration, declaration.animationDuration);
    this.backgroundClip = parse(context, backgroundClip, declaration.backgroundClip);
    this.backgroundColor = parse(context, backgroundColor, declaration.backgroundColor);
    this.backgroundImage = parse(context, backgroundImage, declaration.backgroundImage);
    this.backgroundOrigin = parse(context, backgroundOrigin, declaration.backgroundOrigin);
    this.backgroundPosition = parse(context, backgroundPosition, declaration.backgroundPosition);
    this.backgroundRepeat = parse(context, backgroundRepeat, declaration.backgroundRepeat);
    this.backgroundSize = parse(context, backgroundSize, declaration.backgroundSize);
    this.borderTopColor = parse(context, borderTopColor, declaration.borderTopColor);
    this.borderRightColor = parse(context, borderRightColor, declaration.borderRightColor);
    this.borderBottomColor = parse(context, borderBottomColor, declaration.borderBottomColor);
    this.borderLeftColor = parse(context, borderLeftColor, declaration.borderLeftColor);
    this.borderTopLeftRadius = parse(context, borderTopLeftRadius, declaration.borderTopLeftRadius);
    this.borderTopRightRadius = parse(context, borderTopRightRadius, declaration.borderTopRightRadius);
    this.borderBottomRightRadius = parse(context, borderBottomRightRadius, declaration.borderBottomRightRadius);
    this.borderBottomLeftRadius = parse(context, borderBottomLeftRadius, declaration.borderBottomLeftRadius);
    this.borderTopStyle = parse(context, borderTopStyle, declaration.borderTopStyle);
    this.borderRightStyle = parse(context, borderRightStyle, declaration.borderRightStyle);
    this.borderBottomStyle = parse(context, borderBottomStyle, declaration.borderBottomStyle);
    this.borderLeftStyle = parse(context, borderLeftStyle, declaration.borderLeftStyle);
    this.borderTopWidth = parse(context, borderTopWidth, declaration.borderTopWidth);
    this.borderRightWidth = parse(context, borderRightWidth, declaration.borderRightWidth);
    this.borderBottomWidth = parse(context, borderBottomWidth, declaration.borderBottomWidth);
    this.borderLeftWidth = parse(context, borderLeftWidth, declaration.borderLeftWidth);
    this.boxShadow = parse(context, boxShadow, declaration.boxShadow);
    this.color = parse(context, color, declaration.color);
    this.direction = parse(context, direction, declaration.direction);
    this.display = parse(context, display, declaration.display);
    this.float = parse(context, float, declaration.cssFloat);
    this.fontFamily = parse(context, fontFamily, declaration.fontFamily);
    this.fontSize = parse(context, fontSize, declaration.fontSize);
    this.fontStyle = parse(context, fontStyle, declaration.fontStyle);
    this.fontVariant = parse(context, fontVariant, declaration.fontVariant);
    this.fontWeight = parse(context, fontWeight, declaration.fontWeight);
    this.letterSpacing = parse(context, letterSpacing, declaration.letterSpacing);
    this.lineBreak = parse(context, lineBreak, declaration.lineBreak);
    this.lineHeight = parse(context, lineHeight, declaration.lineHeight);
    this.listStyleImage = parse(context, listStyleImage, declaration.listStyleImage);
    this.listStylePosition = parse(context, listStylePosition, declaration.listStylePosition);
    this.listStyleType = parse(context, listStyleType, declaration.listStyleType);
    this.marginTop = parse(context, marginTop, declaration.marginTop);
    this.marginRight = parse(context, marginRight, declaration.marginRight);
    this.marginBottom = parse(context, marginBottom, declaration.marginBottom);
    this.marginLeft = parse(context, marginLeft, declaration.marginLeft);
    this.opacity = parse(context, opacity, declaration.opacity);
    var overflowTuple = parse(context, overflow, declaration.overflow);
    this.overflowX = overflowTuple[0];
    this.overflowY = overflowTuple[overflowTuple.length > 1 ? 1 : 0];
    this.overflowWrap = parse(context, overflowWrap, declaration.overflowWrap);
    this.paddingTop = parse(context, paddingTop, declaration.paddingTop);
    this.paddingRight = parse(context, paddingRight, declaration.paddingRight);
    this.paddingBottom = parse(context, paddingBottom, declaration.paddingBottom);
    this.paddingLeft = parse(context, paddingLeft, declaration.paddingLeft);
    this.paintOrder = parse(context, paintOrder, declaration.paintOrder);
    this.position = parse(context, position, declaration.position);
    this.textAlign = parse(context, textAlign, declaration.textAlign);
    this.textDecorationColor = parse(context, textDecorationColor, (_a2 = declaration.textDecorationColor) !== null && _a2 !== void 0 ? _a2 : declaration.color);
    this.textDecorationLine = parse(context, textDecorationLine, (_b = declaration.textDecorationLine) !== null && _b !== void 0 ? _b : declaration.textDecoration);
    this.textShadow = parse(context, textShadow, declaration.textShadow);
    this.textTransform = parse(context, textTransform, declaration.textTransform);
    this.transform = parse(context, transform$1, declaration.transform);
    this.transformOrigin = parse(context, transformOrigin, declaration.transformOrigin);
    this.visibility = parse(context, visibility, declaration.visibility);
    this.webkitTextStrokeColor = parse(context, webkitTextStrokeColor, declaration.webkitTextStrokeColor);
    this.webkitTextStrokeWidth = parse(context, webkitTextStrokeWidth, declaration.webkitTextStrokeWidth);
    this.wordBreak = parse(context, wordBreak, declaration.wordBreak);
    this.zIndex = parse(context, zIndex, declaration.zIndex);
  }
  CSSParsedDeclaration2.prototype.isVisible = function() {
    return this.display > 0 && this.opacity > 0 && this.visibility === 0;
  };
  CSSParsedDeclaration2.prototype.isTransparent = function() {
    return isTransparent(this.backgroundColor);
  };
  CSSParsedDeclaration2.prototype.isTransformed = function() {
    return this.transform !== null;
  };
  CSSParsedDeclaration2.prototype.isPositioned = function() {
    return this.position !== 0;
  };
  CSSParsedDeclaration2.prototype.isPositionedWithZIndex = function() {
    return this.isPositioned() && !this.zIndex.auto;
  };
  CSSParsedDeclaration2.prototype.isFloating = function() {
    return this.float !== 0;
  };
  CSSParsedDeclaration2.prototype.isInlineLevel = function() {
    return contains(this.display, 4) || contains(this.display, 33554432) || contains(this.display, 268435456) || contains(this.display, 536870912) || contains(this.display, 67108864) || contains(this.display, 134217728);
  };
  return CSSParsedDeclaration2;
}();
var CSSParsedPseudoDeclaration = function() {
  function CSSParsedPseudoDeclaration2(context, declaration) {
    this.content = parse(context, content, declaration.content);
    this.quotes = parse(context, quotes, declaration.quotes);
  }
  return CSSParsedPseudoDeclaration2;
}();
var CSSParsedCounterDeclaration = function() {
  function CSSParsedCounterDeclaration2(context, declaration) {
    this.counterIncrement = parse(context, counterIncrement, declaration.counterIncrement);
    this.counterReset = parse(context, counterReset, declaration.counterReset);
  }
  return CSSParsedCounterDeclaration2;
}();
var parse = function(context, descriptor, style) {
  var tokenizer = new Tokenizer();
  var value = style !== null && typeof style !== "undefined" ? style.toString() : descriptor.initialValue;
  tokenizer.write(value);
  var parser = new Parser(tokenizer.read());
  switch (descriptor.type) {
    case 2:
      var token = parser.parseComponentValue();
      return descriptor.parse(context, isIdentToken(token) ? token.value : descriptor.initialValue);
    case 0:
      return descriptor.parse(context, parser.parseComponentValue());
    case 1:
      return descriptor.parse(context, parser.parseComponentValues());
    case 4:
      return parser.parseComponentValue();
    case 3:
      switch (descriptor.format) {
        case "angle":
          return angle.parse(context, parser.parseComponentValue());
        case "color":
          return color$1.parse(context, parser.parseComponentValue());
        case "image":
          return image.parse(context, parser.parseComponentValue());
        case "length":
          var length_1 = parser.parseComponentValue();
          return isLength(length_1) ? length_1 : ZERO_LENGTH;
        case "length-percentage":
          var value_1 = parser.parseComponentValue();
          return isLengthPercentage(value_1) ? value_1 : ZERO_LENGTH;
        case "time":
          return time.parse(context, parser.parseComponentValue());
      }
      break;
  }
};
var elementDebuggerAttribute = "data-html2canvas-debug";
var getElementDebugType = function(element) {
  var attribute = element.getAttribute(elementDebuggerAttribute);
  switch (attribute) {
    case "all":
      return 1;
    case "clone":
      return 2;
    case "parse":
      return 3;
    case "render":
      return 4;
    default:
      return 0;
  }
};
var isDebugging = function(element, type) {
  var elementType = getElementDebugType(element);
  return elementType === 1 || type === elementType;
};
var ElementContainer = function() {
  function ElementContainer2(context, element) {
    this.context = context;
    this.textNodes = [];
    this.elements = [];
    this.flags = 0;
    if (isDebugging(element, 3)) {
      debugger;
    }
    this.styles = new CSSParsedDeclaration(context, window.getComputedStyle(element, null));
    if (isHTMLElementNode(element)) {
      if (this.styles.animationDuration.some(function(duration2) {
        return duration2 > 0;
      })) {
        element.style.animationDuration = "0s";
      }
      if (this.styles.transform !== null) {
        element.style.transform = "none";
      }
    }
    this.bounds = parseBounds(this.context, element);
    if (isDebugging(element, 4)) {
      this.flags |= 16;
    }
  }
  return ElementContainer2;
}();
var base64 = "AAAAAAAAAAAAEA4AGBkAAFAaAAACAAAAAAAIABAAGAAwADgACAAQAAgAEAAIABAACAAQAAgAEAAIABAACAAQAAgAEAAIABAAQABIAEQATAAIABAACAAQAAgAEAAIABAAVABcAAgAEAAIABAACAAQAGAAaABwAHgAgACIAI4AlgAIABAAmwCjAKgAsAC2AL4AvQDFAMoA0gBPAVYBWgEIAAgACACMANoAYgFkAWwBdAF8AX0BhQGNAZUBlgGeAaMBlQGWAasBswF8AbsBwwF0AcsBYwHTAQgA2wG/AOMBdAF8AekB8QF0AfkB+wHiAHQBfAEIAAMC5gQIAAsCEgIIAAgAFgIeAggAIgIpAggAMQI5AkACygEIAAgASAJQAlgCYAIIAAgACAAKBQoFCgUTBRMFGQUrBSsFCAAIAAgACAAIAAgACAAIAAgACABdAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABoAmgCrwGvAQgAbgJ2AggAHgEIAAgACADnAXsCCAAIAAgAgwIIAAgACAAIAAgACACKAggAkQKZAggAPADJAAgAoQKkAqwCsgK6AsICCADJAggA0AIIAAgACAAIANYC3gIIAAgACAAIAAgACABAAOYCCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAkASoB+QIEAAgACAA8AEMCCABCBQgACABJBVAFCAAIAAgACAAIAAgACAAIAAgACABTBVoFCAAIAFoFCABfBWUFCAAIAAgACAAIAAgAbQUIAAgACAAIAAgACABzBXsFfQWFBYoFigWKBZEFigWKBYoFmAWfBaYFrgWxBbkFCAAIAAgACAAIAAgACAAIAAgACAAIAMEFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAMgFCADQBQgACAAIAAgACAAIAAgACAAIAAgACAAIAO4CCAAIAAgAiQAIAAgACABAAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAD0AggACAD8AggACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIANYFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAMDvwAIAAgAJAIIAAgACAAIAAgACAAIAAgACwMTAwgACAB9BOsEGwMjAwgAKwMyAwsFYgE3A/MEPwMIAEUDTQNRAwgAWQOsAGEDCAAIAAgACAAIAAgACABpAzQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFOgU0BTUFNgU3BTgFOQU6BTQFNQU2BTcFOAU5BToFNAU1BTYFNwU4BTkFIQUoBSwFCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABtAwgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABMAEwACAAIAAgACAAIABgACAAIAAgACAC/AAgACAAyAQgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACAAIAAwAAgACAAIAAgACAAIAAgACAAIAAAARABIAAgACAAIABQASAAIAAgAIABwAEAAjgCIABsAqAC2AL0AigDQAtwC+IJIQqVAZUBWQqVAZUBlQGVAZUBlQGrC5UBlQGVAZUBlQGVAZUBlQGVAXsKlQGVAbAK6wsrDGUMpQzlDJUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAZUBlQGVAfAKAAuZA64AtwCJALoC6ADwAAgAuACgA/oEpgO6AqsD+AAIAAgAswMIAAgACAAIAIkAuwP5AfsBwwPLAwgACAAIAAgACADRA9kDCAAIAOED6QMIAAgACAAIAAgACADuA/YDCAAIAP4DyQAIAAgABgQIAAgAXQAOBAgACAAIAAgACAAIABMECAAIAAgACAAIAAgACAD8AAQBCAAIAAgAGgQiBCoECAExBAgAEAEIAAgACAAIAAgACAAIAAgACAAIAAgACAA4BAgACABABEYECAAIAAgATAQYAQgAVAQIAAgACAAIAAgACAAIAAgACAAIAFoECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAOQEIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAB+BAcACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAEABhgSMBAgACAAIAAgAlAQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAwAEAAQABAADAAMAAwADAAQABAAEAAQABAAEAAQABHATAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAdQMIAAgACAAIAAgACAAIAMkACAAIAAgAfQMIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACACFA4kDCAAIAAgACAAIAOcBCAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAIcDCAAIAAgACAAIAAgACAAIAAgACAAIAJEDCAAIAAgACADFAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABgBAgAZgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAbAQCBXIECAAIAHkECAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACABAAJwEQACjBKoEsgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAC6BMIECAAIAAgACAAIAAgACABmBAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAxwQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAGYECAAIAAgAzgQIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBd0FXwUIAOIF6gXxBYoF3gT5BQAGCAaKBYoFigWKBYoFigWKBYoFigWKBYoFigXWBIoFigWKBYoFigWKBYoFigWKBYsFEAaKBYoFigWKBYoFigWKBRQGCACKBYoFigWKBQgACAAIANEECAAIABgGigUgBggAJgYIAC4GMwaKBYoF0wQ3Bj4GigWKBYoFigWKBYoFigWKBYoFigWKBYoFigUIAAgACAAIAAgACAAIAAgAigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWKBYoFigWLBf///////wQABAAEAAQABAAEAAQABAAEAAQAAwAEAAQAAgAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAQADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUAAAAFAAUAAAAFAAUAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUAAQAAAAUABQAFAAUABQAFAAAAAAAFAAUAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAFAAUAAQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAAABwAHAAcAAAAHAAcABwAFAAEAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAcABwAFAAUAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAAAAQABAAAAAAAAAAAAAAAFAAUABQAFAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAHAAcAAAAHAAcAAAAAAAUABQAHAAUAAQAHAAEABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwABAAUABQAFAAUAAAAAAAAAAAAAAAEAAQABAAEAAQABAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABQANAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAQABAAEAAQABAAEAAQABAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAABQAHAAUABQAFAAAAAAAAAAcABQAFAAUABQAFAAQABAAEAAQABAAEAAQABAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUAAAAFAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAUAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAcABwAFAAcABwAAAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUABwAHAAUABQAFAAUAAAAAAAcABwAAAAAABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAABQAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAAAAAAAAAAABQAFAAAAAAAFAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAFAAUABQAFAAUAAAAFAAUABwAAAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABwAFAAUABQAFAAAAAAAHAAcAAAAAAAcABwAFAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAAAAAAAAAHAAcABwAAAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAABQAHAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAUABQAFAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAHAAcABQAHAAcAAAAFAAcABwAAAAcABwAFAAUAAAAAAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAFAAcABwAFAAUABQAAAAUAAAAHAAcABwAHAAcABwAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAHAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAABwAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAUAAAAFAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABwAFAAUABQAFAAUAAAAFAAUAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABwAFAAUABQAFAAUABQAAAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABQAFAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABQAFAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAHAAUABQAFAAUABQAFAAUABwAHAAcABwAHAAcABwAHAAUABwAHAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABwAHAAcABwAFAAUABwAHAAcAAAAAAAAAAAAHAAcABQAHAAcABwAHAAcABwAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAcABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAUABQAFAAUABQAFAAUAAAAFAAAABQAAAAAABQAFAAUABQAFAAUABQAFAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAFAAUAAAAAAAUABQAFAAUABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABwAFAAcABwAHAAcABwAFAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAUABQAFAAUABwAHAAUABQAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABQAFAAcABwAHAAUABwAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAcABQAFAAUABQAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAAAAAABwAFAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAAAAAAAAAFAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAUABQAHAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAUABQAFAAUABQAHAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAcABwAFAAUABQAFAAcABwAFAAUABwAHAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAFAAcABwAFAAUABwAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAFAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAFAAUABQAAAAAABQAFAAAAAAAAAAAAAAAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAcABwAAAAAAAAAAAAAABwAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAcABwAFAAcABwAAAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAFAAUABQAAAAUABQAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABwAFAAUABQAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAUABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAHAAcABQAHAAUABQAAAAAAAAAAAAAAAAAFAAAABwAHAAcABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAHAAcABwAAAAAABwAHAAAAAAAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABwAHAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAFAAUABwAFAAcABwAFAAcABQAFAAcABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAHAAcABQAFAAUABQAAAAAABwAHAAcABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAHAAUABQAFAAUABQAFAAUABQAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABwAFAAcABwAFAAUABQAFAAUABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAcABwAFAAUABQAFAAcABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAUABQAFAAUABQAHAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAFAAUABQAFAAAAAAAFAAUABwAHAAcABwAFAAAAAAAAAAcAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABwAHAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAcABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUAAAAHAAUABQAFAAUABQAFAAUABwAFAAUABwAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUAAAAAAAAABQAAAAUABQAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAHAAcABwAHAAcAAAAFAAUAAAAHAAcABQAHAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAAAAUABQAFAAAAAAAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAFAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAFAAUABQAAAAAABQAFAAUABQAFAAUABQAAAAUABQAAAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAUABQAFAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABQAFAAUABQAFAAUABQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAFAAUABQAFAAUADgAOAA4ADgAOAA4ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAA8ADwAPAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAcABwAHAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAgACAAIAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAMAAwADAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAAAAAAAAAAAAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAKAAoACgAAAAAAAAAAAAsADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwACwAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAMAAwADAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAADgAOAA4AAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAAAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4AAAAOAAAAAAAAAAAAAAAAAA4AAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAAAAAAAAAAAA4AAAAOAAAAAAAAAAAADgAOAA4AAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAA4AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4AAAAAAA4ADgAOAA4ADgAOAA4ADgAOAAAADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4ADgAOAAAAAAAAAAAAAAAAAAAAAAAAAAAADgAOAA4ADgAOAA4AAAAAAAAAAAAAAAAAAAAAAA4ADgAOAA4ADgAOAA4ADgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAOAA4ADgAOAA4ADgAAAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4ADgAOAA4AAAAAAAAAAAA=";
var chars$1 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup$1 = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i$1 = 0; i$1 < chars$1.length; i$1++) {
  lookup$1[chars$1.charCodeAt(i$1)] = i$1;
}
var decode = function(base642) {
  var bufferLength = base642.length * 0.75, len = base642.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
  if (base642[base642.length - 1] === "=") {
    bufferLength--;
    if (base642[base642.length - 2] === "=") {
      bufferLength--;
    }
  }
  var buffer = typeof ArrayBuffer !== "undefined" && typeof Uint8Array !== "undefined" && typeof Uint8Array.prototype.slice !== "undefined" ? new ArrayBuffer(bufferLength) : new Array(bufferLength);
  var bytes = Array.isArray(buffer) ? buffer : new Uint8Array(buffer);
  for (i = 0; i < len; i += 4) {
    encoded1 = lookup$1[base642.charCodeAt(i)];
    encoded2 = lookup$1[base642.charCodeAt(i + 1)];
    encoded3 = lookup$1[base642.charCodeAt(i + 2)];
    encoded4 = lookup$1[base642.charCodeAt(i + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }
  return buffer;
};
var polyUint16Array = function(buffer) {
  var length = buffer.length;
  var bytes = [];
  for (var i = 0; i < length; i += 2) {
    bytes.push(buffer[i + 1] << 8 | buffer[i]);
  }
  return bytes;
};
var polyUint32Array = function(buffer) {
  var length = buffer.length;
  var bytes = [];
  for (var i = 0; i < length; i += 4) {
    bytes.push(buffer[i + 3] << 24 | buffer[i + 2] << 16 | buffer[i + 1] << 8 | buffer[i]);
  }
  return bytes;
};
var UTRIE2_SHIFT_2 = 5;
var UTRIE2_SHIFT_1 = 6 + 5;
var UTRIE2_INDEX_SHIFT = 2;
var UTRIE2_SHIFT_1_2 = UTRIE2_SHIFT_1 - UTRIE2_SHIFT_2;
var UTRIE2_LSCP_INDEX_2_OFFSET = 65536 >> UTRIE2_SHIFT_2;
var UTRIE2_DATA_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_2;
var UTRIE2_DATA_MASK = UTRIE2_DATA_BLOCK_LENGTH - 1;
var UTRIE2_LSCP_INDEX_2_LENGTH = 1024 >> UTRIE2_SHIFT_2;
var UTRIE2_INDEX_2_BMP_LENGTH = UTRIE2_LSCP_INDEX_2_OFFSET + UTRIE2_LSCP_INDEX_2_LENGTH;
var UTRIE2_UTF8_2B_INDEX_2_OFFSET = UTRIE2_INDEX_2_BMP_LENGTH;
var UTRIE2_UTF8_2B_INDEX_2_LENGTH = 2048 >> 6;
var UTRIE2_INDEX_1_OFFSET = UTRIE2_UTF8_2B_INDEX_2_OFFSET + UTRIE2_UTF8_2B_INDEX_2_LENGTH;
var UTRIE2_OMITTED_BMP_INDEX_1_LENGTH = 65536 >> UTRIE2_SHIFT_1;
var UTRIE2_INDEX_2_BLOCK_LENGTH = 1 << UTRIE2_SHIFT_1_2;
var UTRIE2_INDEX_2_MASK = UTRIE2_INDEX_2_BLOCK_LENGTH - 1;
var slice16 = function(view, start, end) {
  if (view.slice) {
    return view.slice(start, end);
  }
  return new Uint16Array(Array.prototype.slice.call(view, start, end));
};
var slice32 = function(view, start, end) {
  if (view.slice) {
    return view.slice(start, end);
  }
  return new Uint32Array(Array.prototype.slice.call(view, start, end));
};
var createTrieFromBase64 = function(base642, _byteLength) {
  var buffer = decode(base642);
  var view32 = Array.isArray(buffer) ? polyUint32Array(buffer) : new Uint32Array(buffer);
  var view16 = Array.isArray(buffer) ? polyUint16Array(buffer) : new Uint16Array(buffer);
  var headerLength = 24;
  var index2 = slice16(view16, headerLength / 2, view32[4] / 2);
  var data = view32[5] === 2 ? slice16(view16, (headerLength + view32[4]) / 2) : slice32(view32, Math.ceil((headerLength + view32[4]) / 4));
  return new Trie(view32[0], view32[1], view32[2], view32[3], index2, data);
};
var Trie = function() {
  function Trie2(initialValue, errorValue, highStart, highValueIndex, index2, data) {
    this.initialValue = initialValue;
    this.errorValue = errorValue;
    this.highStart = highStart;
    this.highValueIndex = highValueIndex;
    this.index = index2;
    this.data = data;
  }
  Trie2.prototype.get = function(codePoint) {
    var ix;
    if (codePoint >= 0) {
      if (codePoint < 55296 || codePoint > 56319 && codePoint <= 65535) {
        ix = this.index[codePoint >> UTRIE2_SHIFT_2];
        ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
        return this.data[ix];
      }
      if (codePoint <= 65535) {
        ix = this.index[UTRIE2_LSCP_INDEX_2_OFFSET + (codePoint - 55296 >> UTRIE2_SHIFT_2)];
        ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
        return this.data[ix];
      }
      if (codePoint < this.highStart) {
        ix = UTRIE2_INDEX_1_OFFSET - UTRIE2_OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> UTRIE2_SHIFT_1);
        ix = this.index[ix];
        ix += codePoint >> UTRIE2_SHIFT_2 & UTRIE2_INDEX_2_MASK;
        ix = this.index[ix];
        ix = (ix << UTRIE2_INDEX_SHIFT) + (codePoint & UTRIE2_DATA_MASK);
        return this.data[ix];
      }
      if (codePoint <= 1114111) {
        return this.data[this.highValueIndex];
      }
    }
    return this.errorValue;
  };
  return Trie2;
}();
var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var lookup = typeof Uint8Array === "undefined" ? [] : new Uint8Array(256);
for (var i = 0; i < chars.length; i++) {
  lookup[chars.charCodeAt(i)] = i;
}
var Prepend = 1;
var CR = 2;
var LF = 3;
var Control = 4;
var Extend = 5;
var SpacingMark = 7;
var L$1 = 8;
var V$1 = 9;
var T$1 = 10;
var LV = 11;
var LVT = 12;
var ZWJ = 13;
var Extended_Pictographic = 14;
var RI = 15;
var toCodePoints = function(str) {
  var codePoints = [];
  var i = 0;
  var length = str.length;
  while (i < length) {
    var value = str.charCodeAt(i++);
    if (value >= 55296 && value <= 56319 && i < length) {
      var extra = str.charCodeAt(i++);
      if ((extra & 64512) === 56320) {
        codePoints.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        codePoints.push(value);
        i--;
      }
    } else {
      codePoints.push(value);
    }
  }
  return codePoints;
};
var fromCodePoint = function() {
  var codePoints = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    codePoints[_i] = arguments[_i];
  }
  if (String.fromCodePoint) {
    return String.fromCodePoint.apply(String, codePoints);
  }
  var length = codePoints.length;
  if (!length) {
    return "";
  }
  var codeUnits = [];
  var index2 = -1;
  var result = "";
  while (++index2 < length) {
    var codePoint = codePoints[index2];
    if (codePoint <= 65535) {
      codeUnits.push(codePoint);
    } else {
      codePoint -= 65536;
      codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
    }
    if (index2 + 1 === length || codeUnits.length > 16384) {
      result += String.fromCharCode.apply(String, codeUnits);
      codeUnits.length = 0;
    }
  }
  return result;
};
var UnicodeTrie = createTrieFromBase64(base64);
var BREAK_NOT_ALLOWED = "\xD7";
var BREAK_ALLOWED = "\xF7";
var codePointToClass = function(codePoint) {
  return UnicodeTrie.get(codePoint);
};
var _graphemeBreakAtIndex = function(_codePoints, classTypes, index2) {
  var prevIndex = index2 - 2;
  var prev = classTypes[prevIndex];
  var current = classTypes[index2 - 1];
  var next = classTypes[index2];
  if (current === CR && next === LF) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === CR || current === LF || current === Control) {
    return BREAK_ALLOWED;
  }
  if (next === CR || next === LF || next === Control) {
    return BREAK_ALLOWED;
  }
  if (current === L$1 && [L$1, V$1, LV, LVT].indexOf(next) !== -1) {
    return BREAK_NOT_ALLOWED;
  }
  if ((current === LV || current === V$1) && (next === V$1 || next === T$1)) {
    return BREAK_NOT_ALLOWED;
  }
  if ((current === LVT || current === T$1) && next === T$1) {
    return BREAK_NOT_ALLOWED;
  }
  if (next === ZWJ || next === Extend) {
    return BREAK_NOT_ALLOWED;
  }
  if (next === SpacingMark) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === Prepend) {
    return BREAK_NOT_ALLOWED;
  }
  if (current === ZWJ && next === Extended_Pictographic) {
    while (prev === Extend) {
      prev = classTypes[--prevIndex];
    }
    if (prev === Extended_Pictographic) {
      return BREAK_NOT_ALLOWED;
    }
  }
  if (current === RI && next === RI) {
    var countRI = 0;
    while (prev === RI) {
      countRI++;
      prev = classTypes[--prevIndex];
    }
    if (countRI % 2 === 0) {
      return BREAK_NOT_ALLOWED;
    }
  }
  return BREAK_ALLOWED;
};
var GraphemeBreaker = function(str) {
  var codePoints = toCodePoints(str);
  var length = codePoints.length;
  var index2 = 0;
  var lastEnd = 0;
  var classTypes = codePoints.map(codePointToClass);
  return {
    next: function() {
      if (index2 >= length) {
        return { done: true, value: null };
      }
      var graphemeBreak = BREAK_NOT_ALLOWED;
      while (index2 < length && (graphemeBreak = _graphemeBreakAtIndex(codePoints, classTypes, ++index2)) === BREAK_NOT_ALLOWED) {
      }
      if (graphemeBreak !== BREAK_NOT_ALLOWED || index2 === length) {
        var value = fromCodePoint.apply(null, codePoints.slice(lastEnd, index2));
        lastEnd = index2;
        return { value, done: false };
      }
      return { done: true, value: null };
    }
  };
};
var splitGraphemes = function(str) {
  var breaker = GraphemeBreaker(str);
  var graphemes = [];
  var bk;
  while (!(bk = breaker.next()).done) {
    if (bk.value) {
      graphemes.push(bk.value.slice());
    }
  }
  return graphemes;
};
var testRangeBounds = function(document2) {
  var TEST_HEIGHT = 123;
  if (document2.createRange) {
    var range = document2.createRange();
    if (range.getBoundingClientRect) {
      var testElement = document2.createElement("boundtest");
      testElement.style.height = TEST_HEIGHT + "px";
      testElement.style.display = "block";
      document2.body.appendChild(testElement);
      range.selectNode(testElement);
      var rangeBounds = range.getBoundingClientRect();
      var rangeHeight = Math.round(rangeBounds.height);
      document2.body.removeChild(testElement);
      if (rangeHeight === TEST_HEIGHT) {
        return true;
      }
    }
  }
  return false;
};
var testIOSLineBreak = function(document2) {
  var testElement = document2.createElement("boundtest");
  testElement.style.width = "50px";
  testElement.style.display = "block";
  testElement.style.fontSize = "12px";
  testElement.style.letterSpacing = "0px";
  testElement.style.wordSpacing = "0px";
  document2.body.appendChild(testElement);
  var range = document2.createRange();
  testElement.innerHTML = typeof "".repeat === "function" ? "&#128104;".repeat(10) : "";
  var node = testElement.firstChild;
  var textList = toCodePoints$1(node.data).map(function(i) {
    return fromCodePoint$1(i);
  });
  var offset = 0;
  var prev = {};
  var supports = textList.every(function(text, i) {
    range.setStart(node, offset);
    range.setEnd(node, offset + text.length);
    var rect = range.getBoundingClientRect();
    offset += text.length;
    var boundAhead = rect.x > prev.x || rect.y > prev.y;
    prev = rect;
    if (i === 0) {
      return true;
    }
    return boundAhead;
  });
  document2.body.removeChild(testElement);
  return supports;
};
var testCORS = function() {
  return typeof new Image().crossOrigin !== "undefined";
};
var testResponseType = function() {
  return typeof new XMLHttpRequest().responseType === "string";
};
var testSVG = function(document2) {
  var img = new Image();
  var canvas = document2.createElement("canvas");
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    return false;
  }
  img.src = "data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg'></svg>";
  try {
    ctx.drawImage(img, 0, 0);
    canvas.toDataURL();
  } catch (e2) {
    return false;
  }
  return true;
};
var isGreenPixel = function(data) {
  return data[0] === 0 && data[1] === 255 && data[2] === 0 && data[3] === 255;
};
var testForeignObject = function(document2) {
  var canvas = document2.createElement("canvas");
  var size = 100;
  canvas.width = size;
  canvas.height = size;
  var ctx = canvas.getContext("2d");
  if (!ctx) {
    return Promise.reject(false);
  }
  ctx.fillStyle = "rgb(0, 255, 0)";
  ctx.fillRect(0, 0, size, size);
  var img = new Image();
  var greenImageSrc = canvas.toDataURL();
  img.src = greenImageSrc;
  var svg = createForeignObjectSVG(size, size, 0, 0, img);
  ctx.fillStyle = "red";
  ctx.fillRect(0, 0, size, size);
  return loadSerializedSVG$1(svg).then(function(img2) {
    ctx.drawImage(img2, 0, 0);
    var data = ctx.getImageData(0, 0, size, size).data;
    ctx.fillStyle = "red";
    ctx.fillRect(0, 0, size, size);
    var node = document2.createElement("div");
    node.style.backgroundImage = "url(" + greenImageSrc + ")";
    node.style.height = size + "px";
    return isGreenPixel(data) ? loadSerializedSVG$1(createForeignObjectSVG(size, size, 0, 0, node)) : Promise.reject(false);
  }).then(function(img2) {
    ctx.drawImage(img2, 0, 0);
    return isGreenPixel(ctx.getImageData(0, 0, size, size).data);
  }).catch(function() {
    return false;
  });
};
var createForeignObjectSVG = function(width, height, x, y, node) {
  var xmlns = "http://www.w3.org/2000/svg";
  var svg = document.createElementNS(xmlns, "svg");
  var foreignObject = document.createElementNS(xmlns, "foreignObject");
  svg.setAttributeNS(null, "width", width.toString());
  svg.setAttributeNS(null, "height", height.toString());
  foreignObject.setAttributeNS(null, "width", "100%");
  foreignObject.setAttributeNS(null, "height", "100%");
  foreignObject.setAttributeNS(null, "x", x.toString());
  foreignObject.setAttributeNS(null, "y", y.toString());
  foreignObject.setAttributeNS(null, "externalResourcesRequired", "true");
  svg.appendChild(foreignObject);
  foreignObject.appendChild(node);
  return svg;
};
var loadSerializedSVG$1 = function(svg) {
  return new Promise(function(resolve, reject) {
    var img = new Image();
    img.onload = function() {
      return resolve(img);
    };
    img.onerror = reject;
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
  });
};
var FEATURES = {
  get SUPPORT_RANGE_BOUNDS() {
    var value = testRangeBounds(document);
    Object.defineProperty(FEATURES, "SUPPORT_RANGE_BOUNDS", { value });
    return value;
  },
  get SUPPORT_WORD_BREAKING() {
    var value = FEATURES.SUPPORT_RANGE_BOUNDS && testIOSLineBreak(document);
    Object.defineProperty(FEATURES, "SUPPORT_WORD_BREAKING", { value });
    return value;
  },
  get SUPPORT_SVG_DRAWING() {
    var value = testSVG(document);
    Object.defineProperty(FEATURES, "SUPPORT_SVG_DRAWING", { value });
    return value;
  },
  get SUPPORT_FOREIGNOBJECT_DRAWING() {
    var value = typeof Array.from === "function" && typeof window.fetch === "function" ? testForeignObject(document) : Promise.resolve(false);
    Object.defineProperty(FEATURES, "SUPPORT_FOREIGNOBJECT_DRAWING", { value });
    return value;
  },
  get SUPPORT_CORS_IMAGES() {
    var value = testCORS();
    Object.defineProperty(FEATURES, "SUPPORT_CORS_IMAGES", { value });
    return value;
  },
  get SUPPORT_RESPONSE_TYPE() {
    var value = testResponseType();
    Object.defineProperty(FEATURES, "SUPPORT_RESPONSE_TYPE", { value });
    return value;
  },
  get SUPPORT_CORS_XHR() {
    var value = "withCredentials" in new XMLHttpRequest();
    Object.defineProperty(FEATURES, "SUPPORT_CORS_XHR", { value });
    return value;
  },
  get SUPPORT_NATIVE_TEXT_SEGMENTATION() {
    var value = !!(typeof Intl !== "undefined" && Intl.Segmenter);
    Object.defineProperty(FEATURES, "SUPPORT_NATIVE_TEXT_SEGMENTATION", { value });
    return value;
  }
};
var TextBounds = function() {
  function TextBounds2(text, bounds) {
    this.text = text;
    this.bounds = bounds;
  }
  return TextBounds2;
}();
var parseTextBounds = function(context, value, styles, node) {
  var textList = breakText(value, styles);
  var textBounds = [];
  var offset = 0;
  textList.forEach(function(text) {
    if (styles.textDecorationLine.length || text.trim().length > 0) {
      if (FEATURES.SUPPORT_RANGE_BOUNDS) {
        var clientRects = createRange(node, offset, text.length).getClientRects();
        if (clientRects.length > 1) {
          var subSegments = segmentGraphemes(text);
          var subOffset_1 = 0;
          subSegments.forEach(function(subSegment) {
            textBounds.push(new TextBounds(subSegment, Bounds.fromDOMRectList(context, createRange(node, subOffset_1 + offset, subSegment.length).getClientRects())));
            subOffset_1 += subSegment.length;
          });
        } else {
          textBounds.push(new TextBounds(text, Bounds.fromDOMRectList(context, clientRects)));
        }
      } else {
        var replacementNode = node.splitText(text.length);
        textBounds.push(new TextBounds(text, getWrapperBounds(context, node)));
        node = replacementNode;
      }
    } else if (!FEATURES.SUPPORT_RANGE_BOUNDS) {
      node = node.splitText(text.length);
    }
    offset += text.length;
  });
  return textBounds;
};
var getWrapperBounds = function(context, node) {
  var ownerDocument = node.ownerDocument;
  if (ownerDocument) {
    var wrapper = ownerDocument.createElement("html2canvaswrapper");
    wrapper.appendChild(node.cloneNode(true));
    var parentNode = node.parentNode;
    if (parentNode) {
      parentNode.replaceChild(wrapper, node);
      var bounds = parseBounds(context, wrapper);
      if (wrapper.firstChild) {
        parentNode.replaceChild(wrapper.firstChild, wrapper);
      }
      return bounds;
    }
  }
  return Bounds.EMPTY;
};
var createRange = function(node, offset, length) {
  var ownerDocument = node.ownerDocument;
  if (!ownerDocument) {
    throw new Error("Node has no owner document");
  }
  var range = ownerDocument.createRange();
  range.setStart(node, offset);
  range.setEnd(node, offset + length);
  return range;
};
var segmentGraphemes = function(value) {
  if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var segmenter = new Intl.Segmenter(void 0, { granularity: "grapheme" });
    return Array.from(segmenter.segment(value)).map(function(segment) {
      return segment.segment;
    });
  }
  return splitGraphemes(value);
};
var segmentWords = function(value, styles) {
  if (FEATURES.SUPPORT_NATIVE_TEXT_SEGMENTATION) {
    var segmenter = new Intl.Segmenter(void 0, {
      granularity: "word"
    });
    return Array.from(segmenter.segment(value)).map(function(segment) {
      return segment.segment;
    });
  }
  return breakWords(value, styles);
};
var breakText = function(value, styles) {
  return styles.letterSpacing !== 0 ? segmentGraphemes(value) : segmentWords(value, styles);
};
var wordSeparators = [32, 160, 4961, 65792, 65793, 4153, 4241];
var breakWords = function(str, styles) {
  var breaker = LineBreaker(str, {
    lineBreak: styles.lineBreak,
    wordBreak: styles.overflowWrap === "break-word" ? "break-word" : styles.wordBreak
  });
  var words = [];
  var bk;
  var _loop_1 = function() {
    if (bk.value) {
      var value = bk.value.slice();
      var codePoints = toCodePoints$1(value);
      var word_1 = "";
      codePoints.forEach(function(codePoint) {
        if (wordSeparators.indexOf(codePoint) === -1) {
          word_1 += fromCodePoint$1(codePoint);
        } else {
          if (word_1.length) {
            words.push(word_1);
          }
          words.push(fromCodePoint$1(codePoint));
          word_1 = "";
        }
      });
      if (word_1.length) {
        words.push(word_1);
      }
    }
  };
  while (!(bk = breaker.next()).done) {
    _loop_1();
  }
  return words;
};
var TextContainer = function() {
  function TextContainer2(context, node, styles) {
    this.text = transform(node.data, styles.textTransform);
    this.textBounds = parseTextBounds(context, this.text, styles, node);
  }
  return TextContainer2;
}();
var transform = function(text, transform2) {
  switch (transform2) {
    case 1:
      return text.toLowerCase();
    case 3:
      return text.replace(CAPITALIZE, capitalize);
    case 2:
      return text.toUpperCase();
    default:
      return text;
  }
};
var CAPITALIZE = /(^|\s|:|-|\(|\))([a-z])/g;
var capitalize = function(m, p1, p2) {
  if (m.length > 0) {
    return p1 + p2.toUpperCase();
  }
  return m;
};
var ImageElementContainer = function(_super) {
  __extends(ImageElementContainer2, _super);
  function ImageElementContainer2(context, img) {
    var _this = _super.call(this, context, img) || this;
    _this.src = img.currentSrc || img.src;
    _this.intrinsicWidth = img.naturalWidth;
    _this.intrinsicHeight = img.naturalHeight;
    _this.context.cache.addImage(_this.src);
    return _this;
  }
  return ImageElementContainer2;
}(ElementContainer);
var CanvasElementContainer = function(_super) {
  __extends(CanvasElementContainer2, _super);
  function CanvasElementContainer2(context, canvas) {
    var _this = _super.call(this, context, canvas) || this;
    _this.canvas = canvas;
    _this.intrinsicWidth = canvas.width;
    _this.intrinsicHeight = canvas.height;
    return _this;
  }
  return CanvasElementContainer2;
}(ElementContainer);
var SVGElementContainer = function(_super) {
  __extends(SVGElementContainer2, _super);
  function SVGElementContainer2(context, img) {
    var _this = _super.call(this, context, img) || this;
    var s = new XMLSerializer();
    var bounds = parseBounds(context, img);
    img.setAttribute("width", bounds.width + "px");
    img.setAttribute("height", bounds.height + "px");
    _this.svg = "data:image/svg+xml," + encodeURIComponent(s.serializeToString(img));
    _this.intrinsicWidth = img.width.baseVal.value;
    _this.intrinsicHeight = img.height.baseVal.value;
    _this.context.cache.addImage(_this.svg);
    return _this;
  }
  return SVGElementContainer2;
}(ElementContainer);
var LIElementContainer = function(_super) {
  __extends(LIElementContainer2, _super);
  function LIElementContainer2(context, element) {
    var _this = _super.call(this, context, element) || this;
    _this.value = element.value;
    return _this;
  }
  return LIElementContainer2;
}(ElementContainer);
var OLElementContainer = function(_super) {
  __extends(OLElementContainer2, _super);
  function OLElementContainer2(context, element) {
    var _this = _super.call(this, context, element) || this;
    _this.start = element.start;
    _this.reversed = typeof element.reversed === "boolean" && element.reversed === true;
    return _this;
  }
  return OLElementContainer2;
}(ElementContainer);
var CHECKBOX_BORDER_RADIUS = [
  {
    type: 15,
    flags: 0,
    unit: "px",
    number: 3
  }
];
var RADIO_BORDER_RADIUS = [
  {
    type: 16,
    flags: 0,
    number: 50
  }
];
var reformatInputBounds = function(bounds) {
  if (bounds.width > bounds.height) {
    return new Bounds(bounds.left + (bounds.width - bounds.height) / 2, bounds.top, bounds.height, bounds.height);
  } else if (bounds.width < bounds.height) {
    return new Bounds(bounds.left, bounds.top + (bounds.height - bounds.width) / 2, bounds.width, bounds.width);
  }
  return bounds;
};
var getInputValue = function(node) {
  var value = node.type === PASSWORD ? new Array(node.value.length + 1).join("\u2022") : node.value;
  return value.length === 0 ? node.placeholder || "" : value;
};
var CHECKBOX = "checkbox";
var RADIO = "radio";
var PASSWORD = "password";
var INPUT_COLOR = 707406591;
var InputElementContainer = function(_super) {
  __extends(InputElementContainer2, _super);
  function InputElementContainer2(context, input) {
    var _this = _super.call(this, context, input) || this;
    _this.type = input.type.toLowerCase();
    _this.checked = input.checked;
    _this.value = getInputValue(input);
    if (_this.type === CHECKBOX || _this.type === RADIO) {
      _this.styles.backgroundColor = 3739148031;
      _this.styles.borderTopColor = _this.styles.borderRightColor = _this.styles.borderBottomColor = _this.styles.borderLeftColor = 2779096575;
      _this.styles.borderTopWidth = _this.styles.borderRightWidth = _this.styles.borderBottomWidth = _this.styles.borderLeftWidth = 1;
      _this.styles.borderTopStyle = _this.styles.borderRightStyle = _this.styles.borderBottomStyle = _this.styles.borderLeftStyle = 1;
      _this.styles.backgroundClip = [0];
      _this.styles.backgroundOrigin = [0];
      _this.bounds = reformatInputBounds(_this.bounds);
    }
    switch (_this.type) {
      case CHECKBOX:
        _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = CHECKBOX_BORDER_RADIUS;
        break;
      case RADIO:
        _this.styles.borderTopRightRadius = _this.styles.borderTopLeftRadius = _this.styles.borderBottomRightRadius = _this.styles.borderBottomLeftRadius = RADIO_BORDER_RADIUS;
        break;
    }
    return _this;
  }
  return InputElementContainer2;
}(ElementContainer);
var SelectElementContainer = function(_super) {
  __extends(SelectElementContainer2, _super);
  function SelectElementContainer2(context, element) {
    var _this = _super.call(this, context, element) || this;
    var option2 = element.options[element.selectedIndex || 0];
    _this.value = option2 ? option2.text || "" : "";
    return _this;
  }
  return SelectElementContainer2;
}(ElementContainer);
var TextareaElementContainer = function(_super) {
  __extends(TextareaElementContainer2, _super);
  function TextareaElementContainer2(context, element) {
    var _this = _super.call(this, context, element) || this;
    _this.value = element.value;
    return _this;
  }
  return TextareaElementContainer2;
}(ElementContainer);
var IFrameElementContainer = function(_super) {
  __extends(IFrameElementContainer2, _super);
  function IFrameElementContainer2(context, iframe) {
    var _this = _super.call(this, context, iframe) || this;
    _this.src = iframe.src;
    _this.width = parseInt(iframe.width, 10) || 0;
    _this.height = parseInt(iframe.height, 10) || 0;
    _this.backgroundColor = _this.styles.backgroundColor;
    try {
      if (iframe.contentWindow && iframe.contentWindow.document && iframe.contentWindow.document.documentElement) {
        _this.tree = parseTree(context, iframe.contentWindow.document.documentElement);
        var documentBackgroundColor = iframe.contentWindow.document.documentElement ? parseColor(context, getComputedStyle(iframe.contentWindow.document.documentElement).backgroundColor) : COLORS.TRANSPARENT;
        var bodyBackgroundColor = iframe.contentWindow.document.body ? parseColor(context, getComputedStyle(iframe.contentWindow.document.body).backgroundColor) : COLORS.TRANSPARENT;
        _this.backgroundColor = isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? _this.styles.backgroundColor : bodyBackgroundColor : documentBackgroundColor;
      }
    } catch (e2) {
    }
    return _this;
  }
  return IFrameElementContainer2;
}(ElementContainer);
var LIST_OWNERS = ["OL", "UL", "MENU"];
var parseNodeTree = function(context, node, parent, root) {
  for (var childNode = node.firstChild, nextNode = void 0; childNode; childNode = nextNode) {
    nextNode = childNode.nextSibling;
    if (isTextNode(childNode) && childNode.data.trim().length > 0) {
      parent.textNodes.push(new TextContainer(context, childNode, parent.styles));
    } else if (isElementNode(childNode)) {
      if (isSlotElement(childNode) && childNode.assignedNodes) {
        childNode.assignedNodes().forEach(function(childNode2) {
          return parseNodeTree(context, childNode2, parent, root);
        });
      } else {
        var container = createContainer(context, childNode);
        if (container.styles.isVisible()) {
          if (createsRealStackingContext(childNode, container, root)) {
            container.flags |= 4;
          } else if (createsStackingContext(container.styles)) {
            container.flags |= 2;
          }
          if (LIST_OWNERS.indexOf(childNode.tagName) !== -1) {
            container.flags |= 8;
          }
          parent.elements.push(container);
          childNode.slot;
          if (childNode.shadowRoot) {
            parseNodeTree(context, childNode.shadowRoot, container, root);
          } else if (!isTextareaElement(childNode) && !isSVGElement(childNode) && !isSelectElement(childNode)) {
            parseNodeTree(context, childNode, container, root);
          }
        }
      }
    }
  }
};
var createContainer = function(context, element) {
  if (isImageElement(element)) {
    return new ImageElementContainer(context, element);
  }
  if (isCanvasElement(element)) {
    return new CanvasElementContainer(context, element);
  }
  if (isSVGElement(element)) {
    return new SVGElementContainer(context, element);
  }
  if (isLIElement(element)) {
    return new LIElementContainer(context, element);
  }
  if (isOLElement(element)) {
    return new OLElementContainer(context, element);
  }
  if (isInputElement(element)) {
    return new InputElementContainer(context, element);
  }
  if (isSelectElement(element)) {
    return new SelectElementContainer(context, element);
  }
  if (isTextareaElement(element)) {
    return new TextareaElementContainer(context, element);
  }
  if (isIFrameElement(element)) {
    return new IFrameElementContainer(context, element);
  }
  return new ElementContainer(context, element);
};
var parseTree = function(context, element) {
  var container = createContainer(context, element);
  container.flags |= 4;
  parseNodeTree(context, element, container, container);
  return container;
};
var createsRealStackingContext = function(node, container, root) {
  return container.styles.isPositionedWithZIndex() || container.styles.opacity < 1 || container.styles.isTransformed() || isBodyElement(node) && root.styles.isTransparent();
};
var createsStackingContext = function(styles) {
  return styles.isPositioned() || styles.isFloating();
};
var isTextNode = function(node) {
  return node.nodeType === Node.TEXT_NODE;
};
var isElementNode = function(node) {
  return node.nodeType === Node.ELEMENT_NODE;
};
var isHTMLElementNode = function(node) {
  return isElementNode(node) && typeof node.style !== "undefined" && !isSVGElementNode(node);
};
var isSVGElementNode = function(element) {
  return typeof element.className === "object";
};
var isLIElement = function(node) {
  return node.tagName === "LI";
};
var isOLElement = function(node) {
  return node.tagName === "OL";
};
var isInputElement = function(node) {
  return node.tagName === "INPUT";
};
var isHTMLElement = function(node) {
  return node.tagName === "HTML";
};
var isSVGElement = function(node) {
  return node.tagName === "svg";
};
var isBodyElement = function(node) {
  return node.tagName === "BODY";
};
var isCanvasElement = function(node) {
  return node.tagName === "CANVAS";
};
var isVideoElement = function(node) {
  return node.tagName === "VIDEO";
};
var isImageElement = function(node) {
  return node.tagName === "IMG";
};
var isIFrameElement = function(node) {
  return node.tagName === "IFRAME";
};
var isStyleElement = function(node) {
  return node.tagName === "STYLE";
};
var isScriptElement = function(node) {
  return node.tagName === "SCRIPT";
};
var isTextareaElement = function(node) {
  return node.tagName === "TEXTAREA";
};
var isSelectElement = function(node) {
  return node.tagName === "SELECT";
};
var isSlotElement = function(node) {
  return node.tagName === "SLOT";
};
var isCustomElement = function(node) {
  return node.tagName.indexOf("-") > 0;
};
var CounterState = function() {
  function CounterState2() {
    this.counters = {};
  }
  CounterState2.prototype.getCounterValue = function(name2) {
    var counter = this.counters[name2];
    if (counter && counter.length) {
      return counter[counter.length - 1];
    }
    return 1;
  };
  CounterState2.prototype.getCounterValues = function(name2) {
    var counter = this.counters[name2];
    return counter ? counter : [];
  };
  CounterState2.prototype.pop = function(counters) {
    var _this = this;
    counters.forEach(function(counter) {
      return _this.counters[counter].pop();
    });
  };
  CounterState2.prototype.parse = function(style) {
    var _this = this;
    var counterIncrement2 = style.counterIncrement;
    var counterReset2 = style.counterReset;
    var canReset = true;
    if (counterIncrement2 !== null) {
      counterIncrement2.forEach(function(entry) {
        var counter = _this.counters[entry.counter];
        if (counter && entry.increment !== 0) {
          canReset = false;
          if (!counter.length) {
            counter.push(1);
          }
          counter[Math.max(0, counter.length - 1)] += entry.increment;
        }
      });
    }
    var counterNames = [];
    if (canReset) {
      counterReset2.forEach(function(entry) {
        var counter = _this.counters[entry.counter];
        counterNames.push(entry.counter);
        if (!counter) {
          counter = _this.counters[entry.counter] = [];
        }
        counter.push(entry.reset);
      });
    }
    return counterNames;
  };
  return CounterState2;
}();
var ROMAN_UPPER = {
  integers: [1e3, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1],
  values: ["M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"]
};
var ARMENIAN = {
  integers: [
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "\u0554",
    "\u0553",
    "\u0552",
    "\u0551",
    "\u0550",
    "\u054F",
    "\u054E",
    "\u054D",
    "\u054C",
    "\u054B",
    "\u054A",
    "\u0549",
    "\u0548",
    "\u0547",
    "\u0546",
    "\u0545",
    "\u0544",
    "\u0543",
    "\u0542",
    "\u0541",
    "\u0540",
    "\u053F",
    "\u053E",
    "\u053D",
    "\u053C",
    "\u053B",
    "\u053A",
    "\u0539",
    "\u0538",
    "\u0537",
    "\u0536",
    "\u0535",
    "\u0534",
    "\u0533",
    "\u0532",
    "\u0531"
  ]
};
var HEBREW = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    19,
    18,
    17,
    16,
    15,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "\u05D9\u05F3",
    "\u05D8\u05F3",
    "\u05D7\u05F3",
    "\u05D6\u05F3",
    "\u05D5\u05F3",
    "\u05D4\u05F3",
    "\u05D3\u05F3",
    "\u05D2\u05F3",
    "\u05D1\u05F3",
    "\u05D0\u05F3",
    "\u05EA",
    "\u05E9",
    "\u05E8",
    "\u05E7",
    "\u05E6",
    "\u05E4",
    "\u05E2",
    "\u05E1",
    "\u05E0",
    "\u05DE",
    "\u05DC",
    "\u05DB",
    "\u05D9\u05D8",
    "\u05D9\u05D7",
    "\u05D9\u05D6",
    "\u05D8\u05D6",
    "\u05D8\u05D5",
    "\u05D9",
    "\u05D8",
    "\u05D7",
    "\u05D6",
    "\u05D5",
    "\u05D4",
    "\u05D3",
    "\u05D2",
    "\u05D1",
    "\u05D0"
  ]
};
var GEORGIAN = {
  integers: [
    1e4,
    9e3,
    8e3,
    7e3,
    6e3,
    5e3,
    4e3,
    3e3,
    2e3,
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ],
  values: [
    "\u10F5",
    "\u10F0",
    "\u10EF",
    "\u10F4",
    "\u10EE",
    "\u10ED",
    "\u10EC",
    "\u10EB",
    "\u10EA",
    "\u10E9",
    "\u10E8",
    "\u10E7",
    "\u10E6",
    "\u10E5",
    "\u10E4",
    "\u10F3",
    "\u10E2",
    "\u10E1",
    "\u10E0",
    "\u10DF",
    "\u10DE",
    "\u10DD",
    "\u10F2",
    "\u10DC",
    "\u10DB",
    "\u10DA",
    "\u10D9",
    "\u10D8",
    "\u10D7",
    "\u10F1",
    "\u10D6",
    "\u10D5",
    "\u10D4",
    "\u10D3",
    "\u10D2",
    "\u10D1",
    "\u10D0"
  ]
};
var createAdditiveCounter = function(value, min, max2, symbols, fallback, suffix) {
  if (value < min || value > max2) {
    return createCounterText(value, fallback, suffix.length > 0);
  }
  return symbols.integers.reduce(function(string, integer, index2) {
    while (value >= integer) {
      value -= integer;
      string += symbols.values[index2];
    }
    return string;
  }, "") + suffix;
};
var createCounterStyleWithSymbolResolver = function(value, codePointRangeLength, isNumeric, resolver) {
  var string = "";
  do {
    if (!isNumeric) {
      value--;
    }
    string = resolver(value) + string;
    value /= codePointRangeLength;
  } while (value * codePointRangeLength >= codePointRangeLength);
  return string;
};
var createCounterStyleFromRange = function(value, codePointRangeStart, codePointRangeEnd, isNumeric, suffix) {
  var codePointRangeLength = codePointRangeEnd - codePointRangeStart + 1;
  return (value < 0 ? "-" : "") + (createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, isNumeric, function(codePoint) {
    return fromCodePoint$1(Math.floor(codePoint % codePointRangeLength) + codePointRangeStart);
  }) + suffix);
};
var createCounterStyleFromSymbols = function(value, symbols, suffix) {
  if (suffix === void 0) {
    suffix = ". ";
  }
  var codePointRangeLength = symbols.length;
  return createCounterStyleWithSymbolResolver(Math.abs(value), codePointRangeLength, false, function(codePoint) {
    return symbols[Math.floor(codePoint % codePointRangeLength)];
  }) + suffix;
};
var CJK_ZEROS = 1 << 0;
var CJK_TEN_COEFFICIENTS = 1 << 1;
var CJK_TEN_HIGH_COEFFICIENTS = 1 << 2;
var CJK_HUNDRED_COEFFICIENTS = 1 << 3;
var createCJKCounter = function(value, numbers, multipliers, negativeSign, suffix, flags) {
  if (value < -9999 || value > 9999) {
    return createCounterText(value, 4, suffix.length > 0);
  }
  var tmp = Math.abs(value);
  var string = suffix;
  if (tmp === 0) {
    return numbers[0] + string;
  }
  for (var digit = 0; tmp > 0 && digit <= 4; digit++) {
    var coefficient = tmp % 10;
    if (coefficient === 0 && contains(flags, CJK_ZEROS) && string !== "") {
      string = numbers[coefficient] + string;
    } else if (coefficient > 1 || coefficient === 1 && digit === 0 || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_COEFFICIENTS) || coefficient === 1 && digit === 1 && contains(flags, CJK_TEN_HIGH_COEFFICIENTS) && value > 100 || coefficient === 1 && digit > 1 && contains(flags, CJK_HUNDRED_COEFFICIENTS)) {
      string = numbers[coefficient] + (digit > 0 ? multipliers[digit - 1] : "") + string;
    } else if (coefficient === 1 && digit > 0) {
      string = multipliers[digit - 1] + string;
    }
    tmp = Math.floor(tmp / 10);
  }
  return (value < 0 ? negativeSign : "") + string;
};
var CHINESE_INFORMAL_MULTIPLIERS = "\u5341\u767E\u5343\u842C";
var CHINESE_FORMAL_MULTIPLIERS = "\u62FE\u4F70\u4EDF\u842C";
var JAPANESE_NEGATIVE = "\u30DE\u30A4\u30CA\u30B9";
var KOREAN_NEGATIVE = "\uB9C8\uC774\uB108\uC2A4";
var createCounterText = function(value, type, appendSuffix) {
  var defaultSuffix = appendSuffix ? ". " : "";
  var cjkSuffix = appendSuffix ? "\u3001" : "";
  var koreanSuffix = appendSuffix ? ", " : "";
  var spaceSuffix = appendSuffix ? " " : "";
  switch (type) {
    case 0:
      return "\u2022" + spaceSuffix;
    case 1:
      return "\u25E6" + spaceSuffix;
    case 2:
      return "\u25FE" + spaceSuffix;
    case 5:
      var string = createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
      return string.length < 4 ? "0" + string : string;
    case 4:
      return createCounterStyleFromSymbols(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", cjkSuffix);
    case 6:
      return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix).toLowerCase();
    case 7:
      return createAdditiveCounter(value, 1, 3999, ROMAN_UPPER, 3, defaultSuffix);
    case 8:
      return createCounterStyleFromRange(value, 945, 969, false, defaultSuffix);
    case 9:
      return createCounterStyleFromRange(value, 97, 122, false, defaultSuffix);
    case 10:
      return createCounterStyleFromRange(value, 65, 90, false, defaultSuffix);
    case 11:
      return createCounterStyleFromRange(value, 1632, 1641, true, defaultSuffix);
    case 12:
    case 49:
      return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix);
    case 35:
      return createAdditiveCounter(value, 1, 9999, ARMENIAN, 3, defaultSuffix).toLowerCase();
    case 13:
      return createCounterStyleFromRange(value, 2534, 2543, true, defaultSuffix);
    case 14:
    case 30:
      return createCounterStyleFromRange(value, 6112, 6121, true, defaultSuffix);
    case 15:
      return createCounterStyleFromSymbols(value, "\u5B50\u4E11\u5BC5\u536F\u8FB0\u5DF3\u5348\u672A\u7533\u9149\u620C\u4EA5", cjkSuffix);
    case 16:
      return createCounterStyleFromSymbols(value, "\u7532\u4E59\u4E19\u4E01\u620A\u5DF1\u5E9A\u8F9B\u58EC\u7678", cjkSuffix);
    case 17:
    case 48:
      return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 47:
      return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u8086\u4F0D\u9678\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8CA0", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 42:
      return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", CHINESE_INFORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 41:
      return createCJKCounter(value, "\u96F6\u58F9\u8D30\u53C1\u8086\u4F0D\u9646\u67D2\u634C\u7396", CHINESE_FORMAL_MULTIPLIERS, "\u8D1F", cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS | CJK_HUNDRED_COEFFICIENTS);
    case 26:
      return createCJKCounter(value, "\u3007\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, 0);
    case 25:
      return createCJKCounter(value, "\u96F6\u58F1\u5F10\u53C2\u56DB\u4F0D\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343\u4E07", JAPANESE_NEGATIVE, cjkSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 31:
      return createCJKCounter(value, "\uC601\uC77C\uC774\uC0BC\uC0AC\uC624\uC721\uCE60\uD314\uAD6C", "\uC2ED\uBC31\uCC9C\uB9CC", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 33:
      return createCJKCounter(value, "\u96F6\u4E00\u4E8C\u4E09\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u5341\u767E\u5343\u842C", KOREAN_NEGATIVE, koreanSuffix, 0);
    case 32:
      return createCJKCounter(value, "\u96F6\u58F9\u8CB3\u53C3\u56DB\u4E94\u516D\u4E03\u516B\u4E5D", "\u62FE\u767E\u5343", KOREAN_NEGATIVE, koreanSuffix, CJK_ZEROS | CJK_TEN_COEFFICIENTS | CJK_TEN_HIGH_COEFFICIENTS);
    case 18:
      return createCounterStyleFromRange(value, 2406, 2415, true, defaultSuffix);
    case 20:
      return createAdditiveCounter(value, 1, 19999, GEORGIAN, 3, defaultSuffix);
    case 21:
      return createCounterStyleFromRange(value, 2790, 2799, true, defaultSuffix);
    case 22:
      return createCounterStyleFromRange(value, 2662, 2671, true, defaultSuffix);
    case 22:
      return createAdditiveCounter(value, 1, 10999, HEBREW, 3, defaultSuffix);
    case 23:
      return createCounterStyleFromSymbols(value, "\u3042\u3044\u3046\u3048\u304A\u304B\u304D\u304F\u3051\u3053\u3055\u3057\u3059\u305B\u305D\u305F\u3061\u3064\u3066\u3068\u306A\u306B\u306C\u306D\u306E\u306F\u3072\u3075\u3078\u307B\u307E\u307F\u3080\u3081\u3082\u3084\u3086\u3088\u3089\u308A\u308B\u308C\u308D\u308F\u3090\u3091\u3092\u3093");
    case 24:
      return createCounterStyleFromSymbols(value, "\u3044\u308D\u306F\u306B\u307B\u3078\u3068\u3061\u308A\u306C\u308B\u3092\u308F\u304B\u3088\u305F\u308C\u305D\u3064\u306D\u306A\u3089\u3080\u3046\u3090\u306E\u304A\u304F\u3084\u307E\u3051\u3075\u3053\u3048\u3066\u3042\u3055\u304D\u3086\u3081\u307F\u3057\u3091\u3072\u3082\u305B\u3059");
    case 27:
      return createCounterStyleFromRange(value, 3302, 3311, true, defaultSuffix);
    case 28:
      return createCounterStyleFromSymbols(value, "\u30A2\u30A4\u30A6\u30A8\u30AA\u30AB\u30AD\u30AF\u30B1\u30B3\u30B5\u30B7\u30B9\u30BB\u30BD\u30BF\u30C1\u30C4\u30C6\u30C8\u30CA\u30CB\u30CC\u30CD\u30CE\u30CF\u30D2\u30D5\u30D8\u30DB\u30DE\u30DF\u30E0\u30E1\u30E2\u30E4\u30E6\u30E8\u30E9\u30EA\u30EB\u30EC\u30ED\u30EF\u30F0\u30F1\u30F2\u30F3", cjkSuffix);
    case 29:
      return createCounterStyleFromSymbols(value, "\u30A4\u30ED\u30CF\u30CB\u30DB\u30D8\u30C8\u30C1\u30EA\u30CC\u30EB\u30F2\u30EF\u30AB\u30E8\u30BF\u30EC\u30BD\u30C4\u30CD\u30CA\u30E9\u30E0\u30A6\u30F0\u30CE\u30AA\u30AF\u30E4\u30DE\u30B1\u30D5\u30B3\u30A8\u30C6\u30A2\u30B5\u30AD\u30E6\u30E1\u30DF\u30B7\u30F1\u30D2\u30E2\u30BB\u30B9", cjkSuffix);
    case 34:
      return createCounterStyleFromRange(value, 3792, 3801, true, defaultSuffix);
    case 37:
      return createCounterStyleFromRange(value, 6160, 6169, true, defaultSuffix);
    case 38:
      return createCounterStyleFromRange(value, 4160, 4169, true, defaultSuffix);
    case 39:
      return createCounterStyleFromRange(value, 2918, 2927, true, defaultSuffix);
    case 40:
      return createCounterStyleFromRange(value, 1776, 1785, true, defaultSuffix);
    case 43:
      return createCounterStyleFromRange(value, 3046, 3055, true, defaultSuffix);
    case 44:
      return createCounterStyleFromRange(value, 3174, 3183, true, defaultSuffix);
    case 45:
      return createCounterStyleFromRange(value, 3664, 3673, true, defaultSuffix);
    case 46:
      return createCounterStyleFromRange(value, 3872, 3881, true, defaultSuffix);
    case 3:
    default:
      return createCounterStyleFromRange(value, 48, 57, true, defaultSuffix);
  }
};
var IGNORE_ATTRIBUTE = "data-html2canvas-ignore";
var DocumentCloner = function() {
  function DocumentCloner2(context, element, options) {
    this.context = context;
    this.options = options;
    this.scrolledElements = [];
    this.referenceElement = element;
    this.counters = new CounterState();
    this.quoteDepth = 0;
    if (!element.ownerDocument) {
      throw new Error("Cloned element does not have an owner document");
    }
    this.documentElement = this.cloneNode(element.ownerDocument.documentElement, false);
  }
  DocumentCloner2.prototype.toIFrame = function(ownerDocument, windowSize) {
    var _this = this;
    var iframe = createIFrameContainer(ownerDocument, windowSize);
    if (!iframe.contentWindow) {
      return Promise.reject("Unable to find iframe window");
    }
    var scrollX = ownerDocument.defaultView.pageXOffset;
    var scrollY = ownerDocument.defaultView.pageYOffset;
    var cloneWindow = iframe.contentWindow;
    var documentClone = cloneWindow.document;
    var iframeLoad = iframeLoader(iframe).then(function() {
      return __awaiter(_this, void 0, void 0, function() {
        var onclone, referenceElement;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              this.scrolledElements.forEach(restoreNodeScroll);
              if (cloneWindow) {
                cloneWindow.scrollTo(windowSize.left, windowSize.top);
                if (/(iPad|iPhone|iPod)/g.test(navigator.userAgent) && (cloneWindow.scrollY !== windowSize.top || cloneWindow.scrollX !== windowSize.left)) {
                  this.context.logger.warn("Unable to restore scroll position for cloned document");
                  this.context.windowBounds = this.context.windowBounds.add(cloneWindow.scrollX - windowSize.left, cloneWindow.scrollY - windowSize.top, 0, 0);
                }
              }
              onclone = this.options.onclone;
              referenceElement = this.clonedReferenceElement;
              if (typeof referenceElement === "undefined") {
                return [2, Promise.reject("Error finding the " + this.referenceElement.nodeName + " in the cloned document")];
              }
              if (!(documentClone.fonts && documentClone.fonts.ready))
                return [3, 2];
              return [4, documentClone.fonts.ready];
            case 1:
              _a2.sent();
              _a2.label = 2;
            case 2:
              if (!/(AppleWebKit)/g.test(navigator.userAgent))
                return [3, 4];
              return [4, imagesReady(documentClone)];
            case 3:
              _a2.sent();
              _a2.label = 4;
            case 4:
              if (typeof onclone === "function") {
                return [2, Promise.resolve().then(function() {
                  return onclone(documentClone, referenceElement);
                }).then(function() {
                  return iframe;
                })];
              }
              return [2, iframe];
          }
        });
      });
    });
    documentClone.open();
    documentClone.write(serializeDoctype(document.doctype) + "<html></html>");
    restoreOwnerScroll(this.referenceElement.ownerDocument, scrollX, scrollY);
    documentClone.replaceChild(documentClone.adoptNode(this.documentElement), documentClone.documentElement);
    documentClone.close();
    return iframeLoad;
  };
  DocumentCloner2.prototype.createElementClone = function(node) {
    if (isDebugging(node, 2)) {
      debugger;
    }
    if (isCanvasElement(node)) {
      return this.createCanvasClone(node);
    }
    if (isVideoElement(node)) {
      return this.createVideoClone(node);
    }
    if (isStyleElement(node)) {
      return this.createStyleClone(node);
    }
    var clone2 = node.cloneNode(false);
    if (isImageElement(clone2)) {
      if (isImageElement(node) && node.currentSrc && node.currentSrc !== node.src) {
        clone2.src = node.currentSrc;
        clone2.srcset = "";
      }
      if (clone2.loading === "lazy") {
        clone2.loading = "eager";
      }
    }
    if (isCustomElement(clone2)) {
      return this.createCustomElementClone(clone2);
    }
    return clone2;
  };
  DocumentCloner2.prototype.createCustomElementClone = function(node) {
    var clone2 = document.createElement("html2canvascustomelement");
    copyCSSStyles(node.style, clone2);
    return clone2;
  };
  DocumentCloner2.prototype.createStyleClone = function(node) {
    try {
      var sheet = node.sheet;
      if (sheet && sheet.cssRules) {
        var css2 = [].slice.call(sheet.cssRules, 0).reduce(function(css3, rule) {
          if (rule && typeof rule.cssText === "string") {
            return css3 + rule.cssText;
          }
          return css3;
        }, "");
        var style = node.cloneNode(false);
        style.textContent = css2;
        return style;
      }
    } catch (e2) {
      this.context.logger.error("Unable to access cssRules property", e2);
      if (e2.name !== "SecurityError") {
        throw e2;
      }
    }
    return node.cloneNode(false);
  };
  DocumentCloner2.prototype.createCanvasClone = function(canvas) {
    var _a2;
    if (this.options.inlineImages && canvas.ownerDocument) {
      var img = canvas.ownerDocument.createElement("img");
      try {
        img.src = canvas.toDataURL();
        return img;
      } catch (e2) {
        this.context.logger.info("Unable to inline canvas contents, canvas is tainted", canvas);
      }
    }
    var clonedCanvas = canvas.cloneNode(false);
    try {
      clonedCanvas.width = canvas.width;
      clonedCanvas.height = canvas.height;
      var ctx = canvas.getContext("2d");
      var clonedCtx = clonedCanvas.getContext("2d");
      if (clonedCtx) {
        if (!this.options.allowTaint && ctx) {
          clonedCtx.putImageData(ctx.getImageData(0, 0, canvas.width, canvas.height), 0, 0);
        } else {
          var gl = (_a2 = canvas.getContext("webgl2")) !== null && _a2 !== void 0 ? _a2 : canvas.getContext("webgl");
          if (gl) {
            var attribs = gl.getContextAttributes();
            if ((attribs === null || attribs === void 0 ? void 0 : attribs.preserveDrawingBuffer) === false) {
              this.context.logger.warn("Unable to clone WebGL context as it has preserveDrawingBuffer=false", canvas);
            }
          }
          clonedCtx.drawImage(canvas, 0, 0);
        }
      }
      return clonedCanvas;
    } catch (e2) {
      this.context.logger.info("Unable to clone canvas as it is tainted", canvas);
    }
    return clonedCanvas;
  };
  DocumentCloner2.prototype.createVideoClone = function(video) {
    var canvas = video.ownerDocument.createElement("canvas");
    canvas.width = video.offsetWidth;
    canvas.height = video.offsetHeight;
    var ctx = canvas.getContext("2d");
    try {
      if (ctx) {
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
        if (!this.options.allowTaint) {
          ctx.getImageData(0, 0, canvas.width, canvas.height);
        }
      }
      return canvas;
    } catch (e2) {
      this.context.logger.info("Unable to clone video as it is tainted", video);
    }
    var blankCanvas = video.ownerDocument.createElement("canvas");
    blankCanvas.width = video.offsetWidth;
    blankCanvas.height = video.offsetHeight;
    return blankCanvas;
  };
  DocumentCloner2.prototype.appendChildNode = function(clone2, child, copyStyles) {
    if (!isElementNode(child) || !isScriptElement(child) && !child.hasAttribute(IGNORE_ATTRIBUTE) && (typeof this.options.ignoreElements !== "function" || !this.options.ignoreElements(child))) {
      if (!this.options.copyStyles || !isElementNode(child) || !isStyleElement(child)) {
        clone2.appendChild(this.cloneNode(child, copyStyles));
      }
    }
  };
  DocumentCloner2.prototype.cloneChildNodes = function(node, clone2, copyStyles) {
    var _this = this;
    for (var child = node.shadowRoot ? node.shadowRoot.firstChild : node.firstChild; child; child = child.nextSibling) {
      if (isElementNode(child) && isSlotElement(child) && typeof child.assignedNodes === "function") {
        var assignedNodes = child.assignedNodes();
        if (assignedNodes.length) {
          assignedNodes.forEach(function(assignedNode) {
            return _this.appendChildNode(clone2, assignedNode, copyStyles);
          });
        }
      } else {
        this.appendChildNode(clone2, child, copyStyles);
      }
    }
  };
  DocumentCloner2.prototype.cloneNode = function(node, copyStyles) {
    if (isTextNode(node)) {
      return document.createTextNode(node.data);
    }
    if (!node.ownerDocument) {
      return node.cloneNode(false);
    }
    var window2 = node.ownerDocument.defaultView;
    if (window2 && isElementNode(node) && (isHTMLElementNode(node) || isSVGElementNode(node))) {
      var clone2 = this.createElementClone(node);
      clone2.style.transitionProperty = "none";
      var style = window2.getComputedStyle(node);
      var styleBefore = window2.getComputedStyle(node, ":before");
      var styleAfter = window2.getComputedStyle(node, ":after");
      if (this.referenceElement === node && isHTMLElementNode(clone2)) {
        this.clonedReferenceElement = clone2;
      }
      if (isBodyElement(clone2)) {
        createPseudoHideStyles(clone2);
      }
      var counters = this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
      var before = this.resolvePseudoContent(node, clone2, styleBefore, PseudoElementType.BEFORE);
      if (isCustomElement(node)) {
        copyStyles = true;
      }
      if (!isVideoElement(node)) {
        this.cloneChildNodes(node, clone2, copyStyles);
      }
      if (before) {
        clone2.insertBefore(before, clone2.firstChild);
      }
      var after = this.resolvePseudoContent(node, clone2, styleAfter, PseudoElementType.AFTER);
      if (after) {
        clone2.appendChild(after);
      }
      this.counters.pop(counters);
      if (style && (this.options.copyStyles || isSVGElementNode(node)) && !isIFrameElement(node) || copyStyles) {
        copyCSSStyles(style, clone2);
      }
      if (node.scrollTop !== 0 || node.scrollLeft !== 0) {
        this.scrolledElements.push([clone2, node.scrollLeft, node.scrollTop]);
      }
      if ((isTextareaElement(node) || isSelectElement(node)) && (isTextareaElement(clone2) || isSelectElement(clone2))) {
        clone2.value = node.value;
      }
      return clone2;
    }
    return node.cloneNode(false);
  };
  DocumentCloner2.prototype.resolvePseudoContent = function(node, clone2, style, pseudoElt) {
    var _this = this;
    if (!style) {
      return;
    }
    var value = style.content;
    var document2 = clone2.ownerDocument;
    if (!document2 || !value || value === "none" || value === "-moz-alt-content" || style.display === "none") {
      return;
    }
    this.counters.parse(new CSSParsedCounterDeclaration(this.context, style));
    var declaration = new CSSParsedPseudoDeclaration(this.context, style);
    var anonymousReplacedElement = document2.createElement("html2canvaspseudoelement");
    copyCSSStyles(style, anonymousReplacedElement);
    declaration.content.forEach(function(token) {
      if (token.type === 0) {
        anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
      } else if (token.type === 22) {
        var img = document2.createElement("img");
        img.src = token.value;
        img.style.opacity = "1";
        anonymousReplacedElement.appendChild(img);
      } else if (token.type === 18) {
        if (token.name === "attr") {
          var attr = token.values.filter(isIdentToken);
          if (attr.length) {
            anonymousReplacedElement.appendChild(document2.createTextNode(node.getAttribute(attr[0].value) || ""));
          }
        } else if (token.name === "counter") {
          var _a2 = token.values.filter(nonFunctionArgSeparator), counter = _a2[0], counterStyle = _a2[1];
          if (counter && isIdentToken(counter)) {
            var counterState = _this.counters.getCounterValue(counter.value);
            var counterType = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
            anonymousReplacedElement.appendChild(document2.createTextNode(createCounterText(counterState, counterType, false)));
          }
        } else if (token.name === "counters") {
          var _b = token.values.filter(nonFunctionArgSeparator), counter = _b[0], delim = _b[1], counterStyle = _b[2];
          if (counter && isIdentToken(counter)) {
            var counterStates = _this.counters.getCounterValues(counter.value);
            var counterType_1 = counterStyle && isIdentToken(counterStyle) ? listStyleType.parse(_this.context, counterStyle.value) : 3;
            var separator = delim && delim.type === 0 ? delim.value : "";
            var text = counterStates.map(function(value2) {
              return createCounterText(value2, counterType_1, false);
            }).join(separator);
            anonymousReplacedElement.appendChild(document2.createTextNode(text));
          }
        } else
          ;
      } else if (token.type === 20) {
        switch (token.value) {
          case "open-quote":
            anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, _this.quoteDepth++, true)));
            break;
          case "close-quote":
            anonymousReplacedElement.appendChild(document2.createTextNode(getQuote(declaration.quotes, --_this.quoteDepth, false)));
            break;
          default:
            anonymousReplacedElement.appendChild(document2.createTextNode(token.value));
        }
      }
    });
    anonymousReplacedElement.className = PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
    var newClassName = pseudoElt === PseudoElementType.BEFORE ? " " + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE : " " + PSEUDO_HIDE_ELEMENT_CLASS_AFTER;
    if (isSVGElementNode(clone2)) {
      clone2.className.baseValue += newClassName;
    } else {
      clone2.className += newClassName;
    }
    return anonymousReplacedElement;
  };
  DocumentCloner2.destroy = function(container) {
    if (container.parentNode) {
      container.parentNode.removeChild(container);
      return true;
    }
    return false;
  };
  return DocumentCloner2;
}();
var PseudoElementType;
(function(PseudoElementType2) {
  PseudoElementType2[PseudoElementType2["BEFORE"] = 0] = "BEFORE";
  PseudoElementType2[PseudoElementType2["AFTER"] = 1] = "AFTER";
})(PseudoElementType || (PseudoElementType = {}));
var createIFrameContainer = function(ownerDocument, bounds) {
  var cloneIframeContainer = ownerDocument.createElement("iframe");
  cloneIframeContainer.className = "html2canvas-container";
  cloneIframeContainer.style.visibility = "hidden";
  cloneIframeContainer.style.position = "fixed";
  cloneIframeContainer.style.left = "-10000px";
  cloneIframeContainer.style.top = "0px";
  cloneIframeContainer.style.border = "0";
  cloneIframeContainer.width = bounds.width.toString();
  cloneIframeContainer.height = bounds.height.toString();
  cloneIframeContainer.scrolling = "no";
  cloneIframeContainer.setAttribute(IGNORE_ATTRIBUTE, "true");
  ownerDocument.body.appendChild(cloneIframeContainer);
  return cloneIframeContainer;
};
var imageReady = function(img) {
  return new Promise(function(resolve) {
    if (img.complete) {
      resolve();
      return;
    }
    if (!img.src) {
      resolve();
      return;
    }
    img.onload = resolve;
    img.onerror = resolve;
  });
};
var imagesReady = function(document2) {
  return Promise.all([].slice.call(document2.images, 0).map(imageReady));
};
var iframeLoader = function(iframe) {
  return new Promise(function(resolve, reject) {
    var cloneWindow = iframe.contentWindow;
    if (!cloneWindow) {
      return reject("No window assigned for iframe");
    }
    var documentClone = cloneWindow.document;
    cloneWindow.onload = iframe.onload = function() {
      cloneWindow.onload = iframe.onload = null;
      var interval = setInterval(function() {
        if (documentClone.body.childNodes.length > 0 && documentClone.readyState === "complete") {
          clearInterval(interval);
          resolve(iframe);
        }
      }, 50);
    };
  });
};
var ignoredStyleProperties = [
  "all",
  "d",
  "content"
];
var copyCSSStyles = function(style, target) {
  for (var i = style.length - 1; i >= 0; i--) {
    var property = style.item(i);
    if (ignoredStyleProperties.indexOf(property) === -1) {
      target.style.setProperty(property, style.getPropertyValue(property));
    }
  }
  return target;
};
var serializeDoctype = function(doctype) {
  var str = "";
  if (doctype) {
    str += "<!DOCTYPE ";
    if (doctype.name) {
      str += doctype.name;
    }
    if (doctype.internalSubset) {
      str += doctype.internalSubset;
    }
    if (doctype.publicId) {
      str += '"' + doctype.publicId + '"';
    }
    if (doctype.systemId) {
      str += '"' + doctype.systemId + '"';
    }
    str += ">";
  }
  return str;
};
var restoreOwnerScroll = function(ownerDocument, x, y) {
  if (ownerDocument && ownerDocument.defaultView && (x !== ownerDocument.defaultView.pageXOffset || y !== ownerDocument.defaultView.pageYOffset)) {
    ownerDocument.defaultView.scrollTo(x, y);
  }
};
var restoreNodeScroll = function(_a2) {
  var element = _a2[0], x = _a2[1], y = _a2[2];
  element.scrollLeft = x;
  element.scrollTop = y;
};
var PSEUDO_BEFORE = ":before";
var PSEUDO_AFTER = ":after";
var PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = "___html2canvas___pseudoelement_before";
var PSEUDO_HIDE_ELEMENT_CLASS_AFTER = "___html2canvas___pseudoelement_after";
var PSEUDO_HIDE_ELEMENT_STYLE = '{\n    content: "" !important;\n    display: none !important;\n}';
var createPseudoHideStyles = function(body) {
  createStyles(body, "." + PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + PSEUDO_BEFORE + PSEUDO_HIDE_ELEMENT_STYLE + "\n         ." + PSEUDO_HIDE_ELEMENT_CLASS_AFTER + PSEUDO_AFTER + PSEUDO_HIDE_ELEMENT_STYLE);
};
var createStyles = function(body, styles) {
  var document2 = body.ownerDocument;
  if (document2) {
    var style = document2.createElement("style");
    style.textContent = styles;
    body.appendChild(style);
  }
};
var CacheStorage = function() {
  function CacheStorage2() {
  }
  CacheStorage2.getOrigin = function(url) {
    var link = CacheStorage2._link;
    if (!link) {
      return "about:blank";
    }
    link.href = url;
    link.href = link.href;
    return link.protocol + link.hostname + link.port;
  };
  CacheStorage2.isSameOrigin = function(src) {
    return CacheStorage2.getOrigin(src) === CacheStorage2._origin;
  };
  CacheStorage2.setContext = function(window2) {
    CacheStorage2._link = window2.document.createElement("a");
    CacheStorage2._origin = CacheStorage2.getOrigin(window2.location.href);
  };
  CacheStorage2._origin = "about:blank";
  return CacheStorage2;
}();
var Cache = function() {
  function Cache2(context, _options) {
    this.context = context;
    this._options = _options;
    this._cache = {};
  }
  Cache2.prototype.addImage = function(src) {
    var result = Promise.resolve();
    if (this.has(src)) {
      return result;
    }
    if (isBlobImage(src) || isRenderable(src)) {
      (this._cache[src] = this.loadImage(src)).catch(function() {
      });
      return result;
    }
    return result;
  };
  Cache2.prototype.match = function(src) {
    return this._cache[src];
  };
  Cache2.prototype.loadImage = function(key) {
    return __awaiter(this, void 0, void 0, function() {
      var isSameOrigin, useCORS, useProxy, src;
      var _this = this;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            isSameOrigin = CacheStorage.isSameOrigin(key);
            useCORS = !isInlineImage(key) && this._options.useCORS === true && FEATURES.SUPPORT_CORS_IMAGES && !isSameOrigin;
            useProxy = !isInlineImage(key) && !isSameOrigin && !isBlobImage(key) && typeof this._options.proxy === "string" && FEATURES.SUPPORT_CORS_XHR && !useCORS;
            if (!isSameOrigin && this._options.allowTaint === false && !isInlineImage(key) && !isBlobImage(key) && !useProxy && !useCORS) {
              return [2];
            }
            src = key;
            if (!useProxy)
              return [3, 2];
            return [4, this.proxy(src)];
          case 1:
            src = _a2.sent();
            _a2.label = 2;
          case 2:
            this.context.logger.debug("Added image " + key.substring(0, 256));
            return [4, new Promise(function(resolve, reject) {
              var img = new Image();
              img.onload = function() {
                return resolve(img);
              };
              img.onerror = reject;
              if (isInlineBase64Image(src) || useCORS) {
                img.crossOrigin = "anonymous";
              }
              img.src = src;
              if (img.complete === true) {
                setTimeout(function() {
                  return resolve(img);
                }, 500);
              }
              if (_this._options.imageTimeout > 0) {
                setTimeout(function() {
                  return reject("Timed out (" + _this._options.imageTimeout + "ms) loading image");
                }, _this._options.imageTimeout);
              }
            })];
          case 3:
            return [2, _a2.sent()];
        }
      });
    });
  };
  Cache2.prototype.has = function(key) {
    return typeof this._cache[key] !== "undefined";
  };
  Cache2.prototype.keys = function() {
    return Promise.resolve(Object.keys(this._cache));
  };
  Cache2.prototype.proxy = function(src) {
    var _this = this;
    var proxy = this._options.proxy;
    if (!proxy) {
      throw new Error("No proxy defined");
    }
    var key = src.substring(0, 256);
    return new Promise(function(resolve, reject) {
      var responseType = FEATURES.SUPPORT_RESPONSE_TYPE ? "blob" : "text";
      var xhr2 = new XMLHttpRequest();
      xhr2.onload = function() {
        if (xhr2.status === 200) {
          if (responseType === "text") {
            resolve(xhr2.response);
          } else {
            var reader_1 = new FileReader();
            reader_1.addEventListener("load", function() {
              return resolve(reader_1.result);
            }, false);
            reader_1.addEventListener("error", function(e2) {
              return reject(e2);
            }, false);
            reader_1.readAsDataURL(xhr2.response);
          }
        } else {
          reject("Failed to proxy resource " + key + " with status code " + xhr2.status);
        }
      };
      xhr2.onerror = reject;
      var queryString = proxy.indexOf("?") > -1 ? "&" : "?";
      xhr2.open("GET", "" + proxy + queryString + "url=" + encodeURIComponent(src) + "&responseType=" + responseType);
      if (responseType !== "text" && xhr2 instanceof XMLHttpRequest) {
        xhr2.responseType = responseType;
      }
      if (_this._options.imageTimeout) {
        var timeout_1 = _this._options.imageTimeout;
        xhr2.timeout = timeout_1;
        xhr2.ontimeout = function() {
          return reject("Timed out (" + timeout_1 + "ms) proxying " + key);
        };
      }
      xhr2.send();
    });
  };
  return Cache2;
}();
var INLINE_SVG = /^data:image\/svg\+xml/i;
var INLINE_BASE64 = /^data:image\/.*;base64,/i;
var INLINE_IMG = /^data:image\/.*/i;
var isRenderable = function(src) {
  return FEATURES.SUPPORT_SVG_DRAWING || !isSVG(src);
};
var isInlineImage = function(src) {
  return INLINE_IMG.test(src);
};
var isInlineBase64Image = function(src) {
  return INLINE_BASE64.test(src);
};
var isBlobImage = function(src) {
  return src.substr(0, 4) === "blob";
};
var isSVG = function(src) {
  return src.substr(-3).toLowerCase() === "svg" || INLINE_SVG.test(src);
};
var Vector = function() {
  function Vector2(x, y) {
    this.type = 0;
    this.x = x;
    this.y = y;
  }
  Vector2.prototype.add = function(deltaX, deltaY) {
    return new Vector2(this.x + deltaX, this.y + deltaY);
  };
  return Vector2;
}();
var lerp = function(a2, b, t) {
  return new Vector(a2.x + (b.x - a2.x) * t, a2.y + (b.y - a2.y) * t);
};
var BezierCurve = function() {
  function BezierCurve2(start, startControl, endControl, end) {
    this.type = 1;
    this.start = start;
    this.startControl = startControl;
    this.endControl = endControl;
    this.end = end;
  }
  BezierCurve2.prototype.subdivide = function(t, firstHalf) {
    var ab = lerp(this.start, this.startControl, t);
    var bc = lerp(this.startControl, this.endControl, t);
    var cd = lerp(this.endControl, this.end, t);
    var abbc = lerp(ab, bc, t);
    var bccd = lerp(bc, cd, t);
    var dest = lerp(abbc, bccd, t);
    return firstHalf ? new BezierCurve2(this.start, ab, abbc, dest) : new BezierCurve2(dest, bccd, cd, this.end);
  };
  BezierCurve2.prototype.add = function(deltaX, deltaY) {
    return new BezierCurve2(this.start.add(deltaX, deltaY), this.startControl.add(deltaX, deltaY), this.endControl.add(deltaX, deltaY), this.end.add(deltaX, deltaY));
  };
  BezierCurve2.prototype.reverse = function() {
    return new BezierCurve2(this.end, this.endControl, this.startControl, this.start);
  };
  return BezierCurve2;
}();
var isBezierCurve = function(path) {
  return path.type === 1;
};
var BoundCurves = function() {
  function BoundCurves2(element) {
    var styles = element.styles;
    var bounds = element.bounds;
    var _a2 = getAbsoluteValueForTuple(styles.borderTopLeftRadius, bounds.width, bounds.height), tlh = _a2[0], tlv = _a2[1];
    var _b = getAbsoluteValueForTuple(styles.borderTopRightRadius, bounds.width, bounds.height), trh = _b[0], trv = _b[1];
    var _c = getAbsoluteValueForTuple(styles.borderBottomRightRadius, bounds.width, bounds.height), brh = _c[0], brv = _c[1];
    var _d = getAbsoluteValueForTuple(styles.borderBottomLeftRadius, bounds.width, bounds.height), blh = _d[0], blv = _d[1];
    var factors = [];
    factors.push((tlh + trh) / bounds.width);
    factors.push((blh + brh) / bounds.width);
    factors.push((tlv + blv) / bounds.height);
    factors.push((trv + brv) / bounds.height);
    var maxFactor = Math.max.apply(Math, factors);
    if (maxFactor > 1) {
      tlh /= maxFactor;
      tlv /= maxFactor;
      trh /= maxFactor;
      trv /= maxFactor;
      brh /= maxFactor;
      brv /= maxFactor;
      blh /= maxFactor;
      blv /= maxFactor;
    }
    var topWidth = bounds.width - trh;
    var rightHeight = bounds.height - brv;
    var bottomWidth = bounds.width - brh;
    var leftHeight = bounds.height - blv;
    var borderTopWidth2 = styles.borderTopWidth;
    var borderRightWidth2 = styles.borderRightWidth;
    var borderBottomWidth2 = styles.borderBottomWidth;
    var borderLeftWidth2 = styles.borderLeftWidth;
    var paddingTop2 = getAbsoluteValue(styles.paddingTop, element.bounds.width);
    var paddingRight2 = getAbsoluteValue(styles.paddingRight, element.bounds.width);
    var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, element.bounds.width);
    var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, element.bounds.width);
    this.topLeftBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3, tlh - borderLeftWidth2 / 3, tlv - borderTopWidth2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + borderTopWidth2 / 3);
    this.topRightBorderDoubleOuterBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 3, trh - borderRightWidth2 / 3, trv - borderTopWidth2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + borderTopWidth2 / 3);
    this.bottomRightBorderDoubleOuterBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 3, brv - borderBottomWidth2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
    this.bottomLeftBorderDoubleOuterBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 / 3, blv - borderBottomWidth2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 3, bounds.top + bounds.height - borderBottomWidth2 / 3);
    this.topLeftBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3, tlh - borderLeftWidth2 * 2 / 3, tlv - borderTopWidth2 * 2 / 3, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
    this.topRightBorderDoubleInnerBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 * 2 / 3, trh - borderRightWidth2 * 2 / 3, trv - borderTopWidth2 * 2 / 3, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + borderTopWidth2 * 2 / 3);
    this.bottomRightBorderDoubleInnerBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 * 2 / 3, brv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
    this.bottomLeftBorderDoubleInnerBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + leftHeight, blh - borderLeftWidth2 * 2 / 3, blv - borderBottomWidth2 * 2 / 3, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 * 2 / 3, bounds.top + bounds.height - borderBottomWidth2 * 2 / 3);
    this.topLeftBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2, tlh - borderLeftWidth2 / 2, tlv - borderTopWidth2 / 2, CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + borderTopWidth2 / 2);
    this.topRightBorderStroke = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top + borderTopWidth2 / 2, trh - borderRightWidth2 / 2, trv - borderTopWidth2 / 2, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + borderTopWidth2 / 2);
    this.bottomRightBorderStroke = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh - borderRightWidth2 / 2, brv - borderBottomWidth2 / 2, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
    this.bottomLeftBorderStroke = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 / 2, bounds.top + leftHeight, blh - borderLeftWidth2 / 2, blv - borderBottomWidth2 / 2, CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 / 2, bounds.top + bounds.height - borderBottomWidth2 / 2);
    this.topLeftBorderBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left, bounds.top, tlh, tlv, CORNER.TOP_LEFT) : new Vector(bounds.left, bounds.top);
    this.topRightBorderBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + topWidth, bounds.top, trh, trv, CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top);
    this.bottomRightBorderBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + bottomWidth, bounds.top + rightHeight, brh, brv, CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width, bounds.top + bounds.height);
    this.bottomLeftBorderBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left, bounds.top + leftHeight, blh, blv, CORNER.BOTTOM_LEFT) : new Vector(bounds.left, bounds.top + bounds.height);
    this.topLeftPaddingBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2, Math.max(0, tlh - borderLeftWidth2), Math.max(0, tlv - borderTopWidth2), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + borderTopWidth2);
    this.topRightPaddingBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width - borderRightWidth2), bounds.top + borderTopWidth2, topWidth > bounds.width + borderRightWidth2 ? 0 : Math.max(0, trh - borderRightWidth2), Math.max(0, trv - borderTopWidth2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + borderTopWidth2);
    this.bottomRightPaddingBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - borderLeftWidth2), bounds.top + Math.min(rightHeight, bounds.height - borderBottomWidth2), Math.max(0, brh - borderRightWidth2), Math.max(0, brv - borderBottomWidth2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - borderRightWidth2, bounds.top + bounds.height - borderBottomWidth2);
    this.bottomLeftPaddingBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2, bounds.top + Math.min(leftHeight, bounds.height - borderBottomWidth2), Math.max(0, blh - borderLeftWidth2), Math.max(0, blv - borderBottomWidth2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2, bounds.top + bounds.height - borderBottomWidth2);
    this.topLeftContentBox = tlh > 0 || tlv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2, Math.max(0, tlh - (borderLeftWidth2 + paddingLeft2)), Math.max(0, tlv - (borderTopWidth2 + paddingTop2)), CORNER.TOP_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + borderTopWidth2 + paddingTop2);
    this.topRightContentBox = trh > 0 || trv > 0 ? getCurvePoints(bounds.left + Math.min(topWidth, bounds.width + borderLeftWidth2 + paddingLeft2), bounds.top + borderTopWidth2 + paddingTop2, topWidth > bounds.width + borderLeftWidth2 + paddingLeft2 ? 0 : trh - borderLeftWidth2 + paddingLeft2, trv - (borderTopWidth2 + paddingTop2), CORNER.TOP_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + borderTopWidth2 + paddingTop2);
    this.bottomRightContentBox = brh > 0 || brv > 0 ? getCurvePoints(bounds.left + Math.min(bottomWidth, bounds.width - (borderLeftWidth2 + paddingLeft2)), bounds.top + Math.min(rightHeight, bounds.height + borderTopWidth2 + paddingTop2), Math.max(0, brh - (borderRightWidth2 + paddingRight2)), brv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_RIGHT) : new Vector(bounds.left + bounds.width - (borderRightWidth2 + paddingRight2), bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
    this.bottomLeftContentBox = blh > 0 || blv > 0 ? getCurvePoints(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + leftHeight, Math.max(0, blh - (borderLeftWidth2 + paddingLeft2)), blv - (borderBottomWidth2 + paddingBottom2), CORNER.BOTTOM_LEFT) : new Vector(bounds.left + borderLeftWidth2 + paddingLeft2, bounds.top + bounds.height - (borderBottomWidth2 + paddingBottom2));
  }
  return BoundCurves2;
}();
var CORNER;
(function(CORNER2) {
  CORNER2[CORNER2["TOP_LEFT"] = 0] = "TOP_LEFT";
  CORNER2[CORNER2["TOP_RIGHT"] = 1] = "TOP_RIGHT";
  CORNER2[CORNER2["BOTTOM_RIGHT"] = 2] = "BOTTOM_RIGHT";
  CORNER2[CORNER2["BOTTOM_LEFT"] = 3] = "BOTTOM_LEFT";
})(CORNER || (CORNER = {}));
var getCurvePoints = function(x, y, r1, r2, position2) {
  var kappa = 4 * ((Math.sqrt(2) - 1) / 3);
  var ox = r1 * kappa;
  var oy = r2 * kappa;
  var xm = x + r1;
  var ym = y + r2;
  switch (position2) {
    case CORNER.TOP_LEFT:
      return new BezierCurve(new Vector(x, ym), new Vector(x, ym - oy), new Vector(xm - ox, y), new Vector(xm, y));
    case CORNER.TOP_RIGHT:
      return new BezierCurve(new Vector(x, y), new Vector(x + ox, y), new Vector(xm, ym - oy), new Vector(xm, ym));
    case CORNER.BOTTOM_RIGHT:
      return new BezierCurve(new Vector(xm, y), new Vector(xm, y + oy), new Vector(x + ox, ym), new Vector(x, ym));
    case CORNER.BOTTOM_LEFT:
    default:
      return new BezierCurve(new Vector(xm, ym), new Vector(xm - ox, ym), new Vector(x, y + oy), new Vector(x, y));
  }
};
var calculateBorderBoxPath = function(curves) {
  return [curves.topLeftBorderBox, curves.topRightBorderBox, curves.bottomRightBorderBox, curves.bottomLeftBorderBox];
};
var calculateContentBoxPath = function(curves) {
  return [
    curves.topLeftContentBox,
    curves.topRightContentBox,
    curves.bottomRightContentBox,
    curves.bottomLeftContentBox
  ];
};
var calculatePaddingBoxPath = function(curves) {
  return [
    curves.topLeftPaddingBox,
    curves.topRightPaddingBox,
    curves.bottomRightPaddingBox,
    curves.bottomLeftPaddingBox
  ];
};
var TransformEffect = function() {
  function TransformEffect2(offsetX, offsetY, matrix2) {
    this.offsetX = offsetX;
    this.offsetY = offsetY;
    this.matrix = matrix2;
    this.type = 0;
    this.target = 2 | 4;
  }
  return TransformEffect2;
}();
var ClipEffect = function() {
  function ClipEffect2(path, target) {
    this.path = path;
    this.target = target;
    this.type = 1;
  }
  return ClipEffect2;
}();
var OpacityEffect = function() {
  function OpacityEffect2(opacity2) {
    this.opacity = opacity2;
    this.type = 2;
    this.target = 2 | 4;
  }
  return OpacityEffect2;
}();
var isTransformEffect = function(effect) {
  return effect.type === 0;
};
var isClipEffect = function(effect) {
  return effect.type === 1;
};
var isOpacityEffect = function(effect) {
  return effect.type === 2;
};
var equalPath = function(a2, b) {
  if (a2.length === b.length) {
    return a2.some(function(v, i) {
      return v === b[i];
    });
  }
  return false;
};
var transformPath = function(path, deltaX, deltaY, deltaW, deltaH) {
  return path.map(function(point, index2) {
    switch (index2) {
      case 0:
        return point.add(deltaX, deltaY);
      case 1:
        return point.add(deltaX + deltaW, deltaY);
      case 2:
        return point.add(deltaX + deltaW, deltaY + deltaH);
      case 3:
        return point.add(deltaX, deltaY + deltaH);
    }
    return point;
  });
};
var StackingContext = function() {
  function StackingContext2(container) {
    this.element = container;
    this.inlineLevel = [];
    this.nonInlineLevel = [];
    this.negativeZIndex = [];
    this.zeroOrAutoZIndexOrTransformedOrOpacity = [];
    this.positiveZIndex = [];
    this.nonPositionedFloats = [];
    this.nonPositionedInlineLevel = [];
  }
  return StackingContext2;
}();
var ElementPaint = function() {
  function ElementPaint2(container, parent) {
    this.container = container;
    this.parent = parent;
    this.effects = [];
    this.curves = new BoundCurves(this.container);
    if (this.container.styles.opacity < 1) {
      this.effects.push(new OpacityEffect(this.container.styles.opacity));
    }
    if (this.container.styles.transform !== null) {
      var offsetX = this.container.bounds.left + this.container.styles.transformOrigin[0].number;
      var offsetY = this.container.bounds.top + this.container.styles.transformOrigin[1].number;
      var matrix2 = this.container.styles.transform;
      this.effects.push(new TransformEffect(offsetX, offsetY, matrix2));
    }
    if (this.container.styles.overflowX !== 0) {
      var borderBox = calculateBorderBoxPath(this.curves);
      var paddingBox2 = calculatePaddingBoxPath(this.curves);
      if (equalPath(borderBox, paddingBox2)) {
        this.effects.push(new ClipEffect(borderBox, 2 | 4));
      } else {
        this.effects.push(new ClipEffect(borderBox, 2));
        this.effects.push(new ClipEffect(paddingBox2, 4));
      }
    }
  }
  ElementPaint2.prototype.getEffects = function(target) {
    var inFlow = [2, 3].indexOf(this.container.styles.position) === -1;
    var parent = this.parent;
    var effects = this.effects.slice(0);
    while (parent) {
      var croplessEffects = parent.effects.filter(function(effect) {
        return !isClipEffect(effect);
      });
      if (inFlow || parent.container.styles.position !== 0 || !parent.parent) {
        effects.unshift.apply(effects, croplessEffects);
        inFlow = [2, 3].indexOf(parent.container.styles.position) === -1;
        if (parent.container.styles.overflowX !== 0) {
          var borderBox = calculateBorderBoxPath(parent.curves);
          var paddingBox2 = calculatePaddingBoxPath(parent.curves);
          if (!equalPath(borderBox, paddingBox2)) {
            effects.unshift(new ClipEffect(paddingBox2, 2 | 4));
          }
        }
      } else {
        effects.unshift.apply(effects, croplessEffects);
      }
      parent = parent.parent;
    }
    return effects.filter(function(effect) {
      return contains(effect.target, target);
    });
  };
  return ElementPaint2;
}();
var parseStackTree = function(parent, stackingContext, realStackingContext, listItems) {
  parent.container.elements.forEach(function(child) {
    var treatAsRealStackingContext = contains(child.flags, 4);
    var createsStackingContext2 = contains(child.flags, 2);
    var paintContainer = new ElementPaint(child, parent);
    if (contains(child.styles.display, 2048)) {
      listItems.push(paintContainer);
    }
    var listOwnerItems = contains(child.flags, 8) ? [] : listItems;
    if (treatAsRealStackingContext || createsStackingContext2) {
      var parentStack = treatAsRealStackingContext || child.styles.isPositioned() ? realStackingContext : stackingContext;
      var stack = new StackingContext(paintContainer);
      if (child.styles.isPositioned() || child.styles.opacity < 1 || child.styles.isTransformed()) {
        var order_1 = child.styles.zIndex.order;
        if (order_1 < 0) {
          var index_1 = 0;
          parentStack.negativeZIndex.some(function(current, i) {
            if (order_1 > current.element.container.styles.zIndex.order) {
              index_1 = i;
              return false;
            } else if (index_1 > 0) {
              return true;
            }
            return false;
          });
          parentStack.negativeZIndex.splice(index_1, 0, stack);
        } else if (order_1 > 0) {
          var index_2 = 0;
          parentStack.positiveZIndex.some(function(current, i) {
            if (order_1 >= current.element.container.styles.zIndex.order) {
              index_2 = i + 1;
              return false;
            } else if (index_2 > 0) {
              return true;
            }
            return false;
          });
          parentStack.positiveZIndex.splice(index_2, 0, stack);
        } else {
          parentStack.zeroOrAutoZIndexOrTransformedOrOpacity.push(stack);
        }
      } else {
        if (child.styles.isFloating()) {
          parentStack.nonPositionedFloats.push(stack);
        } else {
          parentStack.nonPositionedInlineLevel.push(stack);
        }
      }
      parseStackTree(paintContainer, stack, treatAsRealStackingContext ? stack : realStackingContext, listOwnerItems);
    } else {
      if (child.styles.isInlineLevel()) {
        stackingContext.inlineLevel.push(paintContainer);
      } else {
        stackingContext.nonInlineLevel.push(paintContainer);
      }
      parseStackTree(paintContainer, stackingContext, realStackingContext, listOwnerItems);
    }
    if (contains(child.flags, 8)) {
      processListItems(child, listOwnerItems);
    }
  });
};
var processListItems = function(owner, elements) {
  var numbering = owner instanceof OLElementContainer ? owner.start : 1;
  var reversed = owner instanceof OLElementContainer ? owner.reversed : false;
  for (var i = 0; i < elements.length; i++) {
    var item = elements[i];
    if (item.container instanceof LIElementContainer && typeof item.container.value === "number" && item.container.value !== 0) {
      numbering = item.container.value;
    }
    item.listValue = createCounterText(numbering, item.container.styles.listStyleType, true);
    numbering += reversed ? -1 : 1;
  }
};
var parseStackingContexts = function(container) {
  var paintContainer = new ElementPaint(container, null);
  var root = new StackingContext(paintContainer);
  var listItems = [];
  parseStackTree(paintContainer, root, root, listItems);
  processListItems(paintContainer.container, listItems);
  return root;
};
var parsePathForBorder = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftPaddingBox, curves.topRightBorderBox, curves.topRightPaddingBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderBox, curves.topRightPaddingBox, curves.bottomRightBorderBox, curves.bottomRightPaddingBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftPaddingBox, curves.topLeftBorderBox, curves.topLeftPaddingBox);
  }
};
var parsePathForBorderDoubleOuter = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox, curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderBox, curves.topRightBorderDoubleOuterBox, curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderBox, curves.bottomRightBorderDoubleOuterBox, curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderBox, curves.bottomLeftBorderDoubleOuterBox, curves.topLeftBorderBox, curves.topLeftBorderDoubleOuterBox);
  }
};
var parsePathForBorderDoubleInner = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createPathFromCurves(curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox, curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox);
    case 1:
      return createPathFromCurves(curves.topRightBorderDoubleInnerBox, curves.topRightPaddingBox, curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox);
    case 2:
      return createPathFromCurves(curves.bottomRightBorderDoubleInnerBox, curves.bottomRightPaddingBox, curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox);
    case 3:
    default:
      return createPathFromCurves(curves.bottomLeftBorderDoubleInnerBox, curves.bottomLeftPaddingBox, curves.topLeftBorderDoubleInnerBox, curves.topLeftPaddingBox);
  }
};
var parsePathForBorderStroke = function(curves, borderSide) {
  switch (borderSide) {
    case 0:
      return createStrokePathFromCurves(curves.topLeftBorderStroke, curves.topRightBorderStroke);
    case 1:
      return createStrokePathFromCurves(curves.topRightBorderStroke, curves.bottomRightBorderStroke);
    case 2:
      return createStrokePathFromCurves(curves.bottomRightBorderStroke, curves.bottomLeftBorderStroke);
    case 3:
    default:
      return createStrokePathFromCurves(curves.bottomLeftBorderStroke, curves.topLeftBorderStroke);
  }
};
var createStrokePathFromCurves = function(outer1, outer2) {
  var path = [];
  if (isBezierCurve(outer1)) {
    path.push(outer1.subdivide(0.5, false));
  } else {
    path.push(outer1);
  }
  if (isBezierCurve(outer2)) {
    path.push(outer2.subdivide(0.5, true));
  } else {
    path.push(outer2);
  }
  return path;
};
var createPathFromCurves = function(outer1, inner1, outer2, inner2) {
  var path = [];
  if (isBezierCurve(outer1)) {
    path.push(outer1.subdivide(0.5, false));
  } else {
    path.push(outer1);
  }
  if (isBezierCurve(outer2)) {
    path.push(outer2.subdivide(0.5, true));
  } else {
    path.push(outer2);
  }
  if (isBezierCurve(inner2)) {
    path.push(inner2.subdivide(0.5, true).reverse());
  } else {
    path.push(inner2);
  }
  if (isBezierCurve(inner1)) {
    path.push(inner1.subdivide(0.5, false).reverse());
  } else {
    path.push(inner1);
  }
  return path;
};
var paddingBox = function(element) {
  var bounds = element.bounds;
  var styles = element.styles;
  return bounds.add(styles.borderLeftWidth, styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth), -(styles.borderTopWidth + styles.borderBottomWidth));
};
var contentBox = function(element) {
  var styles = element.styles;
  var bounds = element.bounds;
  var paddingLeft2 = getAbsoluteValue(styles.paddingLeft, bounds.width);
  var paddingRight2 = getAbsoluteValue(styles.paddingRight, bounds.width);
  var paddingTop2 = getAbsoluteValue(styles.paddingTop, bounds.width);
  var paddingBottom2 = getAbsoluteValue(styles.paddingBottom, bounds.width);
  return bounds.add(paddingLeft2 + styles.borderLeftWidth, paddingTop2 + styles.borderTopWidth, -(styles.borderRightWidth + styles.borderLeftWidth + paddingLeft2 + paddingRight2), -(styles.borderTopWidth + styles.borderBottomWidth + paddingTop2 + paddingBottom2));
};
var calculateBackgroundPositioningArea = function(backgroundOrigin2, element) {
  if (backgroundOrigin2 === 0) {
    return element.bounds;
  }
  if (backgroundOrigin2 === 2) {
    return contentBox(element);
  }
  return paddingBox(element);
};
var calculateBackgroundPaintingArea = function(backgroundClip2, element) {
  if (backgroundClip2 === 0) {
    return element.bounds;
  }
  if (backgroundClip2 === 2) {
    return contentBox(element);
  }
  return paddingBox(element);
};
var calculateBackgroundRendering = function(container, index2, intrinsicSize) {
  var backgroundPositioningArea = calculateBackgroundPositioningArea(getBackgroundValueForIndex(container.styles.backgroundOrigin, index2), container);
  var backgroundPaintingArea = calculateBackgroundPaintingArea(getBackgroundValueForIndex(container.styles.backgroundClip, index2), container);
  var backgroundImageSize = calculateBackgroundSize(getBackgroundValueForIndex(container.styles.backgroundSize, index2), intrinsicSize, backgroundPositioningArea);
  var sizeWidth = backgroundImageSize[0], sizeHeight = backgroundImageSize[1];
  var position2 = getAbsoluteValueForTuple(getBackgroundValueForIndex(container.styles.backgroundPosition, index2), backgroundPositioningArea.width - sizeWidth, backgroundPositioningArea.height - sizeHeight);
  var path = calculateBackgroundRepeatPath(getBackgroundValueForIndex(container.styles.backgroundRepeat, index2), position2, backgroundImageSize, backgroundPositioningArea, backgroundPaintingArea);
  var offsetX = Math.round(backgroundPositioningArea.left + position2[0]);
  var offsetY = Math.round(backgroundPositioningArea.top + position2[1]);
  return [path, offsetX, offsetY, sizeWidth, sizeHeight];
};
var isAuto = function(token) {
  return isIdentToken(token) && token.value === BACKGROUND_SIZE.AUTO;
};
var hasIntrinsicValue = function(value) {
  return typeof value === "number";
};
var calculateBackgroundSize = function(size, _a2, bounds) {
  var intrinsicWidth = _a2[0], intrinsicHeight = _a2[1], intrinsicProportion = _a2[2];
  var first = size[0], second = size[1];
  if (!first) {
    return [0, 0];
  }
  if (isLengthPercentage(first) && second && isLengthPercentage(second)) {
    return [getAbsoluteValue(first, bounds.width), getAbsoluteValue(second, bounds.height)];
  }
  var hasIntrinsicProportion = hasIntrinsicValue(intrinsicProportion);
  if (isIdentToken(first) && (first.value === BACKGROUND_SIZE.CONTAIN || first.value === BACKGROUND_SIZE.COVER)) {
    if (hasIntrinsicValue(intrinsicProportion)) {
      var targetRatio = bounds.width / bounds.height;
      return targetRatio < intrinsicProportion !== (first.value === BACKGROUND_SIZE.COVER) ? [bounds.width, bounds.width / intrinsicProportion] : [bounds.height * intrinsicProportion, bounds.height];
    }
    return [bounds.width, bounds.height];
  }
  var hasIntrinsicWidth = hasIntrinsicValue(intrinsicWidth);
  var hasIntrinsicHeight = hasIntrinsicValue(intrinsicHeight);
  var hasIntrinsicDimensions = hasIntrinsicWidth || hasIntrinsicHeight;
  if (isAuto(first) && (!second || isAuto(second))) {
    if (hasIntrinsicWidth && hasIntrinsicHeight) {
      return [intrinsicWidth, intrinsicHeight];
    }
    if (!hasIntrinsicProportion && !hasIntrinsicDimensions) {
      return [bounds.width, bounds.height];
    }
    if (hasIntrinsicDimensions && hasIntrinsicProportion) {
      var width_1 = hasIntrinsicWidth ? intrinsicWidth : intrinsicHeight * intrinsicProportion;
      var height_1 = hasIntrinsicHeight ? intrinsicHeight : intrinsicWidth / intrinsicProportion;
      return [width_1, height_1];
    }
    var width_2 = hasIntrinsicWidth ? intrinsicWidth : bounds.width;
    var height_2 = hasIntrinsicHeight ? intrinsicHeight : bounds.height;
    return [width_2, height_2];
  }
  if (hasIntrinsicProportion) {
    var width_3 = 0;
    var height_3 = 0;
    if (isLengthPercentage(first)) {
      width_3 = getAbsoluteValue(first, bounds.width);
    } else if (isLengthPercentage(second)) {
      height_3 = getAbsoluteValue(second, bounds.height);
    }
    if (isAuto(first)) {
      width_3 = height_3 * intrinsicProportion;
    } else if (!second || isAuto(second)) {
      height_3 = width_3 / intrinsicProportion;
    }
    return [width_3, height_3];
  }
  var width = null;
  var height = null;
  if (isLengthPercentage(first)) {
    width = getAbsoluteValue(first, bounds.width);
  } else if (second && isLengthPercentage(second)) {
    height = getAbsoluteValue(second, bounds.height);
  }
  if (width !== null && (!second || isAuto(second))) {
    height = hasIntrinsicWidth && hasIntrinsicHeight ? width / intrinsicWidth * intrinsicHeight : bounds.height;
  }
  if (height !== null && isAuto(first)) {
    width = hasIntrinsicWidth && hasIntrinsicHeight ? height / intrinsicHeight * intrinsicWidth : bounds.width;
  }
  if (width !== null && height !== null) {
    return [width, height];
  }
  throw new Error("Unable to calculate background-size for element");
};
var getBackgroundValueForIndex = function(values, index2) {
  var value = values[index2];
  if (typeof value === "undefined") {
    return values[0];
  }
  return value;
};
var calculateBackgroundRepeatPath = function(repeat, _a2, _b, backgroundPositioningArea, backgroundPaintingArea) {
  var x = _a2[0], y = _a2[1];
  var width = _b[0], height = _b[1];
  switch (repeat) {
    case 2:
      return [
        new Vector(Math.round(backgroundPositioningArea.left), Math.round(backgroundPositioningArea.top + y)),
        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(backgroundPositioningArea.top + y)),
        new Vector(Math.round(backgroundPositioningArea.left + backgroundPositioningArea.width), Math.round(height + backgroundPositioningArea.top + y)),
        new Vector(Math.round(backgroundPositioningArea.left), Math.round(height + backgroundPositioningArea.top + y))
      ];
    case 3:
      return [
        new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top)),
        new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.height + backgroundPositioningArea.top))
      ];
    case 1:
      return [
        new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y)),
        new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y)),
        new Vector(Math.round(backgroundPositioningArea.left + x + width), Math.round(backgroundPositioningArea.top + y + height)),
        new Vector(Math.round(backgroundPositioningArea.left + x), Math.round(backgroundPositioningArea.top + y + height))
      ];
    default:
      return [
        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left + backgroundPaintingArea.width), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top)),
        new Vector(Math.round(backgroundPaintingArea.left), Math.round(backgroundPaintingArea.height + backgroundPaintingArea.top))
      ];
  }
};
var SMALL_IMAGE = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
var SAMPLE_TEXT = "Hidden Text";
var FontMetrics = function() {
  function FontMetrics2(document2) {
    this._data = {};
    this._document = document2;
  }
  FontMetrics2.prototype.parseMetrics = function(fontFamily2, fontSize2) {
    var container = this._document.createElement("div");
    var img = this._document.createElement("img");
    var span = this._document.createElement("span");
    var body = this._document.body;
    container.style.visibility = "hidden";
    container.style.fontFamily = fontFamily2;
    container.style.fontSize = fontSize2;
    container.style.margin = "0";
    container.style.padding = "0";
    container.style.whiteSpace = "nowrap";
    body.appendChild(container);
    img.src = SMALL_IMAGE;
    img.width = 1;
    img.height = 1;
    img.style.margin = "0";
    img.style.padding = "0";
    img.style.verticalAlign = "baseline";
    span.style.fontFamily = fontFamily2;
    span.style.fontSize = fontSize2;
    span.style.margin = "0";
    span.style.padding = "0";
    span.appendChild(this._document.createTextNode(SAMPLE_TEXT));
    container.appendChild(span);
    container.appendChild(img);
    var baseline = img.offsetTop - span.offsetTop + 2;
    container.removeChild(span);
    container.appendChild(this._document.createTextNode(SAMPLE_TEXT));
    container.style.lineHeight = "normal";
    img.style.verticalAlign = "super";
    var middle = img.offsetTop - container.offsetTop + 2;
    body.removeChild(container);
    return { baseline, middle };
  };
  FontMetrics2.prototype.getMetrics = function(fontFamily2, fontSize2) {
    var key = fontFamily2 + " " + fontSize2;
    if (typeof this._data[key] === "undefined") {
      this._data[key] = this.parseMetrics(fontFamily2, fontSize2);
    }
    return this._data[key];
  };
  return FontMetrics2;
}();
var Renderer = function() {
  function Renderer2(context, options) {
    this.context = context;
    this.options = options;
  }
  return Renderer2;
}();
var MASK_OFFSET = 1e4;
var CanvasRenderer = function(_super) {
  __extends(CanvasRenderer2, _super);
  function CanvasRenderer2(context, options) {
    var _this = _super.call(this, context, options) || this;
    _this._activeEffects = [];
    _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
    _this.ctx = _this.canvas.getContext("2d");
    if (!options.canvas) {
      _this.canvas.width = Math.floor(options.width * options.scale);
      _this.canvas.height = Math.floor(options.height * options.scale);
      _this.canvas.style.width = options.width + "px";
      _this.canvas.style.height = options.height + "px";
    }
    _this.fontMetrics = new FontMetrics(document);
    _this.ctx.scale(_this.options.scale, _this.options.scale);
    _this.ctx.translate(-options.x, -options.y);
    _this.ctx.textBaseline = "bottom";
    _this._activeEffects = [];
    _this.context.logger.debug("Canvas renderer initialized (" + options.width + "x" + options.height + ") with scale " + options.scale);
    return _this;
  }
  CanvasRenderer2.prototype.applyEffects = function(effects) {
    var _this = this;
    while (this._activeEffects.length) {
      this.popEffect();
    }
    effects.forEach(function(effect) {
      return _this.applyEffect(effect);
    });
  };
  CanvasRenderer2.prototype.applyEffect = function(effect) {
    this.ctx.save();
    if (isOpacityEffect(effect)) {
      this.ctx.globalAlpha = effect.opacity;
    }
    if (isTransformEffect(effect)) {
      this.ctx.translate(effect.offsetX, effect.offsetY);
      this.ctx.transform(effect.matrix[0], effect.matrix[1], effect.matrix[2], effect.matrix[3], effect.matrix[4], effect.matrix[5]);
      this.ctx.translate(-effect.offsetX, -effect.offsetY);
    }
    if (isClipEffect(effect)) {
      this.path(effect.path);
      this.ctx.clip();
    }
    this._activeEffects.push(effect);
  };
  CanvasRenderer2.prototype.popEffect = function() {
    this._activeEffects.pop();
    this.ctx.restore();
  };
  CanvasRenderer2.prototype.renderStack = function(stack) {
    return __awaiter(this, void 0, void 0, function() {
      var styles;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            styles = stack.element.container.styles;
            if (!styles.isVisible())
              return [3, 2];
            return [4, this.renderStackContent(stack)];
          case 1:
            _a2.sent();
            _a2.label = 2;
          case 2:
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.renderNode = function(paint) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (contains(paint.container.flags, 16)) {
              debugger;
            }
            if (!paint.container.styles.isVisible())
              return [3, 3];
            return [4, this.renderNodeBackgroundAndBorders(paint)];
          case 1:
            _a2.sent();
            return [4, this.renderNodeContent(paint)];
          case 2:
            _a2.sent();
            _a2.label = 3;
          case 3:
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.renderTextWithLetterSpacing = function(text, letterSpacing2, baseline) {
    var _this = this;
    if (letterSpacing2 === 0) {
      this.ctx.fillText(text.text, text.bounds.left, text.bounds.top + baseline);
    } else {
      var letters = segmentGraphemes(text.text);
      letters.reduce(function(left, letter) {
        _this.ctx.fillText(letter, left, text.bounds.top + baseline);
        return left + _this.ctx.measureText(letter).width;
      }, text.bounds.left);
    }
  };
  CanvasRenderer2.prototype.createFontStyle = function(styles) {
    var fontVariant2 = styles.fontVariant.filter(function(variant) {
      return variant === "normal" || variant === "small-caps";
    }).join("");
    var fontFamily2 = fixIOSSystemFonts(styles.fontFamily).join(", ");
    var fontSize2 = isDimensionToken(styles.fontSize) ? "" + styles.fontSize.number + styles.fontSize.unit : styles.fontSize.number + "px";
    return [
      [styles.fontStyle, fontVariant2, styles.fontWeight, fontSize2, fontFamily2].join(" "),
      fontFamily2,
      fontSize2
    ];
  };
  CanvasRenderer2.prototype.renderTextNode = function(text, styles) {
    return __awaiter(this, void 0, void 0, function() {
      var _a2, font, fontFamily2, fontSize2, _b, baseline, middle, paintOrder2;
      var _this = this;
      return __generator(this, function(_c) {
        _a2 = this.createFontStyle(styles), font = _a2[0], fontFamily2 = _a2[1], fontSize2 = _a2[2];
        this.ctx.font = font;
        this.ctx.direction = styles.direction === 1 ? "rtl" : "ltr";
        this.ctx.textAlign = "left";
        this.ctx.textBaseline = "alphabetic";
        _b = this.fontMetrics.getMetrics(fontFamily2, fontSize2), baseline = _b.baseline, middle = _b.middle;
        paintOrder2 = styles.paintOrder;
        text.textBounds.forEach(function(text2) {
          paintOrder2.forEach(function(paintOrderLayer) {
            switch (paintOrderLayer) {
              case 0:
                _this.ctx.fillStyle = asString(styles.color);
                _this.renderTextWithLetterSpacing(text2, styles.letterSpacing, baseline);
                var textShadows = styles.textShadow;
                if (textShadows.length && text2.text.trim().length) {
                  textShadows.slice(0).reverse().forEach(function(textShadow2) {
                    _this.ctx.shadowColor = asString(textShadow2.color);
                    _this.ctx.shadowOffsetX = textShadow2.offsetX.number * _this.options.scale;
                    _this.ctx.shadowOffsetY = textShadow2.offsetY.number * _this.options.scale;
                    _this.ctx.shadowBlur = textShadow2.blur.number;
                    _this.renderTextWithLetterSpacing(text2, styles.letterSpacing, baseline);
                  });
                  _this.ctx.shadowColor = "";
                  _this.ctx.shadowOffsetX = 0;
                  _this.ctx.shadowOffsetY = 0;
                  _this.ctx.shadowBlur = 0;
                }
                if (styles.textDecorationLine.length) {
                  _this.ctx.fillStyle = asString(styles.textDecorationColor || styles.color);
                  styles.textDecorationLine.forEach(function(textDecorationLine2) {
                    switch (textDecorationLine2) {
                      case 1:
                        _this.ctx.fillRect(text2.bounds.left, Math.round(text2.bounds.top + baseline), text2.bounds.width, 1);
                        break;
                      case 2:
                        _this.ctx.fillRect(text2.bounds.left, Math.round(text2.bounds.top), text2.bounds.width, 1);
                        break;
                      case 3:
                        _this.ctx.fillRect(text2.bounds.left, Math.ceil(text2.bounds.top + middle), text2.bounds.width, 1);
                        break;
                    }
                  });
                }
                break;
              case 1:
                if (styles.webkitTextStrokeWidth && text2.text.trim().length) {
                  _this.ctx.strokeStyle = asString(styles.webkitTextStrokeColor);
                  _this.ctx.lineWidth = styles.webkitTextStrokeWidth;
                  _this.ctx.lineJoin = !!window.chrome ? "miter" : "round";
                  _this.ctx.strokeText(text2.text, text2.bounds.left, text2.bounds.top + baseline);
                }
                _this.ctx.strokeStyle = "";
                _this.ctx.lineWidth = 0;
                _this.ctx.lineJoin = "miter";
                break;
            }
          });
        });
        return [2];
      });
    });
  };
  CanvasRenderer2.prototype.renderReplacedElement = function(container, curves, image2) {
    if (image2 && container.intrinsicWidth > 0 && container.intrinsicHeight > 0) {
      var box = contentBox(container);
      var path = calculatePaddingBoxPath(curves);
      this.path(path);
      this.ctx.save();
      this.ctx.clip();
      this.ctx.drawImage(image2, 0, 0, container.intrinsicWidth, container.intrinsicHeight, box.left, box.top, box.width, box.height);
      this.ctx.restore();
    }
  };
  CanvasRenderer2.prototype.renderNodeContent = function(paint) {
    return __awaiter(this, void 0, void 0, function() {
      var container, curves, styles, _i, _a2, child, image2, image2, iframeRenderer, canvas, size, _b, fontFamily2, fontSize2, baseline, bounds, x, textBounds, img, image2, url, fontFamily2, bounds;
      return __generator(this, function(_c) {
        switch (_c.label) {
          case 0:
            this.applyEffects(paint.getEffects(4));
            container = paint.container;
            curves = paint.curves;
            styles = container.styles;
            _i = 0, _a2 = container.textNodes;
            _c.label = 1;
          case 1:
            if (!(_i < _a2.length))
              return [3, 4];
            child = _a2[_i];
            return [4, this.renderTextNode(child, styles)];
          case 2:
            _c.sent();
            _c.label = 3;
          case 3:
            _i++;
            return [3, 1];
          case 4:
            if (!(container instanceof ImageElementContainer))
              return [3, 8];
            _c.label = 5;
          case 5:
            _c.trys.push([5, 7, , 8]);
            return [4, this.context.cache.match(container.src)];
          case 6:
            image2 = _c.sent();
            this.renderReplacedElement(container, curves, image2);
            return [3, 8];
          case 7:
            _c.sent();
            this.context.logger.error("Error loading image " + container.src);
            return [3, 8];
          case 8:
            if (container instanceof CanvasElementContainer) {
              this.renderReplacedElement(container, curves, container.canvas);
            }
            if (!(container instanceof SVGElementContainer))
              return [3, 12];
            _c.label = 9;
          case 9:
            _c.trys.push([9, 11, , 12]);
            return [4, this.context.cache.match(container.svg)];
          case 10:
            image2 = _c.sent();
            this.renderReplacedElement(container, curves, image2);
            return [3, 12];
          case 11:
            _c.sent();
            this.context.logger.error("Error loading svg " + container.svg.substring(0, 255));
            return [3, 12];
          case 12:
            if (!(container instanceof IFrameElementContainer && container.tree))
              return [3, 14];
            iframeRenderer = new CanvasRenderer2(this.context, {
              scale: this.options.scale,
              backgroundColor: container.backgroundColor,
              x: 0,
              y: 0,
              width: container.width,
              height: container.height
            });
            return [4, iframeRenderer.render(container.tree)];
          case 13:
            canvas = _c.sent();
            if (container.width && container.height) {
              this.ctx.drawImage(canvas, 0, 0, container.width, container.height, container.bounds.left, container.bounds.top, container.bounds.width, container.bounds.height);
            }
            _c.label = 14;
          case 14:
            if (container instanceof InputElementContainer) {
              size = Math.min(container.bounds.width, container.bounds.height);
              if (container.type === CHECKBOX) {
                if (container.checked) {
                  this.ctx.save();
                  this.path([
                    new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79),
                    new Vector(container.bounds.left + size * 0.16, container.bounds.top + size * 0.5549),
                    new Vector(container.bounds.left + size * 0.27347, container.bounds.top + size * 0.44071),
                    new Vector(container.bounds.left + size * 0.39694, container.bounds.top + size * 0.5649),
                    new Vector(container.bounds.left + size * 0.72983, container.bounds.top + size * 0.23),
                    new Vector(container.bounds.left + size * 0.84, container.bounds.top + size * 0.34085),
                    new Vector(container.bounds.left + size * 0.39363, container.bounds.top + size * 0.79)
                  ]);
                  this.ctx.fillStyle = asString(INPUT_COLOR);
                  this.ctx.fill();
                  this.ctx.restore();
                }
              } else if (container.type === RADIO) {
                if (container.checked) {
                  this.ctx.save();
                  this.ctx.beginPath();
                  this.ctx.arc(container.bounds.left + size / 2, container.bounds.top + size / 2, size / 4, 0, Math.PI * 2, true);
                  this.ctx.fillStyle = asString(INPUT_COLOR);
                  this.ctx.fill();
                  this.ctx.restore();
                }
              }
            }
            if (isTextInputElement(container) && container.value.length) {
              _b = this.createFontStyle(styles), fontFamily2 = _b[0], fontSize2 = _b[1];
              baseline = this.fontMetrics.getMetrics(fontFamily2, fontSize2).baseline;
              this.ctx.font = fontFamily2;
              this.ctx.fillStyle = asString(styles.color);
              this.ctx.textBaseline = "alphabetic";
              this.ctx.textAlign = canvasTextAlign(container.styles.textAlign);
              bounds = contentBox(container);
              x = 0;
              switch (container.styles.textAlign) {
                case 1:
                  x += bounds.width / 2;
                  break;
                case 2:
                  x += bounds.width;
                  break;
              }
              textBounds = bounds.add(x, 0, 0, -bounds.height / 2 + 1);
              this.ctx.save();
              this.path([
                new Vector(bounds.left, bounds.top),
                new Vector(bounds.left + bounds.width, bounds.top),
                new Vector(bounds.left + bounds.width, bounds.top + bounds.height),
                new Vector(bounds.left, bounds.top + bounds.height)
              ]);
              this.ctx.clip();
              this.renderTextWithLetterSpacing(new TextBounds(container.value, textBounds), styles.letterSpacing, baseline);
              this.ctx.restore();
              this.ctx.textBaseline = "alphabetic";
              this.ctx.textAlign = "left";
            }
            if (!contains(container.styles.display, 2048))
              return [3, 20];
            if (!(container.styles.listStyleImage !== null))
              return [3, 19];
            img = container.styles.listStyleImage;
            if (!(img.type === 0))
              return [3, 18];
            image2 = void 0;
            url = img.url;
            _c.label = 15;
          case 15:
            _c.trys.push([15, 17, , 18]);
            return [4, this.context.cache.match(url)];
          case 16:
            image2 = _c.sent();
            this.ctx.drawImage(image2, container.bounds.left - (image2.width + 10), container.bounds.top);
            return [3, 18];
          case 17:
            _c.sent();
            this.context.logger.error("Error loading list-style-image " + url);
            return [3, 18];
          case 18:
            return [3, 20];
          case 19:
            if (paint.listValue && container.styles.listStyleType !== -1) {
              fontFamily2 = this.createFontStyle(styles)[0];
              this.ctx.font = fontFamily2;
              this.ctx.fillStyle = asString(styles.color);
              this.ctx.textBaseline = "middle";
              this.ctx.textAlign = "right";
              bounds = new Bounds(container.bounds.left, container.bounds.top + getAbsoluteValue(container.styles.paddingTop, container.bounds.width), container.bounds.width, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 1);
              this.renderTextWithLetterSpacing(new TextBounds(paint.listValue, bounds), styles.letterSpacing, computeLineHeight(styles.lineHeight, styles.fontSize.number) / 2 + 2);
              this.ctx.textBaseline = "bottom";
              this.ctx.textAlign = "left";
            }
            _c.label = 20;
          case 20:
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.renderStackContent = function(stack) {
    return __awaiter(this, void 0, void 0, function() {
      var _i, _a2, child, _b, _c, child, _d, _e, child, _f, _g, child, _h, _j, child, _k, _l, child, _m, _o, child;
      return __generator(this, function(_p) {
        switch (_p.label) {
          case 0:
            if (contains(stack.element.container.flags, 16)) {
              debugger;
            }
            return [4, this.renderNodeBackgroundAndBorders(stack.element)];
          case 1:
            _p.sent();
            _i = 0, _a2 = stack.negativeZIndex;
            _p.label = 2;
          case 2:
            if (!(_i < _a2.length))
              return [3, 5];
            child = _a2[_i];
            return [4, this.renderStack(child)];
          case 3:
            _p.sent();
            _p.label = 4;
          case 4:
            _i++;
            return [3, 2];
          case 5:
            return [4, this.renderNodeContent(stack.element)];
          case 6:
            _p.sent();
            _b = 0, _c = stack.nonInlineLevel;
            _p.label = 7;
          case 7:
            if (!(_b < _c.length))
              return [3, 10];
            child = _c[_b];
            return [4, this.renderNode(child)];
          case 8:
            _p.sent();
            _p.label = 9;
          case 9:
            _b++;
            return [3, 7];
          case 10:
            _d = 0, _e = stack.nonPositionedFloats;
            _p.label = 11;
          case 11:
            if (!(_d < _e.length))
              return [3, 14];
            child = _e[_d];
            return [4, this.renderStack(child)];
          case 12:
            _p.sent();
            _p.label = 13;
          case 13:
            _d++;
            return [3, 11];
          case 14:
            _f = 0, _g = stack.nonPositionedInlineLevel;
            _p.label = 15;
          case 15:
            if (!(_f < _g.length))
              return [3, 18];
            child = _g[_f];
            return [4, this.renderStack(child)];
          case 16:
            _p.sent();
            _p.label = 17;
          case 17:
            _f++;
            return [3, 15];
          case 18:
            _h = 0, _j = stack.inlineLevel;
            _p.label = 19;
          case 19:
            if (!(_h < _j.length))
              return [3, 22];
            child = _j[_h];
            return [4, this.renderNode(child)];
          case 20:
            _p.sent();
            _p.label = 21;
          case 21:
            _h++;
            return [3, 19];
          case 22:
            _k = 0, _l = stack.zeroOrAutoZIndexOrTransformedOrOpacity;
            _p.label = 23;
          case 23:
            if (!(_k < _l.length))
              return [3, 26];
            child = _l[_k];
            return [4, this.renderStack(child)];
          case 24:
            _p.sent();
            _p.label = 25;
          case 25:
            _k++;
            return [3, 23];
          case 26:
            _m = 0, _o = stack.positiveZIndex;
            _p.label = 27;
          case 27:
            if (!(_m < _o.length))
              return [3, 30];
            child = _o[_m];
            return [4, this.renderStack(child)];
          case 28:
            _p.sent();
            _p.label = 29;
          case 29:
            _m++;
            return [3, 27];
          case 30:
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.mask = function(paths) {
    this.ctx.beginPath();
    this.ctx.moveTo(0, 0);
    this.ctx.lineTo(this.canvas.width, 0);
    this.ctx.lineTo(this.canvas.width, this.canvas.height);
    this.ctx.lineTo(0, this.canvas.height);
    this.ctx.lineTo(0, 0);
    this.formatPath(paths.slice(0).reverse());
    this.ctx.closePath();
  };
  CanvasRenderer2.prototype.path = function(paths) {
    this.ctx.beginPath();
    this.formatPath(paths);
    this.ctx.closePath();
  };
  CanvasRenderer2.prototype.formatPath = function(paths) {
    var _this = this;
    paths.forEach(function(point, index2) {
      var start = isBezierCurve(point) ? point.start : point;
      if (index2 === 0) {
        _this.ctx.moveTo(start.x, start.y);
      } else {
        _this.ctx.lineTo(start.x, start.y);
      }
      if (isBezierCurve(point)) {
        _this.ctx.bezierCurveTo(point.startControl.x, point.startControl.y, point.endControl.x, point.endControl.y, point.end.x, point.end.y);
      }
    });
  };
  CanvasRenderer2.prototype.renderRepeat = function(path, pattern, offsetX, offsetY) {
    this.path(path);
    this.ctx.fillStyle = pattern;
    this.ctx.translate(offsetX, offsetY);
    this.ctx.fill();
    this.ctx.translate(-offsetX, -offsetY);
  };
  CanvasRenderer2.prototype.resizeImage = function(image2, width, height) {
    var _a2;
    if (image2.width === width && image2.height === height) {
      return image2;
    }
    var ownerDocument = (_a2 = this.canvas.ownerDocument) !== null && _a2 !== void 0 ? _a2 : document;
    var canvas = ownerDocument.createElement("canvas");
    canvas.width = Math.max(1, width);
    canvas.height = Math.max(1, height);
    var ctx = canvas.getContext("2d");
    ctx.drawImage(image2, 0, 0, image2.width, image2.height, 0, 0, width, height);
    return canvas;
  };
  CanvasRenderer2.prototype.renderBackgroundImage = function(container) {
    return __awaiter(this, void 0, void 0, function() {
      var index2, _loop_1, this_1, _i, _a2, backgroundImage2;
      return __generator(this, function(_b) {
        switch (_b.label) {
          case 0:
            index2 = container.styles.backgroundImage.length - 1;
            _loop_1 = function(backgroundImage3) {
              var image2, url, _c, path, x, y, width, height, pattern, _d, path, x, y, width, height, _e, lineLength, x0, x1, y0, y1, canvas, ctx, gradient_1, pattern, _f, path, left, top_1, width, height, position2, x, y, _g, rx, ry, radialGradient_1, midX, midY, f2, invF;
              return __generator(this, function(_h) {
                switch (_h.label) {
                  case 0:
                    if (!(backgroundImage3.type === 0))
                      return [3, 5];
                    image2 = void 0;
                    url = backgroundImage3.url;
                    _h.label = 1;
                  case 1:
                    _h.trys.push([1, 3, , 4]);
                    return [4, this_1.context.cache.match(url)];
                  case 2:
                    image2 = _h.sent();
                    return [3, 4];
                  case 3:
                    _h.sent();
                    this_1.context.logger.error("Error loading background-image " + url);
                    return [3, 4];
                  case 4:
                    if (image2) {
                      _c = calculateBackgroundRendering(container, index2, [
                        image2.width,
                        image2.height,
                        image2.width / image2.height
                      ]), path = _c[0], x = _c[1], y = _c[2], width = _c[3], height = _c[4];
                      pattern = this_1.ctx.createPattern(this_1.resizeImage(image2, width, height), "repeat");
                      this_1.renderRepeat(path, pattern, x, y);
                    }
                    return [3, 6];
                  case 5:
                    if (isLinearGradient(backgroundImage3)) {
                      _d = calculateBackgroundRendering(container, index2, [null, null, null]), path = _d[0], x = _d[1], y = _d[2], width = _d[3], height = _d[4];
                      _e = calculateGradientDirection(backgroundImage3.angle, width, height), lineLength = _e[0], x0 = _e[1], x1 = _e[2], y0 = _e[3], y1 = _e[4];
                      canvas = document.createElement("canvas");
                      canvas.width = width;
                      canvas.height = height;
                      ctx = canvas.getContext("2d");
                      gradient_1 = ctx.createLinearGradient(x0, y0, x1, y1);
                      processColorStops(backgroundImage3.stops, lineLength).forEach(function(colorStop) {
                        return gradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                      });
                      ctx.fillStyle = gradient_1;
                      ctx.fillRect(0, 0, width, height);
                      if (width > 0 && height > 0) {
                        pattern = this_1.ctx.createPattern(canvas, "repeat");
                        this_1.renderRepeat(path, pattern, x, y);
                      }
                    } else if (isRadialGradient(backgroundImage3)) {
                      _f = calculateBackgroundRendering(container, index2, [
                        null,
                        null,
                        null
                      ]), path = _f[0], left = _f[1], top_1 = _f[2], width = _f[3], height = _f[4];
                      position2 = backgroundImage3.position.length === 0 ? [FIFTY_PERCENT] : backgroundImage3.position;
                      x = getAbsoluteValue(position2[0], width);
                      y = getAbsoluteValue(position2[position2.length - 1], height);
                      _g = calculateRadius(backgroundImage3, x, y, width, height), rx = _g[0], ry = _g[1];
                      if (rx > 0 && ry > 0) {
                        radialGradient_1 = this_1.ctx.createRadialGradient(left + x, top_1 + y, 0, left + x, top_1 + y, rx);
                        processColorStops(backgroundImage3.stops, rx * 2).forEach(function(colorStop) {
                          return radialGradient_1.addColorStop(colorStop.stop, asString(colorStop.color));
                        });
                        this_1.path(path);
                        this_1.ctx.fillStyle = radialGradient_1;
                        if (rx !== ry) {
                          midX = container.bounds.left + 0.5 * container.bounds.width;
                          midY = container.bounds.top + 0.5 * container.bounds.height;
                          f2 = ry / rx;
                          invF = 1 / f2;
                          this_1.ctx.save();
                          this_1.ctx.translate(midX, midY);
                          this_1.ctx.transform(1, 0, 0, f2, 0, 0);
                          this_1.ctx.translate(-midX, -midY);
                          this_1.ctx.fillRect(left, invF * (top_1 - midY) + midY, width, height * invF);
                          this_1.ctx.restore();
                        } else {
                          this_1.ctx.fill();
                        }
                      }
                    }
                    _h.label = 6;
                  case 6:
                    index2--;
                    return [2];
                }
              });
            };
            this_1 = this;
            _i = 0, _a2 = container.styles.backgroundImage.slice(0).reverse();
            _b.label = 1;
          case 1:
            if (!(_i < _a2.length))
              return [3, 4];
            backgroundImage2 = _a2[_i];
            return [5, _loop_1(backgroundImage2)];
          case 2:
            _b.sent();
            _b.label = 3;
          case 3:
            _i++;
            return [3, 1];
          case 4:
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.renderSolidBorder = function(color2, side, curvePoints) {
    return __awaiter(this, void 0, void 0, function() {
      return __generator(this, function(_a2) {
        this.path(parsePathForBorder(curvePoints, side));
        this.ctx.fillStyle = asString(color2);
        this.ctx.fill();
        return [2];
      });
    });
  };
  CanvasRenderer2.prototype.renderDoubleBorder = function(color2, width, side, curvePoints) {
    return __awaiter(this, void 0, void 0, function() {
      var outerPaths, innerPaths;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (!(width < 3))
              return [3, 2];
            return [4, this.renderSolidBorder(color2, side, curvePoints)];
          case 1:
            _a2.sent();
            return [2];
          case 2:
            outerPaths = parsePathForBorderDoubleOuter(curvePoints, side);
            this.path(outerPaths);
            this.ctx.fillStyle = asString(color2);
            this.ctx.fill();
            innerPaths = parsePathForBorderDoubleInner(curvePoints, side);
            this.path(innerPaths);
            this.ctx.fill();
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.renderNodeBackgroundAndBorders = function(paint) {
    return __awaiter(this, void 0, void 0, function() {
      var styles, hasBackground, borders, backgroundPaintingArea, side, _i, borders_1, border;
      var _this = this;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            this.applyEffects(paint.getEffects(2));
            styles = paint.container.styles;
            hasBackground = !isTransparent(styles.backgroundColor) || styles.backgroundImage.length;
            borders = [
              { style: styles.borderTopStyle, color: styles.borderTopColor, width: styles.borderTopWidth },
              { style: styles.borderRightStyle, color: styles.borderRightColor, width: styles.borderRightWidth },
              { style: styles.borderBottomStyle, color: styles.borderBottomColor, width: styles.borderBottomWidth },
              { style: styles.borderLeftStyle, color: styles.borderLeftColor, width: styles.borderLeftWidth }
            ];
            backgroundPaintingArea = calculateBackgroundCurvedPaintingArea(getBackgroundValueForIndex(styles.backgroundClip, 0), paint.curves);
            if (!(hasBackground || styles.boxShadow.length))
              return [3, 2];
            this.ctx.save();
            this.path(backgroundPaintingArea);
            this.ctx.clip();
            if (!isTransparent(styles.backgroundColor)) {
              this.ctx.fillStyle = asString(styles.backgroundColor);
              this.ctx.fill();
            }
            return [4, this.renderBackgroundImage(paint.container)];
          case 1:
            _a2.sent();
            this.ctx.restore();
            styles.boxShadow.slice(0).reverse().forEach(function(shadow) {
              _this.ctx.save();
              var borderBoxArea = calculateBorderBoxPath(paint.curves);
              var maskOffset = shadow.inset ? 0 : MASK_OFFSET;
              var shadowPaintingArea = transformPath(borderBoxArea, -maskOffset + (shadow.inset ? 1 : -1) * shadow.spread.number, (shadow.inset ? 1 : -1) * shadow.spread.number, shadow.spread.number * (shadow.inset ? -2 : 2), shadow.spread.number * (shadow.inset ? -2 : 2));
              if (shadow.inset) {
                _this.path(borderBoxArea);
                _this.ctx.clip();
                _this.mask(shadowPaintingArea);
              } else {
                _this.mask(borderBoxArea);
                _this.ctx.clip();
                _this.path(shadowPaintingArea);
              }
              _this.ctx.shadowOffsetX = shadow.offsetX.number + maskOffset;
              _this.ctx.shadowOffsetY = shadow.offsetY.number;
              _this.ctx.shadowColor = asString(shadow.color);
              _this.ctx.shadowBlur = shadow.blur.number;
              _this.ctx.fillStyle = shadow.inset ? asString(shadow.color) : "rgba(0,0,0,1)";
              _this.ctx.fill();
              _this.ctx.restore();
            });
            _a2.label = 2;
          case 2:
            side = 0;
            _i = 0, borders_1 = borders;
            _a2.label = 3;
          case 3:
            if (!(_i < borders_1.length))
              return [3, 13];
            border = borders_1[_i];
            if (!(border.style !== 0 && !isTransparent(border.color) && border.width > 0))
              return [3, 11];
            if (!(border.style === 2))
              return [3, 5];
            return [4, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 2)];
          case 4:
            _a2.sent();
            return [3, 11];
          case 5:
            if (!(border.style === 3))
              return [3, 7];
            return [4, this.renderDashedDottedBorder(border.color, border.width, side, paint.curves, 3)];
          case 6:
            _a2.sent();
            return [3, 11];
          case 7:
            if (!(border.style === 4))
              return [3, 9];
            return [4, this.renderDoubleBorder(border.color, border.width, side, paint.curves)];
          case 8:
            _a2.sent();
            return [3, 11];
          case 9:
            return [4, this.renderSolidBorder(border.color, side, paint.curves)];
          case 10:
            _a2.sent();
            _a2.label = 11;
          case 11:
            side++;
            _a2.label = 12;
          case 12:
            _i++;
            return [3, 3];
          case 13:
            return [2];
        }
      });
    });
  };
  CanvasRenderer2.prototype.renderDashedDottedBorder = function(color2, width, side, curvePoints, style) {
    return __awaiter(this, void 0, void 0, function() {
      var strokePaths, boxPaths, startX, startY, endX, endY, length, dashLength, spaceLength, useLineDash, multiplier, numberOfDashes, minSpace, maxSpace, path1, path2, path1, path2;
      return __generator(this, function(_a2) {
        this.ctx.save();
        strokePaths = parsePathForBorderStroke(curvePoints, side);
        boxPaths = parsePathForBorder(curvePoints, side);
        if (style === 2) {
          this.path(boxPaths);
          this.ctx.clip();
        }
        if (isBezierCurve(boxPaths[0])) {
          startX = boxPaths[0].start.x;
          startY = boxPaths[0].start.y;
        } else {
          startX = boxPaths[0].x;
          startY = boxPaths[0].y;
        }
        if (isBezierCurve(boxPaths[1])) {
          endX = boxPaths[1].end.x;
          endY = boxPaths[1].end.y;
        } else {
          endX = boxPaths[1].x;
          endY = boxPaths[1].y;
        }
        if (side === 0 || side === 2) {
          length = Math.abs(startX - endX);
        } else {
          length = Math.abs(startY - endY);
        }
        this.ctx.beginPath();
        if (style === 3) {
          this.formatPath(strokePaths);
        } else {
          this.formatPath(boxPaths.slice(0, 2));
        }
        dashLength = width < 3 ? width * 3 : width * 2;
        spaceLength = width < 3 ? width * 2 : width;
        if (style === 3) {
          dashLength = width;
          spaceLength = width;
        }
        useLineDash = true;
        if (length <= dashLength * 2) {
          useLineDash = false;
        } else if (length <= dashLength * 2 + spaceLength) {
          multiplier = length / (2 * dashLength + spaceLength);
          dashLength *= multiplier;
          spaceLength *= multiplier;
        } else {
          numberOfDashes = Math.floor((length + spaceLength) / (dashLength + spaceLength));
          minSpace = (length - numberOfDashes * dashLength) / (numberOfDashes - 1);
          maxSpace = (length - (numberOfDashes + 1) * dashLength) / numberOfDashes;
          spaceLength = maxSpace <= 0 || Math.abs(spaceLength - minSpace) < Math.abs(spaceLength - maxSpace) ? minSpace : maxSpace;
        }
        if (useLineDash) {
          if (style === 3) {
            this.ctx.setLineDash([0, dashLength + spaceLength]);
          } else {
            this.ctx.setLineDash([dashLength, spaceLength]);
          }
        }
        if (style === 3) {
          this.ctx.lineCap = "round";
          this.ctx.lineWidth = width;
        } else {
          this.ctx.lineWidth = width * 2 + 1.1;
        }
        this.ctx.strokeStyle = asString(color2);
        this.ctx.stroke();
        this.ctx.setLineDash([]);
        if (style === 2) {
          if (isBezierCurve(boxPaths[0])) {
            path1 = boxPaths[3];
            path2 = boxPaths[0];
            this.ctx.beginPath();
            this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
            this.ctx.stroke();
          }
          if (isBezierCurve(boxPaths[1])) {
            path1 = boxPaths[1];
            path2 = boxPaths[2];
            this.ctx.beginPath();
            this.formatPath([new Vector(path1.end.x, path1.end.y), new Vector(path2.start.x, path2.start.y)]);
            this.ctx.stroke();
          }
        }
        this.ctx.restore();
        return [2];
      });
    });
  };
  CanvasRenderer2.prototype.render = function(element) {
    return __awaiter(this, void 0, void 0, function() {
      var stack;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            if (this.options.backgroundColor) {
              this.ctx.fillStyle = asString(this.options.backgroundColor);
              this.ctx.fillRect(this.options.x, this.options.y, this.options.width, this.options.height);
            }
            stack = parseStackingContexts(element);
            return [4, this.renderStack(stack)];
          case 1:
            _a2.sent();
            this.applyEffects([]);
            return [2, this.canvas];
        }
      });
    });
  };
  return CanvasRenderer2;
}(Renderer);
var isTextInputElement = function(container) {
  if (container instanceof TextareaElementContainer) {
    return true;
  } else if (container instanceof SelectElementContainer) {
    return true;
  } else if (container instanceof InputElementContainer && container.type !== RADIO && container.type !== CHECKBOX) {
    return true;
  }
  return false;
};
var calculateBackgroundCurvedPaintingArea = function(clip, curves) {
  switch (clip) {
    case 0:
      return calculateBorderBoxPath(curves);
    case 2:
      return calculateContentBoxPath(curves);
    case 1:
    default:
      return calculatePaddingBoxPath(curves);
  }
};
var canvasTextAlign = function(textAlign2) {
  switch (textAlign2) {
    case 1:
      return "center";
    case 2:
      return "right";
    case 0:
    default:
      return "left";
  }
};
var iOSBrokenFonts = ["-apple-system", "system-ui"];
var fixIOSSystemFonts = function(fontFamilies) {
  return /iPhone OS 15_(0|1)/.test(window.navigator.userAgent) ? fontFamilies.filter(function(fontFamily2) {
    return iOSBrokenFonts.indexOf(fontFamily2) === -1;
  }) : fontFamilies;
};
var ForeignObjectRenderer = function(_super) {
  __extends(ForeignObjectRenderer2, _super);
  function ForeignObjectRenderer2(context, options) {
    var _this = _super.call(this, context, options) || this;
    _this.canvas = options.canvas ? options.canvas : document.createElement("canvas");
    _this.ctx = _this.canvas.getContext("2d");
    _this.options = options;
    _this.canvas.width = Math.floor(options.width * options.scale);
    _this.canvas.height = Math.floor(options.height * options.scale);
    _this.canvas.style.width = options.width + "px";
    _this.canvas.style.height = options.height + "px";
    _this.ctx.scale(_this.options.scale, _this.options.scale);
    _this.ctx.translate(-options.x, -options.y);
    _this.context.logger.debug("EXPERIMENTAL ForeignObject renderer initialized (" + options.width + "x" + options.height + " at " + options.x + "," + options.y + ") with scale " + options.scale);
    return _this;
  }
  ForeignObjectRenderer2.prototype.render = function(element) {
    return __awaiter(this, void 0, void 0, function() {
      var svg, img;
      return __generator(this, function(_a2) {
        switch (_a2.label) {
          case 0:
            svg = createForeignObjectSVG(this.options.width * this.options.scale, this.options.height * this.options.scale, this.options.scale, this.options.scale, element);
            return [4, loadSerializedSVG(svg)];
          case 1:
            img = _a2.sent();
            if (this.options.backgroundColor) {
              this.ctx.fillStyle = asString(this.options.backgroundColor);
              this.ctx.fillRect(0, 0, this.options.width * this.options.scale, this.options.height * this.options.scale);
            }
            this.ctx.drawImage(img, -this.options.x * this.options.scale, -this.options.y * this.options.scale);
            return [2, this.canvas];
        }
      });
    });
  };
  return ForeignObjectRenderer2;
}(Renderer);
var loadSerializedSVG = function(svg) {
  return new Promise(function(resolve, reject) {
    var img = new Image();
    img.onload = function() {
      resolve(img);
    };
    img.onerror = reject;
    img.src = "data:image/svg+xml;charset=utf-8," + encodeURIComponent(new XMLSerializer().serializeToString(svg));
  });
};
var Logger = function() {
  function Logger2(_a2) {
    var id = _a2.id, enabled = _a2.enabled;
    this.id = id;
    this.enabled = enabled;
    this.start = Date.now();
  }
  Logger2.prototype.debug = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this.enabled) {
      if (typeof window !== "undefined" && window.console && typeof console.debug === "function") {
        console.debug.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
      } else {
        this.info.apply(this, args);
      }
    }
  };
  Logger2.prototype.getTime = function() {
    return Date.now() - this.start;
  };
  Logger2.prototype.info = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this.enabled) {
      if (typeof window !== "undefined" && window.console && typeof console.info === "function") {
        console.info.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
      }
    }
  };
  Logger2.prototype.warn = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this.enabled) {
      if (typeof window !== "undefined" && window.console && typeof console.warn === "function") {
        console.warn.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
      } else {
        this.info.apply(this, args);
      }
    }
  };
  Logger2.prototype.error = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (this.enabled) {
      if (typeof window !== "undefined" && window.console && typeof console.error === "function") {
        console.error.apply(console, __spreadArray([this.id, this.getTime() + "ms"], args));
      } else {
        this.info.apply(this, args);
      }
    }
  };
  Logger2.instances = {};
  return Logger2;
}();
var Context = function() {
  function Context2(options, windowBounds) {
    var _a2;
    this.windowBounds = windowBounds;
    this.instanceName = "#" + Context2.instanceCount++;
    this.logger = new Logger({ id: this.instanceName, enabled: options.logging });
    this.cache = (_a2 = options.cache) !== null && _a2 !== void 0 ? _a2 : new Cache(this, options);
  }
  Context2.instanceCount = 1;
  return Context2;
}();
var html2canvas = function(element, options) {
  if (options === void 0) {
    options = {};
  }
  return renderElement(element, options);
};
if (typeof window !== "undefined") {
  CacheStorage.setContext(window);
}
var renderElement = function(element, opts) {
  return __awaiter(void 0, void 0, void 0, function() {
    var ownerDocument, defaultView, resourceOptions, contextOptions, windowOptions, windowBounds, context, foreignObjectRendering, cloneOptions, documentCloner, clonedElement, container, _a2, width, height, left, top, backgroundColor2, renderOptions, canvas, renderer, root, renderer;
    var _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
    return __generator(this, function(_u) {
      switch (_u.label) {
        case 0:
          if (!element || typeof element !== "object") {
            return [2, Promise.reject("Invalid element provided as first argument")];
          }
          ownerDocument = element.ownerDocument;
          if (!ownerDocument) {
            throw new Error("Element is not attached to a Document");
          }
          defaultView = ownerDocument.defaultView;
          if (!defaultView) {
            throw new Error("Document is not attached to a Window");
          }
          resourceOptions = {
            allowTaint: (_b = opts.allowTaint) !== null && _b !== void 0 ? _b : false,
            imageTimeout: (_c = opts.imageTimeout) !== null && _c !== void 0 ? _c : 15e3,
            proxy: opts.proxy,
            useCORS: (_d = opts.useCORS) !== null && _d !== void 0 ? _d : false
          };
          contextOptions = __assign({ logging: (_e = opts.logging) !== null && _e !== void 0 ? _e : true, cache: opts.cache }, resourceOptions);
          windowOptions = {
            windowWidth: (_f = opts.windowWidth) !== null && _f !== void 0 ? _f : defaultView.innerWidth,
            windowHeight: (_g = opts.windowHeight) !== null && _g !== void 0 ? _g : defaultView.innerHeight,
            scrollX: (_h = opts.scrollX) !== null && _h !== void 0 ? _h : defaultView.pageXOffset,
            scrollY: (_j = opts.scrollY) !== null && _j !== void 0 ? _j : defaultView.pageYOffset
          };
          windowBounds = new Bounds(windowOptions.scrollX, windowOptions.scrollY, windowOptions.windowWidth, windowOptions.windowHeight);
          context = new Context(contextOptions, windowBounds);
          foreignObjectRendering = (_k = opts.foreignObjectRendering) !== null && _k !== void 0 ? _k : false;
          cloneOptions = {
            allowTaint: (_l = opts.allowTaint) !== null && _l !== void 0 ? _l : false,
            onclone: opts.onclone,
            ignoreElements: opts.ignoreElements,
            inlineImages: foreignObjectRendering,
            copyStyles: foreignObjectRendering
          };
          context.logger.debug("Starting document clone with size " + windowBounds.width + "x" + windowBounds.height + " scrolled to " + -windowBounds.left + "," + -windowBounds.top);
          documentCloner = new DocumentCloner(context, element, cloneOptions);
          clonedElement = documentCloner.clonedReferenceElement;
          if (!clonedElement) {
            return [2, Promise.reject("Unable to find element in cloned iframe")];
          }
          return [4, documentCloner.toIFrame(ownerDocument, windowBounds)];
        case 1:
          container = _u.sent();
          _a2 = isBodyElement(clonedElement) || isHTMLElement(clonedElement) ? parseDocumentSize(clonedElement.ownerDocument) : parseBounds(context, clonedElement), width = _a2.width, height = _a2.height, left = _a2.left, top = _a2.top;
          backgroundColor2 = parseBackgroundColor(context, clonedElement, opts.backgroundColor);
          renderOptions = {
            canvas: opts.canvas,
            backgroundColor: backgroundColor2,
            scale: (_o = (_m = opts.scale) !== null && _m !== void 0 ? _m : defaultView.devicePixelRatio) !== null && _o !== void 0 ? _o : 1,
            x: ((_p = opts.x) !== null && _p !== void 0 ? _p : 0) + left,
            y: ((_q = opts.y) !== null && _q !== void 0 ? _q : 0) + top,
            width: (_r = opts.width) !== null && _r !== void 0 ? _r : Math.ceil(width),
            height: (_s = opts.height) !== null && _s !== void 0 ? _s : Math.ceil(height)
          };
          if (!foreignObjectRendering)
            return [3, 3];
          context.logger.debug("Document cloned, using foreign object rendering");
          renderer = new ForeignObjectRenderer(context, renderOptions);
          return [4, renderer.render(clonedElement)];
        case 2:
          canvas = _u.sent();
          return [3, 5];
        case 3:
          context.logger.debug("Document cloned, element located at " + left + "," + top + " with size " + width + "x" + height + " using computed rendering");
          context.logger.debug("Starting DOM parsing");
          root = parseTree(context, clonedElement);
          if (backgroundColor2 === root.styles.backgroundColor) {
            root.styles.backgroundColor = COLORS.TRANSPARENT;
          }
          context.logger.debug("Starting renderer for element at " + renderOptions.x + "," + renderOptions.y + " with size " + renderOptions.width + "x" + renderOptions.height);
          renderer = new CanvasRenderer(context, renderOptions);
          return [4, renderer.render(root)];
        case 4:
          canvas = _u.sent();
          _u.label = 5;
        case 5:
          if ((_t = opts.removeContainer) !== null && _t !== void 0 ? _t : true) {
            if (!DocumentCloner.destroy(container)) {
              context.logger.error("Cannot detach cloned iframe as it is not in the DOM anymore");
            }
          }
          context.logger.debug("Finished rendering");
          return [2, canvas];
      }
    });
  });
};
var parseBackgroundColor = function(context, element, backgroundColorOverride) {
  var ownerDocument = element.ownerDocument;
  var documentBackgroundColor = ownerDocument.documentElement ? parseColor(context, getComputedStyle(ownerDocument.documentElement).backgroundColor) : COLORS.TRANSPARENT;
  var bodyBackgroundColor = ownerDocument.body ? parseColor(context, getComputedStyle(ownerDocument.body).backgroundColor) : COLORS.TRANSPARENT;
  var defaultBackgroundColor = typeof backgroundColorOverride === "string" ? parseColor(context, backgroundColorOverride) : backgroundColorOverride === null ? COLORS.TRANSPARENT : 4294967295;
  return element === ownerDocument.documentElement ? isTransparent(documentBackgroundColor) ? isTransparent(bodyBackgroundColor) ? defaultBackgroundColor : bodyBackgroundColor : documentBackgroundColor : defaultBackgroundColor;
};
var CreateCover_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$G = defineComponent({
  props: ["modelValue"],
  emits: ["update:modelValue"],
  setup(props2, context) {
    const { proxy } = getCurrentInstance();
    async function createCover(cb) {
      const nowZoom = proxy == null ? void 0 : proxy.dZoom;
      proxy == null ? void 0 : proxy.selectWidget({
        uuid: "-1"
      });
      proxy == null ? void 0 : proxy.updateZoom(100);
      const opts = {
        useCORS: true,
        scale: 0.2
      };
      setTimeout(async () => {
        var _a2;
        const dom = document.getElementById("page-design-canvas");
        const canvas = await html2canvas(dom, { ...opts, useCORS: true, allowTaint: true, backgroundColor: null });
        const image2 = canvas.toDataURL("image/jpg");
        const url = await api$1.home.base64ToImg({ filedata: image2 });
        if (url) {
          cb((_a2 = url == null ? void 0 : url.data) == null ? void 0 : _a2.http_path);
        }
        proxy == null ? void 0 : proxy.updateZoom(nowZoom);
      }, 10);
    }
    return {
      createCover
    };
  },
  computed: {
    ...mapGetters(["dZoom"])
  },
  methods: {
    ...mapActions(["selectWidget", "updateZoom"])
  }
});
const _hoisted_1$E = { id: "cover-wrap" };
function _sfc_render$C(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$E);
}
var SaveImage = /* @__PURE__ */ _export_sfc(_sfc_main$G, [["render", _sfc_render$C], ["__scopeId", "data-v-33130a74"]]);
const nowVersion = "2";
const fontList = [];
const useFontStore = {
  list: fontList,
  async init() {
    this.list = [];
    localStorage.getItem("FONTS_VERSION") !== nowVersion && localStorage.removeItem("FONTS");
    const localFonts = localStorage.getItem("FONTS") ? JSON.parse(localStorage.getItem("FONTS") || "") : [];
    if (localFonts.length > 0) {
      this.list.push(...localFonts);
    }
    if (this.list.length === 0) {
      const res = await getFonts({ per_page: 400 });
      this.list.unshift(
        ...res.list.map((x) => {
          const { id, alias, oid, value, preview, woff, lang } = x;
          return { id, oid, value, preview, alias, url: woff, lang };
        })
      );
      localStorage.setItem("FONTS", JSON.stringify(this.list));
      localStorage.setItem("FONTS_VERSION", nowVersion);
    }
  }
};
var HeaderOptions_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$F = defineComponent({
  components: { SaveImage },
  props: ["modelValue", "noMenu"],
  emits: ["change", "update:modelValue"],
  setup(props2, context) {
    const { proxy } = getCurrentInstance();
    const store = useStore();
    const state = reactive$1({
      stateBollean: false,
      title: "",
      loading: false,
      psdVisible: false
    });
    const tempid = computed$1(() => store.state.templateId);
    onMounted(() => {
      console.log(store);
    });
    watch(
      () => tempid.value,
      async (n) => {
        const { title } = await api$1.home["getTempDetail"]({ id: n });
        state.title = title;
      }
    );
    async function createImg() {
      const dom = document.getElementById("page-design-canvas");
      const canvas = await html2canvas(dom, { useCORS: true, allowTaint: true, backgroundColor: null });
      const image2 = canvas.toDataURL("image/jpg");
      return image2;
    }
    async function saveTemp2() {
      let res = null;
      const image2 = await createImg();
      {
        res = await api$1.home.saveTemp({ id: tempid.value, cover_base64: image2, title: proxy.title || "\u672A\u547D\u540D\u6A21\u677F", content: JSON.stringify({ page: proxy.dPage, widgets: proxy.dWidgets }), width: proxy.dPage.width, height: proxy.dPage.height });
      }
      res.stat != 0 && useNotification(res.msg || "\u6210\u529F");
      store.commit("setState", { key: "templateDate", value: Date.now() });
      return res;
    }
    async function download2() {
      const image2 = await createImg();
      const link = document.createElement("a");
      link.href = image2;
      link.download = "capture.jpg";
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
    const deleteTemplate = async () => {
      const res = await api$1.home.removeComp({ id: tempid.value });
      if (res.code === 200) {
        store.commit("setState", { key: "templateDate", value: Date.now() });
        store.commit("setState", { key: "templateId", value: null });
      }
    };
    const addTemplate = async () => {
      const res = await saveTemp2();
      if (res.id) {
        store.commit("setState", { key: "templateId", value: res.id });
      }
    };
    const openPsd = () => {
      store.dispatch("resetWidget");
      state.psdVisible = true;
    };
    return {
      ...toRefs(state),
      tempid,
      download: download2,
      saveTemp: saveTemp2,
      deleteTemplate,
      addTemplate,
      openPsd
    };
  },
  computed: {
    ...mapGetters(["dPage", "dWidgets", "tempEditing", "dHistory", "dPageHistory"])
  },
  methods: {
    ...mapActions(["pushHistory", "addGroup"]),
    async load(id, tempId, type2, cb) {
      await useFontStore.init();
    },
    draw() {
      return new Promise((resolve) => {
        this.$refs.canvasImage.createCover(({ key }) => {
          resolve(_config.IMG_URL + key);
        });
      });
    }
  }
});
const _hoisted_1$D = {
  class: "w-full flex items-center",
  style: { "border-bottom": "1px solid #ccc", "border-top": "1px solid #ccc" }
};
const _hoisted_2$z = { class: "top-title text-left p-0 font-bold text-[18px]" };
const _hoisted_3$v = { class: "top-icon-wrap" };
function _sfc_render$B(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _component_el_button = resolveComponent("el-button");
  const _component_SaveImage = resolveComponent("SaveImage");
  return openBlock(), createElementBlock("div", _hoisted_1$D, [
    createElementVNode("div", _hoisted_2$z, [
      _ctx.tempid && !_ctx.noMenu ? (openBlock(), createBlock(_component_el_input, {
        key: 0,
        modelValue: _ctx.title,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.title = $event),
        placeholder: "\u672A\u547D\u540D\u7684\u8BBE\u8BA1",
        class: "input-wrap"
      }, null, 8, ["modelValue"])) : createCommentVNode("", true)
    ]),
    createElementVNode("div", _hoisted_3$v, [
      !_ctx.noMenu ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
        createVNode(_component_el_button, {
          plain: "",
          type: "primary",
          onClick: _ctx.openPsd
        }, {
          default: withCtx(() => [
            createTextVNode("\u4E0A\u4F20PSD\u6A21\u677F")
          ]),
          _: 1
        }, 8, ["onClick"]),
        createVNode(_component_el_button, {
          plain: "",
          type: "primary",
          onClick: _ctx.addTemplate
        }, {
          default: withCtx(() => [
            createTextVNode("\u65B0\u589E\u6A21\u677F")
          ]),
          _: 1
        }, 8, ["onClick"]),
        _ctx.tempid ? (openBlock(), createElementBlock(Fragment, { key: 0 }, [
          createVNode(_component_el_button, {
            plain: "",
            type: "primary",
            onClick: _ctx.saveTemp
          }, {
            default: withCtx(() => [
              createTextVNode("\u4FDD\u5B58\u6A21\u677F")
            ]),
            _: 1
          }, 8, ["onClick"]),
          createVNode(_component_el_button, { onClick: _ctx.deleteTemplate }, {
            default: withCtx(() => [
              createTextVNode("\u5220\u9664")
            ]),
            _: 1
          }, 8, ["onClick"])
        ], 64)) : createCommentVNode("", true)
      ], 64)) : (openBlock(), createBlock(_component_el_button, {
        key: 1,
        loading: _ctx.loading,
        size: "large",
        class: "primary-btn",
        disabled: _ctx.tempEditing,
        plain: "",
        type: "primary",
        onClick: _ctx.download
      }, {
        default: withCtx(() => [
          createTextVNode("\u53E6\u5B58\u4E3A")
        ]),
        _: 1
      }, 8, ["loading", "disabled", "onClick"]))
    ]),
    createVNode(_component_SaveImage, { ref: "canvasImage" }, null, 512)
  ]);
}
var headerOptions = /* @__PURE__ */ _export_sfc(_sfc_main$F, [["render", _sfc_render$B], ["__scopeId", "data-v-361e1284"]]);
var index_vue_vue_type_style_index_0_scoped_true_lang$2 = "";
const _sfc_main$E = defineComponent({
  components: { ElProgress },
  props: ["percent", "text", "cancelText", "msg"],
  emits: ["done", "cancel"],
  setup(props2, context) {
    watch(
      () => props2.percent,
      (num) => {
        if (num >= 100) {
          setTimeout(() => {
            context.emit("done");
          }, 1e3);
        }
      }
    );
    const cancel = () => {
      context.emit("cancel");
    };
    return { cancel };
  }
});
const _hoisted_1$C = {
  key: 0,
  class: "mask"
};
const _hoisted_2$y = { class: "content" };
const _hoisted_3$u = { class: "text" };
const _hoisted_4$q = { class: "text info" };
function _sfc_render$A(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_progress = resolveComponent("el-progress");
  return _ctx.percent ? (openBlock(), createElementBlock("div", _hoisted_1$C, [
    createElementVNode("div", _hoisted_2$y, [
      createElementVNode("div", _hoisted_3$u, toDisplayString(_ctx.text), 1),
      createVNode(_component_el_progress, {
        style: { "width": "100%" },
        "text-inside": true,
        percentage: _ctx.percent
      }, null, 8, ["percentage"]),
      createElementVNode("div", {
        class: "text btn",
        onClick: _cache[0] || (_cache[0] = (...args) => _ctx.cancel && _ctx.cancel(...args))
      }, toDisplayString(_ctx.cancelText), 1),
      createElementVNode("div", _hoisted_4$q, toDisplayString(_ctx.msg), 1)
    ])
  ])) : createCommentVNode("", true);
}
var ProgressLoading = /* @__PURE__ */ _export_sfc(_sfc_main$E, [["render", _sfc_render$A], ["__scopeId", "data-v-761ec24e"]]);
var widgetClassifyListData = [
  {
    name: "\u6A21\u677F",
    icon: "icon-moban",
    show: false,
    component: "temp-list-wrap"
  },
  {
    name: "\u7D20\u6750",
    icon: "icon-sucai",
    show: false,
    component: "graph-list-wrap"
  },
  {
    name: "\u6587\u5B57",
    icon: "icon-wenzi",
    show: false,
    style: { fontWeight: 600 },
    component: "text-list-wrap"
  },
  {
    name: "\u7167\u7247",
    icon: "icon-gallery",
    show: false,
    component: "photo-list-wrap"
  },
  {
    name: "\u80CC\u666F",
    icon: "icon-beijing",
    show: false,
    component: "bg-img-list-wrap"
  }
];
var BgImgListWrap_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$D = defineComponent({
  setup(props2) {
    const store = useStore();
    const state = reactive$1({
      loading: false,
      loadDone: false,
      bgList: [],
      showList: true,
      colors: ["#000000ff", "#999999ff", "#CCCCCCff", "#FFFFFFff", "#E65353ff", "#FFD835ff", "#70BC59ff", "#607AF4ff", "#976BEEff"]
    });
    const pageOptions = { page: 0, per_page: 20 };
    const loadData = () => {
      if (state.loading) {
        return;
      }
      load();
    };
    const load = async (init2 = false) => {
      if (state.loadDone) {
        return;
      }
      state.loading = true;
      pageOptions.page += 1;
      if (init2) {
        state.bgList = [];
        pageOptions.page = 1;
      }
      await api$1.material.getImagesList({ cate: 16, page: pageOptions.page }).then(({ list }) => {
        if (list.length > 0) {
          state.bgList.push(...list);
        } else {
          state.loadDone = true;
        }
      });
      setTimeout(() => {
        state.loading = false;
      }, 100);
    };
    function setBGcolor(color2) {
      store.dispatch("updatePageData", {
        key: "backgroundImage",
        value: ""
      });
      store.dispatch("updatePageData", {
        key: "backgroundColor",
        value: color2,
        pushHistory: true
      });
      store.dispatch("selectWidget", {
        uuid: "-1"
      });
    }
    return {
      ...toRefs(state),
      load,
      setBGcolor,
      loadData
    };
  },
  methods: {
    ...mapActions(["selectWidget", "updatePageData"]),
    async selectItem(item) {
      this.updatePageData({
        key: "backgroundTransform",
        value: {}
      });
      this.updatePageData({
        key: "backgroundImage",
        value: item.url,
        pushHistory: true
      });
      this.selectWidget({
        uuid: "-1"
      });
    },
    dragStart(e2, item) {
      this.$store.commit("selectItem", { data: {}, type: "bg" });
    }
  }
});
const _withScopeId$j = (n) => (pushScopeId("data-v-bb049eb8"), n = n(), popScopeId(), n);
const _hoisted_1$B = { class: "wrap" };
const _hoisted_2$x = { class: "color__box" };
const _hoisted_3$t = ["onClick"];
const _hoisted_4$p = {
  key: 0,
  class: "infinite-list",
  "infinite-scroll-distance": 150,
  style: { "overflow": "auto" }
};
const _hoisted_5$l = { class: "list" };
const _hoisted_6$g = { class: "loading" };
const _hoisted_7$c = /* @__PURE__ */ _withScopeId$j(() => /* @__PURE__ */ createElementVNode("i", { class: "el-icon-loading" }, null, -1));
const _hoisted_8$9 = { class: "loading" };
function _sfc_render$z(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_image = resolveComponent("el-image");
  const _component_imageTip = resolveComponent("imageTip");
  const _directive_infinite_scroll = resolveDirective("infinite-scroll");
  return openBlock(), createElementBlock("div", _hoisted_1$B, [
    createElementVNode("div", _hoisted_2$x, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.colors, (c) => {
        return openBlock(), createElementBlock("div", {
          key: c,
          style: normalizeStyle({ background: c }),
          class: "color__item",
          onClick: ($event) => _ctx.setBGcolor(c)
        }, null, 12, _hoisted_3$t);
      }), 128))
    ]),
    _ctx.showList ? withDirectives((openBlock(), createElementBlock("ul", _hoisted_4$p, [
      createElementVNode("div", _hoisted_5$l, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.bgList, (item, i) => {
          return openBlock(), createBlock(_component_imageTip, {
            key: i + "i",
            detail: item
          }, {
            default: withCtx(() => [
              createVNode(_component_el_image, {
                class: "list__img",
                src: item.thumb,
                fit: "cover",
                lazy: "",
                loading: "lazy",
                onClick: withModifiers(($event) => _ctx.selectItem(item), ["stop"]),
                onDragstart: ($event) => _ctx.dragStart($event, item)
              }, null, 8, ["src", "onClick", "onDragstart"])
            ]),
            _: 2
          }, 1032, ["detail"]);
        }), 128))
      ]),
      withDirectives(createElementVNode("div", _hoisted_6$g, [
        _hoisted_7$c,
        createTextVNode(" \u62FC\u547D\u52A0\u8F7D\u4E2D")
      ], 512), [
        [vShow, _ctx.loading]
      ]),
      withDirectives(createElementVNode("div", _hoisted_8$9, "\u5168\u90E8\u52A0\u8F7D\u5B8C\u6BD5", 512), [
        [vShow, _ctx.loadDone]
      ])
    ])), [
      [_directive_infinite_scroll, _ctx.loadData]
    ]) : createCommentVNode("", true)
  ]);
}
var BgImgListWrap = /* @__PURE__ */ _export_sfc(_sfc_main$D, [["render", _sfc_render$z], ["__scopeId", "data-v-bb049eb8"]]);
var __glob_0_15 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": BgImgListWrap
}, Symbol.toStringTag, { value: "Module" }));
class dragHelper$2 {
  constructor() {
    this.cloneEl = null;
    this.dragging = false;
    this.initial = {};
    this.queue = [];
    window.addEventListener("mousemove", (e2) => {
      if (this.dragging && this.cloneEl) {
        const { offsetX, offsetY, width, height } = this.initial;
        this.moveFlutter(e2.pageX - width / 2, e2.pageY - height / 2, this.distance(e2));
      } else {
        this.finish();
      }
    });
    window.addEventListener("mouseup", (e2) => {
      var _a2;
      window.document.getElementById("app").classList.remove("drag_active");
      const cl = e2.target.classList;
      if (((_a2 = e2.target) == null ? void 0 : _a2.id) === "page-design-canvas" || cl.contains("target") || cl.contains("drop__mask") || cl.contains("edit-text")) {
        setTimeout(() => {
          this.finish(true);
        }, 10);
      } else
        this.finish();
    });
    document.addEventListener("mouseleave", (e2) => {
      this.finish();
    });
    window.onblur = () => {
      this.finish();
    };
  }
  start(e2, finallySize) {
    if (!this.cloneEl) {
      erpStore.commit("setDraging", true);
      window.document.getElementById("app").classList.add("drag_active");
      this.cloneEl = e2.target.cloneNode(true);
      this.cloneEl.classList.add("flutter");
      this.init(e2, e2.target, finallySize || e2.target.offsetWidth, Math.random());
      this.cloneEl.style.width = e2.target.offsetWidth;
      window.document.getElementById("widget-panel").appendChild(this.cloneEl);
      this.dragging = true;
      e2.target.classList.add("hide");
      this.queue.push(() => {
        e2.target.classList.remove("hide");
      });
    }
  }
  init({ offsetX, offsetY, pageX, pageY, x, y }, { offsetWidth: width, offsetHeight: height }, finallySize, flag) {
    this.initial = { offsetX, offsetY, pageX, pageY, width, height, finallySize, flag, x, y };
    this.moveFlutter(pageX - offsetX, pageY - offsetY, 0, 0.3);
    setTimeout(() => {
      this.moveFlutter(pageX - width / 2, pageY - height / 2, 0, 0.3);
    }, 10);
  }
  moveFlutter(x, y, d = 0, lazy = 0) {
    const { width, height, finallySize } = this.initial;
    let scale = null;
    if (width > finallySize) {
      scale = d ? width - d >= finallySize ? `transform: scale(${(width - d) / width});` : null : null;
    } else
      scale = d ? width + d <= finallySize ? `transform: scale(${(width + d) / width})` : null : null;
    const options = [`left: ${x}px`, `top: ${y}px`, `width: ${width}px`, `height: ${height}px`];
    scale && options.push(scale);
    options.push(`transition: all ${lazy}s`);
    this.changeStyle(options);
  }
  changeStyle(arr2) {
    const original = this.cloneEl.style.cssText.split(";");
    original.pop();
    this.cloneEl.style.cssText = original.concat(arr2).join(";") + ";";
  }
  finish(done = false) {
    if (!this.dragging) {
      return;
    }
    this.dragging = false;
    erpStore.commit("setDraging", false);
    erpStore.commit("selectItem", {});
    if (!this.cloneEl) {
      return;
    }
    if (!done) {
      const { pageX, offsetX, pageY, offsetY } = this.initial;
      this.changeStyle([`left: ${pageX - offsetX}px`, `top: ${pageY - offsetY}px`, "transform: scale(1)", "transition: all 0.3s"]);
    }
    setTimeout(
      () => {
        this.queue.length && this.queue.shift()();
        this.cloneEl && this.cloneEl.remove();
        this.cloneEl = null;
      },
      done ? 0 : 300
    );
  }
  distance({ pageX, pageY }) {
    const { pageX: x, pageY: y } = this.initial;
    return Math.hypot(pageX - x, pageY - y);
  }
}
var CompListWrap_vue_vue_type_style_index_0_scoped_true_lang = "";
const dragHelper$1 = new dragHelper$2();
let isDrag$1 = false;
let startPoint$1 = { x: 99999, y: 99999 };
let tempDetail = null;
const _sfc_main$C = defineComponent({
  components: {},
  setup(props2) {
    const state = reactive$1({
      loading: false,
      loadDone: false,
      list: [],
      searchValue: "",
      currentCategory: null,
      types: [],
      showList: []
    });
    const pageOptions = { type: 1, page: 0, per_page: 20 };
    onMounted(async () => {
      console.log(state.types);
      if (state.types.length <= 0) {
        const types = await api$1.material.getKinds({ type: 3 });
        state.types = types;
        for (const iterator of types) {
          const { list } = await api$1.home.getCompList({
            cate: iterator.id,
            type: 1,
            per_page: 3
          });
          state.showList.push(list);
        }
      }
    });
    const mouseup = (e2) => {
      e2.preventDefault();
      isDrag$1 = false;
      tempDetail = null;
      startPoint$1 = { x: 99999, y: 99999 };
    };
    const mousemove = (e2) => {
      e2.preventDefault();
      if (e2.x - startPoint$1.x > 2 || e2.y - startPoint$1.y > 2) {
        isDrag$1 = true;
      }
    };
    const load = async (init2 = false) => {
      var _a2;
      if (init2) {
        state.list = [];
        pageOptions.page = 0;
        state.loadDone = false;
      }
      if (state.loadDone || state.loading) {
        return;
      }
      state.loading = true;
      pageOptions.page += 1;
      const res = await api$1.home.getCompList({
        ...Object.assign(pageOptions, { cate: (_a2 = state.currentCategory) == null ? void 0 : _a2.id })
      });
      if (init2) {
        state.list = res == null ? void 0 : res.list;
      } else {
        (res == null ? void 0 : res.list.length) <= 0 && (state.loadDone = true);
        state.list = state.list.concat(res == null ? void 0 : res.list);
      }
      setTimeout(() => {
        state.loading = false;
      }, 100);
    };
    function action({ name: name2, value }, item, index2) {
      switch (name2) {
        case "del":
          delComp(item, index2);
          break;
      }
    }
    function delComp({ id }, index2) {
      api$1.home.removeComp({ id });
      state.list.splice(index2, 1);
    }
    const selectTypes = (item) => {
      state.currentCategory = item;
      load(true);
    };
    const back = () => {
      state.currentCategory = null;
    };
    return {
      ...toRefs(state),
      load,
      action,
      back,
      selectTypes,
      mouseup,
      mousemove
    };
  },
  methods: {
    ...mapActions(["addGroup", "addWidget"]),
    async selectItem(item) {
      if (isDrag$1) {
        return;
      }
      this.$store.commit("setShowMoveable", false);
      tempDetail = tempDetail || await api$1.home.getTempDetail({ id: item.id, type: 1 });
      const group = await setCompData(tempDetail.data);
      let parent = { x: 0, y: 0 };
      const { width: pW, height: pH } = this.$store.getters.dPage;
      Array.isArray(group) && group.forEach((element) => {
        element.type === "w-group" && (parent = element);
      });
      if (parent.isContainer) {
        group.forEach((element) => {
          element.left += (pW - parent.width) / 2;
          element.top += (pH - parent.height) / 2;
        });
        this.addGroup(group);
      } else {
        group.text && (group.text = decodeURIComponent(group.text));
        group.left = pW / 2 - group.fontSize * (group.text.length / 2);
        group.top = pH / 2 - group.fontSize / 2;
        this.addWidget(group);
      }
    },
    async dragStart(e2, { id, width, height, cover }) {
      startPoint$1 = { x: e2.x, y: e2.y };
      let finalWidth = 0;
      dragHelper$1.start(e2, finalWidth);
      tempDetail = await api$1.home.getTempDetail({ id, type: 1 });
      if (Array.isArray(JSON.parse(tempDetail.data))) {
        this.$store.commit("selectItem", { data: JSON.parse(tempDetail.data), type: "group" });
      } else {
        this.$store.commit("selectItem", { data: JSON.parse(tempDetail.data), type: "text" });
      }
    }
  }
});
const _withScopeId$i = (n) => (pushScopeId("data-v-8dfd48b2"), n = n(), popScopeId(), n);
const _hoisted_1$A = { class: "wrap" };
const _hoisted_2$w = { class: "list-wrap" };
const _hoisted_3$s = ["onMousedown", "onClick", "onDragstart"];
const _hoisted_4$o = {
  key: 0,
  class: "infinite-list",
  "infinite-scroll-distance": 150,
  style: { "overflow": "auto" }
};
const _hoisted_5$k = ["onMousedown", "onClick", "onDragstart"];
const _hoisted_6$f = { class: "loading" };
const _hoisted_7$b = /* @__PURE__ */ _withScopeId$i(() => /* @__PURE__ */ createElementVNode("i", { class: "el-icon-loading" }, null, -1));
const _hoisted_8$8 = { class: "loading" };
function _sfc_render$y(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_image = resolveComponent("el-image");
  const _component_classHeader = resolveComponent("classHeader");
  const _component_el_space = resolveComponent("el-space");
  const _directive_infinite_scroll = resolveDirective("infinite-scroll");
  return openBlock(), createElementBlock("div", _hoisted_1$A, [
    withDirectives(createVNode(_component_classHeader, {
      types: _ctx.types,
      onSelect: _ctx.selectTypes
    }, {
      default: withCtx(({ index: index2 }) => [
        createElementVNode("div", _hoisted_2$w, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.showList[index2], (item, i) => {
            return openBlock(), createElementBlock("div", {
              key: i + "sl",
              draggable: "false",
              onMousedown: ($event) => _ctx.dragStart($event, item),
              onMousemove: _cache[0] || (_cache[0] = (...args) => _ctx.mousemove && _ctx.mousemove(...args)),
              onMouseup: _cache[1] || (_cache[1] = (...args) => _ctx.mouseup && _ctx.mouseup(...args)),
              onClick: withModifiers(($event) => _ctx.selectItem(item), ["stop"]),
              onDragstart: ($event) => _ctx.dragStart($event, item)
            }, [
              createVNode(_component_el_image, {
                class: "list__img-thumb",
                src: item.cover,
                fit: "contain",
                lazy: "",
                loading: "lazy"
              }, null, 8, ["src"])
            ], 40, _hoisted_3$s);
          }), 128))
        ])
      ]),
      _: 1
    }, 8, ["types", "onSelect"]), [
      [vShow, !_ctx.currentCategory]
    ]),
    _ctx.currentCategory ? withDirectives((openBlock(), createElementBlock("ul", _hoisted_4$o, [
      createVNode(_component_classHeader, {
        "is-back": true,
        onBack: _ctx.back
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.currentCategory.name), 1)
        ]),
        _: 1
      }, 8, ["onBack"]),
      createVNode(_component_el_space, {
        fill: "",
        wrap: "",
        fillRatio: 30,
        direction: "horizontal",
        class: "list"
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.list, (item, i) => {
            return openBlock(), createElementBlock("div", {
              key: i + "i",
              class: "list__item",
              draggable: "false",
              onMousedown: ($event) => _ctx.dragStart($event, item),
              onMousemove: _cache[2] || (_cache[2] = (...args) => _ctx.mousemove && _ctx.mousemove(...args)),
              onMouseup: _cache[3] || (_cache[3] = (...args) => _ctx.mouseup && _ctx.mouseup(...args)),
              onClick: withModifiers(($event) => _ctx.selectItem(item), ["stop"]),
              onDragstart: ($event) => _ctx.dragStart($event, item)
            }, [
              createVNode(_component_el_image, {
                class: "list__img",
                src: item.cover,
                fit: "contain",
                lazy: "",
                loading: "lazy"
              }, null, 8, ["src"])
            ], 40, _hoisted_5$k);
          }), 128))
        ]),
        _: 1
      }),
      withDirectives(createElementVNode("div", _hoisted_6$f, [
        _hoisted_7$b,
        createTextVNode(" \u62FC\u547D\u52A0\u8F7D\u4E2D")
      ], 512), [
        [vShow, _ctx.loading]
      ]),
      withDirectives(createElementVNode("div", _hoisted_8$8, "\u5168\u90E8\u52A0\u8F7D\u5B8C\u6BD5", 512), [
        [vShow, _ctx.loadDone]
      ])
    ])), [
      [_directive_infinite_scroll, _ctx.load]
    ]) : createCommentVNode("", true)
  ]);
}
var CompListWrap = /* @__PURE__ */ _export_sfc(_sfc_main$C, [["render", _sfc_render$y], ["__scopeId", "data-v-8dfd48b2"]]);
var __glob_0_16 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": CompListWrap
}, Symbol.toStringTag, { value: "Module" }));
var GraphListWrap_vue_vue_type_style_index_0_scoped_true_lang = "";
let isDrag = false;
let startPoint = { x: 99999, y: 99999 };
const dragHelper = new dragHelper$2();
const _sfc_main$B = defineComponent({
  components: {},
  props: ["active"],
  setup(props2) {
    const colors = ["#f8704b", "#5b89ff", "#2cc4cc", "#a8ba73", "#f8704b"];
    const state = reactive$1({
      loading: false,
      loadDone: false,
      sub: [],
      list: [],
      currentType: 2,
      currentCheck: 0,
      colors,
      currentCategory: null,
      types: [],
      showList: [],
      searchKeyword: ""
    });
    const pageOptions = { page: 0, per_page: 20 };
    onMounted(async () => {
      if (state.types.length <= 0) {
        const types = await api$1.material.getKinds({ type: 2 });
        state.types = types;
        for (const iterator of types) {
          const { list } = await api$1.material.getList({
            cate: iterator.id,
            per_page: 3
          });
          state.showList.push(list);
        }
      }
    });
    const mouseup = (e2) => {
      e2.preventDefault();
      setTimeout(() => {
        isDrag = false;
        startPoint = { x: 99999, y: 99999 };
      }, 10);
    };
    const mousemove = (e2) => {
      e2.preventDefault();
      if (e2.x - startPoint.x > 2 || e2.y - startPoint.y > 2) {
        isDrag = true;
      }
    };
    const load = async (init2 = false) => {
      var _a2;
      if (init2) {
        state.list = [];
        pageOptions.page = 0;
        state.loadDone = false;
      }
      if (state.loadDone || state.loading) {
        return;
      }
      state.loading = true;
      pageOptions.page += 1;
      const list = await api$1.material.getList({
        ...{ cate: (_a2 = state.currentCategory) == null ? void 0 : _a2.id, search: state.searchKeyword, ...pageOptions }
      });
      if (init2) {
        state.list = list == null ? void 0 : list.list;
      } else {
        state.list = state.list.concat(list == null ? void 0 : list.list);
      }
      (list == null ? void 0 : list.list.length) <= 0 && (state.loadDone = true);
      setTimeout(() => {
        state.loading = false;
      }, 100);
    };
    const searchChange = (e2) => {
      state.currentCategory = { name: "\u641C\u7D22\u7ED3\u679C" };
      load(true);
    };
    const selectTypes = (item) => {
      state.currentCategory = item;
      load(true);
    };
    const back = () => {
      state.currentCategory = null;
    };
    return {
      ...toRefs(state),
      load,
      searchChange,
      selectTypes,
      back,
      mouseup,
      mousemove
    };
  },
  computed: {
    ...mapGetters(["dPage"])
  },
  methods: {
    ...mapActions(["addWidget"]),
    async selectItem(item) {
      if (isDrag) {
        return;
      }
      this.$store.commit("setShowMoveable", false);
      let setting = item.type === "svg" ? JSON.parse(JSON.stringify(wSvg.setting)) : JSON.parse(JSON.stringify(wImage.setting));
      const img = await setItem2Data(item);
      setting.width = img.width;
      setting.height = img.height;
      const { width: pW, height: pH } = this.dPage;
      setting.left = pW / 2 - img.width / 2;
      setting.top = pH / 2 - img.height / 2;
      setting.imgUrl = item.url;
      if (item.type === "svg") {
        setting.svgUrl = item.url;
        const models = JSON.parse(item.model);
        for (const key in models) {
          if (Object.hasOwnProperty.call(models, key)) {
            setting[key] = models[key];
          }
        }
      }
      if (item.type === "mask") {
        setting.mask = item.url;
      }
      this.addWidget(setting);
    },
    async dragStart(e2, item) {
      startPoint = { x: e2.x, y: e2.y };
      const { width, height, thumb, url } = item;
      const img = await setItem2Data({ width, height, url: thumb || url });
      dragHelper.start(e2, img.canvasWidth);
      this.$store.commit("selectItem", { data: { value: item }, type: item.type });
    }
  }
});
const _withScopeId$h = (n) => (pushScopeId("data-v-3a0152a9"), n = n(), popScopeId(), n);
const _hoisted_1$z = { class: "wrap" };
const _hoisted_2$v = /* @__PURE__ */ _withScopeId$h(() => /* @__PURE__ */ createElementVNode("div", { style: { "height": "0.5rem" } }, null, -1));
const _hoisted_3$r = { class: "list-wrap" };
const _hoisted_4$n = ["onMousedown", "onClick", "onDragstart"];
const _hoisted_5$j = {
  key: 0,
  class: "infinite-list",
  "infinite-scroll-distance": 150,
  style: { "overflow": "auto" }
};
const _hoisted_6$e = ["onMousedown", "onClick", "onDragstart"];
const _hoisted_7$a = { class: "loading" };
const _hoisted_8$7 = /* @__PURE__ */ _withScopeId$h(() => /* @__PURE__ */ createElementVNode("i", { class: "el-icon-loading" }, null, -1));
function _sfc_render$x(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_search_header = resolveComponent("search-header");
  const _component_el_image = resolveComponent("el-image");
  const _component_classHeader = resolveComponent("classHeader");
  const _component_el_space = resolveComponent("el-space");
  const _directive_infinite_scroll = resolveDirective("infinite-scroll");
  return openBlock(), createElementBlock("div", _hoisted_1$z, [
    createVNode(_component_search_header, {
      modelValue: _ctx.searchKeyword,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.searchKeyword = $event),
      type: "none",
      onChange: _ctx.searchChange
    }, null, 8, ["modelValue", "onChange"]),
    _hoisted_2$v,
    withDirectives(createVNode(_component_classHeader, {
      types: _ctx.types,
      onSelect: _ctx.selectTypes
    }, {
      default: withCtx(({ index: index2 }) => [
        createElementVNode("div", _hoisted_3$r, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.showList[index2], (item, i) => {
            return openBlock(), createElementBlock("div", {
              key: i + "sl",
              draggable: "false",
              onMousedown: ($event) => _ctx.dragStart($event, item),
              onMousemove: _cache[1] || (_cache[1] = (...args) => _ctx.mousemove && _ctx.mousemove(...args)),
              onMouseup: _cache[2] || (_cache[2] = (...args) => _ctx.mouseup && _ctx.mouseup(...args)),
              onClick: withModifiers(($event) => _ctx.selectItem(item), ["stop"]),
              onDragstart: ($event) => _ctx.dragStart($event, item)
            }, [
              createVNode(_component_el_image, {
                class: "list__img-thumb",
                src: item.thumb,
                fit: "contain",
                lazy: "",
                loading: "lazy"
              }, null, 8, ["src"])
            ], 40, _hoisted_4$n);
          }), 128))
        ])
      ]),
      _: 1
    }, 8, ["types", "onSelect"]), [
      [vShow, !_ctx.currentCategory]
    ]),
    _ctx.currentCategory ? withDirectives((openBlock(), createElementBlock("ul", _hoisted_5$j, [
      createVNode(_component_classHeader, {
        "is-back": true,
        onBack: _ctx.back
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.currentCategory.name), 1)
        ]),
        _: 1
      }, 8, ["onBack"]),
      createVNode(_component_el_space, {
        fill: "",
        wrap: "",
        fillRatio: 30,
        direction: "horizontal",
        class: "list"
      }, {
        default: withCtx(() => [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.list, (item, i) => {
            return openBlock(), createElementBlock("div", {
              key: i + "i",
              class: "list__item",
              draggable: "false",
              onMousedown: ($event) => _ctx.dragStart($event, item),
              onMousemove: _cache[3] || (_cache[3] = (...args) => _ctx.mousemove && _ctx.mousemove(...args)),
              onMouseup: _cache[4] || (_cache[4] = (...args) => _ctx.mouseup && _ctx.mouseup(...args)),
              onClick: withModifiers(($event) => _ctx.selectItem(item), ["stop"]),
              onDragstart: ($event) => _ctx.dragStart($event, item)
            }, [
              createVNode(_component_el_image, {
                class: "list__img",
                src: item.thumb,
                fit: "contain",
                lazy: "",
                loading: "lazy"
              }, null, 8, ["src"])
            ], 40, _hoisted_6$e);
          }), 128))
        ]),
        _: 1
      }),
      withDirectives(createElementVNode("div", _hoisted_7$a, [
        _hoisted_8$7,
        createTextVNode(" \u62FC\u547D\u52A0\u8F7D\u4E2D")
      ], 512), [
        [vShow, _ctx.loading]
      ]),
      withDirectives(createElementVNode("div", {
        style: normalizeStyle(_ctx.list.length <= 0 ? "padding-top: 4rem" : ""),
        class: "loading"
      }, "\u5168\u90E8\u52A0\u8F7D\u5B8C\u6BD5", 4), [
        [vShow, _ctx.loadDone]
      ])
    ])), [
      [_directive_infinite_scroll, _ctx.load]
    ]) : createCommentVNode("", true)
  ]);
}
var GraphListWrap = /* @__PURE__ */ _export_sfc(_sfc_main$B, [["render", _sfc_render$x], ["__scopeId", "data-v-3a0152a9"]]);
var __glob_0_17 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": GraphListWrap
}, Symbol.toStringTag, { value: "Module" }));
var PhotoListWrap_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$i = "img-list-wrap";
const _sfc_main$A = {
  name: NAME$i,
  components: {},
  props: ["active"],
  setup() {
    const store = useStore();
    const state = reactive$1({
      recommendImgList: [],
      loadDone: false,
      page: 0,
      currentCategory: null,
      types: [],
      showList: []
    });
    const dPage = computed$1(() => store.getters.dPage);
    let loading = false;
    onMounted(async () => {
      if (state.types.length <= 0) {
        const types = await api$1.material.getKinds({ type: 4 });
        state.types = types;
        for (const iterator of types) {
          const { list } = await api$1.material.getImagesList({ cate: iterator.id, per_page: 2 });
          state.showList.push(list);
        }
      }
    });
    const selectImg = async (index2, list) => {
      const item = list ? list[index2] : state.recommendImgList[index2];
      store.commit("setShowMoveable", false);
      let setting = JSON.parse(JSON.stringify(wImage.setting));
      const img = await setItem2Data(item);
      setting.width = img.width;
      setting.height = img.height;
      setting.imgUrl = item.url;
      const { width: pW, height: pH } = dPage;
      setting.left = pW / 2 - img.width / 2;
      setting.top = pH / 2 - img.height / 2;
      store.dispatch("addWidget", setting);
    };
    const getDataList = async () => {
      if (state.loadDone || loading) {
        return;
      }
      loading = true;
      state.page += 1;
      let { list = [], total } = await api$1.material.getImagesList({ cate: state.currentCategory.id, page: state.page, per_page: 30 });
      list.length <= 0 ? state.loadDone = true : state.recommendImgList = state.recommendImgList.concat(list);
      setTimeout(() => {
        loading = false;
      }, 100);
    };
    const dragStart2 = (index2, list) => {
      const item = list ? list[index2] : state.recommendImgList[index2];
      store.commit("selectItem", { data: { value: item }, type: "image" });
    };
    const searchChange = (e2) => {
      console.log(e2);
    };
    const selectTypes = (item) => {
      state.currentCategory = item;
      getDataList();
    };
    const back = () => {
      state.currentCategory = null;
      state.page = 0;
      state.loadDone = false;
      state.recommendImgList = [];
    };
    return {
      ...toRefs(state),
      selectImg,
      getDataList,
      dragStart: dragStart2,
      searchChange,
      selectTypes,
      back
    };
  }
};
const _withScopeId$g = (n) => (pushScopeId("data-v-75d052a4"), n = n(), popScopeId(), n);
const _hoisted_1$y = { class: "wrap" };
const _hoisted_2$u = /* @__PURE__ */ _withScopeId$g(() => /* @__PURE__ */ createElementVNode("div", { style: { "height": "0.5rem" } }, null, -1));
const _hoisted_3$q = { key: 0 };
const _hoisted_4$m = /* @__PURE__ */ _withScopeId$g(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
const _hoisted_5$i = /* @__PURE__ */ _withScopeId$g(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
const _hoisted_6$d = /* @__PURE__ */ _withScopeId$g(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
const _hoisted_7$9 = { style: { "margin": "0 1rem", "height": "100vh" } };
function _sfc_render$w(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_search_header = resolveComponent("search-header");
  const _component_photo_list = resolveComponent("photo-list");
  const _component_classHeader = resolveComponent("classHeader");
  return openBlock(), createElementBlock("div", _hoisted_1$y, [
    createVNode(_component_search_header, {
      type: "none",
      onChange: $setup.searchChange
    }, null, 8, ["onChange"]),
    _hoisted_2$u,
    withDirectives(createVNode(_component_classHeader, {
      types: _ctx.types,
      onSelect: $setup.selectTypes
    }, {
      default: withCtx(({ index: index2 }) => [
        createVNode(_component_photo_list, {
          isShort: true,
          listData: _ctx.showList[index2],
          onLoad: $setup.getDataList,
          onDrag: ($event) => $setup.dragStart($event, _ctx.showList[index2]),
          onSelect: ($event) => $setup.selectImg($event, _ctx.showList[index2])
        }, null, 8, ["listData", "onLoad", "onDrag", "onSelect"])
      ]),
      _: 1
    }, 8, ["types", "onSelect"]), [
      [vShow, !_ctx.currentCategory]
    ]),
    _ctx.currentCategory ? (openBlock(), createElementBlock("div", _hoisted_3$q, [
      createVNode(_component_classHeader, {
        "is-back": true,
        onBack: $setup.back
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString(_ctx.currentCategory.name), 1)
        ]),
        _: 1
      }, 8, ["onBack"]),
      _hoisted_4$m,
      _hoisted_5$i,
      _hoisted_6$d,
      createElementVNode("div", _hoisted_7$9, [
        createVNode(_component_photo_list, {
          isDone: _ctx.loadDone,
          listData: _ctx.recommendImgList,
          onLoad: $setup.getDataList,
          onDrag: $setup.dragStart,
          onSelect: $setup.selectImg
        }, null, 8, ["isDone", "listData", "onLoad", "onDrag", "onSelect"])
      ])
    ])) : createCommentVNode("", true)
  ]);
}
var PhotoListWrap = /* @__PURE__ */ _export_sfc(_sfc_main$A, [["render", _sfc_render$w], ["__scopeId", "data-v-75d052a4"]]);
var __glob_0_18 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": PhotoListWrap
}, Symbol.toStringTag, { value: "Module" }));
var elButton = "";
var elButtonGroup = "";
var elPopper = "";
var elScrollbar = "";
var elDropdown = "";
var elDropdownItem = "";
var elDropdownMenu = "";
var searchHeader_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$z = defineComponent({
  components: { ElDropdown, ElDropdownItem, ElDropdownMenu },
  props: ["type", "modelValue"],
  emits: ["update:modelValue"],
  setup(props2, context) {
    const state = reactive$1({
      searchValue: "",
      materialCates: [],
      currentIndex: 0
    });
    if (props2.type != "none") {
      api$1.home.getCategories({ type: 1 }).then((list) => {
        list.unshift({ id: 0, name: "\u5168\u90E8" });
        state.materialCates = list;
      });
    }
    watch(
      () => state.searchValue,
      () => {
        context.emit("update:modelValue", state.searchValue);
      }
    );
    function action(fn2, type, currentIndex) {
      currentIndex && (state.currentIndex = currentIndex);
      context.emit(fn2, type);
    }
    return {
      ...toRefs(state),
      action
    };
  }
});
const _withScopeId$f = (n) => (pushScopeId("data-v-6f8d40de"), n = n(), popScopeId(), n);
const _hoisted_1$x = { class: "search__wrap" };
const _hoisted_2$t = /* @__PURE__ */ _withScopeId$f(() => /* @__PURE__ */ createElementVNode("i", { class: "iconfont icon-search" }, null, -1));
function _sfc_render$v(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_button = resolveComponent("el-button");
  const _component_el_input = resolveComponent("el-input");
  return openBlock(), createElementBlock("div", _hoisted_1$x, [
    createVNode(_component_el_input, {
      modelValue: _ctx.searchValue,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.searchValue = $event),
      size: "large",
      placeholder: "\u8F93\u5165\u5173\u952E\u8BCD\u641C\u7D22",
      class: "input-with-select ml-3"
    }, {
      append: withCtx(() => [
        createVNode(_component_el_button, null, {
          default: withCtx(() => [
            _hoisted_2$t
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["modelValue"])
  ]);
}
var searchHeader = /* @__PURE__ */ _export_sfc(_sfc_main$z, [["render", _sfc_render$v], ["__scopeId", "data-v-6f8d40de"]]);
var __glob_0_40 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": searchHeader
}, Symbol.toStringTag, { value: "Module" }));
var elMessageBox = "";
var elInput = "";
var elOverlay = "";
var useConfirm = (title = "\u63D0\u793A", message = "", type = "success") => {
  return new Promise((resolve) => {
    ElMessageBox.confirm(message, title, {
      confirmButtonText: "\u786E\u5B9A",
      cancelButtonText: "\u53D6\u6D88",
      type
    }).then(() => {
      resolve(true);
    }).catch(() => {
      resolve(false);
    });
  });
};
var editModel_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$y = defineComponent({
  components: { ElDropdown, ElDropdownItem, ElDropdownMenu },
  props: {
    options: {
      default: () => []
    },
    data: {}
  },
  emits: ["action"],
  setup(props2, context) {
    async function action(name2, value) {
      if (name2 === "del") {
        const isDel = await useConfirm("\u8B66\u544A", "\u5220\u9664\u540E\u4E0D\u53EF\u6062\u590D,\u662F\u5426\u7EE7\u7EED", "warning");
        if (!isDel) {
          return false;
        }
      }
      context.emit("action", { name: name2, value });
    }
    return {
      action
    };
  }
});
const _withScopeId$e = (n) => (pushScopeId("data-v-9746184a"), n = n(), popScopeId(), n);
const _hoisted_1$w = { class: "wrap" };
const _hoisted_2$s = /* @__PURE__ */ _withScopeId$e(() => /* @__PURE__ */ createElementVNode("i", { class: "iconfont icon-more" }, null, -1));
function _sfc_render$u(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_dropdown_item = resolveComponent("el-dropdown-item");
  const _component_el_dropdown_menu = resolveComponent("el-dropdown-menu");
  const _component_el_dropdown = resolveComponent("el-dropdown");
  return openBlock(), createElementBlock("div", _hoisted_1$w, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true),
    createElementVNode("div", {
      class: "showMask",
      onClick: _cache[0] || (_cache[0] = withModifiers(() => {
      }, ["stop"]))
    }, [
      createVNode(_component_el_dropdown, {
        placement: "bottom-end",
        "show-arrow": false
      }, {
        dropdown: withCtx(() => [
          createVNode(_component_el_dropdown_menu, null, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.options, (op, oi) => {
                return openBlock(), createBlock(_component_el_dropdown_item, {
                  key: oi + "o",
                  onClick: ($event) => op.fn(_ctx.data)
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString(op.name), 1)
                  ]),
                  _: 2
                }, 1032, ["onClick"]);
              }), 128))
            ]),
            _: 1
          })
        ]),
        default: withCtx(() => [
          _hoisted_2$s
        ]),
        _: 1
      })
    ])
  ]);
}
var editModel = /* @__PURE__ */ _export_sfc(_sfc_main$y, [["render", _sfc_render$u], ["__scopeId", "data-v-9746184a"]]);
var __glob_0_36 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": editModel
}, Symbol.toStringTag, { value: "Module" }));
var imgWaterFall_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$h = "img-water-fall";
const _sfc_main$x = defineComponent({
  name: NAME$h,
  components: { editModel },
  props: {
    listData: {
      type: Array,
      required: true
    },
    edit: {}
  },
  emits: ["select", "load"],
  setup(props2, { emit: emit2 }) {
    const state = reactive$1({
      width: 146,
      list: [],
      countHeight: 0
    });
    const columnHeights = [];
    const columnNums = 2;
    const gap = 7;
    watch(
      () => props2.listData,
      () => {
        columnHeights.length = 0;
        const widthLimit = state.width * columnNums;
        const cloneList = JSON.parse(JSON.stringify(props2.listData));
        for (let i = 0; i < cloneList.length; i++) {
          let index2 = i % columnNums;
          const item = cloneList[i];
          item.height = item.height / item.width * state.width;
          item.left = index2 * (widthLimit / columnNums + gap);
          item.top = columnHeights[index2] + gap || 0;
          if (isNaN(columnHeights[index2])) {
            columnHeights[index2] = item.height;
          } else {
            index2 = columnHeights.indexOf(Math.min(...columnHeights));
            item.left = index2 * (widthLimit / columnNums + gap);
            item.top = columnHeights[index2] + gap || 0;
            columnHeights[index2] = item.height + columnHeights[index2] + gap;
          }
        }
        state.countHeight = Math.max(...columnHeights);
        state.list = cloneList;
      }
    );
    const load = () => {
      emit2("load");
    };
    const selectItem = (value, index2) => {
      emit2("select", value);
    };
    const loadError = (item) => {
      item.fail = true;
    };
    return {
      ...toRefs(state),
      load,
      selectItem,
      loadError
    };
  }
});
const _hoisted_1$v = ["onClick"];
const _hoisted_2$r = {
  key: 0,
  class: "list__mask"
};
const _hoisted_3$p = {
  key: 2,
  class: "fail_img"
};
function _sfc_render$t(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_image = resolveComponent("el-image");
  const _component_edit_model = resolveComponent("edit-model");
  return openBlock(), createElementBlock("div", {
    ref: "imgWaterFall",
    style: normalizeStyle({ height: _ctx.countHeight + "px" }),
    class: "img-water-fall"
  }, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.list, (item, i) => {
      return openBlock(), createElementBlock("div", {
        key: i + "iwf",
        style: normalizeStyle({ top: item.top + "px", left: item.left + "px", width: _ctx.width + "px", height: item.height + "px" }),
        class: "img-box",
        onClick: withModifiers(($event) => _ctx.selectItem(item, i), ["stop"])
      }, [
        _ctx.edit ? (openBlock(), createBlock(_component_edit_model, {
          key: 0,
          options: _ctx.edit,
          data: { item, i }
        }, {
          default: withCtx(() => [
            createTextVNode(toDisplayString(item.isDelect) + " ", 1),
            item.isDelect ? (openBlock(), createElementBlock("div", _hoisted_2$r, "\u5DF2\u5220\u9664")) : createCommentVNode("", true),
            !item.fail ? (openBlock(), createBlock(_component_el_image, {
              key: 1,
              class: "img",
              src: item.cover,
              lazy: "",
              loading: "lazy",
              onError: ($event) => _ctx.loadError(item)
            }, null, 8, ["src", "onError"])) : (openBlock(), createElementBlock("div", _hoisted_3$p, toDisplayString(item.title), 1))
          ]),
          _: 2
        }, 1032, ["options", "data"])) : (openBlock(), createBlock(_component_el_image, {
          key: 1,
          class: "img",
          src: item.cover,
          lazy: "",
          loading: "lazy",
          onError: ($event) => _ctx.loadError(item)
        }, null, 8, ["src", "onError"]))
      ], 12, _hoisted_1$v);
    }), 128))
  ], 4);
}
var imgWaterFall = /* @__PURE__ */ _export_sfc(_sfc_main$x, [["render", _sfc_render$t], ["__scopeId", "data-v-58ea164a"]]);
var __glob_0_38 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": imgWaterFall
}, Symbol.toStringTag, { value: "Module" }));
var TempListWrap_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$w = defineComponent({
  components: { searchHeader, imgWaterFall },
  props: {
    isModal: {
      type: Boolean
    }
  },
  setup(props2) {
    const instance = getCurrentInstance();
    const listRef = ref$1(null);
    const store = useStore();
    const state = reactive$1({
      loading: false,
      loadDone: false,
      list: [],
      title: "\u63A8\u8350\u6A21\u677F",
      searchKeyword: ""
    });
    const pageOptions = { page: 0, per_page: 20, cate: 0 };
    const templateDate = computed$1(() => store.state.templateDate);
    const templateId = computed$1(() => store.state.templateId);
    const load = async (init2 = false, stat) => {
      stat && (pageOptions.state = stat);
      if (init2) {
        listRef.value.scrollTop = 0;
        state.list = [];
        pageOptions.page = 0;
        state.loadDone = false;
      }
      if (state.loadDone || state.loading) {
        return;
      }
      state.loading = true;
      pageOptions.page += 1;
      const res = await api$1.home.getTempList({ search: state.searchKeyword, ...pageOptions, sort: "id", order: "desc" });
      res.list.length <= 0 && (state.loadDone = true);
      state.list = state.list.concat(res.list);
      setTimeout(() => {
        state.loading = false;
        checkHeight();
      }, 100);
    };
    function cateChange(type) {
      state.title = type.name;
      const init2 = pageOptions.cate != type.id;
      pageOptions.cate = type.id;
      load(init2, pageOptions.stat);
    }
    function checkHeight() {
      const isLess = listRef.value.offsetHeight > listRef.value.firstElementChild.offsetHeight;
      isLess && load();
    }
    watch(
      () => templateDate.value,
      (n) => {
        load(true);
      }
    );
    watch(
      () => templateId.value,
      async (n) => {
        var _a2, _b, _c;
        if (n) {
          store.commit("setShowMoveable", false);
          store.commit("managerEdit", false);
          store.commit("setDWidgets", []);
          const res = await api$1.home.getTempDetail({ id: n });
          const result = JSON.parse(res.data);
          const { page, widgets } = result;
          const AcImg = (_a2 = store.state) == null ? void 0 : _a2.imgs;
          if (AcImg && AcImg.length) {
            page.backgroundImage = AcImg[0];
          }
          store.commit("setDPage", page);
          (_b = instance == null ? void 0 : instance.proxy) == null ? void 0 : _b.setTemplate(widgets);
          setTimeout(() => {
            store.commit("zoomScreenChange");
          }, 300);
          (_c = instance == null ? void 0 : instance.proxy) == null ? void 0 : _c.selectWidget({
            uuid: "-1"
          });
        }
      }
    );
    return {
      ...toRefs(state),
      load,
      cateChange,
      listRef
    };
  },
  computed: {
    ...mapGetters(["tempEditing", "dHistoryParams"])
  },
  methods: {
    ...mapActions(["selectWidget", "updatePageData", "setTemplate", "pushHistory"]),
    async selectItem(item) {
      this.setTempId(item.id);
    },
    setTempId(tempId) {
      this.$store.commit("setState", { key: "templateId", value: tempId });
    }
  }
});
const _withScopeId$d = (n) => (pushScopeId("data-v-141b759b"), n = n(), popScopeId(), n);
const _hoisted_1$u = { class: "wrap" };
const _hoisted_2$q = {
  ref: "listRef",
  class: "infinite-list",
  "infinite-scroll-distance": 150,
  style: { "overflow": "auto" }
};
const _hoisted_3$o = { class: "loading" };
const _hoisted_4$l = /* @__PURE__ */ _withScopeId$d(() => /* @__PURE__ */ createElementVNode("i", { class: "el-icon-loading" }, null, -1));
function _sfc_render$s(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_search_header = resolveComponent("search-header");
  const _component_img_water_fall = resolveComponent("img-water-fall");
  const _directive_infinite_scroll = resolveDirective("infinite-scroll");
  return openBlock(), createElementBlock("div", _hoisted_1$u, [
    createVNode(_component_search_header, {
      modelValue: _ctx.searchKeyword,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.searchKeyword = $event),
      onChange: _ctx.cateChange
    }, null, 8, ["modelValue", "onChange"]),
    withDirectives((openBlock(), createElementBlock("ul", _hoisted_2$q, [
      createVNode(_component_img_water_fall, {
        listData: _ctx.list,
        onSelect: _ctx.selectItem
      }, null, 8, ["listData", "onSelect"]),
      withDirectives(createElementVNode("div", _hoisted_3$o, [
        _hoisted_4$l,
        createTextVNode(" \u62FC\u547D\u52A0\u8F7D\u4E2D")
      ], 512), [
        [vShow, _ctx.loading]
      ])
    ])), [
      [_directive_infinite_scroll, _ctx.load]
    ])
  ]);
}
var TempListWrap = /* @__PURE__ */ _export_sfc(_sfc_main$w, [["render", _sfc_render$s], ["__scopeId", "data-v-141b759b"]]);
var __glob_0_19 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": TempListWrap
}, Symbol.toStringTag, { value: "Module" }));
var TextListWrap_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$g = "text-list-wrap";
const _sfc_main$v = {
  name: NAME$g,
  setup() {
    const store = useStore();
    const { proxy } = getCurrentInstance();
    const selectBasicText = (item) => {
      store.commit("setShowMoveable", false);
      let setting = JSON.parse(JSON.stringify(wText.setting));
      setting.text = "\u53CC\u51FB\u7F16\u8F91\u6587\u5B57";
      setting.width = item.fontSize * setting.text.length;
      setting.fontSize = item.fontSize;
      setting.fontWeight = item.fontWeight;
      const { width: pW, height: pH } = store.getters.dPage;
      setting.left = pW / 2 - item.fontSize * 3;
      setting.top = pH / 2 - item.fontSize / 2;
      proxy.addWidget(setting);
    };
    const dragStart2 = (e2, item) => {
      store.commit("setDraging", true);
      store.commit("selectItem", { data: { value: item }, type: "text" });
    };
    return {
      selectBasicText,
      dragStart: dragStart2
    };
  },
  data() {
    return {
      basicTextList: [
        {
          text: "+ \u6DFB\u52A0\u6587\u5B57",
          fontSize: 60,
          fontWeight: "bold"
        }
      ]
    };
  },
  methods: {
    ...mapActions(["addWidget"])
  }
};
const _hoisted_1$t = {
  id: "text-list-wrap",
  style: { "margin-top": "0.5rem" }
};
const _hoisted_2$p = { class: "basic-text-wrap" };
const _hoisted_3$n = ["onClick", "onDragstart"];
const _hoisted_4$k = { class: "other-text-wrap" };
function _sfc_render$r(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_comp_list_wrap = resolveComponent("comp-list-wrap");
  return openBlock(), createElementBlock("div", _hoisted_1$t, [
    createElementVNode("ul", _hoisted_2$p, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($data.basicTextList, (item, index2) => {
        return openBlock(), createElementBlock("div", {
          key: index2,
          class: "basic-text-item",
          style: normalizeStyle({
            fontSize: 14 + "px",
            fontWeight: item.fontWeight
          }),
          draggable: "true",
          onClick: ($event) => $setup.selectBasicText(item),
          onDragstart: ($event) => $setup.dragStart($event, item)
        }, toDisplayString(item.text), 45, _hoisted_3$n);
      }), 128))
    ]),
    createElementVNode("div", _hoisted_4$k, [
      createVNode(_component_comp_list_wrap)
    ])
  ]);
}
var TextListWrap = /* @__PURE__ */ _export_sfc(_sfc_main$v, [["render", _sfc_render$r], ["__scopeId", "data-v-57e112ba"]]);
var __glob_0_20 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": TextListWrap
}, Symbol.toStringTag, { value: "Module" }));
var ToolsListWrap_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$f = "tool-list-wrap";
const _sfc_main$u = {
  name: NAME$f,
  components: { imageCutout: index$3 },
  data() {
    return {
      loadDone: false
    };
  },
  computed: {
    ...mapGetters(["dPage"])
  },
  mounted() {
  },
  methods: {
    ...mapActions(["addWidget"]),
    async getDataList() {
      if (this.loadDone || this.loading) {
        return;
      }
      this.loading = true;
      this.page += 1;
    },
    addQrcode() {
      this.$store.commit("setShowMoveable", false);
      let setting = JSON.parse(JSON.stringify(wQrcode.setting));
      const { width: pW, height: pH } = this.dPage;
      setting.left = pW / 2 - setting.width / 2;
      setting.top = pH / 2 - setting.height / 2;
      this.addWidget(setting);
    },
    openImageCutout() {
      this.$refs.imageCutout.open();
    }
  }
};
const _withScopeId$c = (n) => (pushScopeId("data-v-401c999e"), n = n(), popScopeId(), n);
const _hoisted_1$s = { class: "wrap" };
const _hoisted_2$o = /* @__PURE__ */ _withScopeId$c(() => /* @__PURE__ */ createElementVNode("div", { class: "header" }, "\u7EC4\u4EF6", -1));
const _hoisted_3$m = /* @__PURE__ */ _withScopeId$c(() => /* @__PURE__ */ createElementVNode("i", { class: "icon sd-w-qrcode" }, null, -1));
const _hoisted_4$j = /* @__PURE__ */ _withScopeId$c(() => /* @__PURE__ */ createElementVNode("div", { class: "text" }, [
  /* @__PURE__ */ createElementVNode("span", null, "\u4E8C\u7EF4\u7801"),
  /* @__PURE__ */ createElementVNode("span", { class: "desc" }, "\u5728\u8BBE\u8BA1\u4E2D\u4F7F\u7528\u98CE\u683C\u5316\u4E8C\u7EF4\u7801")
], -1));
const _hoisted_5$h = [
  _hoisted_3$m,
  _hoisted_4$j
];
const _hoisted_6$c = /* @__PURE__ */ _withScopeId$c(() => /* @__PURE__ */ createElementVNode("div", { class: "header" }, "\u5176\u5B83", -1));
const _hoisted_7$8 = /* @__PURE__ */ _withScopeId$c(() => /* @__PURE__ */ createElementVNode("i", { class: "icon sd-AI_zhineng" }, null, -1));
const _hoisted_8$6 = /* @__PURE__ */ _withScopeId$c(() => /* @__PURE__ */ createElementVNode("div", { class: "text" }, [
  /* @__PURE__ */ createElementVNode("span", null, "\u667A\u80FD\u62A0\u56FE"),
  /* @__PURE__ */ createTextVNode(),
  /* @__PURE__ */ createElementVNode("span", { class: "desc" }, "\u4E0A\u4F20\u56FE\u50CF\u4E00\u952E\u53BB\u9664\u80CC\u666F")
], -1));
const _hoisted_9$5 = [
  _hoisted_7$8,
  _hoisted_8$6
];
function _sfc_render$q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_imageCutout = resolveComponent("imageCutout");
  return openBlock(), createElementBlock("div", _hoisted_1$s, [
    _hoisted_2$o,
    createElementVNode("div", {
      class: "item",
      onClick: _cache[0] || (_cache[0] = (...args) => $options.addQrcode && $options.addQrcode(...args))
    }, _hoisted_5$h),
    _hoisted_6$c,
    createElementVNode("div", {
      class: "item",
      onClick: _cache[1] || (_cache[1] = (...args) => $options.openImageCutout && $options.openImageCutout(...args))
    }, _hoisted_9$5),
    createVNode(_component_imageCutout, { ref: "imageCutout" }, null, 512)
  ]);
}
var ToolsListWrap = /* @__PURE__ */ _export_sfc(_sfc_main$u, [["render", _sfc_render$q], ["__scopeId", "data-v-401c999e"]]);
var __glob_0_21 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": ToolsListWrap
}, Symbol.toStringTag, { value: "Module" }));
var elTabPane = "";
var elTabs = "";
var UserWrap_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$t = defineComponent({
  components: { uploader, ElTabPane, ElTabs },
  props: ["active"],
  setup(props2) {
    const store = useStore();
    const state = reactive$1({
      prePath: "user",
      percent: { num: 0 },
      imgList: [],
      designList: [],
      isDone: false,
      editOptions: [],
      listRef: null,
      imgListRef: null,
      tabActiveName: ""
    });
    let loading = false;
    let page = 0;
    let listPage = 0;
    const load = (init2) => {
      if (init2) {
        state.imgList = [];
        page = 0;
        state.isDone = false;
      }
      if (state.isDone || loading) {
        return;
      }
      loading = true;
      page += 1;
      api$1.material.getMyPhoto({ page }).then(({ list }) => {
        list.length <= 0 ? state.isDone = true : state.imgList = state.imgList.concat(list);
        setTimeout(() => {
          loading = false;
          checkHeight(state.imgListRef.getRef(), load);
        }, 100);
      });
    };
    const loadDesign = (init2 = false) => {
      if (init2) {
        state.designList = [];
        listPage = 0;
        state.isDone = false;
      }
      if (state.isDone || loading) {
        return;
      }
      loading = true;
      listPage += 1;
      api$1.home.getMyDesign({ page: listPage, per_page: 10 }).then(({ list }) => {
        list.length <= 0 ? state.isDone = true : state.designList = state.designList.concat(
          list.map((x) => {
            x.cover = x.cover + "?r=" + Math.random();
            return x;
          })
        );
        setTimeout(() => {
          loading = false;
          checkHeight(state.listRef, loadDesign);
        }, 100);
      });
    };
    function checkHeight(el, loadFn) {
      const isLess = el.offsetHeight > el.firstElementChild.offsetHeight;
      isLess && loadFn();
    }
    onMounted(() => {
      load(true);
      nextTick(() => {
        state.tabActiveName = "pics";
      });
    });
    const selectImg = async (index2) => {
      const item = state.imgList[index2];
      store.commit("setShowMoveable", false);
      let setting = JSON.parse(JSON.stringify(wImage.setting));
      const img = await setItem2Data(item);
      setting.width = img.width;
      setting.height = img.height;
      setting.imgUrl = item.url;
      const { width: pW, height: pH } = store.getters.dPage;
      setting.left = pW / 2 - img.width / 2;
      setting.top = pH / 2 - img.height / 2;
      store.dispatch("addWidget", setting);
    };
    const deleteImg = async ({ i, item }) => {
      store.commit("setShowMoveable", false);
      const isPass = await useConfirm("\u8B66\u544A", "\u5220\u9664\u540E\u4E0D\u53EF\u627E\u56DE\uFF0C\u5DF2\u5F15\u7528\u8D44\u6E90\u5C06\u4F1A\u5931\u6548\uFF0C\u8BF7\u8C28\u614E\u64CD\u4F5C", "warning");
      if (!isPass) {
        return false;
      }
      const arr2 = item.url.split("/");
      let key = arr2.splice(3, arr2.length - 1).join("/");
      api$1.material.deleteMyPhoto({ id: item.id, key });
      state.imgListRef.delItem(i);
    };
    const deleteWorks = async ({ i, item }) => {
      const isPass = await useConfirm("\u8B66\u544A", "\u5220\u9664\u540E\u4E0D\u53EF\u627E\u56DE\uFF0C\u8BF7\u786E\u8BA4\u64CD\u4F5C", "warning");
      if (isPass) {
        await api$1.material.deleteMyWorks({ id: item.id });
        setTimeout(() => {
          loadDesign(true);
        }, 300);
      }
    };
    state.editOptions = {
      photo: [
        {
          name: "\u5220\u9664",
          fn: deleteImg
        }
      ],
      works: [
        {
          name: "\u5220\u9664",
          fn: deleteWorks
        }
      ]
    };
    const dragStart2 = (index2) => {
      const item = state.imgList[index2];
      store.commit("selectItem", { data: { value: item }, type: "image" });
    };
    const uploadDone = async (res) => {
      await api$1.material.addMyPhoto(res);
      state.imgList = [];
      load(true);
    };
    const tabChange = (tabName) => {
      if (tabName === "design") {
        loadDesign(true);
      }
    };
    const selectDesign = async (item) => {
      const { id } = item;
      window.open(`${window.location.protocol + "//" + window.location.host}/home?id=${id}`);
    };
    const openPSD = () => {
    };
    return {
      ...toRefs(state),
      selectDesign,
      loadDesign,
      load,
      uploadDone,
      selectImg,
      deleteImg,
      dragStart: dragStart2,
      tabChange,
      openPSD
    };
  }
});
const _withScopeId$b = (n) => (pushScopeId("data-v-2589a4d1"), n = n(), popScopeId(), n);
const _hoisted_1$r = { class: "wrap" };
const _hoisted_2$n = /* @__PURE__ */ _withScopeId$b(() => /* @__PURE__ */ createElementVNode("i", { class: "iconfont icon-upload" }, null, -1));
const _hoisted_3$l = { style: { "margin": "1rem", "height": "100vh" } };
const _hoisted_4$i = { class: "wrap" };
const _hoisted_5$g = {
  ref: "listRef",
  class: "infinite-list",
  "infinite-scroll-distance": 150,
  style: { "overflow": "auto" }
};
const _hoisted_6$b = { class: "loading" };
function _sfc_render$p(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tab_pane = resolveComponent("el-tab-pane");
  const _component_el_tabs = resolveComponent("el-tabs");
  const _component_el_button = resolveComponent("el-button");
  const _component_uploader = resolveComponent("uploader");
  const _component_photo_list = resolveComponent("photo-list");
  const _component_img_water_fall = resolveComponent("img-water-fall");
  const _directive_infinite_scroll = resolveDirective("infinite-scroll");
  return openBlock(), createElementBlock("div", _hoisted_1$r, [
    createVNode(_component_el_tabs, {
      modelValue: _ctx.tabActiveName,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.tabActiveName = $event),
      stretch: true,
      class: "tabs",
      onTabChange: _ctx.tabChange
    }, {
      default: withCtx(() => [
        createVNode(_component_el_tab_pane, {
          label: "\u8D44\u6E90\u7BA1\u7406",
          name: "pics"
        }),
        createVNode(_component_el_tab_pane, {
          label: "\u6211\u7684\u4F5C\u54C1",
          name: "design"
        })
      ]),
      _: 1
    }, 8, ["modelValue", "onTabChange"]),
    withDirectives(createElementVNode("div", null, [
      createVNode(_component_uploader, {
        modelValue: _ctx.percent,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.percent = $event),
        class: "upload",
        onDone: _ctx.uploadDone
      }, {
        default: withCtx(() => [
          createVNode(_component_el_button, {
            class: "upload-btn",
            plain: ""
          }, {
            default: withCtx(() => [
              createTextVNode("\u4E0A\u4F20\u56FE\u7247 "),
              _hoisted_2$n
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["modelValue", "onDone"]),
      createVNode(_component_el_button, {
        class: "upload-btn upload-psd",
        plain: "",
        type: "primary",
        onClick: _ctx.openPSD
      }, {
        default: withCtx(() => [
          createTextVNode("\u4E0A\u4F20 PSD \u6A21\u677F")
        ]),
        _: 1
      }, 8, ["onClick"]),
      createElementVNode("div", _hoisted_3$l, [
        createVNode(_component_photo_list, {
          ref: "imgListRef",
          edit: _ctx.editOptions.photo,
          isDone: _ctx.isDone,
          listData: _ctx.imgList,
          onLoad: _ctx.load,
          onDrag: _ctx.dragStart,
          onSelect: _ctx.selectImg
        }, null, 8, ["edit", "isDone", "listData", "onLoad", "onDrag", "onSelect"])
      ])
    ], 512), [
      [vShow, _ctx.tabActiveName === "pics"]
    ]),
    withDirectives(createElementVNode("div", _hoisted_4$i, [
      withDirectives((openBlock(), createElementBlock("ul", _hoisted_5$g, [
        createVNode(_component_img_water_fall, {
          edit: _ctx.editOptions.works,
          listData: _ctx.designList,
          onSelect: _ctx.selectDesign
        }, null, 8, ["edit", "listData", "onSelect"]),
        withDirectives(createElementVNode("div", _hoisted_6$b, "\u5168\u90E8\u52A0\u8F7D\u5B8C\u6BD5", 512), [
          [vShow, _ctx.isDone]
        ])
      ])), [
        [_directive_infinite_scroll, _ctx.loadDesign]
      ])
    ], 512), [
      [vShow, _ctx.tabActiveName === "design"]
    ])
  ]);
}
var UserWrap = /* @__PURE__ */ _export_sfc(_sfc_main$t, [["render", _sfc_render$p], ["__scopeId", "data-v-2589a4d1"]]);
var __glob_0_22 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": UserWrap
}, Symbol.toStringTag, { value: "Module" }));
var widgetPanel_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$e = "widget-panel";
const _sfc_main$s = {
  name: NAME$e,
  components: {
    BgImgListWrap,
    CompListWrap,
    GraphListWrap,
    PhotoListWrap,
    TempListWrap,
    TextListWrap,
    ToolsListWrap,
    UserWrap
  },
  props: {
    noMenu: {
      type: Boolean
    }
  },
  setup(props2) {
    const state = reactive$1({
      widgetClassifyList: widgetClassifyListData,
      activeWidgetClassify: 0,
      active: true
    });
    const clickClassify = (index2) => {
      state.activeWidgetClassify = index2;
      state.active = true;
    };
    onMounted(async () => {
      await nextTick();
    });
    watch(
      () => state.activeWidgetClassify,
      (index2) => {
        if (index2 >= 0 && index2 < state.widgetClassifyList.length) {
          state.widgetClassifyList[index2].show = true;
        }
      }
    );
    return {
      clickClassify,
      ...toRefs(state),
      ...props2 || {}
    };
  },
  methods: {
    ...mapActions(["updateScreen"])
  }
};
const _hoisted_1$q = { id: "widget-panel" };
const _hoisted_2$m = { class: "widget-classify" };
const _hoisted_3$k = { class: "classify-wrap" };
const _hoisted_4$h = ["onClick"];
const _hoisted_5$f = { class: "widget-wrap" };
function _sfc_render$o(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$q, [
    withDirectives(createElementVNode("div", _hoisted_2$m, [
      createElementVNode("ul", _hoisted_3$k, [
        (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.widgetClassifyList, (item, index2) => {
          return openBlock(), createElementBlock("li", {
            key: index2,
            class: normalizeClass(["classify-item", { "active-classify-item": _ctx.activeWidgetClassify === index2 }]),
            onClick: ($event) => $setup.clickClassify(index2)
          }, [
            createElementVNode("i", {
              class: normalizeClass(["iconfont", "icon", item.icon]),
              style: normalizeStyle(item.style)
            }, null, 6),
            createElementVNode("p", null, toDisplayString(item.name), 1)
          ], 10, _hoisted_4$h);
        }), 128))
      ])
    ], 512), [
      [vShow, !$props.noMenu]
    ]),
    withDirectives(createElementVNode("div", _hoisted_5$f, [
      (openBlock(), createBlock(resolveDynamicComponent(_ctx.widgetClassifyList[_ctx.activeWidgetClassify].component), { isModal: $props.noMenu }, null, 8, ["isModal"]))
    ], 512), [
      [vShow, _ctx.active]
    ])
  ]);
}
var widgetPanel = /* @__PURE__ */ _export_sfc(_sfc_main$s, [["render", _sfc_render$o], ["__scopeId", "data-v-1943f226"]]);
var __glob_0_5 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": widgetPanel
}, Symbol.toStringTag, { value: "Module" }));
var alignIconList$1 = [
  {
    key: "align",
    icon: "icon-align-left",
    tip: "\u5DE6\u5BF9\u9F50",
    value: "left"
  },
  {
    key: "align",
    icon: "icon-align-center-horiz",
    tip: "\u6C34\u5E73\u5C45\u4E2D\u5BF9\u9F50",
    value: "ch"
  },
  {
    key: "align",
    icon: "icon-align-right",
    tip: "\u53F3\u5BF9\u9F50",
    value: "right"
  },
  {
    key: "align",
    icon: "icon-align-top",
    tip: "\u4E0A\u5BF9\u9F50",
    value: "top"
  },
  {
    key: "align",
    icon: "icon-align-center-verti",
    tip: "\u5782\u76F4\u5C45\u4E2D\u5BF9\u9F50",
    value: "cv"
  },
  {
    key: "align",
    icon: "icon-align-bottom",
    tip: "\u4E0B\u5BF9\u9F50",
    value: "bottom"
  }
];
/**!
 * Sortable 1.14.0
 * @author	RubaXa   <trash@rubaxa.org>
 * @author	owenm    <owen23355@gmail.com>
 * @license MIT
 */
function ownKeys(object, enumerableOnly) {
  var keys2 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) {
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source2 = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys(Object(source2), true).forEach(function(key) {
        _defineProperty(target, key, source2[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source2));
    } else {
      ownKeys(Object(source2)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source2, key));
      });
    }
  }
  return target;
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _extends() {
  _extends = Object.assign || function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source2 = arguments[i];
      for (var key in source2) {
        if (Object.prototype.hasOwnProperty.call(source2, key)) {
          target[key] = source2[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutPropertiesLoose(source2, excluded) {
  if (source2 == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source2);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source2[key];
  }
  return target;
}
function _objectWithoutProperties(source2, excluded) {
  if (source2 == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source2, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source2);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source2, key))
        continue;
      target[key] = source2[key];
    }
  }
  return target;
}
var version = "1.14.0";
function userAgent(pattern) {
  if (typeof window !== "undefined" && window.navigator) {
    return !!/* @__PURE__ */ navigator.userAgent.match(pattern);
  }
}
var IE11OrLess = userAgent(/(?:Trident.*rv[ :]?11\.|msie|iemobile|Windows Phone)/i);
var Edge = userAgent(/Edge/i);
var FireFox = userAgent(/firefox/i);
var Safari = userAgent(/safari/i) && !userAgent(/chrome/i) && !userAgent(/android/i);
var IOS = userAgent(/iP(ad|od|hone)/i);
var ChromeForAndroid = userAgent(/chrome/i) && userAgent(/android/i);
var captureMode = {
  capture: false,
  passive: false
};
function on$1(el, event, fn2) {
  el.addEventListener(event, fn2, !IE11OrLess && captureMode);
}
function off(el, event, fn2) {
  el.removeEventListener(event, fn2, !IE11OrLess && captureMode);
}
function matches(el, selector) {
  if (!selector)
    return;
  selector[0] === ">" && (selector = selector.substring(1));
  if (el) {
    try {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      }
    } catch (_) {
      return false;
    }
  }
  return false;
}
function getParentOrHost(el) {
  return el.host && el !== document && el.host.nodeType ? el.host : el.parentNode;
}
function closest(el, selector, ctx, includeCTX) {
  if (el) {
    ctx = ctx || document;
    do {
      if (selector != null && (selector[0] === ">" ? el.parentNode === ctx && matches(el, selector) : matches(el, selector)) || includeCTX && el === ctx) {
        return el;
      }
      if (el === ctx)
        break;
    } while (el = getParentOrHost(el));
  }
  return null;
}
var R_SPACE = /\s+/g;
function toggleClass(el, name2, state) {
  if (el && name2) {
    if (el.classList) {
      el.classList[state ? "add" : "remove"](name2);
    } else {
      var className = (" " + el.className + " ").replace(R_SPACE, " ").replace(" " + name2 + " ", " ");
      el.className = (className + (state ? " " + name2 : "")).replace(R_SPACE, " ");
    }
  }
}
function css(el, prop, val) {
  var style = el && el.style;
  if (style) {
    if (val === void 0) {
      if (document.defaultView && document.defaultView.getComputedStyle) {
        val = document.defaultView.getComputedStyle(el, "");
      } else if (el.currentStyle) {
        val = el.currentStyle;
      }
      return prop === void 0 ? val : val[prop];
    } else {
      if (!(prop in style) && prop.indexOf("webkit") === -1) {
        prop = "-webkit-" + prop;
      }
      style[prop] = val + (typeof val === "string" ? "" : "px");
    }
  }
}
function matrix(el, selfOnly) {
  var appliedTransforms = "";
  if (typeof el === "string") {
    appliedTransforms = el;
  } else {
    do {
      var transform2 = css(el, "transform");
      if (transform2 && transform2 !== "none") {
        appliedTransforms = transform2 + " " + appliedTransforms;
      }
    } while (!selfOnly && (el = el.parentNode));
  }
  var matrixFn = window.DOMMatrix || window.WebKitCSSMatrix || window.CSSMatrix || window.MSCSSMatrix;
  return matrixFn && new matrixFn(appliedTransforms);
}
function find(ctx, tagName, iterator) {
  if (ctx) {
    var list = ctx.getElementsByTagName(tagName), i = 0, n = list.length;
    if (iterator) {
      for (; i < n; i++) {
        iterator(list[i], i);
      }
    }
    return list;
  }
  return [];
}
function getWindowScrollingElement() {
  var scrollingElement = document.scrollingElement;
  if (scrollingElement) {
    return scrollingElement;
  } else {
    return document.documentElement;
  }
}
function getRect(el, relativeToContainingBlock, relativeToNonStaticParent, undoScale, container) {
  if (!el.getBoundingClientRect && el !== window)
    return;
  var elRect, top, left, bottom, right, height, width;
  if (el !== window && el.parentNode && el !== getWindowScrollingElement()) {
    elRect = el.getBoundingClientRect();
    top = elRect.top;
    left = elRect.left;
    bottom = elRect.bottom;
    right = elRect.right;
    height = elRect.height;
    width = elRect.width;
  } else {
    top = 0;
    left = 0;
    bottom = window.innerHeight;
    right = window.innerWidth;
    height = window.innerHeight;
    width = window.innerWidth;
  }
  if ((relativeToContainingBlock || relativeToNonStaticParent) && el !== window) {
    container = container || el.parentNode;
    if (!IE11OrLess) {
      do {
        if (container && container.getBoundingClientRect && (css(container, "transform") !== "none" || relativeToNonStaticParent && css(container, "position") !== "static")) {
          var containerRect = container.getBoundingClientRect();
          top -= containerRect.top + parseInt(css(container, "border-top-width"));
          left -= containerRect.left + parseInt(css(container, "border-left-width"));
          bottom = top + elRect.height;
          right = left + elRect.width;
          break;
        }
      } while (container = container.parentNode);
    }
  }
  if (undoScale && el !== window) {
    var elMatrix = matrix(container || el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d;
    if (elMatrix) {
      top /= scaleY;
      left /= scaleX;
      width /= scaleX;
      height /= scaleY;
      bottom = top + height;
      right = left + width;
    }
  }
  return {
    top,
    left,
    bottom,
    right,
    width,
    height
  };
}
function isScrolledPast(el, elSide, parentSide) {
  var parent = getParentAutoScrollElement(el, true), elSideVal = getRect(el)[elSide];
  while (parent) {
    var parentSideVal = getRect(parent)[parentSide], visible = void 0;
    if (parentSide === "top" || parentSide === "left") {
      visible = elSideVal >= parentSideVal;
    } else {
      visible = elSideVal <= parentSideVal;
    }
    if (!visible)
      return parent;
    if (parent === getWindowScrollingElement())
      break;
    parent = getParentAutoScrollElement(parent, false);
  }
  return false;
}
function getChild(el, childNum, options, includeDragEl) {
  var currentChild = 0, i = 0, children = el.children;
  while (i < children.length) {
    if (children[i].style.display !== "none" && children[i] !== Sortable.ghost && (includeDragEl || children[i] !== Sortable.dragged) && closest(children[i], options.draggable, el, false)) {
      if (currentChild === childNum) {
        return children[i];
      }
      currentChild++;
    }
    i++;
  }
  return null;
}
function lastChild(el, selector) {
  var last = el.lastElementChild;
  while (last && (last === Sortable.ghost || css(last, "display") === "none" || selector && !matches(last, selector))) {
    last = last.previousElementSibling;
  }
  return last || null;
}
function index$2(el, selector) {
  var index2 = 0;
  if (!el || !el.parentNode) {
    return -1;
  }
  while (el = el.previousElementSibling) {
    if (el.nodeName.toUpperCase() !== "TEMPLATE" && el !== Sortable.clone && (!selector || matches(el, selector))) {
      index2++;
    }
  }
  return index2;
}
function getRelativeScrollOffset(el) {
  var offsetLeft = 0, offsetTop = 0, winScroller = getWindowScrollingElement();
  if (el) {
    do {
      var elMatrix = matrix(el), scaleX = elMatrix.a, scaleY = elMatrix.d;
      offsetLeft += el.scrollLeft * scaleX;
      offsetTop += el.scrollTop * scaleY;
    } while (el !== winScroller && (el = el.parentNode));
  }
  return [offsetLeft, offsetTop];
}
function indexOfObject(arr2, obj) {
  for (var i in arr2) {
    if (!arr2.hasOwnProperty(i))
      continue;
    for (var key in obj) {
      if (obj.hasOwnProperty(key) && obj[key] === arr2[i][key])
        return Number(i);
    }
  }
  return -1;
}
function getParentAutoScrollElement(el, includeSelf) {
  if (!el || !el.getBoundingClientRect)
    return getWindowScrollingElement();
  var elem = el;
  var gotSelf = false;
  do {
    if (elem.clientWidth < elem.scrollWidth || elem.clientHeight < elem.scrollHeight) {
      var elemCSS = css(elem);
      if (elem.clientWidth < elem.scrollWidth && (elemCSS.overflowX == "auto" || elemCSS.overflowX == "scroll") || elem.clientHeight < elem.scrollHeight && (elemCSS.overflowY == "auto" || elemCSS.overflowY == "scroll")) {
        if (!elem.getBoundingClientRect || elem === document.body)
          return getWindowScrollingElement();
        if (gotSelf || includeSelf)
          return elem;
        gotSelf = true;
      }
    }
  } while (elem = elem.parentNode);
  return getWindowScrollingElement();
}
function extend(dst, src) {
  if (dst && src) {
    for (var key in src) {
      if (src.hasOwnProperty(key)) {
        dst[key] = src[key];
      }
    }
  }
  return dst;
}
function isRectEqual(rect1, rect2) {
  return Math.round(rect1.top) === Math.round(rect2.top) && Math.round(rect1.left) === Math.round(rect2.left) && Math.round(rect1.height) === Math.round(rect2.height) && Math.round(rect1.width) === Math.round(rect2.width);
}
var _throttleTimeout;
function throttle(callback, ms) {
  return function() {
    if (!_throttleTimeout) {
      var args = arguments, _this = this;
      if (args.length === 1) {
        callback.call(_this, args[0]);
      } else {
        callback.apply(_this, args);
      }
      _throttleTimeout = setTimeout(function() {
        _throttleTimeout = void 0;
      }, ms);
    }
  };
}
function cancelThrottle() {
  clearTimeout(_throttleTimeout);
  _throttleTimeout = void 0;
}
function scrollBy(el, x, y) {
  el.scrollLeft += x;
  el.scrollTop += y;
}
function clone(el) {
  var Polymer = window.Polymer;
  var $2 = window.jQuery || window.Zepto;
  if (Polymer && Polymer.dom) {
    return Polymer.dom(el).cloneNode(true);
  } else if ($2) {
    return $2(el).clone(true)[0];
  } else {
    return el.cloneNode(true);
  }
}
var expando = "Sortable" + new Date().getTime();
function AnimationStateManager() {
  var animationStates = [], animationCallbackId;
  return {
    captureAnimationState: function captureAnimationState() {
      animationStates = [];
      if (!this.options.animation)
        return;
      var children = [].slice.call(this.el.children);
      children.forEach(function(child) {
        if (css(child, "display") === "none" || child === Sortable.ghost)
          return;
        animationStates.push({
          target: child,
          rect: getRect(child)
        });
        var fromRect = _objectSpread2({}, animationStates[animationStates.length - 1].rect);
        if (child.thisAnimationDuration) {
          var childMatrix = matrix(child, true);
          if (childMatrix) {
            fromRect.top -= childMatrix.f;
            fromRect.left -= childMatrix.e;
          }
        }
        child.fromRect = fromRect;
      });
    },
    addAnimationState: function addAnimationState(state) {
      animationStates.push(state);
    },
    removeAnimationState: function removeAnimationState(target) {
      animationStates.splice(indexOfObject(animationStates, {
        target
      }), 1);
    },
    animateAll: function animateAll(callback) {
      var _this = this;
      if (!this.options.animation) {
        clearTimeout(animationCallbackId);
        if (typeof callback === "function")
          callback();
        return;
      }
      var animating = false, animationTime = 0;
      animationStates.forEach(function(state) {
        var time2 = 0, target = state.target, fromRect = target.fromRect, toRect = getRect(target), prevFromRect = target.prevFromRect, prevToRect = target.prevToRect, animatingRect = state.rect, targetMatrix = matrix(target, true);
        if (targetMatrix) {
          toRect.top -= targetMatrix.f;
          toRect.left -= targetMatrix.e;
        }
        target.toRect = toRect;
        if (target.thisAnimationDuration) {
          if (isRectEqual(prevFromRect, toRect) && !isRectEqual(fromRect, toRect) && (animatingRect.top - toRect.top) / (animatingRect.left - toRect.left) === (fromRect.top - toRect.top) / (fromRect.left - toRect.left)) {
            time2 = calculateRealTime(animatingRect, prevFromRect, prevToRect, _this.options);
          }
        }
        if (!isRectEqual(toRect, fromRect)) {
          target.prevFromRect = fromRect;
          target.prevToRect = toRect;
          if (!time2) {
            time2 = _this.options.animation;
          }
          _this.animate(target, animatingRect, toRect, time2);
        }
        if (time2) {
          animating = true;
          animationTime = Math.max(animationTime, time2);
          clearTimeout(target.animationResetTimer);
          target.animationResetTimer = setTimeout(function() {
            target.animationTime = 0;
            target.prevFromRect = null;
            target.fromRect = null;
            target.prevToRect = null;
            target.thisAnimationDuration = null;
          }, time2);
          target.thisAnimationDuration = time2;
        }
      });
      clearTimeout(animationCallbackId);
      if (!animating) {
        if (typeof callback === "function")
          callback();
      } else {
        animationCallbackId = setTimeout(function() {
          if (typeof callback === "function")
            callback();
        }, animationTime);
      }
      animationStates = [];
    },
    animate: function animate(target, currentRect, toRect, duration2) {
      if (duration2) {
        css(target, "transition", "");
        css(target, "transform", "");
        var elMatrix = matrix(this.el), scaleX = elMatrix && elMatrix.a, scaleY = elMatrix && elMatrix.d, translateX = (currentRect.left - toRect.left) / (scaleX || 1), translateY = (currentRect.top - toRect.top) / (scaleY || 1);
        target.animatingX = !!translateX;
        target.animatingY = !!translateY;
        css(target, "transform", "translate3d(" + translateX + "px," + translateY + "px,0)");
        this.forRepaintDummy = repaint(target);
        css(target, "transition", "transform " + duration2 + "ms" + (this.options.easing ? " " + this.options.easing : ""));
        css(target, "transform", "translate3d(0,0,0)");
        typeof target.animated === "number" && clearTimeout(target.animated);
        target.animated = setTimeout(function() {
          css(target, "transition", "");
          css(target, "transform", "");
          target.animated = false;
          target.animatingX = false;
          target.animatingY = false;
        }, duration2);
      }
    }
  };
}
function repaint(target) {
  return target.offsetWidth;
}
function calculateRealTime(animatingRect, fromRect, toRect, options) {
  return Math.sqrt(Math.pow(fromRect.top - animatingRect.top, 2) + Math.pow(fromRect.left - animatingRect.left, 2)) / Math.sqrt(Math.pow(fromRect.top - toRect.top, 2) + Math.pow(fromRect.left - toRect.left, 2)) * options.animation;
}
var plugins = [];
var defaults = {
  initializeByDefault: true
};
var PluginManager = {
  mount: function mount(plugin) {
    for (var option2 in defaults) {
      if (defaults.hasOwnProperty(option2) && !(option2 in plugin)) {
        plugin[option2] = defaults[option2];
      }
    }
    plugins.forEach(function(p) {
      if (p.pluginName === plugin.pluginName) {
        throw "Sortable: Cannot mount plugin ".concat(plugin.pluginName, " more than once");
      }
    });
    plugins.push(plugin);
  },
  pluginEvent: function pluginEvent(eventName, sortable, evt) {
    var _this = this;
    this.eventCanceled = false;
    evt.cancel = function() {
      _this.eventCanceled = true;
    };
    var eventNameGlobal = eventName + "Global";
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (sortable[plugin.pluginName][eventNameGlobal]) {
        sortable[plugin.pluginName][eventNameGlobal](_objectSpread2({
          sortable
        }, evt));
      }
      if (sortable.options[plugin.pluginName] && sortable[plugin.pluginName][eventName]) {
        sortable[plugin.pluginName][eventName](_objectSpread2({
          sortable
        }, evt));
      }
    });
  },
  initializePlugins: function initializePlugins(sortable, el, defaults2, options) {
    plugins.forEach(function(plugin) {
      var pluginName = plugin.pluginName;
      if (!sortable.options[pluginName] && !plugin.initializeByDefault)
        return;
      var initialized = new plugin(sortable, el, sortable.options);
      initialized.sortable = sortable;
      initialized.options = sortable.options;
      sortable[pluginName] = initialized;
      _extends(defaults2, initialized.defaults);
    });
    for (var option2 in sortable.options) {
      if (!sortable.options.hasOwnProperty(option2))
        continue;
      var modified = this.modifyOption(sortable, option2, sortable.options[option2]);
      if (typeof modified !== "undefined") {
        sortable.options[option2] = modified;
      }
    }
  },
  getEventProperties: function getEventProperties(name2, sortable) {
    var eventProperties = {};
    plugins.forEach(function(plugin) {
      if (typeof plugin.eventProperties !== "function")
        return;
      _extends(eventProperties, plugin.eventProperties.call(sortable[plugin.pluginName], name2));
    });
    return eventProperties;
  },
  modifyOption: function modifyOption(sortable, name2, value) {
    var modifiedValue;
    plugins.forEach(function(plugin) {
      if (!sortable[plugin.pluginName])
        return;
      if (plugin.optionListeners && typeof plugin.optionListeners[name2] === "function") {
        modifiedValue = plugin.optionListeners[name2].call(sortable[plugin.pluginName], value);
      }
    });
    return modifiedValue;
  }
};
function dispatchEvent(_ref) {
  var sortable = _ref.sortable, rootEl2 = _ref.rootEl, name2 = _ref.name, targetEl = _ref.targetEl, cloneEl2 = _ref.cloneEl, toEl = _ref.toEl, fromEl = _ref.fromEl, oldIndex2 = _ref.oldIndex, newIndex2 = _ref.newIndex, oldDraggableIndex2 = _ref.oldDraggableIndex, newDraggableIndex2 = _ref.newDraggableIndex, originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, extraEventProperties = _ref.extraEventProperties;
  sortable = sortable || rootEl2 && rootEl2[expando];
  if (!sortable)
    return;
  var evt, options = sortable.options, onName = "on" + name2.charAt(0).toUpperCase() + name2.substr(1);
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent(name2, {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent(name2, true, true);
  }
  evt.to = toEl || rootEl2;
  evt.from = fromEl || rootEl2;
  evt.item = targetEl || rootEl2;
  evt.clone = cloneEl2;
  evt.oldIndex = oldIndex2;
  evt.newIndex = newIndex2;
  evt.oldDraggableIndex = oldDraggableIndex2;
  evt.newDraggableIndex = newDraggableIndex2;
  evt.originalEvent = originalEvent;
  evt.pullMode = putSortable2 ? putSortable2.lastPutMode : void 0;
  var allEventProperties = _objectSpread2(_objectSpread2({}, extraEventProperties), PluginManager.getEventProperties(name2, sortable));
  for (var option2 in allEventProperties) {
    evt[option2] = allEventProperties[option2];
  }
  if (rootEl2) {
    rootEl2.dispatchEvent(evt);
  }
  if (options[onName]) {
    options[onName].call(sortable, evt);
  }
}
var _excluded = ["evt"];
var pluginEvent2 = function pluginEvent3(eventName, sortable) {
  var _ref = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, originalEvent = _ref.evt, data = _objectWithoutProperties(_ref, _excluded);
  PluginManager.pluginEvent.bind(Sortable)(eventName, sortable, _objectSpread2({
    dragEl,
    parentEl,
    ghostEl,
    rootEl,
    nextEl,
    lastDownEl,
    cloneEl,
    cloneHidden,
    dragStarted: moved,
    putSortable,
    activeSortable: Sortable.active,
    originalEvent,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex,
    hideGhostForTarget: _hideGhostForTarget,
    unhideGhostForTarget: _unhideGhostForTarget,
    cloneNowHidden: function cloneNowHidden() {
      cloneHidden = true;
    },
    cloneNowShown: function cloneNowShown() {
      cloneHidden = false;
    },
    dispatchSortableEvent: function dispatchSortableEvent(name2) {
      _dispatchEvent({
        sortable,
        name: name2,
        originalEvent
      });
    }
  }, data));
};
function _dispatchEvent(info) {
  dispatchEvent(_objectSpread2({
    putSortable,
    cloneEl,
    targetEl: dragEl,
    rootEl,
    oldIndex,
    oldDraggableIndex,
    newIndex,
    newDraggableIndex
  }, info));
}
var dragEl, parentEl, ghostEl, rootEl, nextEl, lastDownEl, cloneEl, cloneHidden, oldIndex, newIndex, oldDraggableIndex, newDraggableIndex, activeGroup, putSortable, awaitingDragStarted = false, ignoreNextClick = false, sortables = [], tapEvt, touchEvt, lastDx, lastDy, tapDistanceLeft, tapDistanceTop, moved, lastTarget, lastDirection, pastFirstInvertThresh = false, isCircumstantialInvert = false, targetMoveDistance, ghostRelativeParent, ghostRelativeParentInitialScroll = [], _silent = false, savedInputChecked = [];
var documentExists = typeof document !== "undefined", PositionGhostAbsolutely = IOS, CSSFloatProperty = Edge || IE11OrLess ? "cssFloat" : "float", supportDraggable = documentExists && !ChromeForAndroid && !IOS && "draggable" in document.createElement("div"), supportCssPointerEvents = function() {
  if (!documentExists)
    return;
  if (IE11OrLess) {
    return false;
  }
  var el = document.createElement("x");
  el.style.cssText = "pointer-events:auto";
  return el.style.pointerEvents === "auto";
}(), _detectDirection = function _detectDirection2(el, options) {
  var elCSS = css(el), elWidth = parseInt(elCSS.width) - parseInt(elCSS.paddingLeft) - parseInt(elCSS.paddingRight) - parseInt(elCSS.borderLeftWidth) - parseInt(elCSS.borderRightWidth), child1 = getChild(el, 0, options), child2 = getChild(el, 1, options), firstChildCSS = child1 && css(child1), secondChildCSS = child2 && css(child2), firstChildWidth = firstChildCSS && parseInt(firstChildCSS.marginLeft) + parseInt(firstChildCSS.marginRight) + getRect(child1).width, secondChildWidth = secondChildCSS && parseInt(secondChildCSS.marginLeft) + parseInt(secondChildCSS.marginRight) + getRect(child2).width;
  if (elCSS.display === "flex") {
    return elCSS.flexDirection === "column" || elCSS.flexDirection === "column-reverse" ? "vertical" : "horizontal";
  }
  if (elCSS.display === "grid") {
    return elCSS.gridTemplateColumns.split(" ").length <= 1 ? "vertical" : "horizontal";
  }
  if (child1 && firstChildCSS["float"] && firstChildCSS["float"] !== "none") {
    var touchingSideChild2 = firstChildCSS["float"] === "left" ? "left" : "right";
    return child2 && (secondChildCSS.clear === "both" || secondChildCSS.clear === touchingSideChild2) ? "vertical" : "horizontal";
  }
  return child1 && (firstChildCSS.display === "block" || firstChildCSS.display === "flex" || firstChildCSS.display === "table" || firstChildCSS.display === "grid" || firstChildWidth >= elWidth && elCSS[CSSFloatProperty] === "none" || child2 && elCSS[CSSFloatProperty] === "none" && firstChildWidth + secondChildWidth > elWidth) ? "vertical" : "horizontal";
}, _dragElInRowColumn = function _dragElInRowColumn2(dragRect, targetRect, vertical) {
  var dragElS1Opp = vertical ? dragRect.left : dragRect.top, dragElS2Opp = vertical ? dragRect.right : dragRect.bottom, dragElOppLength = vertical ? dragRect.width : dragRect.height, targetS1Opp = vertical ? targetRect.left : targetRect.top, targetS2Opp = vertical ? targetRect.right : targetRect.bottom, targetOppLength = vertical ? targetRect.width : targetRect.height;
  return dragElS1Opp === targetS1Opp || dragElS2Opp === targetS2Opp || dragElS1Opp + dragElOppLength / 2 === targetS1Opp + targetOppLength / 2;
}, _detectNearestEmptySortable = function _detectNearestEmptySortable2(x, y) {
  var ret;
  sortables.some(function(sortable) {
    var threshold = sortable[expando].options.emptyInsertThreshold;
    if (!threshold || lastChild(sortable))
      return;
    var rect = getRect(sortable), insideHorizontally = x >= rect.left - threshold && x <= rect.right + threshold, insideVertically = y >= rect.top - threshold && y <= rect.bottom + threshold;
    if (insideHorizontally && insideVertically) {
      return ret = sortable;
    }
  });
  return ret;
}, _prepareGroup = function _prepareGroup2(options) {
  function toFn(value, pull) {
    return function(to, from, dragEl2, evt) {
      var sameGroup = to.options.group.name && from.options.group.name && to.options.group.name === from.options.group.name;
      if (value == null && (pull || sameGroup)) {
        return true;
      } else if (value == null || value === false) {
        return false;
      } else if (pull && value === "clone") {
        return value;
      } else if (typeof value === "function") {
        return toFn(value(to, from, dragEl2, evt), pull)(to, from, dragEl2, evt);
      } else {
        var otherGroup = (pull ? to : from).options.group.name;
        return value === true || typeof value === "string" && value === otherGroup || value.join && value.indexOf(otherGroup) > -1;
      }
    };
  }
  var group = {};
  var originalGroup = options.group;
  if (!originalGroup || _typeof(originalGroup) != "object") {
    originalGroup = {
      name: originalGroup
    };
  }
  group.name = originalGroup.name;
  group.checkPull = toFn(originalGroup.pull, true);
  group.checkPut = toFn(originalGroup.put);
  group.revertClone = originalGroup.revertClone;
  options.group = group;
}, _hideGhostForTarget = function _hideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "none");
  }
}, _unhideGhostForTarget = function _unhideGhostForTarget2() {
  if (!supportCssPointerEvents && ghostEl) {
    css(ghostEl, "display", "");
  }
};
if (documentExists) {
  document.addEventListener("click", function(evt) {
    if (ignoreNextClick) {
      evt.preventDefault();
      evt.stopPropagation && evt.stopPropagation();
      evt.stopImmediatePropagation && evt.stopImmediatePropagation();
      ignoreNextClick = false;
      return false;
    }
  }, true);
}
var nearestEmptyInsertDetectEvent = function nearestEmptyInsertDetectEvent2(evt) {
  if (dragEl) {
    evt = evt.touches ? evt.touches[0] : evt;
    var nearest = _detectNearestEmptySortable(evt.clientX, evt.clientY);
    if (nearest) {
      var event = {};
      for (var i in evt) {
        if (evt.hasOwnProperty(i)) {
          event[i] = evt[i];
        }
      }
      event.target = event.rootEl = nearest;
      event.preventDefault = void 0;
      event.stopPropagation = void 0;
      nearest[expando]._onDragOver(event);
    }
  }
};
var _checkOutsideTargetEl = function _checkOutsideTargetEl2(evt) {
  if (dragEl) {
    dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
  }
};
function Sortable(el, options) {
  if (!(el && el.nodeType && el.nodeType === 1)) {
    throw "Sortable: `el` must be an HTMLElement, not ".concat({}.toString.call(el));
  }
  this.el = el;
  this.options = options = _extends({}, options);
  el[expando] = this;
  var defaults2 = {
    group: null,
    sort: true,
    disabled: false,
    store: null,
    handle: null,
    draggable: /^[uo]l$/i.test(el.nodeName) ? ">li" : ">*",
    swapThreshold: 1,
    invertSwap: false,
    invertedSwapThreshold: null,
    removeCloneOnHide: true,
    direction: function direction2() {
      return _detectDirection(el, this.options);
    },
    ghostClass: "sortable-ghost",
    chosenClass: "sortable-chosen",
    dragClass: "sortable-drag",
    ignore: "a, img",
    filter: null,
    preventOnFilter: true,
    animation: 0,
    easing: null,
    setData: function setData(dataTransfer, dragEl2) {
      dataTransfer.setData("Text", dragEl2.textContent);
    },
    dropBubble: false,
    dragoverBubble: false,
    dataIdAttr: "data-id",
    delay: 0,
    delayOnTouchOnly: false,
    touchStartThreshold: (Number.parseInt ? Number : window).parseInt(window.devicePixelRatio, 10) || 1,
    forceFallback: false,
    fallbackClass: "sortable-fallback",
    fallbackOnBody: false,
    fallbackTolerance: 0,
    fallbackOffset: {
      x: 0,
      y: 0
    },
    supportPointer: Sortable.supportPointer !== false && "PointerEvent" in window && !Safari,
    emptyInsertThreshold: 5
  };
  PluginManager.initializePlugins(this, el, defaults2);
  for (var name2 in defaults2) {
    !(name2 in options) && (options[name2] = defaults2[name2]);
  }
  _prepareGroup(options);
  for (var fn2 in this) {
    if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
      this[fn2] = this[fn2].bind(this);
    }
  }
  this.nativeDraggable = options.forceFallback ? false : supportDraggable;
  if (this.nativeDraggable) {
    this.options.touchStartThreshold = 1;
  }
  if (options.supportPointer) {
    on$1(el, "pointerdown", this._onTapStart);
  } else {
    on$1(el, "mousedown", this._onTapStart);
    on$1(el, "touchstart", this._onTapStart);
  }
  if (this.nativeDraggable) {
    on$1(el, "dragover", this);
    on$1(el, "dragenter", this);
  }
  sortables.push(this.el);
  options.store && options.store.get && this.sort(options.store.get(this) || []);
  _extends(this, AnimationStateManager());
}
Sortable.prototype = {
  constructor: Sortable,
  _isOutsideThisEl: function _isOutsideThisEl(target) {
    if (!this.el.contains(target) && target !== this.el) {
      lastTarget = null;
    }
  },
  _getDirection: function _getDirection(evt, target) {
    return typeof this.options.direction === "function" ? this.options.direction.call(this, evt, target, dragEl) : this.options.direction;
  },
  _onTapStart: function _onTapStart(evt) {
    if (!evt.cancelable)
      return;
    var _this = this, el = this.el, options = this.options, preventOnFilter = options.preventOnFilter, type = evt.type, touch = evt.touches && evt.touches[0] || evt.pointerType && evt.pointerType === "touch" && evt, target = (touch || evt).target, originalTarget = evt.target.shadowRoot && (evt.path && evt.path[0] || evt.composedPath && evt.composedPath()[0]) || target, filter = options.filter;
    _saveInputCheckedState(el);
    if (dragEl) {
      return;
    }
    if (/mousedown|pointerdown/.test(type) && evt.button !== 0 || options.disabled) {
      return;
    }
    if (originalTarget.isContentEditable) {
      return;
    }
    if (!this.nativeDraggable && Safari && target && target.tagName.toUpperCase() === "SELECT") {
      return;
    }
    target = closest(target, options.draggable, el, false);
    if (target && target.animated) {
      return;
    }
    if (lastDownEl === target) {
      return;
    }
    oldIndex = index$2(target);
    oldDraggableIndex = index$2(target, options.draggable);
    if (typeof filter === "function") {
      if (filter.call(this, evt, target, this)) {
        _dispatchEvent({
          sortable: _this,
          rootEl: originalTarget,
          name: "filter",
          targetEl: target,
          toEl: el,
          fromEl: el
        });
        pluginEvent2("filter", _this, {
          evt
        });
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    } else if (filter) {
      filter = filter.split(",").some(function(criteria) {
        criteria = closest(originalTarget, criteria.trim(), el, false);
        if (criteria) {
          _dispatchEvent({
            sortable: _this,
            rootEl: criteria,
            name: "filter",
            targetEl: target,
            fromEl: el,
            toEl: el
          });
          pluginEvent2("filter", _this, {
            evt
          });
          return true;
        }
      });
      if (filter) {
        preventOnFilter && evt.cancelable && evt.preventDefault();
        return;
      }
    }
    if (options.handle && !closest(originalTarget, options.handle, el, false)) {
      return;
    }
    this._prepareDragStart(evt, touch, target);
  },
  _prepareDragStart: function _prepareDragStart(evt, touch, target) {
    var _this = this, el = _this.el, options = _this.options, ownerDocument = el.ownerDocument, dragStartFn;
    if (target && !dragEl && target.parentNode === el) {
      var dragRect = getRect(target);
      rootEl = el;
      dragEl = target;
      parentEl = dragEl.parentNode;
      nextEl = dragEl.nextSibling;
      lastDownEl = target;
      activeGroup = options.group;
      Sortable.dragged = dragEl;
      tapEvt = {
        target: dragEl,
        clientX: (touch || evt).clientX,
        clientY: (touch || evt).clientY
      };
      tapDistanceLeft = tapEvt.clientX - dragRect.left;
      tapDistanceTop = tapEvt.clientY - dragRect.top;
      this._lastX = (touch || evt).clientX;
      this._lastY = (touch || evt).clientY;
      dragEl.style["will-change"] = "all";
      dragStartFn = function dragStartFn2() {
        pluginEvent2("delayEnded", _this, {
          evt
        });
        if (Sortable.eventCanceled) {
          _this._onDrop();
          return;
        }
        _this._disableDelayedDragEvents();
        if (!FireFox && _this.nativeDraggable) {
          dragEl.draggable = true;
        }
        _this._triggerDragStart(evt, touch);
        _dispatchEvent({
          sortable: _this,
          name: "choose",
          originalEvent: evt
        });
        toggleClass(dragEl, options.chosenClass, true);
      };
      options.ignore.split(",").forEach(function(criteria) {
        find(dragEl, criteria.trim(), _disableDraggable);
      });
      on$1(ownerDocument, "dragover", nearestEmptyInsertDetectEvent);
      on$1(ownerDocument, "mousemove", nearestEmptyInsertDetectEvent);
      on$1(ownerDocument, "touchmove", nearestEmptyInsertDetectEvent);
      on$1(ownerDocument, "mouseup", _this._onDrop);
      on$1(ownerDocument, "touchend", _this._onDrop);
      on$1(ownerDocument, "touchcancel", _this._onDrop);
      if (FireFox && this.nativeDraggable) {
        this.options.touchStartThreshold = 4;
        dragEl.draggable = true;
      }
      pluginEvent2("delayStart", this, {
        evt
      });
      if (options.delay && (!options.delayOnTouchOnly || touch) && (!this.nativeDraggable || !(Edge || IE11OrLess))) {
        if (Sortable.eventCanceled) {
          this._onDrop();
          return;
        }
        on$1(ownerDocument, "mouseup", _this._disableDelayedDrag);
        on$1(ownerDocument, "touchend", _this._disableDelayedDrag);
        on$1(ownerDocument, "touchcancel", _this._disableDelayedDrag);
        on$1(ownerDocument, "mousemove", _this._delayedDragTouchMoveHandler);
        on$1(ownerDocument, "touchmove", _this._delayedDragTouchMoveHandler);
        options.supportPointer && on$1(ownerDocument, "pointermove", _this._delayedDragTouchMoveHandler);
        _this._dragStartTimer = setTimeout(dragStartFn, options.delay);
      } else {
        dragStartFn();
      }
    }
  },
  _delayedDragTouchMoveHandler: function _delayedDragTouchMoveHandler(e2) {
    var touch = e2.touches ? e2.touches[0] : e2;
    if (Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) >= Math.floor(this.options.touchStartThreshold / (this.nativeDraggable && window.devicePixelRatio || 1))) {
      this._disableDelayedDrag();
    }
  },
  _disableDelayedDrag: function _disableDelayedDrag() {
    dragEl && _disableDraggable(dragEl);
    clearTimeout(this._dragStartTimer);
    this._disableDelayedDragEvents();
  },
  _disableDelayedDragEvents: function _disableDelayedDragEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._disableDelayedDrag);
    off(ownerDocument, "touchend", this._disableDelayedDrag);
    off(ownerDocument, "touchcancel", this._disableDelayedDrag);
    off(ownerDocument, "mousemove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "touchmove", this._delayedDragTouchMoveHandler);
    off(ownerDocument, "pointermove", this._delayedDragTouchMoveHandler);
  },
  _triggerDragStart: function _triggerDragStart(evt, touch) {
    touch = touch || evt.pointerType == "touch" && evt;
    if (!this.nativeDraggable || touch) {
      if (this.options.supportPointer) {
        on$1(document, "pointermove", this._onTouchMove);
      } else if (touch) {
        on$1(document, "touchmove", this._onTouchMove);
      } else {
        on$1(document, "mousemove", this._onTouchMove);
      }
    } else {
      on$1(dragEl, "dragend", this);
      on$1(rootEl, "dragstart", this._onDragStart);
    }
    try {
      if (document.selection) {
        _nextTick(function() {
          document.selection.empty();
        });
      } else {
        window.getSelection().removeAllRanges();
      }
    } catch (err) {
    }
  },
  _dragStarted: function _dragStarted(fallback, evt) {
    awaitingDragStarted = false;
    if (rootEl && dragEl) {
      pluginEvent2("dragStarted", this, {
        evt
      });
      if (this.nativeDraggable) {
        on$1(document, "dragover", _checkOutsideTargetEl);
      }
      var options = this.options;
      !fallback && toggleClass(dragEl, options.dragClass, false);
      toggleClass(dragEl, options.ghostClass, true);
      Sortable.active = this;
      fallback && this._appendGhost();
      _dispatchEvent({
        sortable: this,
        name: "start",
        originalEvent: evt
      });
    } else {
      this._nulling();
    }
  },
  _emulateDragOver: function _emulateDragOver() {
    if (touchEvt) {
      this._lastX = touchEvt.clientX;
      this._lastY = touchEvt.clientY;
      _hideGhostForTarget();
      var target = document.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
      var parent = target;
      while (target && target.shadowRoot) {
        target = target.shadowRoot.elementFromPoint(touchEvt.clientX, touchEvt.clientY);
        if (target === parent)
          break;
        parent = target;
      }
      dragEl.parentNode[expando]._isOutsideThisEl(target);
      if (parent) {
        do {
          if (parent[expando]) {
            var inserted = void 0;
            inserted = parent[expando]._onDragOver({
              clientX: touchEvt.clientX,
              clientY: touchEvt.clientY,
              target,
              rootEl: parent
            });
            if (inserted && !this.options.dragoverBubble) {
              break;
            }
          }
          target = parent;
        } while (parent = parent.parentNode);
      }
      _unhideGhostForTarget();
    }
  },
  _onTouchMove: function _onTouchMove(evt) {
    if (tapEvt) {
      var options = this.options, fallbackTolerance = options.fallbackTolerance, fallbackOffset = options.fallbackOffset, touch = evt.touches ? evt.touches[0] : evt, ghostMatrix = ghostEl && matrix(ghostEl, true), scaleX = ghostEl && ghostMatrix && ghostMatrix.a, scaleY = ghostEl && ghostMatrix && ghostMatrix.d, relativeScrollOffset = PositionGhostAbsolutely && ghostRelativeParent && getRelativeScrollOffset(ghostRelativeParent), dx = (touch.clientX - tapEvt.clientX + fallbackOffset.x) / (scaleX || 1) + (relativeScrollOffset ? relativeScrollOffset[0] - ghostRelativeParentInitialScroll[0] : 0) / (scaleX || 1), dy = (touch.clientY - tapEvt.clientY + fallbackOffset.y) / (scaleY || 1) + (relativeScrollOffset ? relativeScrollOffset[1] - ghostRelativeParentInitialScroll[1] : 0) / (scaleY || 1);
      if (!Sortable.active && !awaitingDragStarted) {
        if (fallbackTolerance && Math.max(Math.abs(touch.clientX - this._lastX), Math.abs(touch.clientY - this._lastY)) < fallbackTolerance) {
          return;
        }
        this._onDragStart(evt, true);
      }
      if (ghostEl) {
        if (ghostMatrix) {
          ghostMatrix.e += dx - (lastDx || 0);
          ghostMatrix.f += dy - (lastDy || 0);
        } else {
          ghostMatrix = {
            a: 1,
            b: 0,
            c: 0,
            d: 1,
            e: dx,
            f: dy
          };
        }
        var cssMatrix = "matrix(".concat(ghostMatrix.a, ",").concat(ghostMatrix.b, ",").concat(ghostMatrix.c, ",").concat(ghostMatrix.d, ",").concat(ghostMatrix.e, ",").concat(ghostMatrix.f, ")");
        css(ghostEl, "webkitTransform", cssMatrix);
        css(ghostEl, "mozTransform", cssMatrix);
        css(ghostEl, "msTransform", cssMatrix);
        css(ghostEl, "transform", cssMatrix);
        lastDx = dx;
        lastDy = dy;
        touchEvt = touch;
      }
      evt.cancelable && evt.preventDefault();
    }
  },
  _appendGhost: function _appendGhost() {
    if (!ghostEl) {
      var container = this.options.fallbackOnBody ? document.body : rootEl, rect = getRect(dragEl, true, PositionGhostAbsolutely, true, container), options = this.options;
      if (PositionGhostAbsolutely) {
        ghostRelativeParent = container;
        while (css(ghostRelativeParent, "position") === "static" && css(ghostRelativeParent, "transform") === "none" && ghostRelativeParent !== document) {
          ghostRelativeParent = ghostRelativeParent.parentNode;
        }
        if (ghostRelativeParent !== document.body && ghostRelativeParent !== document.documentElement) {
          if (ghostRelativeParent === document)
            ghostRelativeParent = getWindowScrollingElement();
          rect.top += ghostRelativeParent.scrollTop;
          rect.left += ghostRelativeParent.scrollLeft;
        } else {
          ghostRelativeParent = getWindowScrollingElement();
        }
        ghostRelativeParentInitialScroll = getRelativeScrollOffset(ghostRelativeParent);
      }
      ghostEl = dragEl.cloneNode(true);
      toggleClass(ghostEl, options.ghostClass, false);
      toggleClass(ghostEl, options.fallbackClass, true);
      toggleClass(ghostEl, options.dragClass, true);
      css(ghostEl, "transition", "");
      css(ghostEl, "transform", "");
      css(ghostEl, "box-sizing", "border-box");
      css(ghostEl, "margin", 0);
      css(ghostEl, "top", rect.top);
      css(ghostEl, "left", rect.left);
      css(ghostEl, "width", rect.width);
      css(ghostEl, "height", rect.height);
      css(ghostEl, "opacity", "0.8");
      css(ghostEl, "position", PositionGhostAbsolutely ? "absolute" : "fixed");
      css(ghostEl, "zIndex", "100000");
      css(ghostEl, "pointerEvents", "none");
      Sortable.ghost = ghostEl;
      container.appendChild(ghostEl);
      css(ghostEl, "transform-origin", tapDistanceLeft / parseInt(ghostEl.style.width) * 100 + "% " + tapDistanceTop / parseInt(ghostEl.style.height) * 100 + "%");
    }
  },
  _onDragStart: function _onDragStart(evt, fallback) {
    var _this = this;
    var dataTransfer = evt.dataTransfer;
    var options = _this.options;
    pluginEvent2("dragStart", this, {
      evt
    });
    if (Sortable.eventCanceled) {
      this._onDrop();
      return;
    }
    pluginEvent2("setupClone", this);
    if (!Sortable.eventCanceled) {
      cloneEl = clone(dragEl);
      cloneEl.draggable = false;
      cloneEl.style["will-change"] = "";
      this._hideClone();
      toggleClass(cloneEl, this.options.chosenClass, false);
      Sortable.clone = cloneEl;
    }
    _this.cloneId = _nextTick(function() {
      pluginEvent2("clone", _this);
      if (Sortable.eventCanceled)
        return;
      if (!_this.options.removeCloneOnHide) {
        rootEl.insertBefore(cloneEl, dragEl);
      }
      _this._hideClone();
      _dispatchEvent({
        sortable: _this,
        name: "clone"
      });
    });
    !fallback && toggleClass(dragEl, options.dragClass, true);
    if (fallback) {
      ignoreNextClick = true;
      _this._loopId = setInterval(_this._emulateDragOver, 50);
    } else {
      off(document, "mouseup", _this._onDrop);
      off(document, "touchend", _this._onDrop);
      off(document, "touchcancel", _this._onDrop);
      if (dataTransfer) {
        dataTransfer.effectAllowed = "move";
        options.setData && options.setData.call(_this, dataTransfer, dragEl);
      }
      on$1(document, "drop", _this);
      css(dragEl, "transform", "translateZ(0)");
    }
    awaitingDragStarted = true;
    _this._dragStartId = _nextTick(_this._dragStarted.bind(_this, fallback, evt));
    on$1(document, "selectstart", _this);
    moved = true;
    if (Safari) {
      css(document.body, "user-select", "none");
    }
  },
  _onDragOver: function _onDragOver(evt) {
    var el = this.el, target = evt.target, dragRect, targetRect, revert, options = this.options, group = options.group, activeSortable = Sortable.active, isOwner = activeGroup === group, canSort = options.sort, fromSortable = putSortable || activeSortable, vertical, _this = this, completedFired = false;
    if (_silent)
      return;
    function dragOverEvent(name2, extra) {
      pluginEvent2(name2, _this, _objectSpread2({
        evt,
        isOwner,
        axis: vertical ? "vertical" : "horizontal",
        revert,
        dragRect,
        targetRect,
        canSort,
        fromSortable,
        target,
        completed,
        onMove: function onMove(target2, after2) {
          return _onMove(rootEl, el, dragEl, dragRect, target2, getRect(target2), evt, after2);
        },
        changed
      }, extra));
    }
    function capture() {
      dragOverEvent("dragOverAnimationCapture");
      _this.captureAnimationState();
      if (_this !== fromSortable) {
        fromSortable.captureAnimationState();
      }
    }
    function completed(insertion) {
      dragOverEvent("dragOverCompleted", {
        insertion
      });
      if (insertion) {
        if (isOwner) {
          activeSortable._hideClone();
        } else {
          activeSortable._showClone(_this);
        }
        if (_this !== fromSortable) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : activeSortable.options.ghostClass, false);
          toggleClass(dragEl, options.ghostClass, true);
        }
        if (putSortable !== _this && _this !== Sortable.active) {
          putSortable = _this;
        } else if (_this === Sortable.active && putSortable) {
          putSortable = null;
        }
        if (fromSortable === _this) {
          _this._ignoreWhileAnimating = target;
        }
        _this.animateAll(function() {
          dragOverEvent("dragOverAnimationComplete");
          _this._ignoreWhileAnimating = null;
        });
        if (_this !== fromSortable) {
          fromSortable.animateAll();
          fromSortable._ignoreWhileAnimating = null;
        }
      }
      if (target === dragEl && !dragEl.animated || target === el && !target.animated) {
        lastTarget = null;
      }
      if (!options.dragoverBubble && !evt.rootEl && target !== document) {
        dragEl.parentNode[expando]._isOutsideThisEl(evt.target);
        !insertion && nearestEmptyInsertDetectEvent(evt);
      }
      !options.dragoverBubble && evt.stopPropagation && evt.stopPropagation();
      return completedFired = true;
    }
    function changed() {
      newIndex = index$2(dragEl);
      newDraggableIndex = index$2(dragEl, options.draggable);
      _dispatchEvent({
        sortable: _this,
        name: "change",
        toEl: el,
        newIndex,
        newDraggableIndex,
        originalEvent: evt
      });
    }
    if (evt.preventDefault !== void 0) {
      evt.cancelable && evt.preventDefault();
    }
    target = closest(target, options.draggable, el, true);
    dragOverEvent("dragOver");
    if (Sortable.eventCanceled)
      return completedFired;
    if (dragEl.contains(evt.target) || target.animated && target.animatingX && target.animatingY || _this._ignoreWhileAnimating === target) {
      return completed(false);
    }
    ignoreNextClick = false;
    if (activeSortable && !options.disabled && (isOwner ? canSort || (revert = parentEl !== rootEl) : putSortable === this || (this.lastPutMode = activeGroup.checkPull(this, activeSortable, dragEl, evt)) && group.checkPut(this, activeSortable, dragEl, evt))) {
      vertical = this._getDirection(evt, target) === "vertical";
      dragRect = getRect(dragEl);
      dragOverEvent("dragOverValid");
      if (Sortable.eventCanceled)
        return completedFired;
      if (revert) {
        parentEl = rootEl;
        capture();
        this._hideClone();
        dragOverEvent("revert");
        if (!Sortable.eventCanceled) {
          if (nextEl) {
            rootEl.insertBefore(dragEl, nextEl);
          } else {
            rootEl.appendChild(dragEl);
          }
        }
        return completed(true);
      }
      var elLastChild = lastChild(el, options.draggable);
      if (!elLastChild || _ghostIsLast(evt, vertical, this) && !elLastChild.animated) {
        if (elLastChild === dragEl) {
          return completed(false);
        }
        if (elLastChild && el === evt.target) {
          target = elLastChild;
        }
        if (target) {
          targetRect = getRect(target);
        }
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, !!target) !== false) {
          capture();
          el.appendChild(dragEl);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (elLastChild && _ghostIsFirst(evt, vertical, this)) {
        var firstChild = getChild(el, 0, options, true);
        if (firstChild === dragEl) {
          return completed(false);
        }
        target = firstChild;
        targetRect = getRect(target);
        if (_onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, false) !== false) {
          capture();
          el.insertBefore(dragEl, firstChild);
          parentEl = el;
          changed();
          return completed(true);
        }
      } else if (target.parentNode === el) {
        targetRect = getRect(target);
        var direction2 = 0, targetBeforeFirstSwap, differentLevel = dragEl.parentNode !== el, differentRowCol = !_dragElInRowColumn(dragEl.animated && dragEl.toRect || dragRect, target.animated && target.toRect || targetRect, vertical), side1 = vertical ? "top" : "left", scrolledPastTop = isScrolledPast(target, "top", "top") || isScrolledPast(dragEl, "top", "top"), scrollBefore = scrolledPastTop ? scrolledPastTop.scrollTop : void 0;
        if (lastTarget !== target) {
          targetBeforeFirstSwap = targetRect[side1];
          pastFirstInvertThresh = false;
          isCircumstantialInvert = !differentRowCol && options.invertSwap || differentLevel;
        }
        direction2 = _getSwapDirection(evt, target, targetRect, vertical, differentRowCol ? 1 : options.swapThreshold, options.invertedSwapThreshold == null ? options.swapThreshold : options.invertedSwapThreshold, isCircumstantialInvert, lastTarget === target);
        var sibling;
        if (direction2 !== 0) {
          var dragIndex = index$2(dragEl);
          do {
            dragIndex -= direction2;
            sibling = parentEl.children[dragIndex];
          } while (sibling && (css(sibling, "display") === "none" || sibling === ghostEl));
        }
        if (direction2 === 0 || sibling === target) {
          return completed(false);
        }
        lastTarget = target;
        lastDirection = direction2;
        var nextSibling = target.nextElementSibling, after = false;
        after = direction2 === 1;
        var moveVector = _onMove(rootEl, el, dragEl, dragRect, target, targetRect, evt, after);
        if (moveVector !== false) {
          if (moveVector === 1 || moveVector === -1) {
            after = moveVector === 1;
          }
          _silent = true;
          setTimeout(_unsilent, 30);
          capture();
          if (after && !nextSibling) {
            el.appendChild(dragEl);
          } else {
            target.parentNode.insertBefore(dragEl, after ? nextSibling : target);
          }
          if (scrolledPastTop) {
            scrollBy(scrolledPastTop, 0, scrollBefore - scrolledPastTop.scrollTop);
          }
          parentEl = dragEl.parentNode;
          if (targetBeforeFirstSwap !== void 0 && !isCircumstantialInvert) {
            targetMoveDistance = Math.abs(targetBeforeFirstSwap - getRect(target)[side1]);
          }
          changed();
          return completed(true);
        }
      }
      if (el.contains(dragEl)) {
        return completed(false);
      }
    }
    return false;
  },
  _ignoreWhileAnimating: null,
  _offMoveEvents: function _offMoveEvents() {
    off(document, "mousemove", this._onTouchMove);
    off(document, "touchmove", this._onTouchMove);
    off(document, "pointermove", this._onTouchMove);
    off(document, "dragover", nearestEmptyInsertDetectEvent);
    off(document, "mousemove", nearestEmptyInsertDetectEvent);
    off(document, "touchmove", nearestEmptyInsertDetectEvent);
  },
  _offUpEvents: function _offUpEvents() {
    var ownerDocument = this.el.ownerDocument;
    off(ownerDocument, "mouseup", this._onDrop);
    off(ownerDocument, "touchend", this._onDrop);
    off(ownerDocument, "pointerup", this._onDrop);
    off(ownerDocument, "touchcancel", this._onDrop);
    off(document, "selectstart", this);
  },
  _onDrop: function _onDrop(evt) {
    var el = this.el, options = this.options;
    newIndex = index$2(dragEl);
    newDraggableIndex = index$2(dragEl, options.draggable);
    pluginEvent2("drop", this, {
      evt
    });
    parentEl = dragEl && dragEl.parentNode;
    newIndex = index$2(dragEl);
    newDraggableIndex = index$2(dragEl, options.draggable);
    if (Sortable.eventCanceled) {
      this._nulling();
      return;
    }
    awaitingDragStarted = false;
    isCircumstantialInvert = false;
    pastFirstInvertThresh = false;
    clearInterval(this._loopId);
    clearTimeout(this._dragStartTimer);
    _cancelNextTick(this.cloneId);
    _cancelNextTick(this._dragStartId);
    if (this.nativeDraggable) {
      off(document, "drop", this);
      off(el, "dragstart", this._onDragStart);
    }
    this._offMoveEvents();
    this._offUpEvents();
    if (Safari) {
      css(document.body, "user-select", "");
    }
    css(dragEl, "transform", "");
    if (evt) {
      if (moved) {
        evt.cancelable && evt.preventDefault();
        !options.dropBubble && evt.stopPropagation();
      }
      ghostEl && ghostEl.parentNode && ghostEl.parentNode.removeChild(ghostEl);
      if (rootEl === parentEl || putSortable && putSortable.lastPutMode !== "clone") {
        cloneEl && cloneEl.parentNode && cloneEl.parentNode.removeChild(cloneEl);
      }
      if (dragEl) {
        if (this.nativeDraggable) {
          off(dragEl, "dragend", this);
        }
        _disableDraggable(dragEl);
        dragEl.style["will-change"] = "";
        if (moved && !awaitingDragStarted) {
          toggleClass(dragEl, putSortable ? putSortable.options.ghostClass : this.options.ghostClass, false);
        }
        toggleClass(dragEl, this.options.chosenClass, false);
        _dispatchEvent({
          sortable: this,
          name: "unchoose",
          toEl: parentEl,
          newIndex: null,
          newDraggableIndex: null,
          originalEvent: evt
        });
        if (rootEl !== parentEl) {
          if (newIndex >= 0) {
            _dispatchEvent({
              rootEl: parentEl,
              name: "add",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "remove",
              toEl: parentEl,
              originalEvent: evt
            });
            _dispatchEvent({
              rootEl: parentEl,
              name: "sort",
              toEl: parentEl,
              fromEl: rootEl,
              originalEvent: evt
            });
            _dispatchEvent({
              sortable: this,
              name: "sort",
              toEl: parentEl,
              originalEvent: evt
            });
          }
          putSortable && putSortable.save();
        } else {
          if (newIndex !== oldIndex) {
            if (newIndex >= 0) {
              _dispatchEvent({
                sortable: this,
                name: "update",
                toEl: parentEl,
                originalEvent: evt
              });
              _dispatchEvent({
                sortable: this,
                name: "sort",
                toEl: parentEl,
                originalEvent: evt
              });
            }
          }
        }
        if (Sortable.active) {
          if (newIndex == null || newIndex === -1) {
            newIndex = oldIndex;
            newDraggableIndex = oldDraggableIndex;
          }
          _dispatchEvent({
            sortable: this,
            name: "end",
            toEl: parentEl,
            originalEvent: evt
          });
          this.save();
        }
      }
    }
    this._nulling();
  },
  _nulling: function _nulling() {
    pluginEvent2("nulling", this);
    rootEl = dragEl = parentEl = ghostEl = nextEl = cloneEl = lastDownEl = cloneHidden = tapEvt = touchEvt = moved = newIndex = newDraggableIndex = oldIndex = oldDraggableIndex = lastTarget = lastDirection = putSortable = activeGroup = Sortable.dragged = Sortable.ghost = Sortable.clone = Sortable.active = null;
    savedInputChecked.forEach(function(el) {
      el.checked = true;
    });
    savedInputChecked.length = lastDx = lastDy = 0;
  },
  handleEvent: function handleEvent(evt) {
    switch (evt.type) {
      case "drop":
      case "dragend":
        this._onDrop(evt);
        break;
      case "dragenter":
      case "dragover":
        if (dragEl) {
          this._onDragOver(evt);
          _globalDragOver(evt);
        }
        break;
      case "selectstart":
        evt.preventDefault();
        break;
    }
  },
  toArray: function toArray2() {
    var order = [], el, children = this.el.children, i = 0, n = children.length, options = this.options;
    for (; i < n; i++) {
      el = children[i];
      if (closest(el, options.draggable, this.el, false)) {
        order.push(el.getAttribute(options.dataIdAttr) || _generateId(el));
      }
    }
    return order;
  },
  sort: function sort(order, useAnimation) {
    var items = {}, rootEl2 = this.el;
    this.toArray().forEach(function(id, i) {
      var el = rootEl2.children[i];
      if (closest(el, this.options.draggable, rootEl2, false)) {
        items[id] = el;
      }
    }, this);
    useAnimation && this.captureAnimationState();
    order.forEach(function(id) {
      if (items[id]) {
        rootEl2.removeChild(items[id]);
        rootEl2.appendChild(items[id]);
      }
    });
    useAnimation && this.animateAll();
  },
  save: function save() {
    var store = this.options.store;
    store && store.set && store.set(this);
  },
  closest: function closest$1(el, selector) {
    return closest(el, selector || this.options.draggable, this.el, false);
  },
  option: function option(name2, value) {
    var options = this.options;
    if (value === void 0) {
      return options[name2];
    } else {
      var modifiedValue = PluginManager.modifyOption(this, name2, value);
      if (typeof modifiedValue !== "undefined") {
        options[name2] = modifiedValue;
      } else {
        options[name2] = value;
      }
      if (name2 === "group") {
        _prepareGroup(options);
      }
    }
  },
  destroy: function destroy() {
    pluginEvent2("destroy", this);
    var el = this.el;
    el[expando] = null;
    off(el, "mousedown", this._onTapStart);
    off(el, "touchstart", this._onTapStart);
    off(el, "pointerdown", this._onTapStart);
    if (this.nativeDraggable) {
      off(el, "dragover", this);
      off(el, "dragenter", this);
    }
    Array.prototype.forEach.call(el.querySelectorAll("[draggable]"), function(el2) {
      el2.removeAttribute("draggable");
    });
    this._onDrop();
    this._disableDelayedDragEvents();
    sortables.splice(sortables.indexOf(this.el), 1);
    this.el = el = null;
  },
  _hideClone: function _hideClone() {
    if (!cloneHidden) {
      pluginEvent2("hideClone", this);
      if (Sortable.eventCanceled)
        return;
      css(cloneEl, "display", "none");
      if (this.options.removeCloneOnHide && cloneEl.parentNode) {
        cloneEl.parentNode.removeChild(cloneEl);
      }
      cloneHidden = true;
    }
  },
  _showClone: function _showClone(putSortable2) {
    if (putSortable2.lastPutMode !== "clone") {
      this._hideClone();
      return;
    }
    if (cloneHidden) {
      pluginEvent2("showClone", this);
      if (Sortable.eventCanceled)
        return;
      if (dragEl.parentNode == rootEl && !this.options.group.revertClone) {
        rootEl.insertBefore(cloneEl, dragEl);
      } else if (nextEl) {
        rootEl.insertBefore(cloneEl, nextEl);
      } else {
        rootEl.appendChild(cloneEl);
      }
      if (this.options.group.revertClone) {
        this.animate(dragEl, cloneEl);
      }
      css(cloneEl, "display", "");
      cloneHidden = false;
    }
  }
};
function _globalDragOver(evt) {
  if (evt.dataTransfer) {
    evt.dataTransfer.dropEffect = "move";
  }
  evt.cancelable && evt.preventDefault();
}
function _onMove(fromEl, toEl, dragEl2, dragRect, targetEl, targetRect, originalEvent, willInsertAfter) {
  var evt, sortable = fromEl[expando], onMoveFn = sortable.options.onMove, retVal;
  if (window.CustomEvent && !IE11OrLess && !Edge) {
    evt = new CustomEvent("move", {
      bubbles: true,
      cancelable: true
    });
  } else {
    evt = document.createEvent("Event");
    evt.initEvent("move", true, true);
  }
  evt.to = toEl;
  evt.from = fromEl;
  evt.dragged = dragEl2;
  evt.draggedRect = dragRect;
  evt.related = targetEl || toEl;
  evt.relatedRect = targetRect || getRect(toEl);
  evt.willInsertAfter = willInsertAfter;
  evt.originalEvent = originalEvent;
  fromEl.dispatchEvent(evt);
  if (onMoveFn) {
    retVal = onMoveFn.call(sortable, evt, originalEvent);
  }
  return retVal;
}
function _disableDraggable(el) {
  el.draggable = false;
}
function _unsilent() {
  _silent = false;
}
function _ghostIsFirst(evt, vertical, sortable) {
  var rect = getRect(getChild(sortable.el, 0, sortable.options, true));
  var spacer = 10;
  return vertical ? evt.clientX < rect.left - spacer || evt.clientY < rect.top && evt.clientX < rect.right : evt.clientY < rect.top - spacer || evt.clientY < rect.bottom && evt.clientX < rect.left;
}
function _ghostIsLast(evt, vertical, sortable) {
  var rect = getRect(lastChild(sortable.el, sortable.options.draggable));
  var spacer = 10;
  return vertical ? evt.clientX > rect.right + spacer || evt.clientX <= rect.right && evt.clientY > rect.bottom && evt.clientX >= rect.left : evt.clientX > rect.right && evt.clientY > rect.top || evt.clientX <= rect.right && evt.clientY > rect.bottom + spacer;
}
function _getSwapDirection(evt, target, targetRect, vertical, swapThreshold, invertedSwapThreshold, invertSwap, isLastTarget) {
  var mouseOnAxis = vertical ? evt.clientY : evt.clientX, targetLength = vertical ? targetRect.height : targetRect.width, targetS1 = vertical ? targetRect.top : targetRect.left, targetS2 = vertical ? targetRect.bottom : targetRect.right, invert2 = false;
  if (!invertSwap) {
    if (isLastTarget && targetMoveDistance < targetLength * swapThreshold) {
      if (!pastFirstInvertThresh && (lastDirection === 1 ? mouseOnAxis > targetS1 + targetLength * invertedSwapThreshold / 2 : mouseOnAxis < targetS2 - targetLength * invertedSwapThreshold / 2)) {
        pastFirstInvertThresh = true;
      }
      if (!pastFirstInvertThresh) {
        if (lastDirection === 1 ? mouseOnAxis < targetS1 + targetMoveDistance : mouseOnAxis > targetS2 - targetMoveDistance) {
          return -lastDirection;
        }
      } else {
        invert2 = true;
      }
    } else {
      if (mouseOnAxis > targetS1 + targetLength * (1 - swapThreshold) / 2 && mouseOnAxis < targetS2 - targetLength * (1 - swapThreshold) / 2) {
        return _getInsertDirection(target);
      }
    }
  }
  invert2 = invert2 || invertSwap;
  if (invert2) {
    if (mouseOnAxis < targetS1 + targetLength * invertedSwapThreshold / 2 || mouseOnAxis > targetS2 - targetLength * invertedSwapThreshold / 2) {
      return mouseOnAxis > targetS1 + targetLength / 2 ? 1 : -1;
    }
  }
  return 0;
}
function _getInsertDirection(target) {
  if (index$2(dragEl) < index$2(target)) {
    return 1;
  } else {
    return -1;
  }
}
function _generateId(el) {
  var str = el.tagName + el.className + el.src + el.href + el.textContent, i = str.length, sum2 = 0;
  while (i--) {
    sum2 += str.charCodeAt(i);
  }
  return sum2.toString(36);
}
function _saveInputCheckedState(root) {
  savedInputChecked.length = 0;
  var inputs = root.getElementsByTagName("input");
  var idx = inputs.length;
  while (idx--) {
    var el = inputs[idx];
    el.checked && savedInputChecked.push(el);
  }
}
function _nextTick(fn2) {
  return setTimeout(fn2, 0);
}
function _cancelNextTick(id) {
  return clearTimeout(id);
}
if (documentExists) {
  on$1(document, "touchmove", function(evt) {
    if ((Sortable.active || awaitingDragStarted) && evt.cancelable) {
      evt.preventDefault();
    }
  });
}
Sortable.utils = {
  on: on$1,
  off,
  css,
  find,
  is: function is(el, selector) {
    return !!closest(el, selector, el, false);
  },
  extend,
  throttle,
  closest,
  toggleClass,
  clone,
  index: index$2,
  nextTick: _nextTick,
  cancelNextTick: _cancelNextTick,
  detectDirection: _detectDirection,
  getChild
};
Sortable.get = function(element) {
  return element[expando];
};
Sortable.mount = function() {
  for (var _len = arguments.length, plugins2 = new Array(_len), _key = 0; _key < _len; _key++) {
    plugins2[_key] = arguments[_key];
  }
  if (plugins2[0].constructor === Array)
    plugins2 = plugins2[0];
  plugins2.forEach(function(plugin) {
    if (!plugin.prototype || !plugin.prototype.constructor) {
      throw "Sortable: Mounted plugin must be a constructor function, not ".concat({}.toString.call(plugin));
    }
    if (plugin.utils)
      Sortable.utils = _objectSpread2(_objectSpread2({}, Sortable.utils), plugin.utils);
    PluginManager.mount(plugin);
  });
};
Sortable.create = function(el, options) {
  return new Sortable(el, options);
};
Sortable.version = version;
var autoScrolls = [], scrollEl, scrollRootEl, scrolling = false, lastAutoScrollX, lastAutoScrollY, touchEvt$1, pointerElemChangedInterval;
function AutoScrollPlugin() {
  function AutoScroll() {
    this.defaults = {
      scroll: true,
      forceAutoScrollFallback: false,
      scrollSensitivity: 30,
      scrollSpeed: 10,
      bubbleScroll: true
    };
    for (var fn2 in this) {
      if (fn2.charAt(0) === "_" && typeof this[fn2] === "function") {
        this[fn2] = this[fn2].bind(this);
      }
    }
  }
  AutoScroll.prototype = {
    dragStarted: function dragStarted(_ref) {
      var originalEvent = _ref.originalEvent;
      if (this.sortable.nativeDraggable) {
        on$1(document, "dragover", this._handleAutoScroll);
      } else {
        if (this.options.supportPointer) {
          on$1(document, "pointermove", this._handleFallbackAutoScroll);
        } else if (originalEvent.touches) {
          on$1(document, "touchmove", this._handleFallbackAutoScroll);
        } else {
          on$1(document, "mousemove", this._handleFallbackAutoScroll);
        }
      }
    },
    dragOverCompleted: function dragOverCompleted(_ref2) {
      var originalEvent = _ref2.originalEvent;
      if (!this.options.dragOverBubble && !originalEvent.rootEl) {
        this._handleAutoScroll(originalEvent);
      }
    },
    drop: function drop3() {
      if (this.sortable.nativeDraggable) {
        off(document, "dragover", this._handleAutoScroll);
      } else {
        off(document, "pointermove", this._handleFallbackAutoScroll);
        off(document, "touchmove", this._handleFallbackAutoScroll);
        off(document, "mousemove", this._handleFallbackAutoScroll);
      }
      clearPointerElemChangedInterval();
      clearAutoScrolls();
      cancelThrottle();
    },
    nulling: function nulling() {
      touchEvt$1 = scrollRootEl = scrollEl = scrolling = pointerElemChangedInterval = lastAutoScrollX = lastAutoScrollY = null;
      autoScrolls.length = 0;
    },
    _handleFallbackAutoScroll: function _handleFallbackAutoScroll(evt) {
      this._handleAutoScroll(evt, true);
    },
    _handleAutoScroll: function _handleAutoScroll(evt, fallback) {
      var _this = this;
      var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, elem = document.elementFromPoint(x, y);
      touchEvt$1 = evt;
      if (fallback || this.options.forceAutoScrollFallback || Edge || IE11OrLess || Safari) {
        autoScroll(evt, this.options, elem, fallback);
        var ogElemScroller = getParentAutoScrollElement(elem, true);
        if (scrolling && (!pointerElemChangedInterval || x !== lastAutoScrollX || y !== lastAutoScrollY)) {
          pointerElemChangedInterval && clearPointerElemChangedInterval();
          pointerElemChangedInterval = setInterval(function() {
            var newElem = getParentAutoScrollElement(document.elementFromPoint(x, y), true);
            if (newElem !== ogElemScroller) {
              ogElemScroller = newElem;
              clearAutoScrolls();
            }
            autoScroll(evt, _this.options, newElem, fallback);
          }, 10);
          lastAutoScrollX = x;
          lastAutoScrollY = y;
        }
      } else {
        if (!this.options.bubbleScroll || getParentAutoScrollElement(elem, true) === getWindowScrollingElement()) {
          clearAutoScrolls();
          return;
        }
        autoScroll(evt, this.options, getParentAutoScrollElement(elem, false), false);
      }
    }
  };
  return _extends(AutoScroll, {
    pluginName: "scroll",
    initializeByDefault: true
  });
}
function clearAutoScrolls() {
  autoScrolls.forEach(function(autoScroll2) {
    clearInterval(autoScroll2.pid);
  });
  autoScrolls = [];
}
function clearPointerElemChangedInterval() {
  clearInterval(pointerElemChangedInterval);
}
var autoScroll = throttle(function(evt, options, rootEl2, isFallback) {
  if (!options.scroll)
    return;
  var x = (evt.touches ? evt.touches[0] : evt).clientX, y = (evt.touches ? evt.touches[0] : evt).clientY, sens = options.scrollSensitivity, speed = options.scrollSpeed, winScroller = getWindowScrollingElement();
  var scrollThisInstance = false, scrollCustomFn;
  if (scrollRootEl !== rootEl2) {
    scrollRootEl = rootEl2;
    clearAutoScrolls();
    scrollEl = options.scroll;
    scrollCustomFn = options.scrollFn;
    if (scrollEl === true) {
      scrollEl = getParentAutoScrollElement(rootEl2, true);
    }
  }
  var layersOut = 0;
  var currentParent = scrollEl;
  do {
    var el = currentParent, rect = getRect(el), top = rect.top, bottom = rect.bottom, left = rect.left, right = rect.right, width = rect.width, height = rect.height, canScrollX = void 0, canScrollY = void 0, scrollWidth = el.scrollWidth, scrollHeight = el.scrollHeight, elCSS = css(el), scrollPosX = el.scrollLeft, scrollPosY = el.scrollTop;
    if (el === winScroller) {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll" || elCSS.overflowX === "visible");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll" || elCSS.overflowY === "visible");
    } else {
      canScrollX = width < scrollWidth && (elCSS.overflowX === "auto" || elCSS.overflowX === "scroll");
      canScrollY = height < scrollHeight && (elCSS.overflowY === "auto" || elCSS.overflowY === "scroll");
    }
    var vx = canScrollX && (Math.abs(right - x) <= sens && scrollPosX + width < scrollWidth) - (Math.abs(left - x) <= sens && !!scrollPosX);
    var vy = canScrollY && (Math.abs(bottom - y) <= sens && scrollPosY + height < scrollHeight) - (Math.abs(top - y) <= sens && !!scrollPosY);
    if (!autoScrolls[layersOut]) {
      for (var i = 0; i <= layersOut; i++) {
        if (!autoScrolls[i]) {
          autoScrolls[i] = {};
        }
      }
    }
    if (autoScrolls[layersOut].vx != vx || autoScrolls[layersOut].vy != vy || autoScrolls[layersOut].el !== el) {
      autoScrolls[layersOut].el = el;
      autoScrolls[layersOut].vx = vx;
      autoScrolls[layersOut].vy = vy;
      clearInterval(autoScrolls[layersOut].pid);
      if (vx != 0 || vy != 0) {
        scrollThisInstance = true;
        autoScrolls[layersOut].pid = setInterval(function() {
          if (isFallback && this.layer === 0) {
            Sortable.active._onTouchMove(touchEvt$1);
          }
          var scrollOffsetY = autoScrolls[this.layer].vy ? autoScrolls[this.layer].vy * speed : 0;
          var scrollOffsetX = autoScrolls[this.layer].vx ? autoScrolls[this.layer].vx * speed : 0;
          if (typeof scrollCustomFn === "function") {
            if (scrollCustomFn.call(Sortable.dragged.parentNode[expando], scrollOffsetX, scrollOffsetY, evt, touchEvt$1, autoScrolls[this.layer].el) !== "continue") {
              return;
            }
          }
          scrollBy(autoScrolls[this.layer].el, scrollOffsetX, scrollOffsetY);
        }.bind({
          layer: layersOut
        }), 24);
      }
    }
    layersOut++;
  } while (options.bubbleScroll && currentParent !== winScroller && (currentParent = getParentAutoScrollElement(currentParent, false)));
  scrolling = scrollThisInstance;
}, 30);
var drop = function drop2(_ref) {
  var originalEvent = _ref.originalEvent, putSortable2 = _ref.putSortable, dragEl2 = _ref.dragEl, activeSortable = _ref.activeSortable, dispatchSortableEvent = _ref.dispatchSortableEvent, hideGhostForTarget = _ref.hideGhostForTarget, unhideGhostForTarget = _ref.unhideGhostForTarget;
  if (!originalEvent)
    return;
  var toSortable = putSortable2 || activeSortable;
  hideGhostForTarget();
  var touch = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches[0] : originalEvent;
  var target = document.elementFromPoint(touch.clientX, touch.clientY);
  unhideGhostForTarget();
  if (toSortable && !toSortable.el.contains(target)) {
    dispatchSortableEvent("spill");
    this.onSpill({
      dragEl: dragEl2,
      putSortable: putSortable2
    });
  }
};
function Revert() {
}
Revert.prototype = {
  startIndex: null,
  dragStart: function dragStart(_ref2) {
    var oldDraggableIndex2 = _ref2.oldDraggableIndex;
    this.startIndex = oldDraggableIndex2;
  },
  onSpill: function onSpill(_ref3) {
    var dragEl2 = _ref3.dragEl, putSortable2 = _ref3.putSortable;
    this.sortable.captureAnimationState();
    if (putSortable2) {
      putSortable2.captureAnimationState();
    }
    var nextSibling = getChild(this.sortable.el, this.startIndex, this.options);
    if (nextSibling) {
      this.sortable.el.insertBefore(dragEl2, nextSibling);
    } else {
      this.sortable.el.appendChild(dragEl2);
    }
    this.sortable.animateAll();
    if (putSortable2) {
      putSortable2.animateAll();
    }
  },
  drop
};
_extends(Revert, {
  pluginName: "revertOnSpill"
});
function Remove() {
}
Remove.prototype = {
  onSpill: function onSpill2(_ref4) {
    var dragEl2 = _ref4.dragEl, putSortable2 = _ref4.putSortable;
    var parentSortable = putSortable2 || this.sortable;
    parentSortable.captureAnimationState();
    dragEl2.parentNode && dragEl2.parentNode.removeChild(dragEl2);
    parentSortable.animateAll();
  },
  drop
};
_extends(Remove, {
  pluginName: "removeOnSpill"
});
Sortable.mount(new AutoScrollPlugin());
Sortable.mount(Remove, Revert);
function removeNode(node) {
  if (node.parentElement !== null) {
    node.parentElement.removeChild(node);
  }
}
function insertNodeAt(fatherNode, node, position2) {
  const refNode = position2 === 0 ? fatherNode.children[0] : fatherNode.children[position2 - 1].nextSibling;
  fatherNode.insertBefore(node, refNode);
}
function getConsole() {
  if (typeof window !== "undefined") {
    return window.console;
  }
  return global.console;
}
const console$1 = getConsole();
function cached(fn2) {
  const cache = /* @__PURE__ */ Object.create(null);
  return function cachedFn(str) {
    const hit = cache[str];
    return hit || (cache[str] = fn2(str));
  };
}
const regex$1 = /-(\w)/g;
const camelize = cached((str) => str.replace(regex$1, (_, c) => c.toUpperCase()));
const manageAndEmit$1 = ["Start", "Add", "Remove", "Update", "End"];
const emit$1 = ["Choose", "Unchoose", "Sort", "Filter", "Clone"];
const manage$1 = ["Move"];
const eventHandlerNames = [manage$1, manageAndEmit$1, emit$1].flatMap((events2) => events2).map((evt) => `on${evt}`);
const events = {
  manage: manage$1,
  manageAndEmit: manageAndEmit$1,
  emit: emit$1
};
function isReadOnly(eventName) {
  return eventHandlerNames.indexOf(eventName) !== -1;
}
const tags = [
  "a",
  "abbr",
  "address",
  "area",
  "article",
  "aside",
  "audio",
  "b",
  "base",
  "bdi",
  "bdo",
  "blockquote",
  "body",
  "br",
  "button",
  "canvas",
  "caption",
  "cite",
  "code",
  "col",
  "colgroup",
  "data",
  "datalist",
  "dd",
  "del",
  "details",
  "dfn",
  "dialog",
  "div",
  "dl",
  "dt",
  "em",
  "embed",
  "fieldset",
  "figcaption",
  "figure",
  "footer",
  "form",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "head",
  "header",
  "hgroup",
  "hr",
  "html",
  "i",
  "iframe",
  "img",
  "input",
  "ins",
  "kbd",
  "label",
  "legend",
  "li",
  "link",
  "main",
  "map",
  "mark",
  "math",
  "menu",
  "menuitem",
  "meta",
  "meter",
  "nav",
  "noscript",
  "object",
  "ol",
  "optgroup",
  "option",
  "output",
  "p",
  "param",
  "picture",
  "pre",
  "progress",
  "q",
  "rb",
  "rp",
  "rt",
  "rtc",
  "ruby",
  "s",
  "samp",
  "script",
  "section",
  "select",
  "slot",
  "small",
  "source",
  "span",
  "strong",
  "style",
  "sub",
  "summary",
  "sup",
  "svg",
  "table",
  "tbody",
  "td",
  "template",
  "textarea",
  "tfoot",
  "th",
  "thead",
  "time",
  "title",
  "tr",
  "track",
  "u",
  "ul",
  "var",
  "video",
  "wbr"
];
function isHtmlTag(name2) {
  return tags.includes(name2);
}
function isTransition(name2) {
  return ["transition-group", "TransitionGroup"].includes(name2);
}
function isHtmlAttribute(value) {
  return ["id", "class", "role", "style"].includes(value) || value.startsWith("data-") || value.startsWith("aria-") || value.startsWith("on");
}
function project(entries) {
  return entries.reduce((res, [key, value]) => {
    res[key] = value;
    return res;
  }, {});
}
function getComponentAttributes({ $attrs, componentData = {} }) {
  const attributes = project(
    Object.entries($attrs).filter(([key, _]) => isHtmlAttribute(key))
  );
  return {
    ...attributes,
    ...componentData
  };
}
function createSortableOption({ $attrs, callBackBuilder }) {
  const options = project(getValidSortableEntries($attrs));
  Object.entries(callBackBuilder).forEach(([eventType, eventBuilder]) => {
    events[eventType].forEach((event) => {
      options[`on${event}`] = eventBuilder(event);
    });
  });
  const draggable = `[data-draggable]${options.draggable || ""}`;
  return {
    ...options,
    draggable
  };
}
function getValidSortableEntries(value) {
  return Object.entries(value).filter(([key, _]) => !isHtmlAttribute(key)).map(([key, value2]) => [camelize(key), value2]).filter(([key, _]) => !isReadOnly(key));
}
const getHtmlElementFromNode = ({ el }) => el;
const addContext = (domElement, context) => domElement.__draggable_context = context;
const getContext = (domElement) => domElement.__draggable_context;
class ComponentStructure {
  constructor({
    nodes: { header, default: defaultNodes, footer },
    root,
    realList
  }) {
    this.defaultNodes = defaultNodes;
    this.children = [...header, ...defaultNodes, ...footer];
    this.externalComponent = root.externalComponent;
    this.rootTransition = root.transition;
    this.tag = root.tag;
    this.realList = realList;
  }
  get _isRootComponent() {
    return this.externalComponent || this.rootTransition;
  }
  render(h2, attributes) {
    const { tag, children, _isRootComponent } = this;
    const option2 = !_isRootComponent ? children : { default: () => children };
    return h2(tag, attributes, option2);
  }
  updated() {
    const { defaultNodes, realList } = this;
    defaultNodes.forEach((node, index2) => {
      addContext(getHtmlElementFromNode(node), {
        element: realList[index2],
        index: index2
      });
    });
  }
  getUnderlyingVm(domElement) {
    return getContext(domElement);
  }
  getVmIndexFromDomIndex(domIndex, element) {
    const { defaultNodes } = this;
    const { length } = defaultNodes;
    const domChildren = element.children;
    const domElement = domChildren.item(domIndex);
    if (domElement === null) {
      return length;
    }
    const context = getContext(domElement);
    if (context) {
      return context.index;
    }
    if (length === 0) {
      return 0;
    }
    const firstDomListElement = getHtmlElementFromNode(defaultNodes[0]);
    const indexFirstDomListElement = [...domChildren].findIndex(
      (element2) => element2 === firstDomListElement
    );
    return domIndex < indexFirstDomListElement ? 0 : length;
  }
}
function getSlot(slots, key) {
  const slotValue = slots[key];
  return slotValue ? slotValue() : [];
}
function computeNodes({ $slots, realList, getKey: getKey2 }) {
  const normalizedList = realList || [];
  const [header, footer] = ["header", "footer"].map(
    (name2) => getSlot($slots, name2)
  );
  const { item } = $slots;
  if (!item) {
    throw new Error("draggable element must have an item slot");
  }
  const defaultNodes = normalizedList.flatMap(
    (element, index2) => item({ element, index: index2 }).map((node) => {
      node.key = getKey2(element);
      node.props = { ...node.props || {}, "data-draggable": true };
      return node;
    })
  );
  if (defaultNodes.length !== normalizedList.length) {
    throw new Error("Item slot must have only one child");
  }
  return {
    header,
    footer,
    default: defaultNodes
  };
}
function getRootInformation(tag) {
  const transition = isTransition(tag);
  const externalComponent = !isHtmlTag(tag) && !transition;
  return {
    transition,
    externalComponent,
    tag: externalComponent ? resolveComponent(tag) : transition ? TransitionGroup : tag
  };
}
function computeComponentStructure({ $slots, tag, realList, getKey: getKey2 }) {
  const nodes = computeNodes({ $slots, realList, getKey: getKey2 });
  const root = getRootInformation(tag);
  return new ComponentStructure({ nodes, root, realList });
}
function emit(evtName, evtData) {
  nextTick(() => this.$emit(evtName.toLowerCase(), evtData));
}
function manage(evtName) {
  return (evtData, originalElement) => {
    if (this.realList !== null) {
      return this[`onDrag${evtName}`](evtData, originalElement);
    }
  };
}
function manageAndEmit(evtName) {
  const delegateCallBack = manage.call(this, evtName);
  return (evtData, originalElement) => {
    delegateCallBack.call(this, evtData, originalElement);
    emit.call(this, evtName, evtData);
  };
}
let draggingElement = null;
const props = {
  list: {
    type: Array,
    required: false,
    default: null
  },
  modelValue: {
    type: Array,
    required: false,
    default: null
  },
  itemKey: {
    type: [String, Function],
    required: true
  },
  clone: {
    type: Function,
    default: (original) => {
      return original;
    }
  },
  tag: {
    type: String,
    default: "div"
  },
  move: {
    type: Function,
    default: null
  },
  componentData: {
    type: Object,
    required: false,
    default: null
  }
};
const emits = [
  "update:modelValue",
  "change",
  ...[...events.manageAndEmit, ...events.emit].map((evt) => evt.toLowerCase())
];
const draggableComponent = defineComponent({
  name: "draggable",
  inheritAttrs: false,
  props,
  emits,
  data() {
    return {
      error: false
    };
  },
  render() {
    try {
      this.error = false;
      const { $slots, $attrs, tag, componentData, realList, getKey: getKey2 } = this;
      const componentStructure = computeComponentStructure({
        $slots,
        tag,
        realList,
        getKey: getKey2
      });
      this.componentStructure = componentStructure;
      const attributes = getComponentAttributes({ $attrs, componentData });
      return componentStructure.render(h$1, attributes);
    } catch (err) {
      this.error = true;
      return h$1("pre", { style: { color: "red" } }, err.stack);
    }
  },
  created() {
    if (this.list !== null && this.modelValue !== null) {
      console$1.error(
        "modelValue and list props are mutually exclusive! Please set one or another."
      );
    }
  },
  mounted() {
    if (this.error) {
      return;
    }
    const { $attrs, $el, componentStructure } = this;
    componentStructure.updated();
    const sortableOptions = createSortableOption({
      $attrs,
      callBackBuilder: {
        manageAndEmit: (event) => manageAndEmit.call(this, event),
        emit: (event) => emit.bind(this, event),
        manage: (event) => manage.call(this, event)
      }
    });
    const targetDomElement = $el.nodeType === 1 ? $el : $el.parentElement;
    this._sortable = new Sortable(targetDomElement, sortableOptions);
    this.targetDomElement = targetDomElement;
    targetDomElement.__draggable_component__ = this;
  },
  updated() {
    this.componentStructure.updated();
  },
  beforeUnmount() {
    if (this._sortable !== void 0)
      this._sortable.destroy();
  },
  computed: {
    realList() {
      const { list } = this;
      return list ? list : this.modelValue;
    },
    getKey() {
      const { itemKey } = this;
      if (typeof itemKey === "function") {
        return itemKey;
      }
      return (element) => element[itemKey];
    }
  },
  watch: {
    $attrs: {
      handler(newOptionValue) {
        const { _sortable } = this;
        if (!_sortable)
          return;
        getValidSortableEntries(newOptionValue).forEach(([key, value]) => {
          _sortable.option(key, value);
        });
      },
      deep: true
    }
  },
  methods: {
    getUnderlyingVm(domElement) {
      return this.componentStructure.getUnderlyingVm(domElement) || null;
    },
    getUnderlyingPotencialDraggableComponent(htmElement) {
      return htmElement.__draggable_component__;
    },
    emitChanges(evt) {
      nextTick(() => this.$emit("change", evt));
    },
    alterList(onList) {
      if (this.list) {
        onList(this.list);
        return;
      }
      const newList = [...this.modelValue];
      onList(newList);
      this.$emit("update:modelValue", newList);
    },
    spliceList() {
      const spliceList = (list) => list.splice(...arguments);
      this.alterList(spliceList);
    },
    updatePosition(oldIndex2, newIndex2) {
      const updatePosition = (list) => list.splice(newIndex2, 0, list.splice(oldIndex2, 1)[0]);
      this.alterList(updatePosition);
    },
    getRelatedContextFromMoveEvent({ to, related }) {
      const component = this.getUnderlyingPotencialDraggableComponent(to);
      if (!component) {
        return { component };
      }
      const list = component.realList;
      const context = { list, component };
      if (to !== related && list) {
        const destination = component.getUnderlyingVm(related) || {};
        return { ...destination, ...context };
      }
      return context;
    },
    getVmIndexFromDomIndex(domIndex) {
      return this.componentStructure.getVmIndexFromDomIndex(
        domIndex,
        this.targetDomElement
      );
    },
    onDragStart(evt) {
      this.context = this.getUnderlyingVm(evt.item);
      evt.item._underlying_vm_ = this.clone(this.context.element);
      draggingElement = evt.item;
    },
    onDragAdd(evt) {
      const element = evt.item._underlying_vm_;
      if (element === void 0) {
        return;
      }
      removeNode(evt.item);
      const newIndex2 = this.getVmIndexFromDomIndex(evt.newIndex);
      this.spliceList(newIndex2, 0, element);
      const added = { element, newIndex: newIndex2 };
      this.emitChanges({ added });
    },
    onDragRemove(evt) {
      insertNodeAt(this.$el, evt.item, evt.oldIndex);
      if (evt.pullMode === "clone") {
        removeNode(evt.clone);
        return;
      }
      const { index: oldIndex2, element } = this.context;
      this.spliceList(oldIndex2, 1);
      const removed = { element, oldIndex: oldIndex2 };
      this.emitChanges({ removed });
    },
    onDragUpdate(evt) {
      removeNode(evt.item);
      insertNodeAt(evt.from, evt.item, evt.oldIndex);
      const oldIndex2 = this.context.index;
      const newIndex2 = this.getVmIndexFromDomIndex(evt.newIndex);
      this.updatePosition(oldIndex2, newIndex2);
      const moved2 = { element: this.context.element, oldIndex: oldIndex2, newIndex: newIndex2 };
      this.emitChanges({ moved: moved2 });
    },
    computeFutureIndex(relatedContext, evt) {
      if (!relatedContext.element) {
        return 0;
      }
      const domChildren = [...evt.to.children].filter(
        (el) => el.style["display"] !== "none"
      );
      const currentDomIndex = domChildren.indexOf(evt.related);
      const currentIndex = relatedContext.component.getVmIndexFromDomIndex(
        currentDomIndex
      );
      const draggedInList = domChildren.indexOf(draggingElement) !== -1;
      return draggedInList || !evt.willInsertAfter ? currentIndex : currentIndex + 1;
    },
    onDragMove(evt, originalEvent) {
      const { move, realList } = this;
      if (!move || !realList) {
        return true;
      }
      const relatedContext = this.getRelatedContextFromMoveEvent(evt);
      const futureIndex = this.computeFutureIndex(relatedContext, evt);
      const draggedContext = {
        ...this.context,
        futureIndex
      };
      const sendEvent = {
        ...evt,
        relatedContext,
        draggedContext
      };
      return move(sendEvent, originalEvent);
    },
    onDragEnd() {
      draggingElement = null;
    }
  }
});
var layerList_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$r = defineComponent({
  components: { draggable: draggableComponent },
  props: ["data"],
  emits: ["change"],
  setup(props2, context) {
    let widgets = ref$1([]);
    const state = reactive$1({
      drag: false
    });
    const dragOptions = computed$1(() => {
      return {
        animation: 300,
        ghostClass: "ghost",
        chosenClass: "choose"
      };
    });
    const store = useStore();
    const showItem = (item) => {
      return state.drag === true && item.parent != "-1" ? false : true;
    };
    const getWidgets = () => {
      let widgets2 = [];
      let len = props2.data.length;
      const data = props2.data.slice(0);
      const childs = [];
      for (let i = len - 1; i >= 0; --i) {
        let widget = JSON.parse(JSON.stringify(data[i]));
        if (widget.parent != -1) {
          childs.unshift(widget);
        } else {
          widgets2.push(widget);
        }
      }
      for (const item of childs) {
        const index2 = widgets2.findIndex((x) => x.uuid === item.parent);
        widgets2.splice(index2 + 1, 0, item);
      }
      return widgets2;
    };
    const getIsActive = (uuid) => {
      if (store.getters.dSelectWidgets.length > 0) {
        let widget = store.getters.dSelectWidgets.find((item) => item.uuid === uuid);
        if (widget) {
          return true;
        }
        return false;
      } else {
        return uuid === store.getters.dActiveElement.uuid;
      }
    };
    const selectLayer = (widget) => {
      store.dispatch("selectWidget", { uuid: widget.uuid });
    };
    const hoverLayer = ({ uuid, parent }) => {
      store.dispatch("updateHoverUuid", uuid);
    };
    const onMove = ({ relatedContext, draggedContext }) => {
      const relatedElement = relatedContext.element;
      const draggedElement = draggedContext.element;
      return (!relatedElement || relatedElement.parent == -1) && draggedElement.parent == -1;
    };
    const onDone = () => {
      state.drag = false;
      context.emit("change", widgets.value);
    };
    const lockLayer = (item) => {
      store.dispatch("updateWidgetData", {
        uuid: item.uuid,
        key: "lock",
        value: typeof item.lock === "undefined" ? true : !item.lock,
        pushHistory: false
      });
    };
    return { lockLayer, onDone, onMove, selectLayer, hoverLayer, widgets, getWidgets, getIsActive, ...toRefs(state), dragOptions, showItem };
  },
  watch: {
    data: {
      async handler(nval) {
        this.widgets = this.getWidgets();
      },
      immediate: true,
      deep: true
    }
  }
});
const _hoisted_1$p = { class: "widget-list" };
const _hoisted_2$l = ["onClick", "onMouseover"];
const _hoisted_3$j = { class: "second-layer" };
const _hoisted_4$g = ["src"];
const _hoisted_5$e = ["src"];
const _hoisted_6$a = ["data-type", "data-uuid"];
const _hoisted_7$7 = ["onClick"];
function _sfc_render$n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_draggable = resolveComponent("draggable");
  return openBlock(), createElementBlock("ul", _hoisted_1$p, [
    createVNode(_component_draggable, mergeProps({
      modelValue: _ctx.widgets,
      "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.widgets = $event),
      group: "type",
      "item-key": "uuid"
    }, _ctx.dragOptions, {
      move: _ctx.onMove,
      onStart: _cache[2] || (_cache[2] = ($event) => _ctx.drag = true),
      onEnd: _ctx.onDone
    }), {
      item: withCtx(({ element }) => [
        createElementVNode("li", {
          class: normalizeClass(["widget", { active: _ctx.getIsActive(element.uuid), disable: !_ctx.showItem(element) }, "item-one"]),
          onClick: ($event) => _ctx.selectLayer(element),
          onMouseover: ($event) => _ctx.hoverLayer(element),
          onMouseout: _cache[0] || (_cache[0] = ($event) => _ctx.hoverLayer("-1"))
        }, [
          withDirectives(createElementVNode("span", _hoisted_3$j, null, 512), [
            [vShow, +element.parent !== -1]
          ]),
          element.imgUrl ? (openBlock(), createElementBlock("img", {
            key: 0,
            class: "widget-type widget-type__img",
            src: element.imgUrl
          }, null, 8, _hoisted_4$g)) : element.svgUrl ? (openBlock(), createElementBlock("img", {
            key: 1,
            class: "widget-type widget-type__img",
            src: element.svgUrl
          }, null, 8, _hoisted_5$e)) : (openBlock(), createElementBlock("span", {
            key: 2,
            class: normalizeClass(["widget-type icon", `sd-${element.type}`, element.type])
          }, null, 2)),
          createElementVNode("span", {
            class: normalizeClass(["widget-name", "line-clamp-1", `${element.type}`])
          }, toDisplayString(element.text || element.name) + " " + toDisplayString(element.mask ? "(\u5BB9\u5668)" : ""), 3),
          createElementVNode("div", {
            class: "widget-out",
            "data-type": element.type,
            "data-uuid": element.uuid
          }, [
            createElementVNode("i", {
              class: normalizeClass(["icon", element.lock ? "sd-suoding" : "sd-jiesuo"]),
              onClick: withModifiers(($event) => _ctx.lockLayer(element), ["stop"])
            }, null, 10, _hoisted_7$7)
          ], 8, _hoisted_6$a)
        ], 42, _hoisted_2$l)
      ]),
      _: 1
    }, 16, ["modelValue", "move", "onEnd"])
  ]);
}
var layerList = /* @__PURE__ */ _export_sfc(_sfc_main$r, [["render", _sfc_render$n], ["__scopeId", "data-v-4485592e"]]);
var __glob_0_14 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": layerList
}, Symbol.toStringTag, { value: "Module" }));
var iconItemSelect_vue_vue_type_style_index_0_scoped_true_lang = "";
var iconItemSelect_vue_vue_type_style_index_1_scoped_true_lang = "";
const NAME$d = "icon-item-select";
const _sfc_main$q = {
  name: NAME$d,
  props: {
    label: {
      default: ""
    },
    data: {
      required: true,
      type: Array
    }
  },
  emits: ["finish"],
  data() {
    return {};
  },
  methods: {
    selectItem(item) {
      if (typeof item.select !== "undefined") {
        item.select = !item.select;
      }
      this.$emit("finish", item);
    }
  }
};
const _hoisted_1$o = { class: "icon-item-select" };
const _hoisted_2$k = {
  key: 0,
  class: "label"
};
const _hoisted_3$i = { class: "list btn__bar flex" };
const _hoisted_4$f = ["onClick"];
function _sfc_render$m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tooltip = resolveComponent("el-tooltip");
  return openBlock(), createElementBlock("div", _hoisted_1$o, [
    $props.label ? (openBlock(), createElementBlock("span", _hoisted_2$k, toDisplayString($props.label), 1)) : createCommentVNode("", true),
    createElementVNode("ul", _hoisted_3$i, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($props.data, (item, index2) => {
        return openBlock(), createBlock(_component_el_tooltip, {
          key: index2,
          class: "item",
          effect: "dark",
          content: item.tip,
          placement: "top",
          "auto-close": 400
        }, {
          default: withCtx(() => [
            createElementVNode("li", {
              class: normalizeClass({ "list-item": true, active: item.select }),
              onClick: ($event) => $options.selectItem(item)
            }, [
              createElementVNode("i", {
                class: normalizeClass(`${item.extraIcon ? "icon" : "iconfont"} ${item.icon}`)
              }, null, 2)
            ], 10, _hoisted_4$f)
          ]),
          _: 2
        }, 1032, ["content"]);
      }), 128))
    ])
  ]);
}
var iconItemSelect = /* @__PURE__ */ _export_sfc(_sfc_main$q, [["render", _sfc_render$m], ["__scopeId", "data-v-03f362da"]]);
var __glob_0_7 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": iconItemSelect
}, Symbol.toStringTag, { value: "Module" }));
var numberInput_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$c = "number-input";
const _sfc_main$p = {
  name: NAME$c,
  props: {
    label: {
      default: ""
    },
    modelValue: {
      default: ""
    },
    editable: {
      default: true
    },
    step: {
      default: 1
    },
    maxValue: {},
    minValue: {},
    type: {},
    prepend: {}
  },
  emits: ["finish", "update:modelValue"],
  data() {
    return {
      inputBorder: false,
      tagText: "",
      showEdit: false
    };
  },
  computed: {},
  watch: {
    modelValue() {
      this.fixedNum();
    }
  },
  mounted() {
    this.fixedNum();
  },
  methods: {
    fixedNum() {
      const decimal = String(this.modelValue).split(".")[1];
      if (decimal && decimal.length > 2) {
        setTimeout(() => {
          this.updateValue(Number(this.modelValue).toFixed(2));
        }, 10);
      }
      if (this.maxValue && this.modelValue > this.maxValue) {
        setTimeout(() => {
          this.updateValue(Number(this.maxValue));
        }, 10);
      } else if (typeof this.minValue === "number" && this.modelValue < this.minValue) {
        setTimeout(() => {
          this.updateValue(Number(this.minValue));
        }, 10);
      }
    },
    updateValue(value) {
      this.$emit("update:modelValue", value === "-" ? "-" : Number(value));
    },
    up() {
      this.updateValue(parseInt(this.modelValue || 0, 10) + this.step);
    },
    down() {
      let value = parseInt(this.modelValue || 0, 10) - this.step;
      this.updateValue(value);
    },
    opNumber(e2) {
      e2.stopPropagation();
      switch (e2.keyCode) {
        case 38:
          this.up();
          return;
        case 40:
          this.down();
          return;
      }
    },
    verifyNumber() {
      let value = String(this.modelValue);
      let len = value.length;
      let newValue = "";
      let isNegative = value[0] === "-";
      for (let i = isNegative ? 1 : 0; i < len; ++i) {
        let c = value[i];
        if (c == "." || c >= "0" && c <= "9") {
          newValue += c;
        } else {
          break;
        }
      }
      if (newValue === "") {
        newValue = "0";
      }
      if (isNegative) {
        newValue = "-" + (newValue === "0" ? "" : newValue);
      }
      this.updateValue(newValue);
    },
    focusInput() {
      this.inputBorder = true;
      this.tagText = this.modelValue;
    },
    blurInput() {
      if (this.modelValue === "-") {
        this.updateValue(0);
      }
      this.inputBorder = false;
      if (this.modelValue !== this.tagText) {
        this.$emit("finish", this.modelValue);
      }
    }
  }
};
const _hoisted_1$n = { key: 0 };
const _hoisted_2$j = { class: "prepend" };
const _hoisted_3$h = ["value", "readonly"];
const _hoisted_4$e = {
  key: 1,
  class: "number-input2"
};
const _hoisted_5$d = ["value", "readonly"];
const _hoisted_6$9 = { style: { "color": "rgba(0, 0, 0, 0.45)" } };
function _sfc_render$l(_ctx, _cache, $props, $setup, $data, $options) {
  return $props.type === "simple" ? (openBlock(), createElementBlock("div", _hoisted_1$n, [
    createElementVNode("span", _hoisted_2$j, toDisplayString($props.prepend), 1),
    createElementVNode("input", {
      class: normalizeClass({ "small-input": true, disable: !$props.editable }),
      type: "text",
      value: $props.modelValue,
      readonly: $props.editable ? false : "readonly",
      onInput: _cache[0] || (_cache[0] = ($event) => $options.updateValue($event.target.value)),
      onFocus: _cache[1] || (_cache[1] = (...args) => $options.focusInput && $options.focusInput(...args)),
      onBlur: _cache[2] || (_cache[2] = (...args) => $options.blurInput && $options.blurInput(...args)),
      onKeyup: _cache[3] || (_cache[3] = (...args) => $options.verifyNumber && $options.verifyNumber(...args)),
      onKeydown: _cache[4] || (_cache[4] = (e2) => $options.opNumber(e2))
    }, null, 42, _hoisted_3$h)
  ])) : (openBlock(), createElementBlock("div", _hoisted_4$e, [
    createElementVNode("div", {
      class: "input-wrap",
      onClick: _cache[10] || (_cache[10] = (...args) => _ctx.edit && _ctx.edit(...args))
    }, [
      createElementVNode("input", {
        class: normalizeClass({ "real-input": true, disable: !$props.editable }),
        type: "text",
        value: $props.modelValue,
        readonly: $props.editable ? false : "readonly",
        onInput: _cache[5] || (_cache[5] = ($event) => $options.updateValue($event.target.value)),
        onFocus: _cache[6] || (_cache[6] = (...args) => $options.focusInput && $options.focusInput(...args)),
        onBlur: _cache[7] || (_cache[7] = (...args) => $options.blurInput && $options.blurInput(...args)),
        onKeyup: _cache[8] || (_cache[8] = (...args) => $options.verifyNumber && $options.verifyNumber(...args)),
        onKeydown: _cache[9] || (_cache[9] = (e2) => $options.opNumber(e2))
      }, null, 42, _hoisted_5$d)
    ]),
    createElementVNode("span", _hoisted_6$9, toDisplayString($props.label), 1)
  ]));
}
var numberInput = /* @__PURE__ */ _export_sfc(_sfc_main$p, [["render", _sfc_render$l], ["__scopeId", "data-v-07e3f696"]]);
var __glob_0_8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": numberInput
}, Symbol.toStringTag, { value: "Module" }));
var layerIconList = [
  {
    key: "zIndex",
    icon: "icon-layer-up",
    tip: "\u4E0A\u4E00\u5C42",
    value: 1
  },
  {
    key: "zIndex",
    icon: "icon-layer-down",
    tip: "\u4E0B\u4E00\u5C42",
    value: -1
  }
];
var wGroupStyle_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$b = "w-group-style";
const _sfc_main$o = {
  name: NAME$b,
  components: { numberInput, iconItemSelect, numberSlider },
  data() {
    return {
      activeNames: ["1", "2", "3", "4"],
      innerElement: {},
      tag: false,
      ingoreKeys: ["name", "width", "height"],
      layerIconList,
      alignIconList: alignIconList$1
    };
  },
  computed: {
    ...mapGetters(["dActiveElement"])
  },
  watch: {
    dActiveElement: {
      handler(newValue, oldValue) {
        this.change();
      },
      deep: true
    },
    innerElement: {
      handler(newValue, oldValue) {
        this.changeValue();
      },
      deep: true
    }
  },
  created() {
    this.change();
  },
  methods: {
    ...mapActions(["updateWidgetData", "updateAlign", "updateLayerIndex", "ungroup"]),
    change() {
      this.tag = true;
      this.innerElement = JSON.parse(JSON.stringify(this.dActiveElement));
    },
    changeValue() {
      if (this.tag) {
        this.tag = false;
        return;
      }
      if (this.dMoving) {
        return;
      }
      for (let key in this.innerElement) {
        if (this.ingoreKeys.indexOf(key) !== -1) {
          this.dActiveElement[key] = this.innerElement[key];
        } else if (key !== "setting" && key !== "record" && this.innerElement[key] !== this.dActiveElement[key]) {
          this.updateWidgetData({
            uuid: this.dActiveElement.uuid,
            key,
            value: this.innerElement[key]
          });
        }
      }
    },
    finish(key, value) {
      this.updateWidgetData({
        uuid: this.dActiveElement.uuid,
        key,
        value,
        pushHistory: true
      });
    },
    layerAction(item) {
      this.updateLayerIndex({
        uuid: this.dActiveElement.uuid,
        value: item.value,
        isGroup: true
      });
    },
    alignAction(item) {
      this.updateAlign({
        align: item.value,
        uuid: this.dActiveElement.uuid
      });
    }
  }
};
const _withScopeId$a = (n) => (pushScopeId("data-v-c85f74f2"), n = n(), popScopeId(), n);
const _hoisted_1$m = { id: "w-group-style" };
const _hoisted_2$i = { class: "line-layout" };
const _hoisted_3$g = /* @__PURE__ */ _withScopeId$a(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_number_input = resolveComponent("number-input");
  const _component_el_collapse_item = resolveComponent("el-collapse-item");
  const _component_el_button = resolveComponent("el-button");
  const _component_number_slider = resolveComponent("number-slider");
  const _component_icon_item_select = resolveComponent("icon-item-select");
  const _component_el_collapse = resolveComponent("el-collapse");
  return openBlock(), createElementBlock("div", _hoisted_1$m, [
    createVNode(_component_el_collapse, {
      modelValue: $data.activeNames,
      "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => $data.activeNames = $event)
    }, {
      default: withCtx(() => [
        createVNode(_component_el_collapse_item, {
          title: "\u4F4D\u7F6E\u5C3A\u5BF8",
          name: "1"
        }, {
          default: withCtx(() => [
            createElementVNode("div", _hoisted_2$i, [
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.left,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.innerElement.left = $event),
                label: "X",
                onFinish: _cache[1] || (_cache[1] = (value) => $options.finish("left", value))
              }, null, 8, ["modelValue"]),
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.top,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.innerElement.top = $event),
                label: "Y",
                onFinish: _cache[3] || (_cache[3] = (value) => $options.finish("top", value))
              }, null, 8, ["modelValue"]),
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.width,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $data.innerElement.width = $event),
                style: { "margin-top": "0.5rem" },
                label: "\u5BBD",
                onFinish: _cache[5] || (_cache[5] = (value) => $options.finish("width", value))
              }, null, 8, ["modelValue"]),
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.height,
                "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $data.innerElement.height = $event),
                style: { "margin-top": "0.5rem" },
                label: "\u9AD8",
                onFinish: _cache[7] || (_cache[7] = (value) => $options.finish("height", value))
              }, null, 8, ["modelValue"])
            ])
          ]),
          _: 1
        }),
        createVNode(_component_el_collapse_item, {
          title: "\u6837\u5F0F\u8BBE\u7F6E",
          name: "2"
        }, {
          default: withCtx(() => [
            createVNode(_component_el_button, {
              plain: "",
              type: "primary",
              class: "block-btn",
              onClick: _cache[8] || (_cache[8] = ($event) => _ctx.ungroup($data.innerElement.uuid))
            }, {
              default: withCtx(() => [
                createTextVNode("\u53D6\u6D88\u7EC4\u5408")
              ]),
              _: 1
            }),
            createVNode(_component_number_slider, {
              modelValue: $data.innerElement.opacity,
              "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => $data.innerElement.opacity = $event),
              class: "style-item",
              label: "\u4E0D\u900F\u660E",
              step: 0.05,
              maxValue: 1,
              onFinish: _cache[10] || (_cache[10] = (value) => $options.finish("opacity", value))
            }, null, 8, ["modelValue"]),
            _hoisted_3$g,
            createVNode(_component_icon_item_select, {
              class: "style-item",
              label: "",
              data: $data.layerIconList,
              onFinish: $options.layerAction
            }, null, 8, ["data", "onFinish"]),
            createVNode(_component_icon_item_select, {
              label: "",
              data: $data.alignIconList,
              onFinish: $options.alignAction
            }, null, 8, ["data", "onFinish"])
          ]),
          _: 1
        })
      ]),
      _: 1
    }, 8, ["modelValue"])
  ]);
}
var wGroupStyle = /* @__PURE__ */ _export_sfc(_sfc_main$o, [["render", _sfc_render$k], ["__scopeId", "data-v-c85f74f2"]]);
var __glob_0_26 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": wGroupStyle
}, Symbol.toStringTag, { value: "Module" }));
var index_vue_vue_type_style_index_0_scoped_true_lang$1 = "";
const _sfc_main$n = defineComponent({
  components: { [ElTabPane.name]: ElTabPane, [ElTabs.name]: ElTabs },
  emits: ["select"],
  setup(props2, context) {
    const store = useStore();
    const state = reactive$1({
      dialogVisible: false,
      imgList: [],
      recommendImgList: [],
      isDone: false,
      isPicsDone: false
    });
    let loading = false;
    let page = 0;
    let picPage = 0;
    const load = (init2) => {
      if (init2) {
        state.imgList = [];
        page = 0;
        state.isDone = false;
      }
      if (state.isDone || loading) {
        return;
      }
      loading = true;
      page += 1;
      api$1.material.getMyPhoto({ page }).then(({ list }) => {
        list.length <= 0 ? state.isDone = true : state.imgList = state.imgList.concat(list);
        setTimeout(() => {
          loading = false;
        }, 100);
      });
    };
    const loadPic = (init2) => {
      if (state.isPicsDone || loading) {
        return;
      }
      if (init2 && state.recommendImgList.length > 0) {
        return;
      }
      loading = true;
      picPage += 1;
      api$1.material.getImagesList({ page: picPage }).then(({ list }) => {
        list.length <= 0 ? state.isPicsDone = true : state.recommendImgList = state.recommendImgList.concat(list);
        setTimeout(() => {
          loading = false;
        }, 100);
      });
    };
    const open = () => {
      state.dialogVisible = true;
      load();
      store.commit("setShowMoveable", false);
    };
    const close = () => {
      store.commit("setShowMoveable", true);
    };
    const selectImg = (index2, list) => {
      const item = list ? list[index2] : state.imgList[index2];
      context.emit("select", item);
      state.dialogVisible = false;
    };
    const tabChange = (index2) => {
      if (index2 == 1) {
        loadPic(true);
      }
    };
    return {
      ...toRefs(state),
      open,
      close,
      load,
      loadPic,
      selectImg,
      tabChange
    };
  }
});
const _hoisted_1$l = { class: "pic__box" };
const _hoisted_2$h = { class: "pic__box" };
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_photo_list = resolveComponent("photo-list");
  const _component_el_tab_pane = resolveComponent("el-tab-pane");
  const _component_el_tabs = resolveComponent("el-tabs");
  const _component_el_dialog = resolveComponent("el-dialog");
  return openBlock(), createBlock(_component_el_dialog, {
    modelValue: _ctx.dialogVisible,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.dialogVisible = $event),
    title: "\u9009\u62E9\u56FE\u7247",
    onClose: _ctx.close
  }, {
    default: withCtx(() => [
      createVNode(_component_el_tabs, {
        "tab-position": "left",
        style: { "height": "60vh" },
        class: "demo-tabs",
        onTabChange: _ctx.tabChange
      }, {
        default: withCtx(() => [
          createVNode(_component_el_tab_pane, { label: "\u6211\u7684\u7D20\u6750" }, {
            default: withCtx(() => [
              createElementVNode("div", _hoisted_1$l, [
                createVNode(_component_photo_list, {
                  isDone: _ctx.isDone,
                  listData: _ctx.imgList,
                  onLoad: _ctx.load,
                  onSelect: _ctx.selectImg
                }, null, 8, ["isDone", "listData", "onLoad", "onSelect"])
              ])
            ]),
            _: 1
          }),
          createVNode(_component_el_tab_pane, { label: "\u7167\u7247\u56FE\u5E93" }, {
            default: withCtx(() => [
              createElementVNode("div", _hoisted_2$h, [
                createVNode(_component_photo_list, {
                  isDone: _ctx.isPicsDone,
                  listData: _ctx.recommendImgList,
                  onLoad: _ctx.loadPic,
                  onSelect: _cache[0] || (_cache[0] = ($event) => _ctx.selectImg($event, _ctx.recommendImgList))
                }, null, 8, ["isDone", "listData", "onLoad"])
              ])
            ]),
            _: 1
          })
        ]),
        _: 1
      }, 8, ["onTabChange"])
    ]),
    _: 1
  }, 8, ["modelValue", "onClose"]);
}
var index$1 = /* @__PURE__ */ _export_sfc(_sfc_main$n, [["render", _sfc_render$j], ["__scopeId", "data-v-1871779a"]]);
var wImageStyle_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$a = "w-image-style";
const _sfc_main$m = {
  name: NAME$a,
  components: { numberInput, numberSlider, iconItemSelect, picBox: index$1, imageCutout: index$3 },
  data() {
    return {
      picBoxShow: false,
      activeNames: ["2", "3", "4"],
      innerElement: {},
      tag: false,
      ingoreKeys: ["left", "top", "name", "width", "height", "radiusTopLeft", "radiusTopRight", "radiusBottomLeft", "radiusBottomRight"],
      layerIconList: layerIconList.concat([
        {
          key: "flip",
          icon: "sd-zuoyoufanzhuan",
          extraIcon: true,
          tip: "\u6C34\u5E73\u7FFB\u8F6C",
          value: "Y"
        },
        {
          key: "flip",
          icon: "sd-shangxiafanzhuan",
          extraIcon: true,
          tip: "\u5782\u76F4\u7FFB\u8F6C",
          value: "X"
        }
      ]),
      alignIconList: alignIconList$1,
      toolBarStyle: {}
    };
  },
  computed: {
    ...mapGetters(["dActiveElement", "dMoving", "dWidgets"])
  },
  watch: {
    dActiveElement: {
      handler(newValue, oldValue) {
        this.change();
        if (newValue.uuid != this.lastUuid && typeof this.lastUuid !== "undefined") {
          this.innerElement.cropEdit = false;
          this.$store.commit("setShowRotatable", true);
        }
        this.lastUuid = newValue.uuid;
      },
      deep: true
    },
    innerElement: {
      handler(newValue, oldValue) {
        this.changeValue();
        this.cropHandle();
      },
      deep: true
    }
  },
  created() {
    this.change();
  },
  methods: {
    ...mapActions(["updateWidgetData", "updateAlign", "updateLayerIndex", "addWidget"]),
    change() {
      this.tag = true;
      this.innerElement = JSON.parse(JSON.stringify({ ...this.innerElement, ...this.dActiveElement }));
    },
    changeValue() {
      if (this.tag) {
        this.tag = false;
        return;
      }
      if (this.dMoving) {
        return;
      }
      for (let key in this.innerElement) {
        if (this.ingoreKeys.indexOf(key) !== -1) {
          this.dActiveElement[key] = this.innerElement[key];
        } else if (key !== "cropEdit" && key !== "record" && this.innerElement[key] !== this.dActiveElement[key]) {
          this.updateWidgetData({
            uuid: this.dActiveElement.uuid,
            key,
            value: this.innerElement[key]
          });
        }
      }
    },
    finishSliceData(key, value) {
      const data = this.dActiveElement.sliceData;
      if (data) {
        data[key] = value;
        this.updateWidgetData({
          uuid: this.dActiveElement.uuid,
          key: "sliceData",
          value: data,
          pushHistory: true
        });
      }
    },
    finish(key, value) {
      this.updateWidgetData({
        uuid: this.dActiveElement.uuid,
        key,
        value,
        pushHistory: true
      });
    },
    layerAction(item) {
      if (item.key === "zIndex") {
        this.updateLayerIndex({
          uuid: this.dActiveElement.uuid,
          value: item.value
        });
      } else {
        this.finish(item.key, item.value === this.dActiveElement.flip ? null : item.value);
      }
    },
    async alignAction(item) {
      this.updateAlign({
        align: item.value,
        uuid: this.dActiveElement.uuid
      });
      await this.$nextTick();
      this.$store.commit("updateRect");
    },
    openCropper() {
      this.$refs.crop.open(this.innerElement, this.innerElement.cropData);
    },
    cropDone({ newImg, data, width, height }) {
      this.innerElement.imgUrl = newImg;
      this.innerElement.cropData = data;
      this.innerElement.width = width.toFixed(0);
      this.innerElement.height = height.toFixed(0);
    },
    async changeContainer(setting) {
      const index2 = this.dWidgets.findIndex((x) => x.uuid == this.innerElement.uuid);
      const img = await getImage(setting.svgUrl);
      setting.width = this.innerElement.width;
      setting.height = img.height * (this.innerElement.width / img.width);
      setting.left = this.innerElement.left;
      setting.top = this.innerElement.top;
      setting.imgUrl = this.innerElement.imgUrl;
      this.dWidgets.splice(index2, 1);
      this.addWidget(setting);
    },
    async uploadImgDone(img) {
      this.$store.commit("setShowMoveable", false);
      await api$1.material.addMyPhoto(img);
      this.innerElement.height = img.height * (this.innerElement.width / img.width);
      this.innerElement.imgUrl = img.url;
      this.$store.commit("setShowMoveable", true);
    },
    selectDone(img) {
      this.innerElement.imgUrl = img.url;
    },
    imgCrop(val) {
      const { left, top } = document.getElementById(this.innerElement.uuid).getBoundingClientRect();
      this.toolBarStyle = { left: left + "px", top: top + "px" };
      this.innerElement.cropEdit = val;
      this.$store.commit("setShowRotatable", !val);
    },
    cropHandle() {
      this.$store.commit("setCropUuid", this.innerElement.cropEdit ? this.innerElement.uuid : -1);
    },
    openPicBox() {
      this.$refs.picBox.open();
    },
    openImageCutout() {
      fetch(this.innerElement.imgUrl).then((response) => response.blob()).then((blob) => {
        const file = new File([blob], `image_${Math.random()}.jpg`, { type: "image/jpeg" });
        this.$refs.imageCutout.open(file);
      }).catch((error) => {
        console.error("\u83B7\u53D6\u56FE\u7247\u5931\u8D25:", error);
      });
    },
    async cutImageDone(url) {
      setTimeout(() => {
        this.innerElement.imgUrl = url;
      }, 300);
    }
  }
};
const _withScopeId$9 = (n) => (pushScopeId("data-v-df3e1d04"), n = n(), popScopeId(), n);
const _hoisted_1$k = { id: "w-image-style" };
const _hoisted_2$g = { class: "line-layout" };
const _hoisted_3$f = { class: "options" };
const _hoisted_4$d = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createElementVNode("i", { class: "icon sd-caijian" }, null, -1));
const _hoisted_5$c = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createElementVNode("i", { class: "icon sd-AIkoutu" }, null, -1));
const _hoisted_6$8 = { class: "slide-wrap" };
const _hoisted_7$6 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
const _hoisted_8$5 = /* @__PURE__ */ _withScopeId$9(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_number_input = resolveComponent("number-input");
  const _component_el_collapse_item = resolveComponent("el-collapse-item");
  const _component_el_button = resolveComponent("el-button");
  const _component_number_slider = resolveComponent("number-slider");
  const _component_icon_item_select = resolveComponent("icon-item-select");
  const _component_el_collapse = resolveComponent("el-collapse");
  const _component_inner_tool_bar = resolveComponent("inner-tool-bar");
  const _component_picBox = resolveComponent("picBox");
  const _component_imageCutout = resolveComponent("imageCutout");
  return openBlock(), createElementBlock("div", _hoisted_1$k, [
    createVNode(_component_el_collapse, {
      modelValue: $data.activeNames,
      "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => $data.activeNames = $event)
    }, {
      default: withCtx(() => [
        createVNode(_component_el_collapse_item, {
          title: "\u4F4D\u7F6E\u5C3A\u5BF8",
          name: "1"
        }, {
          default: withCtx(() => [
            createElementVNode("div", _hoisted_2$g, [
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.left,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.innerElement.left = $event),
                label: "X",
                onFinish: _cache[1] || (_cache[1] = (value) => $options.finish("left", value))
              }, null, 8, ["modelValue"]),
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.top,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.innerElement.top = $event),
                label: "Y",
                onFinish: _cache[3] || (_cache[3] = (value) => $options.finish("top", value))
              }, null, 8, ["modelValue"]),
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.width,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $data.innerElement.width = $event),
                style: { "margin-top": "0.5rem" },
                label: "\u5BBD",
                onFinish: _cache[5] || (_cache[5] = (value) => $options.finish("width", value))
              }, null, 8, ["modelValue"]),
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.height,
                "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $data.innerElement.height = $event),
                style: { "margin-top": "0.5rem" },
                label: "\u9AD8",
                onFinish: _cache[7] || (_cache[7] = (value) => $options.finish("height", value))
              }, null, 8, ["modelValue"])
            ])
          ]),
          _: 1
        }),
        createVNode(_component_el_collapse_item, {
          title: "\u8BBE\u7F6E",
          name: "2"
        }, {
          default: withCtx(() => [
            createVNode(_component_el_button, {
              style: { "width": "100%", "margin-bottom": "12px" },
              plain: "",
              onClick: $options.openPicBox
            }, {
              default: withCtx(() => [
                createTextVNode("\u66FF\u6362\u56FE\u7247")
              ]),
              _: 1
            }, 8, ["onClick"]),
            createElementVNode("div", _hoisted_3$f, [
              $data.innerElement.cropEdit ? (openBlock(), createBlock(_component_el_button, {
                key: 0,
                plain: "",
                type: "primary",
                onClick: _cache[8] || (_cache[8] = ($event) => $options.imgCrop(false))
              }, {
                default: withCtx(() => [
                  createTextVNode("\u5B8C\u6210")
                ]),
                _: 1
              })) : (openBlock(), createBlock(_component_el_button, {
                key: 1,
                plain: "",
                type: "primary",
                onClick: _cache[9] || (_cache[9] = ($event) => $options.imgCrop(true))
              }, {
                default: withCtx(() => [
                  _hoisted_4$d,
                  createTextVNode(" \u88C1\u526A")
                ]),
                _: 1
              })),
              createVNode(_component_el_button, {
                plain: "",
                onClick: $options.openImageCutout
              }, {
                default: withCtx(() => [
                  _hoisted_5$c,
                  createTextVNode(" \u62A0\u56FE")
                ]),
                _: 1
              }, 8, ["onClick"]),
              createVNode(_component_el_button, {
                size: "small",
                disabled: "",
                plain: "",
                onClick: $options.openCropper
              }, {
                default: withCtx(() => [
                  createTextVNode("\u7F8E\u5316")
                ]),
                _: 1
              }, 8, ["onClick"])
            ]),
            createElementVNode("div", _hoisted_6$8, [
              createVNode(_component_number_slider, {
                modelValue: $data.innerElement.opacity,
                "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => $data.innerElement.opacity = $event),
                style: { "font-size": "14px" },
                label: "\u4E0D\u900F\u660E",
                step: 0.05,
                maxValue: 1,
                onFinish: _cache[11] || (_cache[11] = (value) => $options.finish("opacity", value))
              }, null, 8, ["modelValue"]),
              createVNode(_component_number_slider, {
                modelValue: $data.innerElement.radius,
                "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => $data.innerElement.radius = $event),
                style: { "font-size": "14px" },
                label: "\u5706\u89D2",
                maxValue: Math.min($data.innerElement.record.width, $data.innerElement.record.height),
                onFinish: _cache[13] || (_cache[13] = (value) => $options.finish("radius", value))
              }, null, 8, ["modelValue", "maxValue"])
            ])
          ]),
          _: 1
        }),
        $data.innerElement.isNinePatch ? (openBlock(), createBlock(_component_el_collapse_item, {
          key: 0,
          title: "\u70B9\u4E5D\u56FE\u8BBE\u7F6E",
          name: "3"
        }, {
          default: withCtx(() => [
            createVNode(_component_number_slider, {
              modelValue: $data.innerElement.sliceData.ratio,
              "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => $data.innerElement.sliceData.ratio = $event),
              step: 0.01,
              label: "\u6BD4\u7387",
              maxValue: 10,
              onFinish: _cache[15] || (_cache[15] = (value) => $options.finishSliceData("ratio", value))
            }, null, 8, ["modelValue"]),
            createVNode(_component_number_slider, {
              modelValue: $data.innerElement.sliceData.left,
              "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => $data.innerElement.sliceData.left = $event),
              step: 0.5,
              label: "\u5927\u5C0F",
              onFinish: _cache[17] || (_cache[17] = (value) => $options.finishSliceData("left", value))
            }, null, 8, ["modelValue"])
          ]),
          _: 1
        })) : createCommentVNode("", true),
        _hoisted_7$6,
        createVNode(_component_icon_item_select, {
          class: "style-item",
          label: "",
          data: $data.layerIconList,
          onFinish: $options.layerAction
        }, null, 8, ["data", "onFinish"]),
        createVNode(_component_icon_item_select, {
          data: $data.alignIconList,
          onFinish: $options.alignAction
        }, null, 8, ["data", "onFinish"]),
        _hoisted_8$5
      ]),
      _: 1
    }, 8, ["modelValue"]),
    withDirectives(createVNode(_component_inner_tool_bar, {
      style: normalizeStyle($data.toolBarStyle)
    }, {
      default: withCtx(() => [
        createVNode(_component_number_slider, {
          modelValue: $data.innerElement.zoom,
          "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => $data.innerElement.zoom = $event),
          class: "inner-bar",
          label: "\u7F29\u653E",
          labelWidth: "40px",
          step: 0.01,
          minValue: 1,
          maxValue: 3
        }, null, 8, ["modelValue"]),
        createElementVNode("i", {
          style: { "padding": "0 8px", "cursor": "pointer" },
          class: "icon sd-queren",
          onClick: _cache[20] || (_cache[20] = ($event) => $options.imgCrop(false))
        })
      ]),
      _: 1
    }, 8, ["style"]), [
      [vShow, $data.innerElement.cropEdit]
    ]),
    createVNode(_component_picBox, {
      ref: "picBox",
      onSelect: $options.selectDone
    }, null, 8, ["onSelect"]),
    createVNode(_component_imageCutout, {
      ref: "imageCutout",
      onDone: $options.cutImageDone
    }, null, 8, ["onDone"])
  ]);
}
var wImageStyle = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$i], ["__scopeId", "data-v-df3e1d04"]]);
var __glob_0_28 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": wImageStyle
}, Symbol.toStringTag, { value: "Module" }));
var elTag = "";
var elOption = "";
var elOptionGroup = "";
var elSelect = "";
var textInputArea_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$9 = "text-input-area";
const _sfc_main$l = {
  name: NAME$9,
  props: {
    label: {
      default: ""
    },
    modelValue: {
      default: ""
    },
    editable: {
      default: true
    },
    max: {}
  },
  emits: ["update:modelValue", "finish"],
  data() {
    return {
      inputBorder: false,
      tagText: ""
    };
  },
  computed: {
    dealValue() {
      return this.modelValue;
    }
  },
  methods: {
    updateValue(value) {
      this.$emit("update:modelValue", this.getValue(value));
    },
    focusInput() {
      this.inputBorder = true;
      this.tagText = this.modelValue;
    },
    blurInput() {
      this.inputBorder = false;
      let v = this.getValue(this.modelValue);
      if (v !== this.tagText) {
        this.$emit("finish", v);
      }
    },
    getValue(value) {
      return value.replace(/\n|\r\n/g, "<br/>").replace(/ /g, "&nbsp;");
    }
  }
};
const _hoisted_1$j = { id: "text-input-area" };
const _hoisted_2$f = {
  key: 0,
  class: "input-label"
};
const _hoisted_3$e = ["maxlength", "value", "readonly"];
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$j, [
    $props.label ? (openBlock(), createElementBlock("p", _hoisted_2$f, toDisplayString($props.label), 1)) : createCommentVNode("", true),
    createElementVNode("div", {
      class: normalizeClass({ "input-wrap": true, active: $data.inputBorder })
    }, [
      createElementVNode("textarea", {
        maxlength: $props.max,
        class: normalizeClass({ "real-input": true, disable: !$props.editable }),
        type: "text",
        rows: "3",
        value: $options.dealValue,
        readonly: $props.editable ? false : "readonly",
        onInput: _cache[0] || (_cache[0] = ($event) => $options.updateValue($event.target.value)),
        onFocus: _cache[1] || (_cache[1] = (...args) => $options.focusInput && $options.focusInput(...args)),
        onBlur: _cache[2] || (_cache[2] = (...args) => $options.blurInput && $options.blurInput(...args))
      }, null, 42, _hoisted_3$e)
    ], 2)
  ]);
}
var textInputArea = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$h], ["__scopeId", "data-v-16b235d8"]]);
var __glob_0_11 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": textInputArea
}, Symbol.toStringTag, { value: "Module" }));
const $ = (n, { decimal: e2 = 0 } = {}) => e2 > 0 ? Number(n.toFixed(e2)) : Math.round(n), j = (n, { onmousedown: e2, onmousemove: t, onmouseup: a2 } = {}) => {
  let o = n.getBoundingClientRect();
  const r = { x: 0, y: 0 }, i = (n2) => {
    let e3 = n2.pageX - o.x, t2 = n2.pageY - o.y;
    e3 < 0 && (e3 = 0), e3 > o.width && (e3 = o.width), t2 < 0 && (t2 = 0), t2 > o.height && (t2 = o.height), r.x = $(e3 / o.width, { decimal: 2 }), r.y = $(t2 / o.height, { decimal: 2 });
  }, l = (n2) => {
    i(n2), t && t(r, n2);
  }, s = (n2) => {
    document.removeEventListener("mousemove", l), document.removeEventListener("mouseup", s), a2 && a2(r, n2);
  }, d = (t2) => {
    o = n.getBoundingClientRect(), i(t2), document.addEventListener("mousemove", l), document.addEventListener("mouseup", s), e2 && e2(r, t2);
  };
  return n.addEventListener("mousedown", d), { destroy() {
    n.removeEventListener("mousedown", d);
  } };
}, E = (n, e2, t) => {
  let a2 = Math.round(n).toString(16), o = Math.round(e2).toString(16), r = Math.round(t).toString(16);
  return 1 === a2.length && (a2 = "0" + a2), 1 === o.length && (o = "0" + o), 1 === r.length && (r = "0" + r), "#" + a2 + o + r;
}, T = (n, e2, t, a2 = 1) => {
  const o = E(n, e2, t);
  let r = Math.round(255 * a2).toString(16);
  return 1 === r.length && (r = "0" + r), o + r;
}, I = (n, e2, t) => {
  n /= 255, e2 /= 255, t /= 255;
  const a2 = Math.min(n, e2, t), o = Math.max(n, e2, t), r = o - a2;
  let i = 0, l = 0;
  if (0 === r)
    i = l = 0;
  else {
    l = r / o;
    const a3 = ((o - n) / 6 + r / 2) / r, s = ((o - e2) / 6 + r / 2) / r, d = ((o - t) / 6 + r / 2) / r;
    n === o ? i = d - s : e2 === o ? i = 1 / 3 + a3 - d : t === o && (i = 2 / 3 + s - a3), i < 0 ? i += 1 : i > 1 && (i -= 1);
  }
  return [360 * i, 100 * l, 100 * o];
};
const N = (n, e2, t) => {
  const [a2, o, r] = function(n2, e3, t2) {
    n2 = n2 / 360 * 6, e3 /= 100, t2 /= 100;
    const a3 = Math.floor(n2), o2 = n2 - a3, r2 = t2 * (1 - e3), i = t2 * (1 - o2 * e3), l = t2 * (1 - (1 - o2) * e3), s = a3 % 6, d = [t2, i, r2, r2, l, t2][s], u2 = [l, t2, t2, i, r2, r2][s], c = [r2, r2, l, t2, t2, i][s];
    return [Math.round(255 * d), Math.round(255 * u2), Math.round(255 * c)];
  }(n, e2, t);
  return E(a2, o, r);
}, R = (n) => {
  let e2 = 0, t = 0, a2 = 0;
  return 4 == (n = n.slice(0, 7)).length ? (e2 = Number("0x" + n[1] + n[1]), t = Number("0x" + n[2] + n[2]), a2 = Number("0x" + n[3] + n[3])) : 7 == n.length && (e2 = Number("0x" + n[1] + n[2]), t = Number("0x" + n[3] + n[4]), a2 = Number("0x" + n[5] + n[6])), [e2, t, a2];
}, L = (n) => {
  const e2 = R(n), t = Number("0x" + n[7] + n[8]);
  return [...e2, Number((t / 255).toFixed(2))];
}, P = (n) => {
  const [e2, t, a2, o] = L(n);
  return ((n2, e3, t2, a3 = 1) => [...I(n2, e3, t2), a3])(e2, t, a2, o);
}, F = (n) => n.startsWith("#") ? "\u7EAF\u8272" : n.startsWith("linear-gradient") ? "\u6E10\u53D8" : "\u56FE\u6848", H = (n, e2) => {
  const t = [];
  return e2.forEach((n2) => {
    t.push(`${n2.color} ${100 * n2.offset}%`);
  }), `linear-gradient(${n}deg, ${t.join(",")})`;
};
function U(n) {
  const e2 = function(n2, e3 = true) {
    const t = document.createElement("div");
    return t.id = "color-pipette-tooltip-container", t.innerHTML = n2, t.style = `
    position: fixed;
    left: 50%;
    top: 9%;
    z-index: 10002;
    display: ${e3 ? "flex" : "none"};
    align-items: center;
    background-color: rgba(0,0,0,0.4);
    padding: 6px 12px;
    border-radius: 4px;
    color: #fff;
    font-size: 18px;
    pointer-events: none;
  `, t;
  }(n);
  document.body.appendChild(e2), setTimeout(() => {
    var n2;
    return null === (n2 = null == e2 ? void 0 : e2.parentNode) || void 0 === n2 ? void 0 : n2.removeChild(e2);
  }, 2e3);
}
const B = { class: "my-tabs" }, O = { class: "my-tabs__header p-0.5 mb-3 rounded bg-gray-100 cursor-pointers" }, D = { class: "my-tabs__header-shell relative flex justify-between" }, V = ["onClick"], X = { class: "my-tabs__content" }, Y = { name: "Tabs" };
var G = Object.assign(Y, { props: { value: { type: String, required: true } }, emits: ["update:value", "change"], setup(g, { expose: h2, emit: v }) {
  const b = g;
  watch(() => b.value, () => {
    _();
  });
  const m = ref$1([]), w = reactive$1({ width: 0, left: 0 });
  let x = 0;
  onMounted(() => {
    x = 100 / m.value.length, w.width = `${x}%`, _();
  });
  let y = null;
  async function _(n = -1) {
    var _a2, _b, _c, _d;
    n < 0 && (n = m.value.findIndex((n2) => n2.props.label === b.value)), w.left = x * n + "%";
    try {
      await nextTick(), (_b = (_a2 = y == null ? void 0 : y.exposed) == null ? void 0 : _a2.changeActive) == null ? void 0 : _b.call(_a2, false), y = m.value[n], (_d = (_c = y.exposed) == null ? void 0 : _c.changeActive) == null ? void 0 : _d.call(_c, true);
    } catch (n2) {
    }
  }
  return h2({ tabs: m }), (n, e2) => (openBlock(), createElementBlock("div", B, [createElementVNode("div", O, [createElementVNode("div", D, [(openBlock(true), createElementBlock(Fragment, null, renderList(m.value, (n2, e3) => (openBlock(), createElementBlock("div", { key: n2.props.label, class: normalizeClass(["my-tab__title relative flex-auto py-1 text-center", { "my-active": n2.props.label === g.value }]), onClick: (t) => function(n3, e4) {
    v("update:value", n3.props.label), _(e4);
  }(n2, e3) }, toDisplayString(n2.props.label), 11, V))), 128)), createElementVNode("div", { class: "my-tab__slider", style: normalizeStyle(w) }, null, 4)])]), createElementVNode("div", X, [renderSlot(n.$slots, "default")])]));
} });
function W(n, e2) {
  void 0 === e2 && (e2 = {});
  var t = e2.insertAt;
  if (n && "undefined" != typeof document) {
    var a2 = document.head || document.getElementsByTagName("head")[0], o = document.createElement("style");
    o.type = "text/css", "top" === t && a2.firstChild ? a2.insertBefore(o, a2.firstChild) : a2.appendChild(o), o.styleSheet ? o.styleSheet.cssText = n : o.appendChild(document.createTextNode(n));
  }
}
W("\n.my-tabs__header[data-v-1f94052c] {\n  margin-bottom: 0.75rem;\n  border-radius: 0.25rem;\n  --tw-bg-opacity: 1;\n  background-color: rgb(243 244 246 / var(--tw-bg-opacity));\n  padding: 0px;\n  padding: 0.125rem;\n}\n.my-tabs__header-shell[data-v-1f94052c] {\n  justify-content: space-between;\n  position: relative;\n  display: flex;\n}\n.my-tab__title[data-v-1f94052c] {\n  text-align: center;\n  position: relative;\n  flex: 1 1 auto;\n  padding-top: 0.25rem;\n  padding-bottom: 0.25rem;\n  z-index: 1;\n}\n.my-tab__title.my-active[data-v-1f94052c] {\n  font-weight: bold;\n}\n.my-tab__slider[data-v-1f94052c] {\n  position: absolute;\n  bottom: 0px;\n  top: 0px;\n  border-radius: 0.25rem;\n  --tw-bg-opacity: 1;\n  background-color: rgb(255 255 255 / var(--tw-bg-opacity));\n  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);\n  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n  transition-property: all;\n  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);\n  transition-duration: 150ms;\n  transition-duration: 150ms;\n}\n"), G.__scopeId = "data-v-1f94052c", G.__file = "packages/color-picker/comps/Tabs.vue";
var q = defineComponent({ setup() {
} });
const K = { t: "1685345224620", class: "sd-xggj", viewBox: "0 0 1024 1024", version: "1.1", xmlns: "http://www.w3.org/2000/svg", "p-id": "8489", width: "20", height: "20" }, J = [createElementVNode("path", { d: "M716.288 140.501333a42.666667 42.666667 0 0 1 60.373333 0l90.496 90.496a42.666667 42.666667 0 0 1 0 60.330667l-120.661333 120.704L595.626667 261.12l120.661333-120.661333zM520.192 185.770667l301.696 301.653333-60.330667 60.373333-301.653333-301.696 60.288-60.330666z", "p-id": "8490" }, null, -1), createElementVNode("path", { d: "M580.565333 366.762667l-60.373333-60.330667-362.026667 362.026667V853.333333l181.034667-3.84 362.026667-362.026666-60.330667-60.373334-331.861333 331.904-60.373334-60.373333 331.904-331.861333z", "p-id": "8491" }, null, -1)];
q.render = function(n, e2, t, a2, o, l) {
  return openBlock(), createElementBlock("svg", K, J);
}, q.__file = "packages/color-picker/comps/svg.vue";
const Q = { name: "TabPanel" };
var Z = Object.assign(Q, { props: { label: { type: String, required: true } }, setup(n, { expose: t }) {
  const a2 = getCurrentInstance();
  a2.parent.exposed.tabs.value.push(a2);
  const o = ref$1(false), l = computed$1(() => ({ display: o.value ? "block" : "none" }));
  return t({ changeActive: function(n2) {
    o.value = n2;
  } }), (n2, e2) => (openBlock(), createElementBlock("div", { class: "tab-panel", style: normalizeStyle(l.value) }, [renderSlot(n2.$slots, "default")], 4));
} });
function nn(n, e2, t) {
  var a2 = (t || {}).atBegin;
  return function(n2, e3, t2) {
    var a3, o = t2 || {}, r = o.noTrailing, i = void 0 !== r && r, l = o.noLeading, s = void 0 !== l && l, d = o.debounceMode, u2 = void 0 === d ? void 0 : d, c = false, p = 0;
    function f2() {
      a3 && clearTimeout(a3);
    }
    function g() {
      for (var t3 = arguments.length, o2 = new Array(t3), r2 = 0; r2 < t3; r2++)
        o2[r2] = arguments[r2];
      var l2 = this, d2 = Date.now() - p;
      function g2() {
        p = Date.now(), e3.apply(l2, o2);
      }
      function h2() {
        a3 = void 0;
      }
      c || (s || !u2 || a3 || g2(), f2(), void 0 === u2 && d2 > n2 ? s ? (p = Date.now(), i || (a3 = setTimeout(u2 ? h2 : g2, n2))) : g2() : true !== i && (a3 = setTimeout(u2 ? h2 : g2, void 0 === u2 ? n2 - d2 : n2)));
    }
    return g.cancel = function(n3) {
      var e4 = (n3 || {}).upcomingOnly, t3 = void 0 !== e4 && e4;
      f2(), c = !t3;
    }, g;
  }(n, e2, { debounceMode: false !== (void 0 !== a2 && a2) });
}
Z.__file = "packages/color-picker/comps/TabPanel.vue";
var en = defineComponent({ props: ["modelValue"], emits: ["change", "update:modelValue"], setup(t, { emit: a2 }) {
  const o = ref$1(90), r = ref$1(null), i = computed$1(() => o.value - 90);
  let l = false;
  const s = ref$1(false);
  watch(() => o.value, (n) => {
    t.modelValue !== o.value && a2("update:modelValue", n), a2("change");
  }), watch(() => t.modelValue, (n) => {
    o.value = n;
  });
  return { inputChange: (n) => {
    a2("change", n);
  }, num: o, turn: (n) => {
    if (!l)
      return;
    const e2 = 27, t2 = 27, a3 = n.offsetX - e2, r2 = n.offsetY - t2, i2 = 180 * Math.atan2(r2, a3) / Math.PI;
    o.value = Math.round(i2 + 90);
  }, touch: (n, e2) => {
    n.preventDefault(), l = e2;
  }, angleInDegrees: i, numInput: r, visiable: s };
} });
const tn = { class: "angle-input-box" };
W(".angle-input {\n  width: 38px;\n  margin-left: 5px;\n  padding: 0 0 0 4px;\n  border: 1px solid #e8eaec;\n  border-radius: 4px;\n  position: relative;\n}\n.angle-input-box {\n  position: relative;\n}\n.angle-input-box::after {\n  content: '\xB0';\n  width: 5px;\n  height: 2px;\n  position: absolute;\n  right: 2px;\n  top: 0;\n}\n.AngleHandle {\n  position: absolute;\n  z-index: 2;\n  right: 2px;\n  margin-top: 3px;\n  background: #ffffff;\n  width: 60px;\n  height: 60px;\n  border-radius: 7px;\n  box-shadow: 0 0 2px rgba(0, 0, 0, 0.6);\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.AngleHandle .angle {\n  width: 54px;\n  height: 54px;\n  position: relative;\n  overflow: hidden;\n  background: #f1f2f4;\n  border-radius: 50%;\n  user-select: none;\n  cursor: pointer;\n}\n.AngleHandle .line {\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 50%;\n  height: 1px;\n  background: #999999;\n  pointer-events: none;\n  transform-origin: left top;\n}\n.AngleHandle .line::before {\n  position: absolute;\n  content: '';\n  left: -1px;\n  top: -1px;\n  width: 3px;\n  height: 3px;\n  border-radius: 50%;\n  background: #999999;\n}\n.AngleHandle .line::after {\n  position: absolute;\n  content: '';\n  right: 0;\n  top: -2px;\n  width: 5px;\n  height: 5px;\n  border-radius: 50%;\n  background: #999999;\n}\n"), en.render = function(n, e2, t, a2, o, s) {
  return openBlock(), createElementBlock("div", tn, [withDirectives(createElementVNode("input", { ref: "numInput", "onUpdate:modelValue": e2[0] || (e2[0] = (e3) => n.num = e3), class: "angle-input", onFocus: e2[1] || (e2[1] = (e3) => n.visiable = true), onBlur: e2[2] || (e2[2] = (e3) => n.visiable = false), onInput: e2[3] || (e2[3] = (...e3) => n.inputChange && n.inputChange(...e3)) }, null, 544), [[vModelText, n.num]]), withDirectives(createElementVNode("div", { class: "AngleHandle", onMousedown: e2[6] || (e2[6] = (e3) => n.touch(e3, true)), onMouseup: e2[7] || (e2[7] = (e3) => n.touch(e3, false)) }, [createElementVNode("div", { class: "angle", onMouseup: e2[4] || (e2[4] = (...e3) => n.turn && n.turn(...e3)), onMousemove: e2[5] || (e2[5] = (...e3) => n.turn && n.turn(...e3)) }, [createElementVNode("div", { style: normalizeStyle(`transform: rotate(${n.angleInDegrees}deg)`), class: "line" }, null, 4)], 32)], 544), [[vShow, n.visiable]])]);
}, en.__file = "packages/color-picker/comps/AngleHandle.vue";
W('/* ! tailwindcss v3.3.2 | MIT License | https://tailwindcss.com */\n\n/*\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\n*/\n\n*,\n::before,\n::after {\n  box-sizing: border-box;\n  /* 1 */\n  border-width: 0;\n  /* 2 */\n  border-style: solid;\n  /* 2 */\n  border-color: #e5e7eb;\n  /* 2 */\n}\n\n::before,\n::after {\n  --tw-content: \'\';\n}\n\n/*\n1. Use a consistent sensible line-height in all browsers.\n2. Prevent adjustments of font size after orientation changes in iOS.\n3. Use a more readable tab size.\n4. Use the user\'s configured `sans` font-family by default.\n5. Use the user\'s configured `sans` font-feature-settings by default.\n6. Use the user\'s configured `sans` font-variation-settings by default.\n*/\n\nhtml {\n  line-height: 1.5;\n  /* 1 */\n  -webkit-text-size-adjust: 100%;\n  /* 2 */\n  -moz-tab-size: 4;\n  /* 3 */\n  tab-size: 4;\n  /* 3 */\n  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";\n  /* 4 */\n  font-feature-settings: normal;\n  /* 5 */\n  font-variation-settings: normal;\n  /* 6 */\n}\n\n/*\n1. Remove the margin in all browsers.\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\n*/\n\nbody {\n  margin: 0;\n  /* 1 */\n  line-height: inherit;\n  /* 2 */\n}\n\n/*\n1. Add the correct height in Firefox.\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\n3. Ensure horizontal rules are visible by default.\n*/\n\nhr {\n  height: 0;\n  /* 1 */\n  color: inherit;\n  /* 2 */\n  border-top-width: 1px;\n  /* 3 */\n}\n\n/*\nAdd the correct text decoration in Chrome, Edge, and Safari.\n*/\n\nabbr:where([title]) {\n  -webkit-text-decoration: underline dotted;\n  text-decoration: underline dotted;\n}\n\n/*\nRemove the default font size and weight for headings.\n*/\n\nh1,\nh2,\nh3,\nh4,\nh5,\nh6 {\n  font-size: inherit;\n  font-weight: inherit;\n}\n\n/*\nReset links to optimize for opt-in styling instead of opt-out.\n*/\n\na {\n  color: inherit;\n  text-decoration: inherit;\n}\n\n/*\nAdd the correct font weight in Edge and Safari.\n*/\n\nb,\nstrong {\n  font-weight: bolder;\n}\n\n/*\n1. Use the user\'s configured `mono` font family by default.\n2. Correct the odd `em` font sizing in all browsers.\n*/\n\ncode,\nkbd,\nsamp,\npre {\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;\n  /* 1 */\n  font-size: 1em;\n  /* 2 */\n}\n\n/*\nAdd the correct font size in all browsers.\n*/\n\nsmall {\n  font-size: 80%;\n}\n\n/*\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\n*/\n\nsub,\nsup {\n  font-size: 75%;\n  line-height: 0;\n  position: relative;\n  vertical-align: baseline;\n}\n\nsub {\n  bottom: -0.25em;\n}\n\nsup {\n  top: -0.5em;\n}\n\n/*\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\n3. Remove gaps between table borders by default.\n*/\n\ntable {\n  text-indent: 0;\n  /* 1 */\n  border-color: inherit;\n  /* 2 */\n  border-collapse: collapse;\n  /* 3 */\n}\n\n/*\n1. Change the font styles in all browsers.\n2. Remove the margin in Firefox and Safari.\n3. Remove default padding in all browsers.\n*/\n\nbutton,\ninput,\noptgroup,\nselect,\ntextarea {\n  font-family: inherit;\n  /* 1 */\n  font-size: 100%;\n  /* 1 */\n  font-weight: inherit;\n  /* 1 */\n  line-height: inherit;\n  /* 1 */\n  color: inherit;\n  /* 1 */\n  margin: 0;\n  /* 2 */\n  padding: 0;\n  /* 3 */\n}\n\n/*\nRemove the inheritance of text transform in Edge and Firefox.\n*/\n\nbutton,\nselect {\n  text-transform: none;\n}\n\n/*\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Remove default button styles.\n*/\n\nbutton,\n[type=\'button\'],\n[type=\'reset\'],\n[type=\'submit\'] {\n  -webkit-appearance: button;\n  /* 1 */\n  background-color: transparent;\n  /* 2 */\n  background-image: none;\n  /* 2 */\n}\n\n/*\nUse the modern Firefox focus style for all focusable elements.\n*/\n\n:-moz-focusring {\n  outline: auto;\n}\n\n/*\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\n*/\n\n:-moz-ui-invalid {\n  box-shadow: none;\n}\n\n/*\nAdd the correct vertical alignment in Chrome and Firefox.\n*/\n\nprogress {\n  vertical-align: baseline;\n}\n\n/*\nCorrect the cursor style of increment and decrement buttons in Safari.\n*/\n\n::-webkit-inner-spin-button,\n::-webkit-outer-spin-button {\n  height: auto;\n}\n\n/*\n1. Correct the odd appearance in Chrome and Safari.\n2. Correct the outline style in Safari.\n*/\n\n[type=\'search\'] {\n  -webkit-appearance: textfield;\n  /* 1 */\n  outline-offset: -2px;\n  /* 2 */\n}\n\n/*\nRemove the inner padding in Chrome and Safari on macOS.\n*/\n\n::-webkit-search-decoration {\n  -webkit-appearance: none;\n}\n\n/*\n1. Correct the inability to style clickable types in iOS and Safari.\n2. Change font properties to `inherit` in Safari.\n*/\n\n::-webkit-file-upload-button {\n  -webkit-appearance: button;\n  /* 1 */\n  font: inherit;\n  /* 2 */\n}\n\n/*\nAdd the correct display in Chrome and Safari.\n*/\n\nsummary {\n  display: list-item;\n}\n\n/*\nRemoves the default spacing and border for appropriate elements.\n*/\n\nblockquote,\ndl,\ndd,\nh1,\nh2,\nh3,\nh4,\nh5,\nh6,\nhr,\nfigure,\np,\npre {\n  margin: 0;\n}\n\nfieldset {\n  margin: 0;\n  padding: 0;\n}\n\nlegend {\n  padding: 0;\n}\n\nol,\nul,\nmenu {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n}\n\n/*\nPrevent resizing textareas horizontally by default.\n*/\n\ntextarea {\n  resize: vertical;\n}\n\n/*\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\n2. Set the default placeholder color to the user\'s configured gray 400 color.\n*/\n\ninput::placeholder,\ntextarea::placeholder {\n  opacity: 1;\n  /* 1 */\n  color: #9ca3af;\n  /* 2 */\n}\n\n/*\nSet the default cursor for buttons.\n*/\n\nbutton,\n[role="button"] {\n  cursor: pointer;\n}\n\n/*\nMake sure disabled buttons don\'t get the pointer cursor.\n*/\n\n:disabled {\n  cursor: default;\n}\n\n/*\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\n   This can trigger a poorly considered lint error in some tools but is included by design.\n*/\n\nimg,\nsvg,\nvideo,\ncanvas,\naudio,\niframe,\nembed,\nobject {\n  display: block;\n  /* 1 */\n  vertical-align: middle;\n  /* 2 */\n}\n\n/*\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\n*/\n\nimg,\nvideo {\n  max-width: 100%;\n  height: auto;\n}\n\n/* Make elements with the HTML hidden attribute stay hidden by default */\n\n[hidden] {\n  display: none;\n}\n\n*,\n::before,\n::after {\n  --tw-border-spacing-x: 0;\n  --tw-border-spacing-y: 0;\n  --tw-translate-x: 0;\n  --tw-translate-y: 0;\n  --tw-rotate: 0;\n  --tw-skew-x: 0;\n  --tw-skew-y: 0;\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  --tw-pan-x: ;\n  --tw-pan-y: ;\n  --tw-pinch-zoom: ;\n  --tw-scroll-snap-strictness: proximity;\n  --tw-gradient-from-position: ;\n  --tw-gradient-via-position: ;\n  --tw-gradient-to-position: ;\n  --tw-ordinal: ;\n  --tw-slashed-zero: ;\n  --tw-numeric-figure: ;\n  --tw-numeric-spacing: ;\n  --tw-numeric-fraction: ;\n  --tw-ring-inset: ;\n  --tw-ring-offset-width: 0px;\n  --tw-ring-offset-color: #fff;\n  --tw-ring-color: rgb(59 130 246 / 0.5);\n  --tw-ring-offset-shadow: 0 0 #0000;\n  --tw-ring-shadow: 0 0 #0000;\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  --tw-blur: ;\n  --tw-brightness: ;\n  --tw-contrast: ;\n  --tw-grayscale: ;\n  --tw-hue-rotate: ;\n  --tw-invert: ;\n  --tw-saturate: ;\n  --tw-sepia: ;\n  --tw-drop-shadow: ;\n  --tw-backdrop-blur: ;\n  --tw-backdrop-brightness: ;\n  --tw-backdrop-contrast: ;\n  --tw-backdrop-grayscale: ;\n  --tw-backdrop-hue-rotate: ;\n  --tw-backdrop-invert: ;\n  --tw-backdrop-opacity: ;\n  --tw-backdrop-saturate: ;\n  --tw-backdrop-sepia: ;\n}\n\n::backdrop {\n  --tw-border-spacing-x: 0;\n  --tw-border-spacing-y: 0;\n  --tw-translate-x: 0;\n  --tw-translate-y: 0;\n  --tw-rotate: 0;\n  --tw-skew-x: 0;\n  --tw-skew-y: 0;\n  --tw-scale-x: 1;\n  --tw-scale-y: 1;\n  --tw-pan-x: ;\n  --tw-pan-y: ;\n  --tw-pinch-zoom: ;\n  --tw-scroll-snap-strictness: proximity;\n  --tw-gradient-from-position: ;\n  --tw-gradient-via-position: ;\n  --tw-gradient-to-position: ;\n  --tw-ordinal: ;\n  --tw-slashed-zero: ;\n  --tw-numeric-figure: ;\n  --tw-numeric-spacing: ;\n  --tw-numeric-fraction: ;\n  --tw-ring-inset: ;\n  --tw-ring-offset-width: 0px;\n  --tw-ring-offset-color: #fff;\n  --tw-ring-color: rgb(59 130 246 / 0.5);\n  --tw-ring-offset-shadow: 0 0 #0000;\n  --tw-ring-shadow: 0 0 #0000;\n  --tw-shadow: 0 0 #0000;\n  --tw-shadow-colored: 0 0 #0000;\n  --tw-blur: ;\n  --tw-brightness: ;\n  --tw-contrast: ;\n  --tw-grayscale: ;\n  --tw-hue-rotate: ;\n  --tw-invert: ;\n  --tw-saturate: ;\n  --tw-sepia: ;\n  --tw-drop-shadow: ;\n  --tw-backdrop-blur: ;\n  --tw-backdrop-brightness: ;\n  --tw-backdrop-contrast: ;\n  --tw-backdrop-grayscale: ;\n  --tw-backdrop-hue-rotate: ;\n  --tw-backdrop-invert: ;\n  --tw-backdrop-opacity: ;\n  --tw-backdrop-saturate: ;\n  --tw-backdrop-sepia: ;\n}');
const an = (n) => (pushScopeId("data-v-f2777002"), n = n(), popScopeId(), n), on = { class: "color-picker" }, rn = { key: 1, class: "title" }, ln = { key: 2, class: "cp__gradient flex-center" }, sn = { class: "cp__gradient-bar" }, dn = ["data-sort", "onMousedown", "onKeydown"], un = an(() => createElementVNode("div", { class: "cpp__color-saturation" }, null, -1)), cn = an(() => createElementVNode("div", { class: "cpp__color-value" }, null, -1)), pn = { class: "cps__track" }, fn = { class: "cps__track" }, gn = { class: "cp__box" }, hn = ["value"], vn = ["value"], bn = ["onClick"], mn = { name: "ColorPicker", inheritAttrs: false };
var wn = Object.assign(mn, { props: { value: { type: String, default: "#ffffffff" }, modes: { type: Array, default: () => ["\u7EAF\u8272", "\u6E10\u53D8"] }, defaultColor: { type: String, default: "#ffffffff" }, defaultGradient: { type: String, default: "linear-gradient(90deg, #fffae0ff 0%, #ffd1f1ff 100%)" }, defaultImage: { type: String, default: "https://st0.dancf.com/csc/157/material-2d-textures/0/20190714-174653-ed3c.jpg" } }, emits: ["update:value", "change", "native-pick", "blur"], setup(o, { emit: f2 }) {
  const g = o, h2 = ref$1(F(g.value)), m = ref$1(90), M = ref$1([]), A2 = reactive$1({ h: 0, s: 0, l: 0, a: 0 }), $2 = ref$1("#f00"), E2 = ref$1("#000"), B3 = ref$1(0);
  let O2 = ref$1({});
  const D2 = "EyeDropper" in window, V2 = ref$1(), X2 = ref$1(), Y2 = ref$1(), W2 = ref$1(), K2 = ref$1(), J2 = ref$1(), Q2 = ref$1();
  let tn2 = null, an2 = null, mn2 = null, wn2 = null, xn = null, yn = true, _n = null;
  const kn = ref$1([]), zn = { color: g.defaultColor, gradient: g.defaultGradient, image: g.defaultImage }, Cn = computed$1(() => g.modes.includes("\u6E10\u53D8")), Sn = computed$1(() => {
    const n = R(E2.value).join(",");
    return { background: `linear-gradient(to right, rgba(${n}, 0) 0%, rgb(${n}) 100%)` };
  });
  watch(O2, (n) => {
    Nn(n.color);
  }), watch(E2, (n) => {
    !function(n2) {
      if (/^#(?:[0-9a-f]{3}){1,2}$/i.test(n2)) {
        const e2 = R(n2), [t, a2, o2] = I(...e2);
        A2.h = t, A2.s = a2, A2.l = o2, Y2.value.style.left = `${A2.s}%`, Y2.value.style.top = 100 - A2.l + "%", W2.value.style.left = A2.h / 360 * 100 + "%", E2.value = n2;
      }
    }(n);
  }), watch(() => g.value, (n) => {
    const e2 = F(n);
    e2 !== h2.value && (h2.value = e2), Tn(e2), $n(n), Mn(n);
  });
  const Mn = nn(300, async (n) => {
    const e2 = kn.value, t = e2.indexOf(n);
    -1 !== t && kn.value.splice(t, 1), e2.length >= 4 && kn.value.splice(e2.length - 1, 1);
    const a2 = [n];
    kn.value = a2.concat(e2);
  }), An = watch(A2, function(n) {
    const e2 = ((n2, e3, t2, a2 = 1) => `${N(n2, e3, t2)}${0 === a2 ? "00" : Math.round(255 * a2).toString(16)}`)(...Object.values(n));
    let t;
    "\u7EAF\u8272" === h2.value ? t = e2 : "\u6E10\u53D8" === h2.value && (O2.value.color = e2, t = H(m.value, M.value));
    In(e2), jn(t);
  }, { deep: true });
  function $n(n) {
    "\u7EAF\u8272" === h2.value ? zn.color = n : "\u6E10\u53D8" === h2.value ? zn.gradient = n : "\u56FE\u6848" === h2.value && (zn.image = n);
  }
  function jn(n) {
    n !== g.value && ($n(n), f2("update:value", n), f2("change", { mode: h2.value, color: n, angle: Number(m.value), stops: M.value }));
  }
  async function En(n) {
    if (n === h2.value)
      return;
    let e2;
    h2.value = n, "\u7EAF\u8272" === n ? e2 = zn.color : "\u6E10\u53D8" === n ? e2 = zn.gradient : "\u56FE\u6848" === n && (e2 = zn.image), jn(e2);
  }
  function Tn(n) {
    "\u7EAF\u8272" === n ? Nn(g.value) : "\u6E10\u53D8" === n && (0 === M.value.length ? g.value.match(/[^,]+/g).forEach((n2, e2) => {
      if (0 === e2)
        return void (m.value = Number(n2.match(/\d+/)[0]));
      let [t, a2] = n2.trim().split(" ");
      t.startsWith("#") || (t = T(t)), a2 = a2.match(/\d+/)[0] / 100, M.value.push({ color: t, offset: a2 }), O2.value = M.value[0];
    }) : Nn(O2.value.color));
  }
  function In(n) {
    var _a2;
    $2.value = `hsl(${A2.h}, 100%, 50%)`, E2.value = n.slice(0, 7), E2.value, B3.value = Math.round(100 * ((_a2 = A2.a) != null ? _a2 : 1));
  }
  function Nn(n) {
    if (yn) {
      const e2 = P(n);
      A2.h = e2[0], A2.s = e2[1], A2.l = e2[2], A2.a = e2[3], In(n);
      let t = A2.s;
      const a2 = Math.round(100 - A2.l);
      Y2.value.style.left = `${t}%`, Y2.value.style.top = `${a2}%`, t = A2.h / 360, W2.value.style.left = 100 * t + "%", J2.value.style.left = 100 * A2.a + "%";
    }
  }
  function Rn(n) {
    if (n.stopPropagation(), n.preventDefault(), !["Backspace", "Delete"].includes(n.key))
      return;
    if (2 === M.value.length)
      return;
    const e2 = M.value.indexOf(O2.value);
    M.value.splice(e2, 1), O2.value = M.value[0];
  }
  function Ln() {
    yn = false, _n && clearTimeout(_n), _n = setTimeout(() => {
      yn = true;
    }, 16);
  }
  async function Pn(n) {
    let e2 = "";
    if (n && n.target.value) {
      const t = n.target.value;
      e2 = t + (7 === t.length ? "ff" : "");
    } else {
      const n2 = new window.EyeDropper();
      U("\u6309Esc\u53EF\u9000\u51FA");
      try {
        const t = await n2.open();
        e2 = t.sRGBHex + "ff";
      } catch (n3) {
        console.log("\u7528\u6237\u53D6\u6D88\u4E86\u53D6\u8272");
      }
    }
    "\u6E10\u53D8" === h2.value ? (O2.value.color = e2, O2.value = { ...O2.value }) : f2("update:value", e2), f2("native-pick", e2);
  }
  onMounted(async function() {
    Y2.value.style.left = `${A2.s}%`, Y2.value.style.top = 100 - A2.l + "%", W2.value.style.left = A2.h / 360 * 100 + "%", J2.value.style.left = 100 * A2.a + "%", Cn.value && (tn2 = j(V2.value, { onmousedown: function(n2) {
      if (xn)
        return;
      const e3 = M.value.findIndex((e4) => e4.offset >= n2.x), t2 = M.value[e3 - 1], a2 = L(t2.color), o2 = M.value[e3], r = L(o2.color), i = [];
      for (let e4 = 0; e4 < 3; e4 += 1)
        i.push(a2[e4] + (r[e4] - a2[e4]) * n2.x);
      const l = o2.offset - n2.x - (n2.x - t2.offset) > 0 ? a2[3] : r[3], s = T(...i, l);
      O2.value = { color: s, offset: n2.x }, M.value.splice(e3, 0, O2.value);
    }, onmousemove: function(n2) {
      if (!xn)
        return;
      O2.value.offset = n2.x, M.value.sort((n3, e3) => n3.offset - e3.offset);
      jn(H(m.value, M.value));
    }, onmouseup: function() {
      xn = false;
    } }));
    function n(n2) {
      Ln();
      const e3 = 100 * n2.x, t2 = 100 * n2.y;
      A2.s = Math.round(e3), A2.l = Math.round(100 - t2), Y2.value.style.left = `${e3}%`, Y2.value.style.top = `${t2}%`;
    }
    function e2(n2) {
      Ln(), A2.h = 360 * n2.x, W2.value.style.left = 100 * n2.x + "%";
    }
    function t(n2) {
      Ln(), A2.a = n2.x, J2.value.style.left = 100 * n2.x + "%";
    }
    an2 = j(X2.value, { onmousemove: n, onmouseup: n }), mn2 = j(K2.value, { onmousemove: e2, onmouseup: e2 }), wn2 = j(Q2.value, { onmousemove: t, onmouseup: t }), Tn(h2.value), $n(g.value);
  }), onBeforeUnmount(() => {
    an2 == null ? void 0 : an2.destroy(), mn2 == null ? void 0 : mn2.destroy(), wn2 == null ? void 0 : wn2.destroy(), An(), tn2 && tn2.destroy();
  });
  const Fn = (n) => {
    const e2 = function(n2) {
      let e3 = n2.replace(/\s/g, "");
      n2.startsWith("#") || (e3 = "#" + e3);
      e3.length < 9 && (e3 = e3.padEnd(9, "f"));
      return e3;
    }(n.target.value);
    f2("blur", e2), f2("update:value", e2);
  };
  function Hn() {
    jn(H(m.value, M.value));
  }
  return (n, e2) => (openBlock(), createElementBlock("div", on, [o.modes.length > 1 ? (openBlock(), createBlock(G, { key: 0, value: h2.value, "onUpdate:value": En }, { default: withCtx(() => [(openBlock(true), createElementBlock(Fragment, null, renderList(o.modes, (n2) => (openBlock(), createBlock(Z, { key: n2, label: n2 }, null, 8, ["label"]))), 128))]), _: 1 }, 8, ["value"])) : (openBlock(), createElementBlock("div", rn, toDisplayString(h2.value), 1)), Cn.value ? withDirectives((openBlock(), createElementBlock("div", ln, [createElementVNode("div", sn, [createElementVNode("div", { ref_key: "elGradientTrack", ref: V2, class: "cpgb__track", style: normalizeStyle([{ width: "100%" }, { background: o.value }]) }, [createCommentVNode(' tabindex="-1" \u662F\u5143\u7D20\u53EF\u4EE5\u89E6\u53D1 keydown \u4E8B\u4EF6 '), (openBlock(true), createElementBlock(Fragment, null, renderList(M.value, (n2, e3) => (openBlock(), createElementBlock("div", { key: e3, class: normalizeClass(["cpgb__pointer", { "cpgb__pointer--active": n2 === unref(O2) }]), "data-sort": e3, style: normalizeStyle({ left: 100 * n2.offset + "%", background: n2.color }), tabindex: "-1", onMousedown: (e4) => {
    return t = n2, xn = true, void (O2.value = t);
    var t;
  }, onKeydown: withModifiers(Rn, ["stop"]) }, null, 46, dn))), 128))], 4)]), createVNode(en, { modelValue: m.value, "onUpdate:modelValue": e2[0] || (e2[0] = (n2) => m.value = n2), onChange: Hn }, null, 8, ["modelValue"])], 512)), [[vShow, "\u6E10\u53D8" === h2.value]]) : createCommentVNode("v-if", true), createElementVNode("div", { ref_key: "elPalette", ref: X2, class: "cp__palette", style: normalizeStyle({ background: $2.value }) }, [un, cn, createElementVNode("div", { ref_key: "elPalettePointer", ref: Y2, class: "cpp__pointer" }, null, 512)], 4), createElementVNode("div", { ref_key: "elSliderHux", ref: K2, class: "cp__slider cp__slider-hux" }, [createElementVNode("div", pn, [createElementVNode("div", { ref_key: "elSliderHuxPointer", ref: W2, class: "cpst__pointer" }, null, 512)])], 512), createElementVNode("div", { ref_key: "elSliderAlpha", ref: Q2, class: "cp__slider cp__slider-alpha" }, [createElementVNode("div", { class: "cpsa__background", style: normalizeStyle(Sn.value) }, null, 4), createElementVNode("div", fn, [createElementVNode("div", { ref_key: "elSliderAlphaPointer", ref: J2, class: "cpst__pointer" }, null, 512)])], 512), createElementVNode("div", gn, [createElementVNode("div", { class: "item", onClick: Pn }, [D2 ? (openBlock(), createBlock(q, { key: 0 })) : (openBlock(), createElementBlock("input", { key: 1, class: "native", type: "color", onInput: Pn }, null, 32))]), createCommentVNode(` <input :value="value" @input="$emit('update:value', $event.target.value)" class="input" /> `), "\u6E10\u53D8" === h2.value ? (openBlock(), createElementBlock("input", { key: 0, class: "input", value: unref(O2).color }, null, 8, hn)) : (openBlock(), createElementBlock("input", { key: 1, value: o.value, class: "input", onBlur: Fn }, null, 40, vn)), "\u7EAF\u8272" === h2.value ? (openBlock(true), createElementBlock(Fragment, { key: 2 }, renderList(kn.value, (n2) => (openBlock(), createElementBlock("div", { key: n2, class: "item item-color", style: normalizeStyle({ background: n2 }), onClick: (e3) => Pn({ target: { value: n2 } }) }, null, 12, bn))), 128)) : createCommentVNode("v-if", true), createCommentVNode(' <input :value="alpha" class="w-12" size="small" :min="0" :max="100" @input="onChangeAlpha" @change="onChangeAlpha" /> ')])]));
} });
W(".flex-center[data-v-f2777002] {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n}\n.title[data-v-f2777002] {\n  margin-bottom: 0.75rem;\n  font-size: 15px;\n  font-weight: 600;\n}\n.color-picker[data-v-f2777002] {\n  -webkit-user-select: none;\n  user-select: none;\n  min-width: 220px;\n}\n.cp__gradient-bar[data-v-f2777002] {\n  display: flex;\n  justify-content: center;\n  height: 16px;\n  width: 100%;\n  padding: 0 8px;\n}\n.cpgb__track[data-v-f2777002] {\n  position: relative;\n  cursor: pointer;\n}\n.cpgb__pointer[data-v-f2777002] {\n  cursor: grab;\n  position: absolute;\n  top: 0px;\n  top: -0.125rem;\n  height: 1.25rem;\n  --tw-translate-x: -50%;\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n  border-width: 2px;\n  border-style: solid;\n  --tw-border-opacity: 1;\n  border-color: rgb(255 255 255 / var(--tw-border-opacity));\n  --tw-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);\n  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n  outline: 2px solid transparent;\n  outline-offset: 2px;\n  width: 18px;\n}\n.cpgb__pointer--active[data-v-f2777002] {\n  z-index: 1;\n  border-radius: 3px;\n  box-shadow: 0 0 4px 0 rgba(0, 0, 0, 0.2), 0 0 0 1.2px #2254f4;\n}\n.cp__palette[data-v-f2777002] {\n  height: 140px;\n  position: relative;\n  margin-top: 0.75rem;\n  margin-top: 0.875rem;\n  cursor: pointer;\n  overflow: hidden;\n  border-radius: 0.25rem;\n}\n.cp__palette .cpp__color-saturation[data-v-f2777002],\n.cp__palette .cpp__color-value[data-v-f2777002] {\n  position: absolute;\n  bottom: 0px;\n  right: 0px;\n  top: 0px;\n  width: 100%;\n  height: 100%;\n}\n.cp__palette .cpp__color-saturation[data-v-f2777002] {\n  background-image: linear-gradient(to right, var(--tw-gradient-stops));\n  --tw-gradient-from: #fff var(--tw-gradient-from-position);\n  --tw-gradient-to: rgba(255, 255, 255, 0) var(--tw-gradient-to-position);\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\n}\n.cp__palette .cpp__color-value[data-v-f2777002] {\n  background-image: linear-gradient(to top, var(--tw-gradient-stops));\n  --tw-gradient-from: #000 var(--tw-gradient-from-position);\n  --tw-gradient-to: rgba(0, 0, 0, 0) var(--tw-gradient-to-position);\n  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);\n}\n.cp__palette .cpp__pointer[data-v-f2777002] {\n  position: absolute;\n  height: 0.75rem;\n  width: 0.75rem;\n  --tw-translate-x: -0.25rem;\n  --tw-translate-x: -0.375rem;\n  --tw-translate-y: -0.25rem;\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n  border-radius: 9999px;\n  border-width: 2px;\n  --tw-border-opacity: 1;\n  border-color: rgb(255 255 255 / var(--tw-border-opacity));\n  --tw-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);\n  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);\n  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);\n}\n.cp__slider[data-v-f2777002] {\n  position: relative;\n  margin-top: 0.75rem;\n  margin-top: 0.875rem;\n  height: 0.5rem;\n  border-radius: 0.25rem;\n}\n.cp__slider-hux[data-v-f2777002] {\n  background: linear-gradient(90deg, red 0, #ff0 17%, #0f0 33%, #0ff 50%, #00f 67%, #f0f 83%, red);\n}\n.cp__slider-alpha[data-v-f2777002] {\n  background: linear-gradient(to top right, hsla(0, 0%, 80%, 0.4) 25%, transparent 0, transparent 75%, hsla(0, 0%, 80%, 0.4) 0, hsla(0, 0%, 80%, 0.4)), linear-gradient(to top right, hsla(0, 0%, 80%, 0.4) 25%, transparent 0, transparent 75%, hsla(0, 0%, 80%, 0.4) 0, hsla(0, 0%, 80%, 0.4));\n  background-size: 6px 6px;\n  background-position: 0 0, 3px 3px;\n}\n.cp__slider .cpsa__background[data-v-f2777002] {\n  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.06);\n  height: 100%;\n  border-radius: 0.25rem;\n}\n.cp__box[data-v-f2777002] {\n  margin-top: 0.75rem;\n  margin-top: 0.875rem;\n  display: flex;\n}\n.cp__box .item[data-v-f2777002] {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  cursor: pointer;\n  margin-left: 6px;\n  width: 24px;\n  height: 24px;\n  box-sizing: border-box;\n  border-radius: 4px;\n}\n.cp__box .item-color[data-v-f2777002] {\n  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.06);\n}\n.cp__box .item[data-v-f2777002]:first-of-type {\n  margin: 0;\n}\n.cp__box .item[data-v-f2777002]:hover {\n  transform: scale(1.08);\n}\n.cp__box .input[data-v-f2777002] {\n  width: 4.7rem;\n  margin-left: 2px;\n}\n.cp__box .native[data-v-f2777002] {\n  width: 100%;\n  height: 100%;\n}\n.cps__track[data-v-f2777002] {\n  position: absolute;\n  left: 0.25rem;\n  right: 0.25rem;\n  top: 0px;\n}\n.cpst__pointer[data-v-f2777002] {\n  cursor: pointer;\n  box-shadow: 0 0 2px rgba(0, 0, 0, 0.6);\n  position: absolute;\n  top: 0px;\n  box-sizing: content-box;\n  height: 0.5rem;\n  width: 0.5rem;\n  --tw-translate-x: -0.5rem;\n  --tw-translate-y: -0.25rem;\n  transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skewX(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y));\n  border-radius: 9999px;\n  border-width: 4px;\n  --tw-border-opacity: 1;\n  border-color: rgb(255 255 255 / var(--tw-border-opacity));\n}\n"), wn.__scopeId = "data-v-f2777002", wn.__file = "packages/color-picker/index.vue", wn.install = (n) => {
  n.component(wn.name, wn);
};
var colorSelect_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$8 = "color-select";
const _sfc_main$k = defineComponent({
  name: NAME$8,
  components: { colorPicker: wn },
  inheritAttrs: false,
  props: {
    label: {
      default: ""
    },
    modelValue: {
      default: ""
    },
    width: {
      default: "100%"
    },
    modes: {
      default: () => ["\u7EAF\u8272"]
    }
  },
  emits: ["finish", "update:modelValue", "change"],
  setup(props2, { emit: emit2 }) {
    const store = useStore();
    const state = reactive$1({
      innerColor: "#ffffffff"
    });
    onMounted(() => {
      if (props2.modelValue) {
        state.innerColor = props2.modelValue + (props2.modelValue.length === 7 ? "ff" : "");
      }
    });
    const dropColor = async (e2) => {
      console.log("\u53D6\u8272: ", e2);
    };
    const updateValue = (value) => {
      emit2("update:modelValue", value);
    };
    const activeChange = (value) => {
      updateValue(value);
    };
    const onChange = () => {
      emit2("finish", state.innerColor);
    };
    const inputBlur = (color2) => {
      state.innerColor = color2;
    };
    const enter = () => {
      store.commit("setShowMoveable", false);
    };
    const hide = () => {
      store.commit("setShowMoveable", true);
    };
    const colorChange = (e2) => {
      emit2("change", e2);
    };
    return {
      ...toRefs(state),
      activeChange,
      onChange,
      dropColor,
      inputBlur,
      enter,
      hide,
      colorChange
    };
  }
});
const _hoisted_1$i = {
  key: 0,
  class: "input-label"
};
const _hoisted_2$e = { class: "content" };
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_color_picker = resolveComponent("color-picker");
  const _component_el_popover = resolveComponent("el-popover");
  return openBlock(), createElementBlock("div", {
    class: "color__select",
    style: normalizeStyle({ width: _ctx.width })
  }, [
    _ctx.label ? (openBlock(), createElementBlock("p", _hoisted_1$i, toDisplayString(_ctx.label), 1)) : createCommentVNode("", true),
    createElementVNode("div", _hoisted_2$e, [
      createVNode(_component_el_popover, {
        placement: "left-end",
        trigger: "click",
        width: "auto",
        onAfterEnter: _ctx.enter,
        onBeforeLeave: _ctx.hide
      }, {
        reference: withCtx(() => [
          createElementVNode("div", {
            class: "color__bar",
            style: normalizeStyle({ background: _ctx.innerColor })
          }, null, 4)
        ]),
        default: withCtx(() => [
          createVNode(_component_color_picker, {
            value: _ctx.innerColor,
            "onUpdate:value": _cache[0] || (_cache[0] = ($event) => _ctx.innerColor = $event),
            modes: _ctx.modes,
            onChange: _ctx.colorChange,
            onNativePick: _ctx.dropColor
          }, null, 8, ["value", "modes", "onChange", "onNativePick"])
        ]),
        _: 1
      }, 8, ["onAfterEnter", "onBeforeLeave"])
    ])
  ], 4);
}
var colorSelect = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$g], ["__scopeId", "data-v-30405e68"]]);
var __glob_0_6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": colorSelect
}, Symbol.toStringTag, { value: "Module" }));
var localization = {
  dotColorTypes: [
    {
      key: "single",
      value: "\u5355\u8272"
    },
    {
      key: "gradient",
      value: "\u6E10\u53D8\u8272"
    }
  ],
  dotTypes: [
    {
      key: "dots",
      value: "\u5706\u70B9\u98CE\u683C"
    },
    {
      key: "rounded",
      value: "\u5706\u6DA6\u98CE\u683C"
    },
    {
      key: "classy",
      value: "\u7ECF\u5178\u98CE\u683C"
    },
    {
      key: "classy-rounded",
      value: "\u5706\u89D2\u98CE\u683C"
    },
    {
      key: "square",
      value: "\u65B9\u5F62\u98CE\u683C"
    },
    {
      key: "extra-rounded",
      value: "\u7279\u6B8A\u98CE\u683C"
    }
  ]
};
var wQrcodeStyle_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$7 = "w-image-style";
const _sfc_main$j = {
  name: NAME$7,
  components: { ElSelect, ElOption, numberInput, numberSlider, iconItemSelect, textInputArea, colorSelect, uploader },
  data() {
    return {
      activeNames: ["2", "3", "4"],
      innerElement: {},
      tag: false,
      ingoreKeys: ["left", "top", "name", "width", "height", "radiusTopLeft", "radiusTopRight", "radiusBottomLeft", "radiusBottomRight"],
      layerIconList,
      alignIconList: alignIconList$1,
      localization
    };
  },
  computed: {
    ...mapGetters(["dActiveElement", "dMoving", "dWidgets"])
  },
  watch: {
    dActiveElement: {
      handler(newValue, oldValue) {
        this.change();
        if (newValue.uuid == -1) {
          this.innerElement.cropEdit = false;
          this.updateWidgetData({
            uuid: this.lastUuid,
            key: "cropEdit",
            value: false
          });
        } else {
          this.lastUuid = newValue.uuid;
        }
      },
      deep: true
    },
    innerElement: {
      handler(newValue, oldValue) {
        this.changeValue();
      },
      deep: true
    }
  },
  created() {
    this.change();
  },
  methods: {
    ...mapActions(["updateWidgetData", "updateAlign", "updateLayerIndex", "addWidget"]),
    change() {
      this.tag = true;
      this.innerElement = JSON.parse(JSON.stringify(this.dActiveElement));
    },
    changeValue() {
      if (this.tag) {
        this.tag = false;
        return;
      }
      if (this.dMoving) {
        return;
      }
      for (let key in this.innerElement) {
        if (this.ingoreKeys.indexOf(key) !== -1) {
          this.dActiveElement[key] = this.innerElement[key];
        } else if (key !== "setting" && key !== "record" && this.innerElement[key] !== this.dActiveElement[key]) {
          this.updateWidgetData({
            uuid: this.dActiveElement.uuid,
            key,
            value: this.innerElement[key]
          });
        }
      }
    },
    finish(key, value) {
      this.updateWidgetData({
        uuid: this.dActiveElement.uuid,
        key,
        value,
        pushHistory: true
      });
    },
    layerAction(item) {
      console.log(item);
      this.updateLayerIndex({
        uuid: this.dActiveElement.uuid,
        value: item.value
      });
    },
    async alignAction(item) {
      this.updateAlign({
        align: item.value,
        uuid: this.dActiveElement.uuid
      });
      await this.$nextTick();
      this.$store.commit("updateRect");
    },
    async uploadImgDone(img) {
      this.$store.commit("setShowMoveable", false);
      await api$1.material.addMyPhoto(img);
      this.innerElement.url = img.url;
      this.$store.commit("setShowMoveable", true);
    }
  }
};
const _withScopeId$8 = (n) => (pushScopeId("data-v-1fb0f52c"), n = n(), popScopeId(), n);
const _hoisted_1$h = { id: "w-image-style" };
const _hoisted_2$d = { class: "line-layout" };
const _hoisted_3$d = {
  style: { "flex-wrap": "nowrap" },
  class: "line-layout"
};
const _hoisted_4$c = {
  style: { "flex-wrap": "nowrap", "margin-top": "1rem" },
  class: "line-layout"
};
const _hoisted_5$b = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
const _hoisted_6$7 = { class: "slide-wrap logo__layout" };
const _hoisted_7$5 = ["src"];
const _hoisted_8$4 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
const _hoisted_9$4 = { class: "slide-wrap" };
const _hoisted_10$4 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
const _hoisted_11$3 = /* @__PURE__ */ _withScopeId$8(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_number_input = resolveComponent("number-input");
  const _component_el_collapse_item = resolveComponent("el-collapse-item");
  const _component_el_option = resolveComponent("el-option");
  const _component_el_select = resolveComponent("el-select");
  const _component_color_select = resolveComponent("color-select");
  const _component_number_slider = resolveComponent("number-slider");
  const _component_text_input_area = resolveComponent("text-input-area");
  const _component_el_button = resolveComponent("el-button");
  const _component_uploader = resolveComponent("uploader");
  const _component_icon_item_select = resolveComponent("icon-item-select");
  const _component_el_collapse = resolveComponent("el-collapse");
  return openBlock(), createElementBlock("div", _hoisted_1$h, [
    createVNode(_component_el_collapse, {
      modelValue: $data.activeNames,
      "onUpdate:modelValue": _cache[21] || (_cache[21] = ($event) => $data.activeNames = $event)
    }, {
      default: withCtx(() => [
        createVNode(_component_el_collapse_item, {
          title: "\u4F4D\u7F6E\u5C3A\u5BF8",
          name: "1"
        }, {
          default: withCtx(() => [
            createElementVNode("div", _hoisted_2$d, [
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.left,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.innerElement.left = $event),
                label: "X",
                onFinish: _cache[1] || (_cache[1] = (value) => $options.finish("left", value))
              }, null, 8, ["modelValue"]),
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.top,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.innerElement.top = $event),
                label: "Y",
                onFinish: _cache[3] || (_cache[3] = (value) => $options.finish("top", value))
              }, null, 8, ["modelValue"]),
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.width,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $data.innerElement.width = $event),
                style: { "margin-top": "0.5rem" },
                label: "\u5BBD",
                onFinish: _cache[5] || (_cache[5] = (value) => $options.finish("width", value))
              }, null, 8, ["modelValue"]),
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.height,
                "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $data.innerElement.height = $event),
                style: { "margin-top": "0.5rem" },
                label: "\u9AD8",
                onFinish: _cache[7] || (_cache[7] = (value) => $options.finish("height", value))
              }, null, 8, ["modelValue"])
            ])
          ]),
          _: 1
        }),
        createVNode(_component_el_collapse_item, {
          title: "\u6837\u5F0F\u8BBE\u8BA1",
          name: "2"
        }, {
          default: withCtx(() => [
            createElementVNode("div", _hoisted_3$d, [
              createVNode(_component_el_select, {
                modelValue: $data.innerElement.dotColorType,
                "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => $data.innerElement.dotColorType = $event)
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList($data.localization.dotColorTypes, (ctype) => {
                    return openBlock(), createBlock(_component_el_option, {
                      key: ctype.key,
                      label: ctype.value,
                      value: ctype.key
                    }, null, 8, ["label", "value"]);
                  }), 128))
                ]),
                _: 1
              }, 8, ["modelValue"]),
              createVNode(_component_el_select, {
                modelValue: $data.innerElement.dotType,
                "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => $data.innerElement.dotType = $event),
                class: "selector"
              }, {
                default: withCtx(() => [
                  (openBlock(true), createElementBlock(Fragment, null, renderList($data.localization.dotTypes, (dtype) => {
                    return openBlock(), createBlock(_component_el_option, {
                      key: dtype.key,
                      label: dtype.value,
                      value: dtype.key
                    }, null, 8, ["label", "value"]);
                  }), 128))
                ]),
                _: 1
              }, 8, ["modelValue"])
            ]),
            createElementVNode("div", _hoisted_4$c, [
              createVNode(_component_color_select, {
                modelValue: $data.innerElement.dotColor,
                "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => $data.innerElement.dotColor = $event),
                onFinish: _cache[11] || (_cache[11] = (value) => $options.finish("dotColor", value))
              }, null, 8, ["modelValue"]),
              withDirectives(createVNode(_component_color_select, {
                modelValue: $data.innerElement.dotColor2,
                "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => $data.innerElement.dotColor2 = $event),
                onFinish: _cache[13] || (_cache[13] = (value) => $options.finish("dotColor2", value))
              }, null, 8, ["modelValue"]), [
                [vShow, $data.innerElement.dotColorType !== "single"]
              ])
            ]),
            withDirectives(createVNode(_component_number_slider, {
              modelValue: $data.innerElement.dotRotation,
              "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => $data.innerElement.dotRotation = $event),
              style: { "margin-top": "8px" },
              label: "\u6E10\u53D8\u89D2\u5EA6",
              step: 1,
              minValue: 0,
              maxValue: 360,
              onFinish: _cache[15] || (_cache[15] = (value) => $options.finish("dotRotation", value))
            }, null, 8, ["modelValue"]), [
              [vShow, $data.innerElement.dotColorType !== "single"]
            ])
          ]),
          _: 1
        }),
        createVNode(_component_el_collapse_item, {
          title: "\u5185\u5BB9\u8BBE\u7F6E",
          name: "3"
        }, {
          default: withCtx(() => [
            createVNode(_component_text_input_area, {
              modelValue: $data.innerElement.value,
              "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => $data.innerElement.value = $event),
              max: 40,
              label: "",
              onFinish: _cache[17] || (_cache[17] = (value) => $options.finish("value", value))
            }, null, 8, ["modelValue"]),
            _hoisted_5$b,
            createElementVNode("div", _hoisted_6$7, [
              withDirectives(createElementVNode("img", {
                src: $data.innerElement.url,
                class: "logo"
              }, null, 8, _hoisted_7$5), [
                [vShow, $data.innerElement.url]
              ]),
              createVNode(_component_uploader, {
                class: "options__upload",
                onDone: $options.uploadImgDone
              }, {
                default: withCtx(() => [
                  createVNode(_component_el_button, {
                    size: "small",
                    plain: ""
                  }, {
                    default: withCtx(() => [
                      createTextVNode(toDisplayString($data.innerElement.url ? "\u66FF\u6362\u56FE\u7247" : "\u4E0A\u4F20 Logo"), 1)
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["onDone"]),
              withDirectives(createVNode(_component_el_button, {
                size: "small",
                link: "",
                onClick: _cache[18] || (_cache[18] = ($event) => $options.finish("url", ""))
              }, {
                default: withCtx(() => [
                  createTextVNode("\u5220\u9664")
                ]),
                _: 1
              }, 512), [
                [vShow, $data.innerElement.url]
              ])
            ]),
            _hoisted_8$4,
            createElementVNode("div", _hoisted_9$4, [
              createVNode(_component_number_slider, {
                modelValue: $data.innerElement.opacity,
                "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => $data.innerElement.opacity = $event),
                label: "\u4E0D\u900F\u660E",
                step: 0.01,
                maxValue: 1,
                onFinish: _cache[20] || (_cache[20] = (value) => $options.finish("opacity", value))
              }, null, 8, ["modelValue"])
            ])
          ]),
          _: 1
        }),
        _hoisted_10$4,
        createVNode(_component_icon_item_select, {
          class: "style-item",
          label: "",
          data: $data.layerIconList,
          onFinish: $options.layerAction
        }, null, 8, ["data", "onFinish"]),
        createVNode(_component_icon_item_select, {
          data: $data.alignIconList,
          onFinish: $options.alignAction
        }, null, 8, ["data", "onFinish"]),
        _hoisted_11$3
      ]),
      _: 1
    }, 8, ["modelValue"])
  ]);
}
var wQrcodeStyle = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$f], ["__scopeId", "data-v-1fb0f52c"]]);
var __glob_0_30 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": wQrcodeStyle
}, Symbol.toStringTag, { value: "Module" }));
var wSvgStyle_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$6 = "w-image-style";
const _sfc_main$i = {
  name: NAME$6,
  components: { numberInput, numberSlider, iconItemSelect, colorSelect },
  data() {
    return {
      activeNames: ["2", "3", "4"],
      innerElement: {},
      tag: false,
      ingoreKeys: ["left", "top", "name", "width", "height", "radiusTopLeft", "radiusTopRight", "radiusBottomLeft", "radiusBottomRight"],
      layerIconList,
      alignIconList: alignIconList$1
    };
  },
  computed: {
    ...mapGetters(["dActiveElement", "dMoving"])
  },
  watch: {
    dActiveElement: {
      handler(newValue, oldValue) {
        this.change();
      },
      deep: true
    },
    innerElement: {
      handler(newValue, oldValue) {
        this.changeValue();
      },
      deep: true
    }
  },
  created() {
    this.change();
  },
  methods: {
    ...mapActions(["updateWidgetData", "updateAlign", "updateLayerIndex"]),
    change() {
      this.tag = true;
      this.innerElement = JSON.parse(JSON.stringify(this.dActiveElement));
    },
    changeValue() {
      if (this.tag) {
        this.tag = false;
        return;
      }
      if (this.dMoving) {
        return;
      }
      for (let key in this.innerElement) {
        if (this.ingoreKeys.indexOf(key) !== -1) {
          this.dActiveElement[key] = this.innerElement[key];
        } else if (key !== "setting" && key !== "record" && this.innerElement[key] !== this.dActiveElement[key]) {
          this.updateWidgetData({
            uuid: this.dActiveElement.uuid,
            key,
            value: this.innerElement[key]
          });
        }
      }
    },
    colorFinish(key) {
      this.finish(key, this.innerElement[key]);
    },
    finish(key, value) {
      this.updateWidgetData({
        uuid: this.dActiveElement.uuid,
        key,
        value,
        pushHistory: true
      });
    },
    layerAction(item) {
      this.updateLayerIndex({
        uuid: this.dActiveElement.uuid,
        value: item.value
      });
    },
    alignAction(item) {
      this.updateAlign({
        align: item.value,
        uuid: this.dActiveElement.uuid
      });
    }
  }
};
const _withScopeId$7 = (n) => (pushScopeId("data-v-a6306dae"), n = n(), popScopeId(), n);
const _hoisted_1$g = { id: "w-image-style" };
const _hoisted_2$c = { class: "line-layout" };
const _hoisted_3$c = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
const _hoisted_4$b = { class: "slide-wrap" };
const _hoisted_5$a = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
const _hoisted_6$6 = /* @__PURE__ */ _withScopeId$7(() => /* @__PURE__ */ createElementVNode("br", null, null, -1));
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_number_input = resolveComponent("number-input");
  const _component_el_collapse_item = resolveComponent("el-collapse-item");
  const _component_color_select = resolveComponent("color-select");
  const _component_number_slider = resolveComponent("number-slider");
  const _component_icon_item_select = resolveComponent("icon-item-select");
  const _component_el_collapse = resolveComponent("el-collapse");
  return openBlock(), createElementBlock("div", _hoisted_1$g, [
    createVNode(_component_el_collapse, {
      modelValue: $data.activeNames,
      "onUpdate:modelValue": _cache[11] || (_cache[11] = ($event) => $data.activeNames = $event)
    }, {
      default: withCtx(() => [
        createVNode(_component_el_collapse_item, {
          title: "\u4F4D\u7F6E\u5C3A\u5BF8",
          name: "1"
        }, {
          default: withCtx(() => [
            createElementVNode("div", _hoisted_2$c, [
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.left,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.innerElement.left = $event),
                label: "X",
                onFinish: _cache[1] || (_cache[1] = (value) => $options.finish("left", value))
              }, null, 8, ["modelValue"]),
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.top,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.innerElement.top = $event),
                label: "Y",
                onFinish: _cache[3] || (_cache[3] = (value) => $options.finish("top", value))
              }, null, 8, ["modelValue"]),
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.width,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $data.innerElement.width = $event),
                style: { "margin-top": "0.5rem" },
                label: "\u5BBD",
                onFinish: _cache[5] || (_cache[5] = (value) => $options.finish("width", value))
              }, null, 8, ["modelValue"]),
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.height,
                "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $data.innerElement.height = $event),
                style: { "margin-top": "0.5rem" },
                label: "\u9AD8",
                onFinish: _cache[7] || (_cache[7] = (value) => $options.finish("height", value))
              }, null, 8, ["modelValue"])
            ])
          ]),
          _: 1
        }),
        createVNode(_component_el_collapse_item, {
          title: "\u8BBE\u7F6E\u989C\u8272",
          name: "2"
        }, {
          default: withCtx(() => [
            (openBlock(true), createElementBlock(Fragment, null, renderList($data.innerElement.colors, (c, ci) => {
              return openBlock(), createElementBlock("div", {
                key: ci + "c"
              }, [
                createVNode(_component_color_select, {
                  modelValue: $data.innerElement.colors[ci],
                  "onUpdate:modelValue": ($event) => $data.innerElement.colors[ci] = $event,
                  onFinish: _cache[8] || (_cache[8] = (value) => $options.colorFinish("colors"))
                }, null, 8, ["modelValue", "onUpdate:modelValue"])
              ]);
            }), 128)),
            _hoisted_3$c,
            createElementVNode("div", _hoisted_4$b, [
              createVNode(_component_number_slider, {
                modelValue: $data.innerElement.opacity,
                "onUpdate:modelValue": _cache[9] || (_cache[9] = ($event) => $data.innerElement.opacity = $event),
                label: "\u4E0D\u900F\u660E",
                step: 0.01,
                maxValue: 1,
                onFinish: _cache[10] || (_cache[10] = (value) => $options.finish("opacity", value))
              }, null, 8, ["modelValue"])
            ])
          ]),
          _: 1
        }),
        _hoisted_5$a,
        createVNode(_component_icon_item_select, {
          class: "style-item",
          label: "",
          data: $data.layerIconList,
          onFinish: $options.layerAction
        }, null, 8, ["data", "onFinish"]),
        createVNode(_component_icon_item_select, {
          data: $data.alignIconList,
          onFinish: $options.alignAction
        }, null, 8, ["data", "onFinish"]),
        _hoisted_6$6
      ]),
      _: 1
    }, 8, ["modelValue"])
  ]);
}
var wSvgStyle = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$e], ["__scopeId", "data-v-a6306dae"]]);
var __glob_0_32 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": wSvgStyle
}, Symbol.toStringTag, { value: "Module" }));
const styleIconList1 = [
  {
    key: "fontWeight",
    icon: "icon-bold",
    tip: "\u52A0\u7C97",
    value: ["normal", "bold"],
    select: false
  },
  {
    key: "fontStyle",
    icon: "icon-italic",
    tip: "\u659C\u4F53",
    value: ["normal", "italic"],
    select: false
  },
  {
    key: "textDecoration",
    icon: "icon-underline",
    tip: "\u4E0B\u5212\u7EBF",
    value: ["none", "underline"],
    select: false
  },
  {
    key: "textDecoration",
    icon: "icon-strikethrough",
    tip: "\u5220\u9664\u7EBF",
    value: ["none", "line-through"],
    select: false
  },
  {
    key: "writingMode",
    icon: "icon-textorientation",
    tip: "\u7AD6\u7248\u6587\u5B57",
    value: ["horizontal-tb", "vertical-rl"],
    select: false
  }
];
const styleIconList2 = [
  {
    key: "textAlign",
    icon: "icon-align-left-text",
    tip: "\u5DE6\u5BF9\u9F50",
    value: "left",
    select: false
  },
  {
    key: "textAlign",
    icon: "icon-align-center-text",
    tip: "\u5C45\u4E2D\u5BF9\u9F50",
    value: "center",
    select: false
  },
  {
    key: "textAlign",
    icon: "icon-align-right-text",
    tip: "\u53F3\u5BF9\u9F50",
    value: "right",
    select: false
  },
  {
    key: "textAlign",
    icon: "icon-align-justify-text",
    tip: "\u4E24\u7AEF\u5BF9\u9F50",
    value: "justify",
    select: false
  }
];
const alignIconList = [
  {
    key: "align",
    icon: "icon-align-left",
    tip: "\u5DE6\u5BF9\u9F50",
    value: "left"
  },
  {
    key: "align",
    icon: "icon-align-center-horiz",
    tip: "\u6C34\u5E73\u5C45\u4E2D\u5BF9\u9F50",
    value: "ch"
  },
  {
    key: "align",
    icon: "icon-align-right",
    tip: "\u53F3\u5BF9\u9F50",
    value: "right"
  },
  {
    key: "align",
    icon: "icon-align-top",
    tip: "\u4E0A\u5BF9\u9F50",
    value: "top"
  },
  {
    key: "align",
    icon: "icon-align-center-verti",
    tip: "\u5782\u76F4\u5C45\u4E2D\u5BF9\u9F50",
    value: "cv"
  },
  {
    key: "align",
    icon: "icon-align-bottom",
    tip: "\u4E0B\u5BF9\u9F50",
    value: "bottom"
  }
];
var valueSelect_vue_vue_type_style_index_0_scoped_true_lang = "";
var valueSelect_vue_vue_type_style_index_1_scoped_true_lang = "";
const NAME$5 = "value-input";
const _sfc_main$h = {
  name: NAME$5,
  components: { ElTabPane, ElTabs },
  props: {
    label: {
      default: ""
    },
    modelValue: {
      default: ""
    },
    suffix: {
      default: ""
    },
    data: {
      required: true
    },
    disable: {
      default: true
    },
    inputWidth: {
      default: "80px"
    },
    readonly: {
      default: false
    },
    step: {
      default: 1
    }
  },
  emits: ["finish", "update:modelValue"],
  data() {
    return {
      inputBorder: false,
      tagText: "",
      width: "0",
      innerValue: "",
      innerPreview: "",
      activeTab: "\u4E2D\u6587"
    };
  },
  computed: {
    showValue() {
      return this.innerValue;
    }
  },
  watch: {
    modelValue(value) {
      this.innerValue = typeof this.modelValue === "object" ? this.modelValue.alias : this.modelValue;
    },
    inputBorder(value) {
      if (value) {
        this.tagText = this.innerValue;
      } else {
        if (this.innerValue !== this.tagText) {
          this.$emit("finish", this.innerValue);
        }
      }
    }
  },
  created() {
    this.innerValue = typeof this.modelValue === "object" ? this.modelValue.alias : this.modelValue;
  },
  mounted() {
    this.width = this.$refs.select.offsetWidth;
  },
  methods: {
    selectItem(item) {
      let value = typeof item === "object" ? item.alias : item;
      if (this.innerValue !== value) {
        this.innerValue = value;
        this.innerPreview = item.preview;
        this.$emit("finish", item);
      }
    },
    inputText(e2) {
      this.innerValue = e2.target.value;
      setTimeout(() => {
        this.$emit("finish", this.innerValue);
      }, 100);
    },
    opNumber(e2) {
      e2.stopPropagation();
      switch (e2.keyCode) {
        case 38:
          typeof this.innerValue === "number" && this.up();
          return;
        case 40:
          typeof this.innerValue === "number" && this.down();
          return;
      }
    },
    up() {
      this.$emit("update:modelValue", parseInt(this.modelValue || 0, 10) + this.step);
    },
    down() {
      let value = parseInt(this.modelValue || 0, 10) - this.step;
      if (value < 0) {
        value = 0;
      }
      this.$emit("update:modelValue", value);
    }
  }
};
const _withScopeId$6 = (n) => (pushScopeId("data-v-23aae044"), n = n(), popScopeId(), n);
const _hoisted_1$f = {
  key: 0,
  class: "input-label"
};
const _hoisted_2$b = {
  key: 0,
  class: "list-ul"
};
const _hoisted_3$b = ["onClick"];
const _hoisted_4$a = ["src"];
const _hoisted_5$9 = { key: 1 };
const _hoisted_6$5 = {
  key: 1,
  class: "tabs-wrap"
};
const _hoisted_7$4 = { class: "list-ul" };
const _hoisted_8$3 = ["onClick"];
const _hoisted_9$3 = ["src"];
const _hoisted_10$3 = ["readonly", "value"];
const _hoisted_11$2 = /* @__PURE__ */ _withScopeId$6(() => /* @__PURE__ */ createElementVNode("div", { class: "op-btn" }, [
  /* @__PURE__ */ createElementVNode("i", { class: "iconfont icon-down1" })
], -1));
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tab_pane = resolveComponent("el-tab-pane");
  const _component_el_tabs = resolveComponent("el-tabs");
  const _component_el_popover = resolveComponent("el-popover");
  return openBlock(), createElementBlock("div", {
    ref: "select",
    class: "value-select",
    style: normalizeStyle({ width: $props.inputWidth })
  }, [
    $props.label ? (openBlock(), createElementBlock("p", _hoisted_1$f, toDisplayString($props.label), 1)) : createCommentVNode("", true),
    createVNode(_component_el_popover, {
      placement: "bottom-end",
      trigger: "click",
      width: "auto"
    }, {
      reference: withCtx(() => [
        createElementVNode("div", {
          class: normalizeClass(["input-wrap", { active: $data.inputBorder }]),
          style: normalizeStyle({ width: $props.inputWidth })
        }, [
          createElementVNode("input", {
            style: normalizeStyle({ fontFamily: $props.modelValue.value }),
            class: normalizeClass(["real-input", { disable: !$props.disable }]),
            readonly: $props.readonly ? "readonly" : false,
            type: "text",
            value: $options.showValue,
            onInput: _cache[1] || (_cache[1] = (...args) => $options.inputText && $options.inputText(...args)),
            onFocus: _cache[2] || (_cache[2] = ($event) => $data.inputBorder = true),
            onBlur: _cache[3] || (_cache[3] = ($event) => $data.inputBorder = false),
            onKeydown: _cache[4] || (_cache[4] = (e2) => $options.opNumber(e2))
          }, null, 46, _hoisted_10$3),
          _hoisted_11$2
        ], 6)
      ]),
      default: withCtx(() => [
        $props.data && Array.isArray($props.data) ? (openBlock(), createElementBlock("ul", _hoisted_2$b, [
          (openBlock(true), createElementBlock(Fragment, null, renderList($props.data, (listItem) => {
            return openBlock(), createElementBlock("li", {
              key: typeof listItem === "object" ? listItem.alias : listItem,
              class: normalizeClass({ active: listItem == $data.innerValue }),
              onClick: ($event) => $options.selectItem(listItem)
            }, [
              listItem.preview ? (openBlock(), createElementBlock("img", {
                key: 0,
                class: "preview",
                src: listItem.preview
              }, null, 8, _hoisted_4$a)) : (openBlock(), createElementBlock("span", _hoisted_5$9, toDisplayString((typeof listItem === "object" ? listItem.alias : listItem) + $props.suffix), 1))
            ], 10, _hoisted_3$b);
          }), 128))
        ])) : (openBlock(), createElementBlock("div", _hoisted_6$5, [
          createVNode(_component_el_tabs, {
            modelValue: $data.activeTab,
            "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.activeTab = $event)
          }, {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList($props.data, (val, key, i) => {
                return openBlock(), createBlock(_component_el_tab_pane, {
                  key: "tab" + i,
                  label: key,
                  name: key
                }, {
                  default: withCtx(() => [
                    createElementVNode("ul", _hoisted_7$4, [
                      (openBlock(true), createElementBlock(Fragment, null, renderList($props.data[key], (listItem) => {
                        return openBlock(), createElementBlock("li", {
                          key: typeof listItem === "object" ? listItem.alias : listItem,
                          class: normalizeClass({ active: listItem == $data.innerValue }),
                          onClick: ($event) => $options.selectItem(listItem)
                        }, [
                          listItem.preview ? (openBlock(), createElementBlock("img", {
                            key: 0,
                            class: "preview",
                            src: listItem.preview
                          }, null, 8, _hoisted_9$3)) : (openBlock(), createElementBlock("span", {
                            key: 1,
                            style: normalizeStyle({ fontFamily: `'${listItem.value}'` })
                          }, toDisplayString((typeof listItem === "object" ? listItem.alias : listItem) + $props.suffix), 5))
                        ], 10, _hoisted_8$3);
                      }), 128))
                    ])
                  ]),
                  _: 2
                }, 1032, ["label", "name"]);
              }), 128))
            ]),
            _: 1
          }, 8, ["modelValue"])
        ]))
      ]),
      _: 1
    })
  ], 4);
}
var valueSelect = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$d], ["__scopeId", "data-v-23aae044"]]);
var __glob_0_12 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": valueSelect
}, Symbol.toStringTag, { value: "Module" }));
var elInputNumber = "";
var elCheckbox = "";
var TextWrap_vue_vue_type_style_index_0_scoped_true_lang = "";
let froze_font_effect_list = [];
const _sfc_main$g = defineComponent({
  components: { colorSelect, ElInputNumber, numberInput, ElCheckbox, draggable: draggableComponent },
  props: ["modelValue", "degree", "data"],
  emits: ["update:modelValue"],
  setup(props2, { emit: emit2 }) {
    const state = reactive$1({
      strength: 50,
      visiable: false,
      list: [],
      layers: [],
      draging: false,
      unfold: true
    });
    const dragOptions = {
      animation: 300,
      ghostClass: "ghost",
      chosenClass: "choose"
    };
    const coefficient = computed$1(() => Math.round(160 / 27));
    let rawData = [];
    onMounted(async () => {
      await nextTick();
      if (!props2.data.textEffects) {
        return;
      }
      const clone2 = JSON.parse(JSON.stringify(props2.data.textEffects)) || [];
      state.layers = clone2.map((x) => {
        x.uuid = String(Math.random());
        return x;
      }).reverse();
      rawData = JSON.parse(JSON.stringify(state.layers));
    });
    watch(
      () => state.layers,
      (v) => {
        const newEffect = v.map((x) => {
          delete x.uuid;
          return x;
        });
        emit2("update:modelValue", newEffect.reverse());
      },
      { deep: true }
    );
    const selectEffect = async (id) => {
      state.visiable = false;
      if (id) {
        const { data } = await api$1.home.getTempDetail({ id, type: 1 });
        state.layers = JSON.parse(data).textEffects.map((x) => {
          x.uuid = String(Math.random());
          return x;
        }).reverse();
      } else
        state.layers = [];
    };
    const removeLayer = (i) => {
      state.layers.splice(i, 1);
      rawData = JSON.parse(JSON.stringify(state.layers));
    };
    const addLayer = () => {
      const filling = { enable: false, type: 0, color: "#000000ff" };
      const stroke = { enable: false, width: 0, color: "#000000ff", type: "outer" };
      const offset = { enable: false, x: 0, y: 0 };
      const shadow = { enable: false, color: "#000000ff", offsetX: 0, offsetY: 0, blur: 0, opacity: 0 };
      state.layers.unshift({ filling, stroke, shadow, offset, uuid: String(Math.random()) });
      rawData = JSON.parse(JSON.stringify(state.layers));
    };
    const finish = () => {
    };
    const colorChange = (e2, item) => {
      const modeStr = {
        \u6E10\u53D8: 2,
        \u7EAF\u8272: 0
      };
      item.gradient = {
        angle: e2.angle,
        stops: e2.stops
      };
      setTimeout(() => {
        item.type = modeStr[e2.mode] || 0;
      }, 100);
    };
    const onDone = () => {
      state.draging = false;
    };
    const strengthChange = (x) => {
      const effectScale = 1 + (x - 50) / 50;
      state.layers.forEach((item, index2) => {
        if (item.stroke) {
          item.stroke.width = rawData[index2].stroke.width * effectScale;
        }
        if (item.shadow) {
          item.shadow.blur = rawData[index2].shadow.blur * effectScale;
        }
      });
    };
    const openSet = async () => {
      state.visiable = !state.visiable;
      if (froze_font_effect_list.length <= 0) {
        const { list } = await api$1.home.getCompList({
          cate: 12,
          type: 1,
          per_page: 30
        });
        state.list = list;
        froze_font_effect_list = list;
      } else
        state.list = froze_font_effect_list;
    };
    return {
      ...toRefs(state),
      selectEffect,
      finish,
      coefficient,
      removeLayer,
      addLayer,
      dragOptions,
      onDone,
      strengthChange,
      openSet,
      colorChange,
      getGradientOrImg
    };
  },
  methods: {}
});
const _withScopeId$5 = (n) => (pushScopeId("data-v-746de162"), n = n(), popScopeId(), n);
const _hoisted_1$e = { class: "card-header" };
const _hoisted_2$a = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createElementVNode("span", { class: "title" }, "\u6587\u5B57\u7279\u6548", -1));
const _hoisted_3$a = { class: "select__box" };
const _hoisted_4$9 = ["onClick"];
const _hoisted_5$8 = ["src"];
const _hoisted_6$4 = { class: "text item" };
const _hoisted_7$3 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createElementVNode("span", { style: { "width": "65px" } }, "\u5F3A\u5EA6", -1));
const _hoisted_8$2 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createElementVNode("b", null, "\u9AD8\u7EA7\u7F16\u8F91", -1));
const _hoisted_9$2 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createElementVNode("div", { class: "line" }, null, -1));
const _hoisted_10$2 = { style: { "display": "flex", "justify-content": "space-between" } };
const _hoisted_11$1 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createElementVNode("div", { class: "line" }, null, -1));
const _hoisted_12$1 = { class: "feature__grab-wrap" };
const _hoisted_13 = { class: "layer__title" };
const _hoisted_14 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createElementVNode("i", { class: "icon sd-yidong" }, null, -1));
const _hoisted_15 = { style: { "font-size": "12px" } };
const _hoisted_16 = /* @__PURE__ */ _withScopeId$5(() => /* @__PURE__ */ createElementVNode("b", null, "\u7279\u6548\u5C42", -1));
const _hoisted_17 = ["onClick"];
const _hoisted_18 = {
  key: 0,
  class: "feature__item"
};
const _hoisted_19 = {
  key: 1,
  class: "feature__item"
};
const _hoisted_20 = {
  key: 2,
  class: "feature__item"
};
const _hoisted_21 = {
  key: 3,
  class: "feature__item"
};
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_button = resolveComponent("el-button");
  const _component_el_popover = resolveComponent("el-popover");
  const _component_el_slider = resolveComponent("el-slider");
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_color_select = resolveComponent("color-select");
  const _component_el_input_number = resolveComponent("el-input-number");
  const _component_numberInput = resolveComponent("numberInput");
  const _component_draggable = resolveComponent("draggable");
  const _component_el_collapse_item = resolveComponent("el-collapse-item");
  const _component_el_card = resolveComponent("el-card");
  return openBlock(), createBlock(_component_el_card, {
    class: "box-card",
    shadow: "hover",
    "body-style": { padding: "20px" }
  }, {
    header: withCtx(() => [
      createElementVNode("div", _hoisted_1$e, [
        createElementVNode("div", {
          style: normalizeStyle({
            position: "relative",
            width: "27px",
            fontSize: "27px",
            color: _ctx.data.color,
            fontWeight: _ctx.data.fontWeight,
            fontStyle: _ctx.data.fontStyle,
            textDecoration: _ctx.data.textDecoration,
            opacity: _ctx.data.opacity,
            backgroundColor: _ctx.data.backgroundColor
          })
        }, [
          (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.modelValue, (ef, efi) => {
            return openBlock(), createElementBlock("div", {
              key: efi + "effect",
              style: normalizeStyle({
                color: ef.filling && ef.filling.enable && ef.filling.type === 0 ? ef.filling.color : "transparent",
                webkitTextStroke: ef.stroke && ef.stroke.enable ? `${ef.stroke.width / _ctx.coefficient}px ${ef.stroke.color}` : void 0,
                textShadow: ef.shadow && ef.shadow.enable ? `${ef.shadow.offsetX / _ctx.coefficient}px ${ef.shadow.offsetY / _ctx.coefficient}px ${ef.shadow.blur / _ctx.coefficient}px ${ef.shadow.color}` : void 0,
                backgroundImage: ef.filling && ef.filling.enable ? ef.filling.type === 0 ? void 0 : _ctx.getGradientOrImg(ef) : void 0,
                webkitBackgroundClip: ef.filling && ef.filling.enable ? ef.filling.type === 0 ? void 0 : "text" : void 0
              }),
              class: "demo"
            }, " A ", 4);
          }), 128)),
          createTextVNode(" A ")
        ], 4),
        _hoisted_2$a,
        createVNode(_component_el_popover, {
          visible: _ctx.visiable,
          placement: "left",
          width: 220,
          trigger: "click"
        }, {
          reference: withCtx(() => [
            createVNode(_component_el_button, {
              class: "button",
              link: "",
              onClick: _ctx.openSet
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.visiable ? "\u53D6\u6D88" : "\u9009\u62E9"), 1)
              ]),
              _: 1
            }, 8, ["onClick"])
          ]),
          default: withCtx(() => [
            createElementVNode("div", _hoisted_3$a, [
              createElementVNode("div", {
                class: "select__box__select-item",
                onClick: _cache[0] || (_cache[0] = ($event) => _ctx.selectEffect(null))
              }, "\u65E0"),
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.list, (l, li) => {
                return openBlock(), createElementBlock("div", {
                  key: "list" + li,
                  class: "select__box__select-item",
                  onClick: ($event) => _ctx.selectEffect(l.id)
                }, [
                  createElementVNode("img", {
                    src: l.cover
                  }, null, 8, _hoisted_5$8)
                ], 8, _hoisted_4$9);
              }), 128))
            ])
          ]),
          _: 1
        }, 8, ["visible"])
      ])
    ]),
    default: withCtx(() => [
      withDirectives(createElementVNode("div", _hoisted_6$4, [
        _hoisted_7$3,
        createTextVNode(),
        createVNode(_component_el_slider, {
          modelValue: _ctx.strength,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.strength = $event),
          "show-input": "",
          maxValue: 100,
          "input-size": "small",
          "show-input-controls": false,
          onInput: _ctx.strengthChange
        }, null, 8, ["modelValue", "onInput"])
      ], 512), [
        [vShow, _ctx.layers && _ctx.layers.length > 0]
      ]),
      createVNode(_component_el_collapse_item, null, {
        title: withCtx(() => [
          _hoisted_8$2
        ]),
        default: withCtx(() => [
          _hoisted_9$2,
          createElementVNode("div", _hoisted_10$2, [
            createVNode(_component_el_button, {
              class: "add-layer",
              size: "small",
              type: "primary",
              link: "",
              onClick: _ctx.addLayer
            }, {
              default: withCtx(() => [
                createTextVNode(" + \u65B0\u5EFA\u7279\u6548\u5C42")
              ]),
              _: 1
            }, 8, ["onClick"]),
            createTextVNode(),
            withDirectives(createVNode(_component_el_button, {
              class: "add-layer",
              size: "small",
              type: "primary",
              link: "",
              onClick: _cache[2] || (_cache[2] = ($event) => _ctx.unfold = !_ctx.unfold)
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.unfold ? "\u6536\u8D77" : "\u5C55\u5F00") + "\u5168\u90E8", 1)
              ]),
              _: 1
            }, 512), [
              [vShow, _ctx.layers && _ctx.layers.length > 0]
            ])
          ]),
          _hoisted_11$1,
          createVNode(_component_draggable, mergeProps({
            modelValue: _ctx.layers,
            "onUpdate:modelValue": _cache[5] || (_cache[5] = ($event) => _ctx.layers = $event),
            handle: ".sd-yidong",
            "item-key": "uuid"
          }, _ctx.dragOptions), {
            item: withCtx(({ element, index: index2 }) => [
              createElementVNode("div", _hoisted_12$1, [
                createElementVNode("div", _hoisted_13, [
                  _hoisted_14,
                  createElementVNode("span", _hoisted_15, [
                    _hoisted_16,
                    createTextVNode(" " + toDisplayString(index2 + 1), 1)
                  ]),
                  createElementVNode("i", {
                    class: "icon sd-delete",
                    onClick: ($event) => _ctx.removeLayer(index2)
                  }, null, 8, _hoisted_17)
                ]),
                element.filling && [0, 2, "0", "2"].includes(element.filling.type) ? withDirectives((openBlock(), createElementBlock("div", _hoisted_18, [
                  createVNode(_component_el_checkbox, {
                    modelValue: element.filling.enable,
                    "onUpdate:modelValue": ($event) => element.filling.enable = $event,
                    label: "\u586B\u5145",
                    class: "feature__header"
                  }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                  createVNode(_component_color_select, {
                    modelValue: element.filling.color,
                    "onUpdate:modelValue": ($event) => element.filling.color = $event,
                    width: "28px",
                    modes: ["\u7EAF\u8272", "\u6E10\u53D8"],
                    label: "",
                    onChange: ($event) => _ctx.colorChange($event, element.filling)
                  }, null, 8, ["modelValue", "onUpdate:modelValue", "onChange"])
                ], 512)), [
                  [vShow, _ctx.unfold]
                ]) : createCommentVNode("", true),
                element.stroke ? withDirectives((openBlock(), createElementBlock("div", _hoisted_19, [
                  createVNode(_component_el_checkbox, {
                    modelValue: element.stroke.enable,
                    "onUpdate:modelValue": ($event) => element.stroke.enable = $event,
                    label: "\u63CF\u8FB9",
                    class: "feature__header"
                  }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                  createVNode(_component_el_input_number, {
                    modelValue: element.stroke.width,
                    "onUpdate:modelValue": ($event) => element.stroke.width = $event,
                    style: { "width": "65px", "margin-right": "0.5rem" },
                    min: 0,
                    size: "small",
                    "controls-position": "right"
                  }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                  createVNode(_component_color_select, {
                    modelValue: element.stroke.color,
                    "onUpdate:modelValue": ($event) => element.stroke.color = $event,
                    width: "28px",
                    label: "",
                    onFinish: _cache[3] || (_cache[3] = (value) => _ctx.finish("color", value))
                  }, null, 8, ["modelValue", "onUpdate:modelValue"])
                ], 512)), [
                  [vShow, _ctx.unfold]
                ]) : createCommentVNode("", true),
                element.offset ? withDirectives((openBlock(), createElementBlock("div", _hoisted_20, [
                  createVNode(_component_el_checkbox, {
                    modelValue: element.offset.enable,
                    "onUpdate:modelValue": ($event) => element.offset.enable = $event,
                    label: "\u504F\u79FB",
                    class: "feature__header"
                  }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                  createVNode(_component_numberInput, {
                    modelValue: element.offset.x,
                    "onUpdate:modelValue": ($event) => element.offset.x = $event,
                    style: { "width": "49.5px", "margin-right": "2px" },
                    prepend: "x",
                    type: "simple"
                  }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                  createVNode(_component_numberInput, {
                    modelValue: element.offset.y,
                    "onUpdate:modelValue": ($event) => element.offset.y = $event,
                    style: { "width": "49.5px" },
                    prepend: "y",
                    type: "simple"
                  }, null, 8, ["modelValue", "onUpdate:modelValue"])
                ], 512)), [
                  [vShow, _ctx.unfold]
                ]) : createCommentVNode("", true),
                element.shadow ? withDirectives((openBlock(), createElementBlock("div", _hoisted_21, [
                  createVNode(_component_el_checkbox, {
                    modelValue: element.shadow.enable,
                    "onUpdate:modelValue": ($event) => element.shadow.enable = $event,
                    label: "\u9634\u5F71",
                    class: "feature__header"
                  }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                  createVNode(_component_numberInput, {
                    modelValue: element.shadow.blur,
                    "onUpdate:modelValue": ($event) => element.shadow.blur = $event,
                    prepend: "blur",
                    minValue: 0,
                    style: { "width": "30px", "margin-right": "2px" },
                    type: "simple"
                  }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                  createVNode(_component_numberInput, {
                    modelValue: element.shadow.offsetX,
                    "onUpdate:modelValue": ($event) => element.shadow.offsetX = $event,
                    prepend: "x",
                    style: { "width": "30px", "margin-right": "2px" },
                    type: "simple"
                  }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                  createVNode(_component_numberInput, {
                    modelValue: element.shadow.offsetY,
                    "onUpdate:modelValue": ($event) => element.shadow.offsetY = $event,
                    prepend: "y",
                    style: { "width": "30px", "margin-right": "0.5rem" },
                    type: "simple"
                  }, null, 8, ["modelValue", "onUpdate:modelValue"]),
                  createVNode(_component_color_select, {
                    modelValue: element.shadow.color,
                    "onUpdate:modelValue": ($event) => element.shadow.color = $event,
                    width: "28px",
                    label: "",
                    onFinish: _cache[4] || (_cache[4] = (value) => _ctx.finish("color", value))
                  }, null, 8, ["modelValue", "onUpdate:modelValue"])
                ], 512)), [
                  [vShow, _ctx.unfold]
                ]) : createCommentVNode("", true)
              ])
            ]),
            _: 1
          }, 16, ["modelValue"])
        ]),
        _: 1
      })
    ]),
    _: 1
  });
}
var effectWrap = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$c], ["__scopeId", "data-v-746de162"]]);
var __glob_0_24 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": effectWrap
}, Symbol.toStringTag, { value: "Module" }));
var index_vue_vue_type_style_index_0_scoped_true_lang = "";
var index_vue_vue_type_style_index_1_scoped_true_lang = "";
const _sfc_main$f = {
  name: "WTextarea",
  props: {
    modelValue: {
      type: String,
      default: ""
    },
    tag: {
      type: String,
      default: "wise"
    },
    tools: {
      type: Array,
      default() {
        return [
          { type: "tag", text: "\u63D2\u5165\u53D8\u91CF" }
        ];
      }
    },
    maxlength: {
      type: [String, Number],
      default: ""
    }
  },
  emits: ["input", "add", "update:modelValue"],
  data() {
    return {
      currentText: this.modelValue,
      contentId: `content${this.getGuid()}`,
      isLocked: false,
      currentTagId: null,
      savedRange: {},
      vars: []
    };
  },
  computed: {
    count() {
      let num = this.maxlength - this.currentText.length;
      let text = num < 0 ? `\u5DF2\u8D85\u51FA${Math.abs(num)}\u4E2A\u5B57\u7B26` : `\u8FD8\u53EF\u4EE5\u8F93\u5165${num}\u4E2A\u5B57\u7B26`;
      return { num, text };
    }
  },
  watch: {
    modelValue(val) {
      if (!this.isLocked) {
        this.$refs.wTextareaContent.innerHTML = val;
      }
    },
    isLocked(val) {
      if (val) {
        const { uuid } = this.$store.getters.dActiveElement;
        this.updateWidgetData({
          uuid,
          key: "editable",
          value: true,
          pushHistory: false
        });
      }
    }
  },
  mounted() {
    this.currentText && (this.$refs.wTextareaContent.innerHTML = this.currentText);
    this.createStyle();
    this.initData();
    document.addEventListener("selectionchange", this.selectHandler);
  },
  beforeUnmount() {
    document.removeEventListener("selectionchange", this.selectHandler);
  },
  methods: {
    ...mapActions(["updateWidgetData"]),
    async initData() {
      const res = await api$1.home.getVars();
      let vars = [];
      for (const [key, value] of Object.entries(res.data)) {
        vars.push({ title: value, key });
      }
      this.vars = vars;
    },
    updateData(text) {
      this.$emit("update:modelValue", text);
    },
    createStyle() {
      let style = document.createElement("style");
      style.innerHTML = `.w-textarea ${this.tag} {
        cursor: default;
        -webkit-user-modify: read-only !important;
      }`;
      this.$refs.wTextarea.appendChild(style);
    },
    closeModal() {
      this.form.text = "";
      this.showModal = false;
    },
    addTag({ title: text }) {
      let node = document.createElement(this.tag);
      node.innerText = text;
      node.id = this.getGuid();
      this.insertNode(node);
    },
    insertNode(node) {
      var _a2, _b;
      (_b = (_a2 = this == null ? void 0 : this.savedRange) == null ? void 0 : _a2.deleteContents) == null ? void 0 : _b.call(_a2);
      this.savedRange.insertNode(node);
      let target = this.$refs.wTextareaContent;
      this.updateData(target.innerHTML);
      this.currentText = target.innerText;
    },
    handleInput(target) {
      this.updateData(target.innerHTML);
      this.currentText = target.innerText;
    },
    handleDelete(e2) {
      if (this.currentTagId) {
        let t = document.getElementById(this.currentTagId);
        this.$refs.wTextareaContent.removeChild(t);
        this.currentTagId = null;
        e2.preventDefault();
        this.handleInput(e2.target);
      }
    },
    inputClick(e2) {
      this.isLocked = true;
      const TAG_NAME = e2.target.nodeName;
      if (TAG_NAME === this.tag.toUpperCase()) {
        this.currentTagId = e2.target.id;
        e2.target.className = "active";
      } else if (this.currentTagId) {
        let target = document.getElementById(this.currentTagId);
        target.className = "";
        this.currentTagId = null;
      } else {
        this.currentTagId = null;
      }
    },
    getGuid() {
      return `r${new Date().getTime()}d${Math.ceil(Math.random() * 1e3)}`;
    },
    selectHandler() {
      let sel = window.getSelection();
      let range = sel.rangeCount > 0 ? sel.getRangeAt(0) : null;
      if (range && range.commonAncestorContainer.ownerDocument.activeElement.id === this.contentId) {
        this.savedRange = range;
      }
    }
  }
};
const _hoisted_1$d = {
  ref: "wTextarea",
  class: "w-textarea"
};
const _hoisted_2$9 = ["id"];
const _hoisted_3$9 = {
  key: 0,
  class: "w-textarea_tools"
};
const _hoisted_4$8 = ["onClick"];
const _hoisted_5$7 = { class: "w-textarea_dialog" };
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$d, [
    createElementVNode("div", {
      id: $data.contentId,
      ref: "wTextareaContent",
      class: "w-textarea_input text-left",
      onClick: _cache[0] || (_cache[0] = ($event) => $options.inputClick($event)),
      onFocus: _cache[1] || (_cache[1] = ($event) => $data.isLocked = true),
      onBlur: _cache[2] || (_cache[2] = ($event) => $data.isLocked = false),
      onKeydown: _cache[3] || (_cache[3] = withKeys(($event) => $options.handleDelete($event), ["delete"])),
      onInput: _cache[4] || (_cache[4] = ($event) => $options.handleInput($event.target))
    }, null, 40, _hoisted_2$9),
    $data.vars.length > 0 || $props.maxlength ? (openBlock(), createElementBlock("div", _hoisted_3$9, [
      (openBlock(true), createElementBlock(Fragment, null, renderList($data.vars, (item) => {
        return openBlock(), createElementBlock("button", {
          key: item.key,
          class: "w-textarea_tools__item",
          onClick: ($event) => $options.addTag(item)
        }, toDisplayString(item.title), 9, _hoisted_4$8);
      }), 128))
    ])) : createCommentVNode("", true),
    createElementVNode("div", _hoisted_5$7, [
      renderSlot(_ctx.$slots, "default", {}, void 0, true)
    ])
  ], 512);
}
var textArea = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$b], ["__scopeId", "data-v-7965140c"]]);
var usePageFontsFilter = () => {
  const collector = /* @__PURE__ */ new Set();
  const fonts = {};
  const { dWidgets: widgets } = erpStore.getters;
  for (let i = 0; i < widgets.length; i++) {
    const { type, fontClass } = widgets[i];
    if (type === "w-text") {
      collector.add(fontClass.id);
      fonts[fontClass.id] = toRaw(fontClass);
    }
  }
  return Array.from(collector).map((id) => fonts[id]);
};
var wTextStyle_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$4 = "w-text-style";
const _sfc_main$e = {
  name: NAME$4,
  components: { numberInput, colorSelect, iconItemSelect, textArea, valueSelect, effectWrap, numberSlider },
  data() {
    return {
      activeNames: [],
      innerElement: {},
      tag: false,
      ingoreKeys: ["left", "top", "name", "width", "height", "text", "color", "backgroundColor"],
      fontSizeList: [12, 14, 24, 26, 28, 30, 36, 48, 60, 72, 96, 108, 120, 140, 180, 200, 250, 300, 400, 500],
      fontClassList: [],
      lineHeightList: [1, 1.5, 2],
      letterSpacingList: [0, 10, 25, 50, 75, 100, 200],
      layerIconList,
      styleIconList1,
      styleIconList2,
      alignIconList
    };
  },
  computed: {
    ...mapGetters(["dActiveElement", "dMoving"]),
    isModel() {
      return this.$store.state.templateMode === 2;
    },
    isDraw() {
      return true;
    }
  },
  watch: {
    dActiveElement: {
      handler(newValue, oldValue) {
        this.change();
      },
      deep: true
    },
    innerElement: {
      handler(newValue, oldValue) {
        this.changeValue();
      },
      deep: true
    }
  },
  created() {
    this.timer = null;
    this.change();
    setTimeout(() => {
      this.loadFonts();
    }, 100);
  },
  methods: {
    ...mapActions(["updateWidgetData", "updateAlign", "updateLayerIndex", "pushHistory"]),
    testEffect({ key, value, style }) {
      console.log("\u9009\u62E9\u56DE\u8C03");
      const uuid = this.dActiveElement.uuid;
      this.$store.commit("setWidgetStyle", { uuid, key, value });
      if (style) {
        this.finish("color", style.color || "");
      }
    },
    loadFonts() {
      const localFonts = useFontStore.list;
      const fontLists = { \u5F53\u524D\u9875\u9762: [], \u4E2D\u6587: [], \u82F1\u6587: [] };
      for (const font of localFonts) {
        const { id, oid, value, url, alias, preview, lang } = font;
        const item = { id, oid, value, url, alias, preview };
        lang === "zh" ? fontLists["\u4E2D\u6587"].unshift(item) : fontLists["\u82F1\u6587"].unshift(item);
      }
      fontLists["\u5F53\u524D\u9875\u9762"] = usePageFontsFilter();
      this.fontClassList = fontLists;
    },
    change() {
      if (this.timer) {
        return;
      }
      this.timer = true;
      setTimeout(() => {
        this.timer = null;
      }, 300);
      this.tag = true;
      this.innerElement = JSON.parse(JSON.stringify(this.dActiveElement));
      this.changeStyleIconList();
    },
    changeValue() {
      if (this.tag) {
        this.tag = false;
        return;
      }
      if (this.dMoving) {
        return;
      }
      for (let key in this.innerElement) {
        if (this.ingoreKeys.indexOf(key) !== -1) {
          this.dActiveElement[key] = this.innerElement[key];
        } else if (key !== "setting" && key !== "record" && this.innerElement[key] !== this.dActiveElement[key]) {
          this.updateWidgetData({
            uuid: this.dActiveElement.uuid,
            key,
            value: this.innerElement[key],
            pushHistory: false
          });
        }
      }
    },
    finish(key, value) {
      this.updateWidgetData({
        uuid: this.dActiveElement.uuid,
        key,
        value,
        pushHistory: false
      });
      setTimeout(() => {
        key === "fontClass" && (this.fontClassList["\u5F53\u524D\u9875\u9762"] = usePageFontsFilter());
      }, 300);
    },
    layerAction(item) {
      this.updateLayerIndex({
        uuid: this.dActiveElement.uuid,
        value: item.value
      });
    },
    async textStyleAction(item) {
      let value = item.key === "textAlign" ? item.value : item.value[item.select ? 1 : 0];
      this.innerElement[item.key] = value;
      item.key === "writingMode" && this.relationChange();
      await this.$nextTick();
      this.$store.commit("updateRect");
    },
    async alignAction(item) {
      this.updateAlign({
        align: item.value,
        uuid: this.dActiveElement.uuid
      });
      await this.$nextTick();
      this.$store.commit("updateRect");
    },
    changeStyleIconList() {
      for (let i = 0; i < this.styleIconList1.length; ++i) {
        let key = this.styleIconList1[i].key;
        this.styleIconList1[i].select = false;
        switch (key) {
          case "fontWeight":
          case "fontStyle":
            if (this.innerElement[key] !== "normal") {
              this.styleIconList1[i].select = true;
            }
            break;
          case "textDecoration":
            if (this.innerElement[key] !== this.styleIconList1[i].value[0] && this.innerElement[key] == this.styleIconList1[i].value[1]) {
              this.styleIconList1[i].select = !this.styleIconList1[i].select;
            }
            break;
          case "writingMode":
            if (this.innerElement[key] !== this.styleIconList1[i].value[0]) {
              this.styleIconList1[i].select = true;
            }
            break;
        }
      }
      for (let i = 0; i < this.styleIconList2.length; i++) {
        let key = this.styleIconList2[i].key;
        this.styleIconList2[i].select = false;
        if (key === "textAlign" && this.innerElement[key] === this.styleIconList2[i].value) {
          this.styleIconList2[i].select = true;
          continue;
        }
      }
    },
    relationChange() {
      setTimeout(() => {
        if (this.dActiveElement.writingMode) {
          const w_record = this.dActiveElement.width;
          this.innerElement.width = this.dActiveElement.height;
          this.innerElement.height = w_record;
        }
      }, 10);
    }
  }
};
const _hoisted_1$c = { id: "w-text-style" };
const _hoisted_2$8 = { class: "line-layout" };
const _hoisted_3$8 = { class: "line-layout style-item" };
const _hoisted_4$7 = { class: "style-item slide-wrap" };
const _hoisted_5$6 = {
  style: { "flex-wrap": "nowrap" },
  class: "line-layout style-item"
};
const _hoisted_6$3 = { class: "line-layout style-item" };
const _hoisted_7$2 = {
  key: 0,
  style: { "margin-top": "10px" },
  class: "line-layout style-item"
};
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_number_input = resolveComponent("number-input");
  const _component_el_collapse_item = resolveComponent("el-collapse-item");
  const _component_value_select = resolveComponent("value-select");
  const _component_icon_item_select = resolveComponent("icon-item-select");
  const _component_number_slider = resolveComponent("number-slider");
  const _component_color_select = resolveComponent("color-select");
  const _component_effect_wrap = resolveComponent("effect-wrap");
  const _component_text_area = resolveComponent("text-area");
  const _component_el_collapse = resolveComponent("el-collapse");
  return openBlock(), createElementBlock("div", _hoisted_1$c, [
    createVNode(_component_el_collapse, {
      modelValue: $data.activeNames,
      "onUpdate:modelValue": _cache[20] || (_cache[20] = ($event) => $data.activeNames = $event)
    }, {
      default: withCtx(() => [
        createVNode(_component_el_collapse_item, {
          title: "\u4F4D\u7F6E\u5C3A\u5BF8",
          name: "1"
        }, {
          default: withCtx(() => [
            createElementVNode("div", _hoisted_2$8, [
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.left,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.innerElement.left = $event),
                label: "X",
                onFinish: _cache[1] || (_cache[1] = (value) => $options.finish("left", value))
              }, null, 8, ["modelValue"]),
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.top,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.innerElement.top = $event),
                label: "Y",
                onFinish: _cache[3] || (_cache[3] = (value) => $options.finish("top", value))
              }, null, 8, ["modelValue"]),
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.width,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $data.innerElement.width = $event),
                style: { "margin-top": "0.5rem" },
                label: "\u5BBD",
                editable: true,
                onFinish: _cache[5] || (_cache[5] = (value) => $options.finish("width", value))
              }, null, 8, ["modelValue"]),
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.height,
                "onUpdate:modelValue": _cache[6] || (_cache[6] = ($event) => $data.innerElement.height = $event),
                style: { "margin-top": "0.5rem" },
                label: "\u9AD8",
                editable: true,
                onFinish: _cache[7] || (_cache[7] = (value) => $options.finish("height", value))
              }, null, 8, ["modelValue"])
            ])
          ]),
          _: 1
        }),
        createElementVNode("div", _hoisted_3$8, [
          createVNode(_component_value_select, {
            modelValue: $data.innerElement.fontClass,
            "onUpdate:modelValue": _cache[8] || (_cache[8] = ($event) => $data.innerElement.fontClass = $event),
            label: "\u6587\u5B57",
            data: $data.fontClassList,
            inputWidth: "152px",
            readonly: true,
            onFinish: _cache[9] || (_cache[9] = (font) => $options.finish("fontClass", font))
          }, null, 8, ["modelValue", "data"]),
          createVNode(_component_value_select, {
            modelValue: $data.innerElement.fontSize,
            "onUpdate:modelValue": _cache[10] || (_cache[10] = ($event) => $data.innerElement.fontSize = $event),
            label: "\u5927\u5C0F",
            suffix: "px",
            data: $data.fontSizeList,
            onFinish: _cache[11] || (_cache[11] = (value) => $options.finish("fontSize", value))
          }, null, 8, ["modelValue", "data"])
        ]),
        createVNode(_component_icon_item_select, {
          class: "style-item",
          data: $data.styleIconList1,
          onFinish: $options.textStyleAction
        }, null, 8, ["data", "onFinish"]),
        createVNode(_component_icon_item_select, {
          class: "style-item",
          data: $data.styleIconList2,
          onFinish: $options.textStyleAction
        }, null, 8, ["data", "onFinish"]),
        createElementVNode("div", _hoisted_4$7, [
          createVNode(_component_number_slider, {
            modelValue: $data.innerElement.letterSpacing,
            "onUpdate:modelValue": _cache[12] || (_cache[12] = ($event) => $data.innerElement.letterSpacing = $event),
            style: { "font-size": "14px" },
            label: "\u5B57\u8DDD",
            labelWidth: "40px",
            step: 0.05,
            minValue: -$data.innerElement.fontSize,
            maxValue: $data.innerElement.fontSize * 2,
            onFinish: _cache[13] || (_cache[13] = (value) => $options.finish("letterSpacing", value))
          }, null, 8, ["modelValue", "minValue", "maxValue"]),
          createVNode(_component_number_slider, {
            modelValue: $data.innerElement.lineHeight,
            "onUpdate:modelValue": _cache[14] || (_cache[14] = ($event) => $data.innerElement.lineHeight = $event),
            style: { "font-size": "14px" },
            label: "\u884C\u8DDD",
            labelWidth: "40px",
            step: 0.05,
            minValue: 0,
            maxValue: 2.5,
            onFinish: _cache[15] || (_cache[15] = (value) => $options.finish("lineHeight", value))
          }, null, 8, ["modelValue"])
        ]),
        createElementVNode("div", _hoisted_5$6, [
          createVNode(_component_color_select, {
            modelValue: $data.innerElement.color,
            "onUpdate:modelValue": _cache[16] || (_cache[16] = ($event) => $data.innerElement.color = $event),
            label: "\u989C\u8272",
            onFinish: _cache[17] || (_cache[17] = (value) => $options.finish("color", value))
          }, null, 8, ["modelValue"])
        ]),
        createElementVNode("div", _hoisted_6$3, [
          createVNode(_component_effect_wrap, {
            modelValue: $data.innerElement.textEffects,
            "onUpdate:modelValue": _cache[18] || (_cache[18] = ($event) => $data.innerElement.textEffects = $event),
            data: $data.innerElement,
            degree: $data.innerElement.degree,
            onSelect: $options.testEffect
          }, null, 8, ["modelValue", "data", "degree", "onSelect"])
        ]),
        createVNode(_component_icon_item_select, {
          class: "style-item",
          data: $data.layerIconList,
          onFinish: $options.layerAction
        }, null, 8, ["data", "onFinish"]),
        createVNode(_component_icon_item_select, {
          class: "style-item",
          data: $data.alignIconList,
          onFinish: $options.alignAction
        }, null, 8, ["data", "onFinish"]),
        $options.isModel ? (openBlock(), createElementBlock("div", _hoisted_7$2, [
          createVNode(_component_text_area, {
            modelValue: $data.innerElement.text,
            "onUpdate:modelValue": _cache[19] || (_cache[19] = ($event) => $data.innerElement.text = $event)
          }, null, 8, ["modelValue"])
        ])) : createCommentVNode("", true)
      ]),
      _: 1
    }, 8, ["modelValue"])
  ]);
}
var wTextStyle = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$a], ["__scopeId", "data-v-deb8c5b4"]]);
var __glob_0_34 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": wTextStyle
}, Symbol.toStringTag, { value: "Module" }));
var stylePanel_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$3 = "style-panel";
const _sfc_main$d = defineComponent({
  name: NAME$3,
  components: { iconItemSelect, layerList, wGroupStyle, wImageStyle, wQrcodeStyle, wSvgStyle, wTextStyle },
  props: ["noMenu"],
  data() {
    return {
      activeTab: 0,
      alignIconList: alignIconList$1,
      showGroupCombined: false
    };
  },
  computed: {
    ...mapGetters(["dActiveElement", "dWidgets", "dSelectWidgets"])
  },
  watch: {
    dSelectWidgets: {
      handler(items) {
        setTimeout(() => {
          this.showGroupCombined = items.length > 1;
        }, 100);
      },
      deep: true
    }
  },
  methods: {
    ...mapActions(["selectWidget", "updateAlign", "updateHoverUuid", "getCombined", "realCombined", "ungroup", "pushHistory"]),
    alignAction(item) {
      const sWidgets = JSON.parse(JSON.stringify(this.dSelectWidgets));
      this.getCombined().then((group) => {
        for (let i = 0; i < sWidgets.length; i++) {
          const element = sWidgets[i];
          this.updateAlign({
            align: item.value,
            uuid: element.uuid,
            group
          });
        }
        this.pushHistory();
      });
    },
    layerChange(newLayer) {
      this.$store.commit("setDWidgets", newLayer.reverse());
      this.$store.commit("setShowMoveable", false);
    }
  }
});
const _hoisted_1$b = { id: "style-panel" };
const _hoisted_2$7 = { class: "style-tab" };
const _hoisted_3$7 = { class: "style-wrap" };
const _hoisted_4$6 = { style: { "padding": "2rem 0" } };
const _hoisted_5$5 = { class: "layer-wrap" };
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_button = resolveComponent("el-button");
  const _component_icon_item_select = resolveComponent("icon-item-select");
  const _component_layer_list = resolveComponent("layer-list");
  return openBlock(), createElementBlock("div", _hoisted_1$b, [
    createElementVNode("div", _hoisted_2$7, [
      createElementVNode("span", {
        class: normalizeClass(["tab", { "active-tab": _ctx.activeTab === 0 }]),
        onClick: _cache[0] || (_cache[0] = ($event) => _ctx.activeTab = 0)
      }, "\u8BBE\u7F6E", 2),
      createElementVNode("span", {
        class: normalizeClass(["tab", { "active-tab": _ctx.activeTab === 1 }]),
        onClick: _cache[1] || (_cache[1] = ($event) => _ctx.activeTab = 1)
      }, "\u56FE\u5C42", 2)
    ]),
    withDirectives(createElementVNode("div", _hoisted_3$7, [
      withDirectives(createElementVNode("div", _hoisted_4$6, [
        createVNode(_component_el_button, {
          plain: "",
          type: "primary",
          class: "gounp__btn",
          onClick: _ctx.realCombined
        }, {
          default: withCtx(() => [
            createTextVNode("\u6210\u7EC4")
          ]),
          _: 1
        }, 8, ["onClick"]),
        createVNode(_component_icon_item_select, {
          label: "",
          data: _ctx.alignIconList,
          onFinish: _ctx.alignAction
        }, null, 8, ["data", "onFinish"])
      ], 512), [
        [vShow, _ctx.showGroupCombined]
      ]),
      _ctx.dActiveElement.type ? withDirectives((openBlock(), createBlock(resolveDynamicComponent(_ctx.dActiveElement.type + "-style"), {
        key: 0,
        noMenu: _ctx.noMenu
      }, null, 8, ["noMenu"])), [
        [vShow, !_ctx.showGroupCombined]
      ]) : createCommentVNode("", true)
    ], 512), [
      [vShow, _ctx.activeTab === 0]
    ]),
    withDirectives(createElementVNode("div", _hoisted_5$5, [
      createVNode(_component_layer_list, {
        data: _ctx.dWidgets,
        onChange: _ctx.layerChange
      }, null, 8, ["data", "onChange"])
    ], 512), [
      [vShow, _ctx.activeTab === 1]
    ])
  ]);
}
var stylePanel = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$9], ["__scopeId", "data-v-7af37c76"]]);
var __glob_0_4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": stylePanel
}, Symbol.toStringTag, { value: "Module" }));
var elDialog = "";
var tuiImageEditor$1 = "";
var tuiColorPicker$1 = "";
var tuiImageEditor = { exports: {} };
var tuiColorPicker = { exports: {} };
/*!
 * TOAST UI Color Picker
 * @version 2.2.8
 * @author NHN Cloud FE Development Team <dl_javascript@nhn.com>
 * @license MIT
 */
(function(module, exports) {
  (function webpackUniversalModuleDefinition(root, factory) {
    module.exports = factory();
  })(window, function() {
    return function(modules2) {
      var installedModules = {};
      function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) {
          return installedModules[moduleId].exports;
        }
        var module2 = installedModules[moduleId] = {
          i: moduleId,
          l: false,
          exports: {}
        };
        modules2[moduleId].call(module2.exports, module2, module2.exports, __webpack_require__);
        module2.l = true;
        return module2.exports;
      }
      __webpack_require__.m = modules2;
      __webpack_require__.c = installedModules;
      __webpack_require__.d = function(exports2, name2, getter) {
        if (!__webpack_require__.o(exports2, name2)) {
          Object.defineProperty(exports2, name2, { enumerable: true, get: getter });
        }
      };
      __webpack_require__.r = function(exports2) {
        if (typeof Symbol !== "undefined" && Symbol.toStringTag) {
          Object.defineProperty(exports2, Symbol.toStringTag, { value: "Module" });
        }
        Object.defineProperty(exports2, "__esModule", { value: true });
      };
      __webpack_require__.t = function(value, mode) {
        if (mode & 1)
          value = __webpack_require__(value);
        if (mode & 8)
          return value;
        if (mode & 4 && typeof value === "object" && value && value.__esModule)
          return value;
        var ns = /* @__PURE__ */ Object.create(null);
        __webpack_require__.r(ns);
        Object.defineProperty(ns, "default", { enumerable: true, value });
        if (mode & 2 && typeof value != "string")
          for (var key in value)
            __webpack_require__.d(ns, key, function(key2) {
              return value[key2];
            }.bind(null, key));
        return ns;
      };
      __webpack_require__.n = function(module2) {
        var getter = module2 && module2.__esModule ? function getDefault() {
          return module2["default"];
        } : function getModuleExports() {
          return module2;
        };
        __webpack_require__.d(getter, "a", getter);
        return getter;
      };
      __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      __webpack_require__.p = "dist";
      return __webpack_require__(__webpack_require__.s = 33);
    }([
      function(module2, exports2, __webpack_require__) {
        function extend2(target, objects) {
          var hasOwnProp = Object.prototype.hasOwnProperty;
          var source2, prop, i, len;
          for (i = 1, len = arguments.length; i < len; i += 1) {
            source2 = arguments[i];
            for (prop in source2) {
              if (hasOwnProp.call(source2, prop)) {
                target[prop] = source2[prop];
              }
            }
          }
          return target;
        }
        module2.exports = extend2;
      },
      function(module2, exports2, __webpack_require__) {
        function isArray2(obj) {
          return obj instanceof Array;
        }
        module2.exports = isArray2;
      },
      function(module2, exports2, __webpack_require__) {
        var isArray2 = __webpack_require__(1);
        var forEachArray = __webpack_require__(6);
        var forEachOwnProperties = __webpack_require__(7);
        function forEach3(obj, iteratee, context) {
          if (isArray2(obj)) {
            forEachArray(obj, iteratee, context);
          } else {
            forEachOwnProperties(obj, iteratee, context);
          }
        }
        module2.exports = forEach3;
      },
      function(module2, exports2, __webpack_require__) {
        function isUndefined2(obj) {
          return obj === void 0;
        }
        module2.exports = isUndefined2;
      },
      function(module2, exports2, __webpack_require__) {
        var browser2 = __webpack_require__(22);
        var forEach3 = __webpack_require__(2);
        var forEachArray = __webpack_require__(6);
        var forEachOwnProperties = __webpack_require__(7);
        var sendHostname = __webpack_require__(37);
        var currentId = 0;
        var utils2 = {
          getLength: function(obj) {
            var length = 0;
            forEachOwnProperties(obj, function() {
              length += 1;
            });
            return length;
          },
          map: function(obj, iteratee, context) {
            var result = [];
            forEach3(obj, function() {
              result.push(iteratee.apply(context || null, arguments));
            });
            return result;
          },
          filter: function(arr2, iteratee, context) {
            var result = [];
            forEachArray(arr2, function(elem) {
              if (iteratee.apply(context || null, arguments)) {
                result.push(elem);
              }
            });
            return result;
          },
          generateId: function() {
            currentId += 1;
            return currentId;
          },
          isOldBrowser: function() {
            return browser2.msie && browser2.version < 9;
          }(),
          sendHostName: function() {
            sendHostname("color-picker", "UA-129987462-1");
          }
        };
        module2.exports = utils2;
      },
      function(module2, exports2, __webpack_require__) {
        var isArray2 = __webpack_require__(1);
        function inArray(searchElement, array, startIndex) {
          var i;
          var length;
          startIndex = startIndex || 0;
          if (!isArray2(array)) {
            return -1;
          }
          if (Array.prototype.indexOf) {
            return Array.prototype.indexOf.call(array, searchElement, startIndex);
          }
          length = array.length;
          for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
            if (array[i] === searchElement) {
              return i;
            }
          }
          return -1;
        }
        module2.exports = inArray;
      },
      function(module2, exports2, __webpack_require__) {
        function forEachArray(arr2, iteratee, context) {
          var index2 = 0;
          var len = arr2.length;
          context = context || null;
          for (; index2 < len; index2 += 1) {
            if (iteratee.call(context, arr2[index2], index2, arr2) === false) {
              break;
            }
          }
        }
        module2.exports = forEachArray;
      },
      function(module2, exports2, __webpack_require__) {
        function forEachOwnProperties(obj, iteratee, context) {
          var key;
          context = context || null;
          for (key in obj) {
            if (obj.hasOwnProperty(key)) {
              if (iteratee.call(context, obj[key], key, obj) === false) {
                break;
              }
            }
          }
        }
        module2.exports = forEachOwnProperties;
      },
      function(module2, exports2, __webpack_require__) {
        var addClass2 = __webpack_require__(39);
        var isFunction2 = __webpack_require__(13);
        var isNumber2 = __webpack_require__(41);
        var isUndefined2 = __webpack_require__(3);
        var domUtil = __webpack_require__(9);
        var Collection = __webpack_require__(19);
        var util = __webpack_require__(4);
        function View(options, container) {
          var id = util.generateId();
          if (isUndefined2(container)) {
            container = domUtil.appendHTMLElement("div");
          }
          addClass2(container, "tui-view-" + id);
          this.id = id;
          this.container = container;
          this.childs = new Collection(function(view) {
            return view.id;
          });
          this.parent = null;
        }
        View.prototype.addChild = function(view, fn2) {
          if (fn2) {
            fn2.call(view, this);
          }
          view.parent = this;
          this.childs.add(view);
        };
        View.prototype.removeChild = function(id, fn2) {
          var view = isNumber2(id) ? this.childs.items[id] : id;
          if (fn2) {
            fn2.call(view, this);
          }
          this.childs.remove(view.id);
        };
        View.prototype.render = function() {
          this.childs.each(function(childView) {
            childView.render();
          });
        };
        View.prototype.recursive = function(fn2, skipThis) {
          if (!isFunction2(fn2)) {
            return;
          }
          if (!skipThis) {
            fn2(this);
          }
          this.childs.each(function(childView) {
            childView.recursive(fn2);
          });
        };
        View.prototype.resize = function() {
          var args = Array.prototype.slice.call(arguments);
          var parent = this.parent;
          while (parent) {
            if (isFunction2(parent._onResize)) {
              parent._onResize.apply(parent, args);
            }
            parent = parent.parent;
          }
        };
        View.prototype._beforeDestroy = function() {
        };
        View.prototype._destroy = function() {
          this._beforeDestroy();
          this.container.innerHTML = "";
          this.id = this.parent = this.childs = this.container = null;
        };
        View.prototype.destroy = function(isChildView) {
          if (this.childs) {
            this.childs.each(function(childView) {
              childView.destroy(true);
              childView._destroy();
            });
            this.childs.clear();
          }
          if (isChildView) {
            return;
          }
          this._destroy();
        };
        View.prototype.getViewBound = function() {
          var bound = this.container.getBoundingClientRect();
          return {
            x: bound.left,
            y: bound.top,
            width: bound.right - bound.left,
            height: bound.bottom - bound.top
          };
        };
        module2.exports = View;
      },
      function(module2, exports2, __webpack_require__) {
        var domUtil = {
          appendHTMLElement: function(tagName, container, className) {
            var el = document.createElement(tagName);
            el.className = className || "";
            if (container) {
              container.appendChild(el);
            } else {
              document.body.appendChild(el);
            }
            return el;
          }
        };
        module2.exports = domUtil;
      },
      function(module2, exports2, __webpack_require__) {
        var extend2 = __webpack_require__(0);
        var isExisty = __webpack_require__(20);
        var isString2 = __webpack_require__(11);
        var isObject2 = __webpack_require__(21);
        var isArray2 = __webpack_require__(1);
        var isFunction2 = __webpack_require__(13);
        var forEach3 = __webpack_require__(2);
        var R_EVENTNAME_SPLIT = /\s+/g;
        function CustomEvents() {
          this.events = null;
          this.contexts = null;
        }
        CustomEvents.mixin = function(func) {
          extend2(func.prototype, CustomEvents.prototype);
        };
        CustomEvents.prototype._getHandlerItem = function(handler, context) {
          var item = { handler };
          if (context) {
            item.context = context;
          }
          return item;
        };
        CustomEvents.prototype._safeEvent = function(eventName) {
          var events2 = this.events;
          var byName;
          if (!events2) {
            events2 = this.events = {};
          }
          if (eventName) {
            byName = events2[eventName];
            if (!byName) {
              byName = [];
              events2[eventName] = byName;
            }
            events2 = byName;
          }
          return events2;
        };
        CustomEvents.prototype._safeContext = function() {
          var context = this.contexts;
          if (!context) {
            context = this.contexts = [];
          }
          return context;
        };
        CustomEvents.prototype._indexOfContext = function(ctx) {
          var context = this._safeContext();
          var index2 = 0;
          while (context[index2]) {
            if (ctx === context[index2][0]) {
              return index2;
            }
            index2 += 1;
          }
          return -1;
        };
        CustomEvents.prototype._memorizeContext = function(ctx) {
          var context, index2;
          if (!isExisty(ctx)) {
            return;
          }
          context = this._safeContext();
          index2 = this._indexOfContext(ctx);
          if (index2 > -1) {
            context[index2][1] += 1;
          } else {
            context.push([ctx, 1]);
          }
        };
        CustomEvents.prototype._forgetContext = function(ctx) {
          var context, contextIndex;
          if (!isExisty(ctx)) {
            return;
          }
          context = this._safeContext();
          contextIndex = this._indexOfContext(ctx);
          if (contextIndex > -1) {
            context[contextIndex][1] -= 1;
            if (context[contextIndex][1] <= 0) {
              context.splice(contextIndex, 1);
            }
          }
        };
        CustomEvents.prototype._bindEvent = function(eventName, handler, context) {
          var events2 = this._safeEvent(eventName);
          this._memorizeContext(context);
          events2.push(this._getHandlerItem(handler, context));
        };
        CustomEvents.prototype.on = function(eventName, handler, context) {
          var self2 = this;
          if (isString2(eventName)) {
            eventName = eventName.split(R_EVENTNAME_SPLIT);
            forEach3(eventName, function(name2) {
              self2._bindEvent(name2, handler, context);
            });
          } else if (isObject2(eventName)) {
            context = handler;
            forEach3(eventName, function(func, name2) {
              self2.on(name2, func, context);
            });
          }
        };
        CustomEvents.prototype.once = function(eventName, handler, context) {
          var self2 = this;
          if (isObject2(eventName)) {
            context = handler;
            forEach3(eventName, function(func, name2) {
              self2.once(name2, func, context);
            });
            return;
          }
          function onceHandler() {
            handler.apply(context, arguments);
            self2.off(eventName, onceHandler, context);
          }
          this.on(eventName, onceHandler, context);
        };
        CustomEvents.prototype._spliceMatches = function(arr2, predicate) {
          var i = 0;
          var len;
          if (!isArray2(arr2)) {
            return;
          }
          for (len = arr2.length; i < len; i += 1) {
            if (predicate(arr2[i]) === true) {
              arr2.splice(i, 1);
              len -= 1;
              i -= 1;
            }
          }
        };
        CustomEvents.prototype._matchHandler = function(handler) {
          var self2 = this;
          return function(item) {
            var needRemove = handler === item.handler;
            if (needRemove) {
              self2._forgetContext(item.context);
            }
            return needRemove;
          };
        };
        CustomEvents.prototype._matchContext = function(context) {
          var self2 = this;
          return function(item) {
            var needRemove = context === item.context;
            if (needRemove) {
              self2._forgetContext(item.context);
            }
            return needRemove;
          };
        };
        CustomEvents.prototype._matchHandlerAndContext = function(handler, context) {
          var self2 = this;
          return function(item) {
            var matchHandler = handler === item.handler;
            var matchContext = context === item.context;
            var needRemove = matchHandler && matchContext;
            if (needRemove) {
              self2._forgetContext(item.context);
            }
            return needRemove;
          };
        };
        CustomEvents.prototype._offByEventName = function(eventName, handler) {
          var self2 = this;
          var andByHandler = isFunction2(handler);
          var matchHandler = self2._matchHandler(handler);
          eventName = eventName.split(R_EVENTNAME_SPLIT);
          forEach3(eventName, function(name2) {
            var handlerItems = self2._safeEvent(name2);
            if (andByHandler) {
              self2._spliceMatches(handlerItems, matchHandler);
            } else {
              forEach3(handlerItems, function(item) {
                self2._forgetContext(item.context);
              });
              self2.events[name2] = [];
            }
          });
        };
        CustomEvents.prototype._offByHandler = function(handler) {
          var self2 = this;
          var matchHandler = this._matchHandler(handler);
          forEach3(this._safeEvent(), function(handlerItems) {
            self2._spliceMatches(handlerItems, matchHandler);
          });
        };
        CustomEvents.prototype._offByObject = function(obj, handler) {
          var self2 = this;
          var matchFunc;
          if (this._indexOfContext(obj) < 0) {
            forEach3(obj, function(func, name2) {
              self2.off(name2, func);
            });
          } else if (isString2(handler)) {
            matchFunc = this._matchContext(obj);
            self2._spliceMatches(this._safeEvent(handler), matchFunc);
          } else if (isFunction2(handler)) {
            matchFunc = this._matchHandlerAndContext(handler, obj);
            forEach3(this._safeEvent(), function(handlerItems) {
              self2._spliceMatches(handlerItems, matchFunc);
            });
          } else {
            matchFunc = this._matchContext(obj);
            forEach3(this._safeEvent(), function(handlerItems) {
              self2._spliceMatches(handlerItems, matchFunc);
            });
          }
        };
        CustomEvents.prototype.off = function(eventName, handler) {
          if (isString2(eventName)) {
            this._offByEventName(eventName, handler);
          } else if (!arguments.length) {
            this.events = {};
            this.contexts = [];
          } else if (isFunction2(eventName)) {
            this._offByHandler(eventName);
          } else if (isObject2(eventName)) {
            this._offByObject(eventName, handler);
          }
        };
        CustomEvents.prototype.fire = function(eventName) {
          this.invoke.apply(this, arguments);
        };
        CustomEvents.prototype.invoke = function(eventName) {
          var events2, args, index2, item;
          if (!this.hasListener(eventName)) {
            return true;
          }
          events2 = this._safeEvent(eventName);
          args = Array.prototype.slice.call(arguments, 1);
          index2 = 0;
          while (events2[index2]) {
            item = events2[index2];
            if (item.handler.apply(item.context, args) === false) {
              return false;
            }
            index2 += 1;
          }
          return true;
        };
        CustomEvents.prototype.hasListener = function(eventName) {
          return this.getListenerLength(eventName) > 0;
        };
        CustomEvents.prototype.getListenerLength = function(eventName) {
          var events2 = this._safeEvent(eventName);
          return events2.length;
        };
        module2.exports = CustomEvents;
      },
      function(module2, exports2, __webpack_require__) {
        function isString2(obj) {
          return typeof obj === "string" || obj instanceof String;
        }
        module2.exports = isString2;
      },
      function(module2, exports2, __webpack_require__) {
        var hexRX = /(^#[0-9A-F]{6}$)|(^#[0-9A-F]{3}$)/i;
        var colorUtil = {
          leadingZero: function(number, length) {
            var zero = "";
            var i = 0;
            if ((number + "").length > length) {
              return number + "";
            }
            for (; i < length - 1; i += 1) {
              zero += "0";
            }
            return (zero + number).slice(length * -1);
          },
          isValidRGB: function(str) {
            return hexRX.test(str);
          },
          hexToRGB: function(hexStr) {
            var r, g, b;
            if (!colorUtil.isValidRGB(hexStr)) {
              return false;
            }
            hexStr = hexStr.substring(1);
            r = parseInt(hexStr.substr(0, 2), 16);
            g = parseInt(hexStr.substr(2, 2), 16);
            b = parseInt(hexStr.substr(4, 2), 16);
            return [r, g, b];
          },
          rgbToHEX: function(r, g, b) {
            var hexStr = "#" + colorUtil.leadingZero(r.toString(16), 2) + colorUtil.leadingZero(g.toString(16), 2) + colorUtil.leadingZero(b.toString(16), 2);
            if (colorUtil.isValidRGB(hexStr)) {
              return hexStr;
            }
            return false;
          },
          rgbToHSV: function(r, g, b) {
            var max2, min, h2, s, v, d;
            r /= 255;
            g /= 255;
            b /= 255;
            max2 = Math.max(r, g, b);
            min = Math.min(r, g, b);
            v = max2;
            d = max2 - min;
            s = max2 === 0 ? 0 : d / max2;
            if (max2 === min) {
              h2 = 0;
            } else {
              switch (max2) {
                case r:
                  h2 = (g - b) / d + (g < b ? 6 : 0);
                  break;
                case g:
                  h2 = (b - r) / d + 2;
                  break;
                case b:
                  h2 = (r - g) / d + 4;
                  break;
              }
              h2 /= 6;
            }
            return [Math.round(h2 * 360), Math.round(s * 100), Math.round(v * 100)];
          },
          hsvToRGB: function(h2, s, v) {
            var r, g, b;
            var i;
            var f2, p, q2, t;
            h2 = Math.max(0, Math.min(360, h2));
            s = Math.max(0, Math.min(100, s));
            v = Math.max(0, Math.min(100, v));
            s /= 100;
            v /= 100;
            if (s === 0) {
              r = g = b = v;
              return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
            }
            h2 /= 60;
            i = Math.floor(h2);
            f2 = h2 - i;
            p = v * (1 - s);
            q2 = v * (1 - s * f2);
            t = v * (1 - s * (1 - f2));
            switch (i) {
              case 0:
                r = v;
                g = t;
                b = p;
                break;
              case 1:
                r = q2;
                g = v;
                b = p;
                break;
              case 2:
                r = p;
                g = v;
                b = t;
                break;
              case 3:
                r = p;
                g = q2;
                b = v;
                break;
              case 4:
                r = t;
                g = p;
                b = v;
                break;
              default:
                r = v;
                g = p;
                b = q2;
                break;
            }
            return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
          }
        };
        module2.exports = colorUtil;
      },
      function(module2, exports2, __webpack_require__) {
        function isFunction2(obj) {
          return obj instanceof Function;
        }
        module2.exports = isFunction2;
      },
      function(module2, exports2, __webpack_require__) {
        var isString2 = __webpack_require__(11);
        var forEach3 = __webpack_require__(2);
        var safeEvent = __webpack_require__(26);
        function on2(element, types, handler, context) {
          if (isString2(types)) {
            forEach3(types.split(/\s+/g), function(type) {
              bindEvent(element, type, handler, context);
            });
            return;
          }
          forEach3(types, function(func, type) {
            bindEvent(element, type, func, handler);
          });
        }
        function bindEvent(element, type, handler, context) {
          function eventHandler(e2) {
            handler.call(context || element, e2 || window.event);
          }
          if ("addEventListener" in element) {
            element.addEventListener(type, eventHandler);
          } else if ("attachEvent" in element) {
            element.attachEvent("on" + type, eventHandler);
          }
          memorizeHandler(element, type, handler, eventHandler);
        }
        function memorizeHandler(element, type, handler, wrappedHandler) {
          var events2 = safeEvent(element, type);
          var existInEvents = false;
          forEach3(events2, function(obj) {
            if (obj.handler === handler) {
              existInEvents = true;
              return false;
            }
            return true;
          });
          if (!existInEvents) {
            events2.push({
              handler,
              wrappedHandler
            });
          }
        }
        module2.exports = on2;
      },
      function(module2, exports2, __webpack_require__) {
        function preventDefault(e2) {
          if (e2.preventDefault) {
            e2.preventDefault();
            return;
          }
          e2.returnValue = false;
        }
        module2.exports = preventDefault;
      },
      function(module2, exports2, __webpack_require__) {
        function convertToKebabCase(key) {
          return key.replace(/([A-Z])/g, function(match) {
            return "-" + match.toLowerCase();
          });
        }
        module2.exports = convertToKebabCase;
      },
      function(module2, exports2, __webpack_require__) {
        var isString2 = __webpack_require__(11);
        var forEach3 = __webpack_require__(2);
        var safeEvent = __webpack_require__(26);
        function off2(element, types, handler) {
          if (isString2(types)) {
            forEach3(types.split(/\s+/g), function(type) {
              unbindEvent(element, type, handler);
            });
            return;
          }
          forEach3(types, function(func, type) {
            unbindEvent(element, type, func);
          });
        }
        function unbindEvent(element, type, handler) {
          var events2 = safeEvent(element, type);
          var index2;
          if (!handler) {
            forEach3(events2, function(item) {
              removeHandler(element, type, item.wrappedHandler);
            });
            events2.splice(0, events2.length);
          } else {
            forEach3(events2, function(item, idx) {
              if (handler === item.handler) {
                removeHandler(element, type, item.wrappedHandler);
                index2 = idx;
                return false;
              }
              return true;
            });
            events2.splice(index2, 1);
          }
        }
        function removeHandler(element, type, handler) {
          if ("removeEventListener" in element) {
            element.removeEventListener(type, handler);
          } else if ("detachEvent" in element) {
            element.detachEvent("on" + type, handler);
          }
        }
        module2.exports = off2;
      },
      function(module2, exports2, __webpack_require__) {
        var createObject = __webpack_require__(50);
        function inherit(subType, superType) {
          var prototype = createObject(superType.prototype);
          prototype.constructor = subType;
          subType.prototype = prototype;
        }
        module2.exports = inherit;
      },
      function(module2, exports2, __webpack_require__) {
        var forEachArray = __webpack_require__(6);
        var forEachOwnProperties = __webpack_require__(7);
        var extend2 = __webpack_require__(0);
        var isArray2 = __webpack_require__(1);
        var isExisty = __webpack_require__(20);
        var isFunction2 = __webpack_require__(13);
        var isObject2 = __webpack_require__(21);
        var util = __webpack_require__(4);
        var slice = Array.prototype.slice;
        function Collection(getItemIDFn) {
          this.items = {};
          this.length = 0;
          if (isFunction2(getItemIDFn)) {
            this.getItemID = getItemIDFn;
          }
        }
        Collection.and = function(filters) {
          var cnt;
          filters = slice.call(arguments);
          cnt = filters.length;
          return function(item) {
            var i = 0;
            for (; i < cnt; i += 1) {
              if (!filters[i].call(null, item)) {
                return false;
              }
            }
            return true;
          };
        };
        Collection.or = function(filters) {
          var cnt;
          filters = slice.call(arguments);
          cnt = filters.length;
          return function(item) {
            var i = 1;
            var result = filters[0].call(null, item);
            for (; i < cnt; i += 1) {
              result = result || filters[i].call(null, item);
            }
            return result;
          };
        };
        Collection.merge = function(firstCollection) {
          var newItems = {};
          var merged = new Collection(firstCollection.getItemID);
          forEachArray(arguments, function(col) {
            extend2(newItems, col.items);
          });
          merged.items = newItems;
          merged.length = util.getLength(merged.items);
          return merged;
        };
        Collection.prototype.getItemID = function(item) {
          return item._id + "";
        };
        Collection.prototype.add = function(item) {
          var id, ownItems;
          if (arguments.length > 1) {
            forEachArray(slice.call(arguments), function(o) {
              this.add(o);
            }, this);
            return;
          }
          id = this.getItemID(item);
          ownItems = this.items;
          if (!ownItems[id]) {
            this.length += 1;
          }
          ownItems[id] = item;
        };
        Collection.prototype.remove = function(id) {
          var removed = [];
          var ownItems, itemToRemove;
          if (!this.length) {
            return removed;
          }
          if (arguments.length > 1) {
            removed = util.map(slice.call(arguments), function(id2) {
              return this.remove(id2);
            }, this);
            return removed;
          }
          ownItems = this.items;
          if (isObject2(id)) {
            id = this.getItemID(id);
          }
          if (!ownItems[id]) {
            return removed;
          }
          this.length -= 1;
          itemToRemove = ownItems[id];
          delete ownItems[id];
          return itemToRemove;
        };
        Collection.prototype.clear = function() {
          this.items = {};
          this.length = 0;
        };
        Collection.prototype.has = function(id) {
          var isFilter, has;
          if (!this.length) {
            return false;
          }
          isFilter = isFunction2(id);
          has = false;
          if (isFilter) {
            this.each(function(item) {
              if (id(item) === true) {
                has = true;
                return false;
              }
              return true;
            });
          } else {
            id = isObject2(id) ? this.getItemID(id) : id;
            has = isExisty(this.items[id]);
          }
          return has;
        };
        Collection.prototype.doWhenHas = function(id, fn2, context) {
          var item = this.items[id];
          if (!isExisty(item)) {
            return;
          }
          fn2.call(context || this, item);
        };
        Collection.prototype.find = function(filter) {
          var result = new Collection();
          if (this.hasOwnProperty("getItemID")) {
            result.getItemID = this.getItemID;
          }
          this.each(function(item) {
            if (filter(item) === true) {
              result.add(item);
            }
          });
          return result;
        };
        Collection.prototype.groupBy = function(key, groupFunc) {
          var result = {};
          var keyIsFunc = isFunction2(key);
          var getItemIDFn = this.getItemID;
          var collection, baseValue;
          if (isArray2(key)) {
            forEachArray(key, function(k) {
              result[k + ""] = new Collection(getItemIDFn);
            });
            if (!groupFunc) {
              return result;
            }
            key = groupFunc;
            keyIsFunc = true;
          }
          this.each(function(item) {
            if (keyIsFunc) {
              baseValue = key(item);
            } else {
              baseValue = item[key];
              if (isFunction2(baseValue)) {
                baseValue = baseValue.apply(item);
              }
            }
            collection = result[baseValue];
            if (!collection) {
              collection = result[baseValue] = new Collection(getItemIDFn);
            }
            collection.add(item);
          });
          return result;
        };
        Collection.prototype.single = function() {
          var result;
          this.each(function(item) {
            result = item;
            return false;
          }, this);
          return result;
        };
        Collection.prototype.sort = function(compareFunction) {
          var arr2 = [];
          this.each(function(item) {
            arr2.push(item);
          });
          if (isFunction2(compareFunction)) {
            arr2 = arr2.sort(compareFunction);
          }
          return arr2;
        };
        Collection.prototype.each = function(iteratee, context) {
          forEachOwnProperties(this.items, iteratee, context || this);
        };
        Collection.prototype.toArray = function() {
          if (!this.length) {
            return [];
          }
          return util.map(this.items, function(item) {
            return item;
          });
        };
        module2.exports = Collection;
      },
      function(module2, exports2, __webpack_require__) {
        var isUndefined2 = __webpack_require__(3);
        var isNull = __webpack_require__(36);
        function isExisty(param) {
          return !isUndefined2(param) && !isNull(param);
        }
        module2.exports = isExisty;
      },
      function(module2, exports2, __webpack_require__) {
        function isObject2(obj) {
          return obj === Object(obj);
        }
        module2.exports = isObject2;
      },
      function(module2, exports2, __webpack_require__) {
        var browser2 = {
          chrome: false,
          firefox: false,
          safari: false,
          msie: false,
          edge: false,
          others: false,
          version: 0
        };
        if (typeof window !== "undefined" && window.navigator) {
          detectBrowser();
        }
        function detectBrowser() {
          var nav = window.navigator;
          var appName = nav.appName.replace(/\s/g, "_");
          var userAgent2 = nav.userAgent;
          var rIE = /MSIE\s([0-9]+[.0-9]*)/;
          var rIE11 = /Trident.*rv:11\./;
          var rEdge = /Edge\/(\d+)\./;
          var versionRegex = {
            firefox: /Firefox\/(\d+)\./,
            chrome: /Chrome\/(\d+)\./,
            safari: /Version\/([\d.]+).*Safari\/(\d+)/
          };
          var key, tmp;
          var detector = {
            Microsoft_Internet_Explorer: function() {
              var detectedVersion = userAgent2.match(rIE);
              if (detectedVersion) {
                browser2.msie = true;
                browser2.version = parseFloat(detectedVersion[1]);
              } else {
                browser2.others = true;
              }
            },
            Netscape: function() {
              var detected = false;
              if (rIE11.exec(userAgent2)) {
                browser2.msie = true;
                browser2.version = 11;
                detected = true;
              } else if (rEdge.exec(userAgent2)) {
                browser2.edge = true;
                browser2.version = userAgent2.match(rEdge)[1];
                detected = true;
              } else {
                for (key in versionRegex) {
                  if (versionRegex.hasOwnProperty(key)) {
                    tmp = userAgent2.match(versionRegex[key]);
                    if (tmp && tmp.length > 1) {
                      browser2[key] = detected = true;
                      browser2.version = parseFloat(tmp[1] || 0);
                      break;
                    }
                  }
                }
              }
              if (!detected) {
                browser2.others = true;
              }
            }
          };
          var fn2 = detector[appName];
          if (fn2) {
            detector[appName]();
          }
        }
        module2.exports = browser2;
      },
      function(module2, exports2, __webpack_require__) {
        var isUndefined2 = __webpack_require__(3);
        function getClass(element) {
          if (!element || !element.className) {
            return "";
          }
          if (isUndefined2(element.className.baseVal)) {
            return element.className;
          }
          return element.className.baseVal;
        }
        module2.exports = getClass;
      },
      function(module2, exports2, __webpack_require__) {
        (function(global2) {
          var CustomEvents = __webpack_require__(10);
          var disableTextSelection = __webpack_require__(42);
          var enableTextSelection = __webpack_require__(44);
          var getMouseButton = __webpack_require__(47);
          var getTarget2 = __webpack_require__(28);
          var off2 = __webpack_require__(17);
          var on2 = __webpack_require__(14);
          var preventDefault = __webpack_require__(15);
          var extend2 = __webpack_require__(0);
          function Drag(options, container) {
            on2(container, "mousedown", this._onMouseDown, this);
            this.options = extend2({
              distance: 10
            }, options);
            this.container = container;
            this._isMoved = false;
            this._distance = 0;
            this._dragStartFired = false;
            this._dragStartEventData = null;
          }
          Drag.prototype.destroy = function() {
            off2(this.container, "mousedown", this._onMouseDown);
            this.options = this.container = this._isMoved = this._distance = this._dragStartFired = this._dragStartEventData = null;
          };
          Drag.prototype._toggleDragEvent = function(toBind) {
            var container = this.container;
            if (toBind) {
              disableTextSelection(container);
              on2(window, "dragstart", preventDefault);
              on2(global2.document, {
                mousemove: this._onMouseMove,
                mouseup: this._onMouseUp
              }, this);
            } else {
              enableTextSelection(container);
              off2(window, "dragstart", preventDefault);
              off2(global2.document, {
                mousemove: this._onMouseMove,
                mouseup: this._onMouseUp
              });
            }
          };
          Drag.prototype._getEventData = function(mouseEvent) {
            return {
              target: getTarget2(mouseEvent),
              originEvent: mouseEvent
            };
          };
          Drag.prototype._onMouseDown = function(mouseDownEvent) {
            if (getMouseButton(mouseDownEvent) !== 0) {
              return;
            }
            this._distance = 0;
            this._dragStartFired = false;
            this._dragStartEventData = this._getEventData(mouseDownEvent);
            this._toggleDragEvent(true);
          };
          Drag.prototype._onMouseMove = function(mouseMoveEvent) {
            var distance2 = this.options.distance;
            preventDefault(mouseMoveEvent);
            this._isMoved = true;
            if (this._distance < distance2) {
              this._distance += 1;
              return;
            }
            if (!this._dragStartFired) {
              this._dragStartFired = true;
              if (!this.invoke("dragStart", this._dragStartEventData)) {
                this._toggleDragEvent(false);
                return;
              }
            }
            this.fire("drag", this._getEventData(mouseMoveEvent));
          };
          Drag.prototype._onMouseUp = function(mouseUpEvent) {
            this._toggleDragEvent(false);
            if (this._isMoved) {
              this._isMoved = false;
              this.fire("dragEnd", this._getEventData(mouseUpEvent));
              return;
            }
            this.fire("click", this._getEventData(mouseUpEvent));
          };
          CustomEvents.mixin(Drag);
          module2.exports = Drag;
        }).call(this, __webpack_require__(25));
      },
      function(module2, exports2) {
        var g;
        g = function() {
          return this;
        }();
        try {
          g = g || new Function("return this")();
        } catch (e2) {
          if (typeof window === "object")
            g = window;
        }
        module2.exports = g;
      },
      function(module2, exports2, __webpack_require__) {
        var EVENT_KEY = "_feEventKey";
        function safeEvent(element, type) {
          var events2 = element[EVENT_KEY];
          var handlers;
          if (!events2) {
            events2 = element[EVENT_KEY] = {};
          }
          handlers = events2[type];
          if (!handlers) {
            handlers = events2[type] = [];
          }
          return handlers;
        }
        module2.exports = safeEvent;
      },
      function(module2, exports2, __webpack_require__) {
        function testCSSProp(props2) {
          var style = document.documentElement.style;
          var i, len;
          for (i = 0, len = props2.length; i < len; i += 1) {
            if (props2[i] in style) {
              return props2[i];
            }
          }
          return false;
        }
        module2.exports = testCSSProp;
      },
      function(module2, exports2, __webpack_require__) {
        function getTarget2(e2) {
          return e2.target || e2.srcElement;
        }
        module2.exports = getTarget2;
      },
      function(module2, exports2, __webpack_require__) {
        var CustomEvents = __webpack_require__(10);
        var getTarget2 = __webpack_require__(28);
        var off2 = __webpack_require__(17);
        var on2 = __webpack_require__(14);
        var hasClass2 = __webpack_require__(30);
        var extend2 = __webpack_require__(0);
        var inherit = __webpack_require__(18);
        var domUtil = __webpack_require__(9);
        var colorUtil = __webpack_require__(12);
        var View = __webpack_require__(8);
        var tmpl = __webpack_require__(51);
        function Palette(options, container) {
          this.options = extend2({
            cssPrefix: "tui-colorpicker-",
            preset: ["#181818", "#282828", "#383838", "#585858", "#B8B8B8", "#D8D8D8", "#E8E8E8", "#F8F8F8", "#AB4642", "#DC9656", "#F7CA88", "#A1B56C", "#86C1B9", "#7CAFC2", "#BA8BAF", "#A16946"],
            detailTxt: "Detail"
          }, options);
          container = domUtil.appendHTMLElement("div", container, this.options.cssPrefix + "palette-container");
          View.call(this, options, container);
        }
        inherit(Palette, View);
        Palette.prototype._onClick = function(clickEvent) {
          var options = this.options;
          var target = getTarget2(clickEvent);
          var eventData = {};
          if (hasClass2(target, options.cssPrefix + "palette-button")) {
            eventData.color = target.value;
            this.fire("_selectColor", eventData);
            return;
          }
          if (hasClass2(target, options.cssPrefix + "palette-toggle-slider")) {
            this.fire("_toggleSlider");
          }
        };
        Palette.prototype._onChange = function(changeEvent) {
          var options = this.options;
          var target = getTarget2(changeEvent);
          var eventData = {};
          if (hasClass2(target, options.cssPrefix + "palette-hex")) {
            eventData.color = target.value;
            this.fire("_selectColor", eventData);
          }
        };
        Palette.prototype._beforeDestroy = function() {
          this._toggleEvent(false);
        };
        Palette.prototype._toggleEvent = function(toBind) {
          var options = this.options;
          var container = this.container;
          var handleEvent2 = toBind ? on2 : off2;
          var hexTextBox;
          handleEvent2(container, "click", this._onClick, this);
          hexTextBox = container.querySelector("." + options.cssPrefix + "palette-hex", container);
          if (hexTextBox) {
            handleEvent2(hexTextBox, "change", this._onChange, this);
          }
        };
        Palette.prototype.render = function(color2) {
          var options = this.options;
          var html = "";
          this._toggleEvent(false);
          html = tmpl({
            cssPrefix: options.cssPrefix,
            preset: options.preset,
            detailTxt: options.detailTxt,
            color: color2,
            isValidRGB: colorUtil.isValidRGB,
            getItemClass: function(itemColor) {
              return !itemColor ? " " + options.cssPrefix + "color-transparent" : "";
            },
            isSelected: function(itemColor) {
              return itemColor === color2 ? " " + options.cssPrefix + "selected" : "";
            }
          });
          this.container.innerHTML = html;
          this._toggleEvent(true);
        };
        CustomEvents.mixin(Palette);
        module2.exports = Palette;
      },
      function(module2, exports2, __webpack_require__) {
        var inArray = __webpack_require__(5);
        var getClass = __webpack_require__(23);
        function hasClass2(element, cssClass) {
          var origin;
          if (element.classList) {
            return element.classList.contains(cssClass);
          }
          origin = getClass(element).split(/\s+/);
          return inArray(cssClass, origin) > -1;
        }
        module2.exports = hasClass2;
      },
      function(module2, exports2, __webpack_require__) {
        var CustomEvents = __webpack_require__(10);
        var getMousePosition = __webpack_require__(53);
        var closest2 = __webpack_require__(54);
        var hasClass2 = __webpack_require__(30);
        var extend2 = __webpack_require__(0);
        var inherit = __webpack_require__(18);
        var domUtil = __webpack_require__(9);
        var svgvml = __webpack_require__(32);
        var colorUtil = __webpack_require__(12);
        var View = __webpack_require__(8);
        var Drag = __webpack_require__(24);
        var tmpl = __webpack_require__(57);
        var DEFAULT_COLORSLIDER_POS_LIMIT_MIN = -7;
        var DEFAULT_COLORSLIDER_POS_LIMIT_MAX = 112;
        var DEFAULT_HUEBAR_POS_LIMIT_MIN = -3;
        var DEFAULT_HUEBAR_POS_LIMIT_MAX = 115;
        var HUE_WHEEL_MAX = 359.99;
        function Slider(options, container) {
          container = domUtil.appendHTMLElement("div", container, options.cssPrefix + "slider-container");
          container.style.display = "none";
          View.call(this, options, container);
          this.options = extend2({
            color: "#f8f8f8",
            cssPrefix: "tui-colorpicker-"
          }, options);
          this._dragDataCache = {};
          this.sliderHandleElement = null;
          this.huebarHandleElement = null;
          this.baseColorElement = null;
          this.drag = new Drag({
            distance: 0
          }, container);
          this.colorSliderPosLimitRange = [DEFAULT_COLORSLIDER_POS_LIMIT_MIN, DEFAULT_COLORSLIDER_POS_LIMIT_MAX];
          this.huebarPosLimitRange = [DEFAULT_HUEBAR_POS_LIMIT_MIN, DEFAULT_HUEBAR_POS_LIMIT_MAX];
          this.drag.on({
            dragStart: this._onDragStart,
            drag: this._onDrag,
            dragEnd: this._onDragEnd,
            click: this._onClick
          }, this);
        }
        inherit(Slider, View);
        Slider.prototype._beforeDestroy = function() {
          this.drag.off();
          this.drag = this.options = this._dragDataCache = this.sliderHandleElement = this.huebarHandleElement = this.baseColorElement = null;
        };
        Slider.prototype.toggle = function(onOff) {
          this.container.style.display = !!onOff ? "block" : "none";
        };
        Slider.prototype.isVisible = function() {
          return this.container.style.display === "block";
        };
        Slider.prototype.render = function(colorStr) {
          var container = this.container;
          var options = this.options;
          var html = tmpl.layout;
          var rgb2, hsv;
          if (!colorUtil.isValidRGB(colorStr)) {
            return;
          }
          html = html.replace(/{{slider}}/, tmpl.slider);
          html = html.replace(/{{huebar}}/, tmpl.huebar);
          html = html.replace(/{{cssPrefix}}/g, options.cssPrefix);
          html = html.replace(/{{id}}/g, options.id);
          this.container.innerHTML = html;
          this.sliderSvgElement = container.querySelector("." + options.cssPrefix + "svg-slider");
          this.huebarSvgElement = container.querySelector("." + options.cssPrefix + "svg-huebar");
          this.sliderHandleElement = container.querySelector("." + options.cssPrefix + "slider-handle");
          this.huebarHandleElement = container.querySelector("." + options.cssPrefix + "huebar-handle");
          this.baseColorElement = container.querySelector("." + options.cssPrefix + "slider-basecolor");
          rgb2 = colorUtil.hexToRGB(colorStr);
          hsv = colorUtil.rgbToHSV.apply(null, rgb2);
          this.moveHue(hsv[0], true);
          this.moveSaturationAndValue(hsv[1], hsv[2], true);
        };
        Slider.prototype._setColorSliderPosMax = function() {
          var sliderRects = this.sliderSvgElement.getClientRects()[0];
          if (sliderRects) {
            this.colorSliderPosLimitRange[1] = sliderRects.height - 10;
          }
        };
        Slider.prototype._moveColorSliderHandle = function(newLeft, newTop, silent) {
          var handle = this.sliderHandleElement;
          var handleColor;
          newTop = Math.max(this.colorSliderPosLimitRange[0], newTop);
          newTop = Math.min(this.colorSliderPosLimitRange[1], newTop);
          newLeft = Math.max(this.colorSliderPosLimitRange[0], newLeft);
          newLeft = Math.min(this.colorSliderPosLimitRange[1], newLeft);
          svgvml.setTranslateXY(handle, newLeft, newTop);
          handleColor = newTop > 50 ? "white" : "black";
          svgvml.setStrokeColor(handle, handleColor);
          if (!silent) {
            this.fire("_selectColor", {
              color: colorUtil.rgbToHEX.apply(null, this.getRGB())
            });
          }
        };
        Slider.prototype.moveSaturationAndValue = function(saturation, value, silent) {
          var absMin, maxValue, newLeft, newTop;
          saturation = saturation || 0;
          value = value || 0;
          absMin = Math.abs(this.colorSliderPosLimitRange[0]);
          maxValue = this.colorSliderPosLimitRange[1];
          newLeft = saturation * maxValue / 100 - absMin;
          newTop = maxValue - value * maxValue / 100 - absMin;
          this._moveColorSliderHandle(newLeft, newTop, silent);
        };
        Slider.prototype._moveColorSliderByPosition = function(x, y) {
          var offset = this.colorSliderPosLimitRange[0];
          this._moveColorSliderHandle(x + offset, y + offset);
        };
        Slider.prototype.getSaturationAndValue = function() {
          var absMin = Math.abs(this.colorSliderPosLimitRange[0]);
          var maxValue = absMin + this.colorSliderPosLimitRange[1];
          var position2 = svgvml.getTranslateXY(this.sliderHandleElement);
          var saturation, value;
          saturation = (position2[1] + absMin) / maxValue * 100;
          value = 100 - (position2[0] + absMin) / maxValue * 100;
          return [saturation, value];
        };
        Slider.prototype._setHueBarPosMax = function() {
          var huebarRects = this.huebarSvgElement.getClientRects()[0];
          if (huebarRects) {
            this.huebarPosLimitRange[1] = huebarRects.height - 7;
          }
        };
        Slider.prototype._moveHueHandle = function(newTop, silent) {
          var hueHandleElement = this.huebarHandleElement;
          var baseColorElement = this.baseColorElement;
          var newGradientColor, hexStr;
          newTop = Math.max(this.huebarPosLimitRange[0], newTop);
          newTop = Math.min(this.huebarPosLimitRange[1], newTop);
          svgvml.setTranslateY(hueHandleElement, newTop);
          newGradientColor = colorUtil.hsvToRGB(this.getHue(), 100, 100);
          hexStr = colorUtil.rgbToHEX.apply(null, newGradientColor);
          svgvml.setGradientColorStop(baseColorElement, hexStr);
          if (!silent) {
            this.fire("_selectColor", {
              color: colorUtil.rgbToHEX.apply(null, this.getRGB())
            });
          }
        };
        Slider.prototype.moveHue = function(degree, silent) {
          var newTop = 0;
          var absMin, maxValue;
          absMin = Math.abs(this.huebarPosLimitRange[0]);
          maxValue = absMin + this.huebarPosLimitRange[1];
          degree = degree || 0;
          newTop = maxValue * degree / HUE_WHEEL_MAX - absMin;
          this._moveHueHandle(newTop, silent);
        };
        Slider.prototype._moveHueByPosition = function(y) {
          var offset = this.huebarPosLimitRange[0];
          this._moveHueHandle(y + offset);
        };
        Slider.prototype.getHue = function() {
          var handle = this.huebarHandleElement;
          var position2 = svgvml.getTranslateXY(handle);
          var absMin, maxValue;
          absMin = Math.abs(this.huebarPosLimitRange[0]);
          maxValue = absMin + this.huebarPosLimitRange[1];
          return (position2[0] + absMin) * HUE_WHEEL_MAX / maxValue;
        };
        Slider.prototype.getHSV = function() {
          var sv = this.getSaturationAndValue();
          var h2 = this.getHue();
          return [h2].concat(sv);
        };
        Slider.prototype.getRGB = function() {
          return colorUtil.hsvToRGB.apply(null, this.getHSV());
        };
        Slider.prototype._prepareColorSliderForMouseEvent = function(event) {
          var options = this.options;
          var sliderPart = closest2(event.target, "." + options.cssPrefix + "slider-part");
          var cache;
          cache = this._dragDataCache = {
            isColorSlider: hasClass2(sliderPart, options.cssPrefix + "slider-left"),
            parentElement: sliderPart
          };
          return cache;
        };
        Slider.prototype._onClick = function(clickEvent) {
          var cache = this._prepareColorSliderForMouseEvent(clickEvent);
          var mousePos = getMousePosition(clickEvent.originEvent, cache.parentElement);
          if (cache.isColorSlider) {
            this._moveColorSliderByPosition(mousePos[0], mousePos[1]);
          } else {
            this._moveHueByPosition(mousePos[1]);
          }
          this._dragDataCache = null;
        };
        Slider.prototype._onDragStart = function(dragStartEvent) {
          this._setColorSliderPosMax();
          this._setHueBarPosMax();
          this._prepareColorSliderForMouseEvent(dragStartEvent);
        };
        Slider.prototype._onDrag = function(dragEvent) {
          var cache = this._dragDataCache;
          var mousePos = getMousePosition(dragEvent.originEvent, cache.parentElement);
          if (cache.isColorSlider) {
            this._moveColorSliderByPosition(mousePos[0], mousePos[1]);
          } else {
            this._moveHueByPosition(mousePos[1]);
          }
        };
        Slider.prototype._onDragEnd = function() {
          this._dragDataCache = null;
        };
        CustomEvents.mixin(Slider);
        module2.exports = Slider;
      },
      function(module2, exports2, __webpack_require__) {
        var isOldBrowser = __webpack_require__(4).isOldBrowser;
        var PARSE_TRANSLATE_NUM_REGEX = /[\.\-0-9]+/g;
        var SVG_HUE_HANDLE_RIGHT_POS = -6;
        var svgvml = {
          getTranslateXY: function(obj) {
            var temp;
            if (isOldBrowser) {
              temp = obj.style;
              return [parseFloat(temp.top), parseFloat(temp.left)];
            }
            temp = obj.getAttribute("transform");
            if (!temp) {
              return [0, 0];
            }
            temp = temp.match(PARSE_TRANSLATE_NUM_REGEX);
            return [parseFloat(temp[1]), parseFloat(temp[0])];
          },
          setTranslateXY: function(obj, x, y) {
            if (isOldBrowser) {
              obj.style.left = x + "px";
              obj.style.top = y + "px";
            } else {
              obj.setAttribute("transform", "translate(" + x + "," + y + ")");
            }
          },
          setTranslateY: function(obj, y) {
            if (isOldBrowser) {
              obj.style.top = y + "px";
            } else {
              obj.setAttribute("transform", "translate(" + SVG_HUE_HANDLE_RIGHT_POS + "," + y + ")");
            }
          },
          setStrokeColor: function(obj, colorStr) {
            if (isOldBrowser) {
              obj.strokecolor = colorStr;
            } else {
              obj.setAttribute("stroke", colorStr);
            }
          },
          setGradientColorStop: function(obj, colorStr) {
            if (isOldBrowser) {
              obj.color = colorStr;
            } else {
              obj.setAttribute("stop-color", colorStr);
            }
          }
        };
        module2.exports = svgvml;
      },
      function(module2, exports2, __webpack_require__) {
        __webpack_require__(34);
        module2.exports = __webpack_require__(35);
      },
      function(module2, exports2, __webpack_require__) {
      },
      function(module2, exports2, __webpack_require__) {
        var Collection = __webpack_require__(19);
        var View = __webpack_require__(8);
        var Drag = __webpack_require__(24);
        var create2 = __webpack_require__(48);
        var Palette = __webpack_require__(29);
        var Slider = __webpack_require__(31);
        var colorUtil = __webpack_require__(12);
        var svgvml = __webpack_require__(32);
        var colorPicker = {
          Collection,
          View,
          Drag,
          create: create2,
          Palette,
          Slider,
          colorutil: colorUtil,
          svgvml
        };
        module2.exports = colorPicker;
      },
      function(module2, exports2, __webpack_require__) {
        function isNull(obj) {
          return obj === null;
        }
        module2.exports = isNull;
      },
      function(module2, exports2, __webpack_require__) {
        var isUndefined2 = __webpack_require__(3);
        var imagePing = __webpack_require__(38);
        var ms7days = 7 * 24 * 60 * 60 * 1e3;
        function isExpired(date) {
          var now2 = new Date().getTime();
          return now2 - date > ms7days;
        }
        function sendHostname(appName, trackingId) {
          var url = "https://www.google-analytics.com/collect";
          var hostname = location.hostname;
          var hitType = "event";
          var eventCategory = "use";
          var applicationKeyForStorage = "TOAST UI " + appName + " for " + hostname + ": Statistics";
          var date = window.localStorage.getItem(applicationKeyForStorage);
          if (!isUndefined2(window.tui) && window.tui.usageStatistics === false) {
            return;
          }
          if (date && !isExpired(date)) {
            return;
          }
          window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());
          setTimeout(function() {
            if (document.readyState === "interactive" || document.readyState === "complete") {
              imagePing(url, {
                v: 1,
                t: hitType,
                tid: trackingId,
                cid: hostname,
                dp: hostname,
                dh: appName,
                el: appName,
                ec: eventCategory
              });
            }
          }, 1e3);
        }
        module2.exports = sendHostname;
      },
      function(module2, exports2, __webpack_require__) {
        var forEachOwnProperties = __webpack_require__(7);
        function imagePing(url, trackingInfo) {
          var trackingElement = document.createElement("img");
          var queryString = "";
          forEachOwnProperties(trackingInfo, function(value, key) {
            queryString += "&" + key + "=" + value;
          });
          queryString = queryString.substring(1);
          trackingElement.src = url + "?" + queryString;
          trackingElement.style.display = "none";
          document.body.appendChild(trackingElement);
          document.body.removeChild(trackingElement);
          return trackingElement;
        }
        module2.exports = imagePing;
      },
      function(module2, exports2, __webpack_require__) {
        var forEach3 = __webpack_require__(2);
        var inArray = __webpack_require__(5);
        var getClass = __webpack_require__(23);
        var setClassName = __webpack_require__(40);
        function addClass2(element) {
          var cssClass = Array.prototype.slice.call(arguments, 1);
          var classList = element.classList;
          var newClass = [];
          var origin;
          if (classList) {
            forEach3(cssClass, function(name2) {
              element.classList.add(name2);
            });
            return;
          }
          origin = getClass(element);
          if (origin) {
            cssClass = [].concat(origin.split(/\s+/), cssClass);
          }
          forEach3(cssClass, function(cls) {
            if (inArray(cls, newClass) < 0) {
              newClass.push(cls);
            }
          });
          setClassName(element, newClass);
        }
        module2.exports = addClass2;
      },
      function(module2, exports2, __webpack_require__) {
        var isArray2 = __webpack_require__(1);
        var isUndefined2 = __webpack_require__(3);
        function setClassName(element, cssClass) {
          cssClass = isArray2(cssClass) ? cssClass.join(" ") : cssClass;
          cssClass = cssClass.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
          if (isUndefined2(element.className.baseVal)) {
            element.className = cssClass;
            return;
          }
          element.className.baseVal = cssClass;
        }
        module2.exports = setClassName;
      },
      function(module2, exports2, __webpack_require__) {
        function isNumber2(obj) {
          return typeof obj === "number" || obj instanceof Number;
        }
        module2.exports = isNumber2;
      },
      function(module2, exports2, __webpack_require__) {
        var on2 = __webpack_require__(14);
        var preventDefault = __webpack_require__(15);
        var setData = __webpack_require__(43);
        var testCSSProp = __webpack_require__(27);
        var SUPPORT_SELECTSTART = "onselectstart" in document;
        var KEY_PREVIOUS_USER_SELECT = "prevUserSelect";
        var userSelectProperty = testCSSProp([
          "userSelect",
          "WebkitUserSelect",
          "OUserSelect",
          "MozUserSelect",
          "msUserSelect"
        ]);
        function disableTextSelection(el) {
          if (!el) {
            el = document;
          }
          if (SUPPORT_SELECTSTART) {
            on2(el, "selectstart", preventDefault);
          } else {
            el = el === document ? document.documentElement : el;
            setData(el, KEY_PREVIOUS_USER_SELECT, el.style[userSelectProperty]);
            el.style[userSelectProperty] = "none";
          }
        }
        module2.exports = disableTextSelection;
      },
      function(module2, exports2, __webpack_require__) {
        var convertToKebabCase = __webpack_require__(16);
        function setData(element, key, value) {
          if (element.dataset) {
            element.dataset[key] = value;
            return;
          }
          element.setAttribute("data-" + convertToKebabCase(key), value);
        }
        module2.exports = setData;
      },
      function(module2, exports2, __webpack_require__) {
        var off2 = __webpack_require__(17);
        var preventDefault = __webpack_require__(15);
        var getData = __webpack_require__(45);
        var removeData = __webpack_require__(46);
        var testCSSProp = __webpack_require__(27);
        var SUPPORT_SELECTSTART = "onselectstart" in document;
        var KEY_PREVIOUS_USER_SELECT = "prevUserSelect";
        var userSelectProperty = testCSSProp([
          "userSelect",
          "WebkitUserSelect",
          "OUserSelect",
          "MozUserSelect",
          "msUserSelect"
        ]);
        function enableTextSelection(el) {
          if (!el) {
            el = document;
          }
          if (SUPPORT_SELECTSTART) {
            off2(el, "selectstart", preventDefault);
          } else {
            el = el === document ? document.documentElement : el;
            el.style[userSelectProperty] = getData(el, KEY_PREVIOUS_USER_SELECT) || "auto";
            removeData(el, KEY_PREVIOUS_USER_SELECT);
          }
        }
        module2.exports = enableTextSelection;
      },
      function(module2, exports2, __webpack_require__) {
        var convertToKebabCase = __webpack_require__(16);
        function getData(element, key) {
          if (element.dataset) {
            return element.dataset[key];
          }
          return element.getAttribute("data-" + convertToKebabCase(key));
        }
        module2.exports = getData;
      },
      function(module2, exports2, __webpack_require__) {
        var convertToKebabCase = __webpack_require__(16);
        function removeData(element, key) {
          if (element.dataset) {
            delete element.dataset[key];
            return;
          }
          element.removeAttribute("data-" + convertToKebabCase(key));
        }
        module2.exports = removeData;
      },
      function(module2, exports2, __webpack_require__) {
        var browser2 = __webpack_require__(22);
        var inArray = __webpack_require__(5);
        var primaryButton = ["0", "1", "3", "5", "7"];
        var secondaryButton = ["2", "6"];
        var wheelButton = ["4"];
        function getMouseButton(mouseEvent) {
          if (browser2.msie && browser2.version <= 8) {
            return getMouseButtonIE8AndEarlier(mouseEvent);
          }
          return mouseEvent.button;
        }
        function getMouseButtonIE8AndEarlier(mouseEvent) {
          var button = String(mouseEvent.button);
          if (inArray(button, primaryButton) > -1) {
            return 0;
          }
          if (inArray(button, secondaryButton) > -1) {
            return 2;
          }
          if (inArray(button, wheelButton) > -1) {
            return 1;
          }
          return null;
        }
        module2.exports = getMouseButton;
      },
      function(module2, exports2, __webpack_require__) {
        var CustomEvents = __webpack_require__(10);
        var extend2 = __webpack_require__(0);
        var util = __webpack_require__(4);
        var colorUtil = __webpack_require__(12);
        var Layout = __webpack_require__(49);
        var Palette = __webpack_require__(29);
        var Slider = __webpack_require__(31);
        var currentId = 0;
        function generateId() {
          currentId += 1;
          return currentId;
        }
        function ColorPicker(options) {
          var layout;
          if (!(this instanceof ColorPicker)) {
            return new ColorPicker(options);
          }
          options = this.options = extend2({
            container: null,
            color: "#f8f8f8",
            preset: ["#181818", "#282828", "#383838", "#585858", "#b8b8b8", "#d8d8d8", "#e8e8e8", "#f8f8f8", "#ab4642", "#dc9656", "#f7ca88", "#a1b56c", "#86c1b9", "#7cafc2", "#ba8baf", "#a16946"],
            cssPrefix: "tui-colorpicker-",
            detailTxt: "Detail",
            id: generateId(),
            usageStatistics: true
          }, options);
          if (!options.container) {
            throw new Error("ColorPicker(): need container option.");
          }
          layout = this.layout = new Layout(options, options.container);
          this.palette = new Palette(options, layout.container);
          this.palette.on({
            _selectColor: this._onSelectColorInPalette,
            _toggleSlider: this._onToggleSlider
          }, this);
          this.slider = new Slider(options, layout.container);
          this.slider.on("_selectColor", this._onSelectColorInSlider, this);
          layout.addChild(this.palette);
          layout.addChild(this.slider);
          this.render(options.color);
          if (options.usageStatistics) {
            util.sendHostName();
          }
        }
        ColorPicker.prototype._onSelectColorInPalette = function(selectColorEventData) {
          var color2 = selectColorEventData.color;
          var opt = this.options;
          if (!colorUtil.isValidRGB(color2) && color2 !== "") {
            this.render();
            return;
          }
          this.fire("selectColor", {
            color: color2,
            origin: "palette"
          });
          if (opt.color === color2) {
            return;
          }
          opt.color = color2;
          this.render(color2);
        };
        ColorPicker.prototype._onToggleSlider = function() {
          this.slider.toggle(!this.slider.isVisible());
        };
        ColorPicker.prototype._onSelectColorInSlider = function(selectColorEventData) {
          var color2 = selectColorEventData.color;
          var opt = this.options;
          this.fire("selectColor", {
            color: color2,
            origin: "slider"
          });
          if (opt.color === color2) {
            return;
          }
          opt.color = color2;
          this.palette.render(color2);
        };
        ColorPicker.prototype.setColor = function(hexStr) {
          if (!colorUtil.isValidRGB(hexStr)) {
            throw new Error("ColorPicker#setColor(): need valid hex string color value");
          }
          this.options.color = hexStr;
          this.render(hexStr);
        };
        ColorPicker.prototype.getColor = function() {
          return this.options.color;
        };
        ColorPicker.prototype.toggle = function(isShow) {
          this.layout.container.style.display = !!isShow ? "block" : "none";
        };
        ColorPicker.prototype.render = function(color2) {
          this.layout.render(color2 || this.options.color);
        };
        ColorPicker.prototype.destroy = function() {
          this.layout.destroy();
          this.options.container.innerHTML = "";
          this.layout = this.slider = this.palette = this.options = null;
        };
        CustomEvents.mixin(ColorPicker);
        module2.exports = ColorPicker;
      },
      function(module2, exports2, __webpack_require__) {
        var extend2 = __webpack_require__(0);
        var inherit = __webpack_require__(18);
        var domUtil = __webpack_require__(9);
        var View = __webpack_require__(8);
        function Layout(options, container) {
          this.options = extend2({
            cssPrefix: "tui-colorpicker-"
          }, options);
          container = domUtil.appendHTMLElement("div", container, this.options.cssPrefix + "container");
          View.call(this, options, container);
          this.render();
        }
        inherit(Layout, View);
        Layout.prototype.render = function(color2) {
          this.recursive(function(view) {
            view.render(color2);
          }, true);
        };
        module2.exports = Layout;
      },
      function(module2, exports2, __webpack_require__) {
        function createObject(obj) {
          function F2() {
          }
          F2.prototype = obj;
          return new F2();
        }
        module2.exports = createObject;
      },
      function(module2, exports2, __webpack_require__) {
        var template = __webpack_require__(52);
        module2.exports = function(context) {
          var item = ['<li><input class="{{cssPrefix}}palette-button{{isSelected @this}}{{getItemClass @this}}" type="button"', "{{if isValidRGB @this}}", ' style="background-color:{{@this}};color:{{@this}}"', "{{/if}}", ' title="{{@this}}" value="{{@this}}" /></li>'].join("");
          var layout = ['<ul class="{{cssPrefix}}clearfix">', "{{each preset}}", item, "{{/each}}", "</ul>", '<div class="{{cssPrefix}}clearfix" style="overflow:hidden">', '<input type="button" class="{{cssPrefix}}palette-toggle-slider" value="{{detailTxt}}" />', '<input type="text" class="{{cssPrefix}}palette-hex" value="{{color}}" maxlength="7" />', '<span class="{{cssPrefix}}palette-preview" style="background-color:{{color}};color:{{color}}">{{color}}</span>', "</div>"].join("\n");
          return template(layout, context);
        };
      },
      function(module2, exports2, __webpack_require__) {
        var inArray = __webpack_require__(5);
        var forEach3 = __webpack_require__(2);
        var isArray2 = __webpack_require__(1);
        var isString2 = __webpack_require__(11);
        var extend2 = __webpack_require__(0);
        var EXPRESSION_REGEXP = /{{\s?|\s?}}/g;
        var BRACKET_NOTATION_REGEXP = /^[a-zA-Z0-9_@]+\[[a-zA-Z0-9_@"']+\]$/;
        var BRACKET_REGEXP = /\[\s?|\s?\]/;
        var DOT_NOTATION_REGEXP = /^[a-zA-Z_]+\.[a-zA-Z_]+$/;
        var DOT_REGEXP = /\./;
        var STRING_NOTATION_REGEXP = /^["']\w+["']$/;
        var STRING_REGEXP = /"|'/g;
        var NUMBER_REGEXP = /^-?\d+\.?\d*$/;
        var EXPRESSION_INTERVAL = 2;
        var BLOCK_HELPERS = {
          "if": handleIf,
          "each": handleEach,
          "with": handleWith
        };
        var isValidSplit = "a".split(/a/).length === 3;
        var splitByRegExp = function() {
          if (isValidSplit) {
            return function(text, regexp) {
              return text.split(regexp);
            };
          }
          return function(text, regexp) {
            var result = [];
            var prevIndex = 0;
            var match, index2;
            if (!regexp.global) {
              regexp = new RegExp(regexp, "g");
            }
            match = regexp.exec(text);
            while (match !== null) {
              index2 = match.index;
              result.push(text.slice(prevIndex, index2));
              prevIndex = index2 + match[0].length;
              match = regexp.exec(text);
            }
            result.push(text.slice(prevIndex));
            return result;
          };
        }();
        function getValueFromContext(exp, context) {
          var splitedExps;
          var value = context[exp];
          if (exp === "true") {
            value = true;
          } else if (exp === "false") {
            value = false;
          } else if (STRING_NOTATION_REGEXP.test(exp)) {
            value = exp.replace(STRING_REGEXP, "");
          } else if (BRACKET_NOTATION_REGEXP.test(exp)) {
            splitedExps = exp.split(BRACKET_REGEXP);
            value = getValueFromContext(splitedExps[0], context)[getValueFromContext(splitedExps[1], context)];
          } else if (DOT_NOTATION_REGEXP.test(exp)) {
            splitedExps = exp.split(DOT_REGEXP);
            value = getValueFromContext(splitedExps[0], context)[splitedExps[1]];
          } else if (NUMBER_REGEXP.test(exp)) {
            value = parseFloat(exp);
          }
          return value;
        }
        function extractElseif(ifExps, sourcesInsideBlock) {
          var exps = [ifExps];
          var sourcesInsideIf = [];
          var otherIfCount = 0;
          var start = 0;
          forEach3(sourcesInsideBlock, function(source2, index2) {
            if (source2.indexOf("if") === 0) {
              otherIfCount += 1;
            } else if (source2 === "/if") {
              otherIfCount -= 1;
            } else if (!otherIfCount && (source2.indexOf("elseif") === 0 || source2 === "else")) {
              exps.push(source2 === "else" ? ["true"] : source2.split(" ").slice(1));
              sourcesInsideIf.push(sourcesInsideBlock.slice(start, index2));
              start = index2 + 1;
            }
          });
          sourcesInsideIf.push(sourcesInsideBlock.slice(start));
          return {
            exps,
            sourcesInsideIf
          };
        }
        function handleIf(exps, sourcesInsideBlock, context) {
          var analyzed = extractElseif(exps, sourcesInsideBlock);
          var result = false;
          var compiledSource = "";
          forEach3(analyzed.exps, function(exp, index2) {
            result = handleExpression(exp, context);
            if (result) {
              compiledSource = compile(analyzed.sourcesInsideIf[index2], context);
            }
            return !result;
          });
          return compiledSource;
        }
        function handleEach(exps, sourcesInsideBlock, context) {
          var collection = handleExpression(exps, context);
          var additionalKey = isArray2(collection) ? "@index" : "@key";
          var additionalContext = {};
          var result = "";
          forEach3(collection, function(item, key) {
            additionalContext[additionalKey] = key;
            additionalContext["@this"] = item;
            extend2(context, additionalContext);
            result += compile(sourcesInsideBlock.slice(), context);
          });
          return result;
        }
        function handleWith(exps, sourcesInsideBlock, context) {
          var asIndex = inArray("as", exps);
          var alias = exps[asIndex + 1];
          var result = handleExpression(exps.slice(0, asIndex), context);
          var additionalContext = {};
          additionalContext[alias] = result;
          return compile(sourcesInsideBlock, extend2(context, additionalContext)) || "";
        }
        function extractSourcesInsideBlock(sources, start, end) {
          var sourcesInsideBlock = sources.splice(start + 1, end - start);
          sourcesInsideBlock.pop();
          return sourcesInsideBlock;
        }
        function handleBlockHelper(helperKeyword, sourcesToEnd, context) {
          var executeBlockHelper = BLOCK_HELPERS[helperKeyword];
          var helperCount = 1;
          var startBlockIndex = 0;
          var endBlockIndex;
          var index2 = startBlockIndex + EXPRESSION_INTERVAL;
          var expression = sourcesToEnd[index2];
          while (helperCount && isString2(expression)) {
            if (expression.indexOf(helperKeyword) === 0) {
              helperCount += 1;
            } else if (expression.indexOf("/" + helperKeyword) === 0) {
              helperCount -= 1;
              endBlockIndex = index2;
            }
            index2 += EXPRESSION_INTERVAL;
            expression = sourcesToEnd[index2];
          }
          if (helperCount) {
            throw Error(helperKeyword + " needs {{/" + helperKeyword + "}} expression.");
          }
          sourcesToEnd[startBlockIndex] = executeBlockHelper(
            sourcesToEnd[startBlockIndex].split(" ").slice(1),
            extractSourcesInsideBlock(sourcesToEnd, startBlockIndex, endBlockIndex),
            context
          );
          return sourcesToEnd;
        }
        function handleExpression(exps, context) {
          var result = getValueFromContext(exps[0], context);
          if (result instanceof Function) {
            return executeFunction(result, exps.slice(1), context);
          }
          return result;
        }
        function executeFunction(helper, argExps, context) {
          var args = [];
          forEach3(argExps, function(exp) {
            args.push(getValueFromContext(exp, context));
          });
          return helper.apply(null, args);
        }
        function compile(sources, context) {
          var index2 = 1;
          var expression = sources[index2];
          var exps, firstExp, result;
          while (isString2(expression)) {
            exps = expression.split(" ");
            firstExp = exps[0];
            if (BLOCK_HELPERS[firstExp]) {
              result = handleBlockHelper(firstExp, sources.splice(index2, sources.length - index2), context);
              sources = sources.concat(result);
            } else {
              sources[index2] = handleExpression(exps, context);
            }
            index2 += EXPRESSION_INTERVAL;
            expression = sources[index2];
          }
          return sources.join("");
        }
        function template(text, context) {
          return compile(splitByRegExp(text, EXPRESSION_REGEXP), context);
        }
        module2.exports = template;
      },
      function(module2, exports2, __webpack_require__) {
        var isArray2 = __webpack_require__(1);
        function getMousePosition(position2, relativeElement) {
          var positionArray = isArray2(position2);
          var clientX = positionArray ? position2[0] : position2.clientX;
          var clientY = positionArray ? position2[1] : position2.clientY;
          var rect;
          if (!relativeElement) {
            return [clientX, clientY];
          }
          rect = relativeElement.getBoundingClientRect();
          return [
            clientX - rect.left - relativeElement.clientLeft,
            clientY - rect.top - relativeElement.clientTop
          ];
        }
        module2.exports = getMousePosition;
      },
      function(module2, exports2, __webpack_require__) {
        var matches2 = __webpack_require__(55);
        function closest2(element, selector) {
          var parent = element.parentNode;
          if (matches2(element, selector)) {
            return element;
          }
          while (parent && parent !== document) {
            if (matches2(parent, selector)) {
              return parent;
            }
            parent = parent.parentNode;
          }
          return null;
        }
        module2.exports = closest2;
      },
      function(module2, exports2, __webpack_require__) {
        var inArray = __webpack_require__(5);
        var toArray3 = __webpack_require__(56);
        var elProto = Element.prototype;
        var matchSelector = elProto.matches || elProto.webkitMatchesSelector || elProto.mozMatchesSelector || elProto.msMatchesSelector || function(selector) {
          var doc2 = this.document || this.ownerDocument;
          return inArray(this, toArray3(doc2.querySelectorAll(selector))) > -1;
        };
        function matches2(element, selector) {
          return matchSelector.call(element, selector);
        }
        module2.exports = matches2;
      },
      function(module2, exports2, __webpack_require__) {
        var forEachArray = __webpack_require__(6);
        function toArray3(arrayLike) {
          var arr2;
          try {
            arr2 = Array.prototype.slice.call(arrayLike);
          } catch (e2) {
            arr2 = [];
            forEachArray(arrayLike, function(value) {
              arr2.push(value);
            });
          }
          return arr2;
        }
        module2.exports = toArray3;
      },
      function(module2, exports2, __webpack_require__) {
        (function(global2) {
          var isOldBrowser = __webpack_require__(4).isOldBrowser;
          var layout = ['<div class="{{cssPrefix}}slider-left {{cssPrefix}}slider-part">{{slider}}</div>', '<div class="{{cssPrefix}}slider-right {{cssPrefix}}slider-part">{{huebar}}</div>'].join("\n");
          var SVGSlider = ['<svg class="{{cssPrefix}}svg {{cssPrefix}}svg-slider">', "<defs>", '<linearGradient id="{{cssPrefix}}svg-fill-color-{{id}}" x1="0%" y1="0%" x2="100%" y2="0%">', '<stop offset="0%" stop-color="rgb(255,255,255)" />', '<stop class="{{cssPrefix}}slider-basecolor" offset="100%" stop-color="rgb(255,0,0)" />', "</linearGradient>", '<linearGradient id="{{cssPrefix}}svn-fill-black-{{id}}" x1="0%" y1="0%" x2="0%" y2="100%">', '<stop offset="0%" style="stop-color:rgb(0,0,0);stop-opacity:0" />', '<stop offset="100%" style="stop-color:rgb(0,0,0);stop-opacity:1" />', "</linearGradient>", "</defs>", '<rect width="100%" height="100%" fill="url(#{{cssPrefix}}svg-fill-color-{{id}})"></rect>', '<rect width="100%" height="100%" fill="url(#{{cssPrefix}}svn-fill-black-{{id}})"></rect>', '<path transform="translate(0,0)" class="{{cssPrefix}}slider-handle" d="M0 7.5 L15 7.5 M7.5 15 L7.5 0 M2 7 a5.5 5.5 0 1 1 0 1 Z" stroke="black" stroke-width="0.75" fill="none" />', "</svg>"].join("\n");
          var VMLSlider = ['<div class="{{cssPrefix}}vml-slider">', '<v:rect strokecolor="none" class="{{cssPrefix}}vml {{cssPrefix}}vml-slider-bg">', '<v:fill class="{{cssPrefix}}vml {{cssPrefix}}slider-basecolor" type="gradient" method="none" color="#ff0000" color2="#fff" angle="90" />', "</v:rect>", '<v:rect strokecolor="#ccc" class="{{cssPrefix}}vml {{cssPrefix}}vml-slider-bg">', '<v:fill type="gradient" method="none" color="black" color2="white" o:opacity2="0%" class="{{cssPrefix}}vml" />', "</v:rect>", '<v:shape class="{{cssPrefix}}vml {{cssPrefix}}slider-handle" coordsize="1 1" style="width:1px;height:1px;"path="m 0,7 l 14,7 m 7,14 l 7,0 ar 12,12 2,2 z" filled="false" stroked="true" />', "</div>"].join("\n");
          var SVGHuebar = ['<svg class="{{cssPrefix}}svg {{cssPrefix}}svg-huebar">', "<defs>", '<linearGradient id="g-{{id}}" x1="0%" y1="0%" x2="0%" y2="100%">', '<stop offset="0%" stop-color="rgb(255,0,0)" />', '<stop offset="16.666%" stop-color="rgb(255,255,0)" />', '<stop offset="33.333%" stop-color="rgb(0,255,0)" />', '<stop offset="50%" stop-color="rgb(0,255,255)" />', '<stop offset="66.666%" stop-color="rgb(0,0,255)" />', '<stop offset="83.333%" stop-color="rgb(255,0,255)" />', '<stop offset="100%" stop-color="rgb(255,0,0)" />', "</linearGradient>", "</defs>", '<rect width="18px" height="100%" fill="url(#g-{{id}})"></rect>', '<path transform="translate(-6,-3)" class="{{cssPrefix}}huebar-handle" d="M0 0 L4 4 L0 8 L0 0 Z" fill="black" stroke="none" />', "</svg>"].join("\n");
          var VMLHuebar = ['<div class="{{cssPrefix}}vml-huebar">', '<v:rect strokecolor="#ccc" class="{{cssPrefix}}vml {{cssPrefix}}vml-huebar-bg">', '<v:fill type="gradient" method="none" colors="0% rgb(255,0,0), 16.666% rgb(255,255,0), 33.333% rgb(0,255,0), 50% rgb(0,255,255), 66.666% rgb(0,0,255), 83.333% rgb(255,0,255), 100% rgb(255,0,0)" angle="180" class="{{cssPrefix}}vml" />', "</v:rect>", '<v:shape class="{{cssPrefix}}vml {{cssPrefix}}huebar-handle" coordsize="1 1" style="width:1px;height:1px;position:absolute;z-index:1;right:22px;top:-3px;"path="m 0,0 l 4,4 l 0,8 l 0,0 z" filled="true" fillcolor="black" stroked="false" />', "</div>"].join("\n");
          if (isOldBrowser) {
            global2.document.namespaces.add("v", "urn:schemas-microsoft-com:vml");
          }
          module2.exports = {
            layout,
            slider: isOldBrowser ? VMLSlider : SVGSlider,
            huebar: isOldBrowser ? VMLHuebar : SVGHuebar
          };
        }).call(this, __webpack_require__(25));
      }
    ]);
  });
})(tuiColorPicker);
/*!
 * TOAST UI ImageEditor
 * @version 3.15.3
 * @license MIT
 */
(function(module, exports) {
  (function webpackUniversalModuleDefinition(root, factory) {
    module.exports = factory(tuiColorPicker.exports);
  })(self, function(__WEBPACK_EXTERNAL_MODULE__4858__) {
    return function() {
      var __webpack_modules__ = {
        2777: function(__unused_webpack_module, exports2, __webpack_require__2) {
          /*! Fabric.js Copyright 2008-2015, Printio (Juriy Zaytsev, Maxim Chernyak) */
          var fabric = fabric || { version: "4.6.0" };
          {
            exports2.fabric = fabric;
          }
          if (typeof document !== "undefined" && typeof window !== "undefined") {
            if (document instanceof (typeof HTMLDocument !== "undefined" ? HTMLDocument : Document)) {
              fabric.document = document;
            } else {
              fabric.document = document.implementation.createHTMLDocument("");
            }
            fabric.window = window;
          } else {
            var jsdom = __webpack_require__2(4960);
            var virtualWindow = new jsdom.JSDOM(
              decodeURIComponent("%3C!DOCTYPE%20html%3E%3Chtml%3E%3Chead%3E%3C%2Fhead%3E%3Cbody%3E%3C%2Fbody%3E%3C%2Fhtml%3E"),
              {
                features: {
                  FetchExternalResources: ["img"]
                },
                resources: "usable"
              }
            ).window;
            fabric.document = virtualWindow.document;
            fabric.jsdomImplForWrapper = __webpack_require__2(6759).implForWrapper;
            fabric.nodeCanvas = __webpack_require__2(6272).Canvas;
            fabric.window = virtualWindow;
            DOMParser = fabric.window.DOMParser;
          }
          fabric.isTouchSupported = "ontouchstart" in fabric.window || "ontouchstart" in fabric.document || fabric.window && fabric.window.navigator && fabric.window.navigator.maxTouchPoints > 0;
          fabric.isLikelyNode = typeof Buffer !== "undefined" && typeof window === "undefined";
          fabric.SHARED_ATTRIBUTES = [
            "display",
            "transform",
            "fill",
            "fill-opacity",
            "fill-rule",
            "opacity",
            "stroke",
            "stroke-dasharray",
            "stroke-linecap",
            "stroke-dashoffset",
            "stroke-linejoin",
            "stroke-miterlimit",
            "stroke-opacity",
            "stroke-width",
            "id",
            "paint-order",
            "vector-effect",
            "instantiated_by_use",
            "clip-path"
          ];
          fabric.DPI = 96;
          fabric.reNum = "(?:[-+]?(?:\\d+|\\d*\\.\\d+)(?:[eE][-+]?\\d+)?)";
          fabric.commaWsp = "(?:\\s+,?\\s*|,\\s*)";
          fabric.rePathCommand = /([-+]?((\d+\.\d+)|((\d+)|(\.\d+)))(?:[eE][-+]?\d+)?)/ig;
          fabric.reNonWord = /[ \n\.,;!\?\-]/;
          fabric.fontPaths = {};
          fabric.iMatrix = [1, 0, 0, 1, 0, 0];
          fabric.svgNS = "http://www.w3.org/2000/svg";
          fabric.perfLimitSizeTotal = 2097152;
          fabric.maxCacheSideLimit = 4096;
          fabric.minCacheSideLimit = 256;
          fabric.charWidthsCache = {};
          fabric.textureSize = 2048;
          fabric.disableStyleCopyPaste = false;
          fabric.enableGLFiltering = true;
          fabric.devicePixelRatio = fabric.window.devicePixelRatio || fabric.window.webkitDevicePixelRatio || fabric.window.mozDevicePixelRatio || 1;
          fabric.browserShadowBlurConstant = 1;
          fabric.arcToSegmentsCache = {};
          fabric.boundsOfCurveCache = {};
          fabric.cachesBoundsOfCurve = true;
          fabric.forceGLPutImageData = false;
          fabric.initFilterBackend = function() {
            if (fabric.enableGLFiltering && fabric.isWebglSupported && fabric.isWebglSupported(fabric.textureSize)) {
              console.log("max texture size: " + fabric.maxTextureSize);
              return new fabric.WebglFilterBackend({ tileSize: fabric.textureSize });
            } else if (fabric.Canvas2dFilterBackend) {
              return new fabric.Canvas2dFilterBackend();
            }
          };
          if (typeof document !== "undefined" && typeof window !== "undefined") {
            window.fabric = fabric;
          }
          (function() {
            function _removeEventListener(eventName, handler) {
              if (!this.__eventListeners[eventName]) {
                return;
              }
              var eventListener = this.__eventListeners[eventName];
              if (handler) {
                eventListener[eventListener.indexOf(handler)] = false;
              } else {
                fabric.util.array.fill(eventListener, false);
              }
            }
            function on2(eventName, handler) {
              if (!this.__eventListeners) {
                this.__eventListeners = {};
              }
              if (arguments.length === 1) {
                for (var prop in eventName) {
                  this.on(prop, eventName[prop]);
                }
              } else {
                if (!this.__eventListeners[eventName]) {
                  this.__eventListeners[eventName] = [];
                }
                this.__eventListeners[eventName].push(handler);
              }
              return this;
            }
            function _once(eventName, handler) {
              var _handler = function() {
                handler.apply(this, arguments);
                this.off(eventName, _handler);
              }.bind(this);
              this.on(eventName, _handler);
            }
            function once(eventName, handler) {
              if (arguments.length === 1) {
                for (var prop in eventName) {
                  _once.call(this, prop, eventName[prop]);
                }
              } else {
                _once.call(this, eventName, handler);
              }
              return this;
            }
            function off2(eventName, handler) {
              if (!this.__eventListeners) {
                return this;
              }
              if (arguments.length === 0) {
                for (eventName in this.__eventListeners) {
                  _removeEventListener.call(this, eventName);
                }
              } else if (arguments.length === 1 && typeof arguments[0] === "object") {
                for (var prop in eventName) {
                  _removeEventListener.call(this, prop, eventName[prop]);
                }
              } else {
                _removeEventListener.call(this, eventName, handler);
              }
              return this;
            }
            function fire(eventName, options) {
              if (!this.__eventListeners) {
                return this;
              }
              var listenersForEvent = this.__eventListeners[eventName];
              if (!listenersForEvent) {
                return this;
              }
              for (var i = 0, len = listenersForEvent.length; i < len; i++) {
                listenersForEvent[i] && listenersForEvent[i].call(this, options || {});
              }
              this.__eventListeners[eventName] = listenersForEvent.filter(function(value) {
                return value !== false;
              });
              return this;
            }
            fabric.Observable = {
              fire,
              on: on2,
              once,
              off: off2
            };
          })();
          fabric.Collection = {
            _objects: [],
            add: function() {
              this._objects.push.apply(this._objects, arguments);
              if (this._onObjectAdded) {
                for (var i = 0, length = arguments.length; i < length; i++) {
                  this._onObjectAdded(arguments[i]);
                }
              }
              this.renderOnAddRemove && this.requestRenderAll();
              return this;
            },
            insertAt: function(object, index2, nonSplicing) {
              var objects = this._objects;
              if (nonSplicing) {
                objects[index2] = object;
              } else {
                objects.splice(index2, 0, object);
              }
              this._onObjectAdded && this._onObjectAdded(object);
              this.renderOnAddRemove && this.requestRenderAll();
              return this;
            },
            remove: function() {
              var objects = this._objects, index2, somethingRemoved = false;
              for (var i = 0, length = arguments.length; i < length; i++) {
                index2 = objects.indexOf(arguments[i]);
                if (index2 !== -1) {
                  somethingRemoved = true;
                  objects.splice(index2, 1);
                  this._onObjectRemoved && this._onObjectRemoved(arguments[i]);
                }
              }
              this.renderOnAddRemove && somethingRemoved && this.requestRenderAll();
              return this;
            },
            forEachObject: function(callback, context) {
              var objects = this.getObjects();
              for (var i = 0, len = objects.length; i < len; i++) {
                callback.call(context, objects[i], i, objects);
              }
              return this;
            },
            getObjects: function(type) {
              if (typeof type === "undefined") {
                return this._objects.concat();
              }
              return this._objects.filter(function(o) {
                return o.type === type;
              });
            },
            item: function(index2) {
              return this._objects[index2];
            },
            isEmpty: function() {
              return this._objects.length === 0;
            },
            size: function() {
              return this._objects.length;
            },
            contains: function(object, deep) {
              if (this._objects.indexOf(object) > -1) {
                return true;
              } else if (deep) {
                return this._objects.some(function(obj) {
                  return typeof obj.contains === "function" && obj.contains(object, true);
                });
              }
              return false;
            },
            complexity: function() {
              return this._objects.reduce(function(memo, current) {
                memo += current.complexity ? current.complexity() : 0;
                return memo;
              }, 0);
            }
          };
          fabric.CommonMethods = {
            _setOptions: function(options) {
              for (var prop in options) {
                this.set(prop, options[prop]);
              }
            },
            _initGradient: function(filler, property) {
              if (filler && filler.colorStops && !(filler instanceof fabric.Gradient)) {
                this.set(property, new fabric.Gradient(filler));
              }
            },
            _initPattern: function(filler, property, callback) {
              if (filler && filler.source && !(filler instanceof fabric.Pattern)) {
                this.set(property, new fabric.Pattern(filler, callback));
              } else {
                callback && callback();
              }
            },
            _setObject: function(obj) {
              for (var prop in obj) {
                this._set(prop, obj[prop]);
              }
            },
            set: function(key, value) {
              if (typeof key === "object") {
                this._setObject(key);
              } else {
                this._set(key, value);
              }
              return this;
            },
            _set: function(key, value) {
              this[key] = value;
            },
            toggle: function(property) {
              var value = this.get(property);
              if (typeof value === "boolean") {
                this.set(property, !value);
              }
              return this;
            },
            get: function(property) {
              return this[property];
            }
          };
          (function(global2) {
            var sqrt2 = Math.sqrt, atan2 = Math.atan2, pow = Math.pow, PiBy180 = Math.PI / 180, PiBy2 = Math.PI / 2;
            fabric.util = {
              cos: function(angle2) {
                if (angle2 === 0) {
                  return 1;
                }
                if (angle2 < 0) {
                  angle2 = -angle2;
                }
                var angleSlice = angle2 / PiBy2;
                switch (angleSlice) {
                  case 1:
                  case 3:
                    return 0;
                  case 2:
                    return -1;
                }
                return Math.cos(angle2);
              },
              sin: function(angle2) {
                if (angle2 === 0) {
                  return 0;
                }
                var angleSlice = angle2 / PiBy2, sign2 = 1;
                if (angle2 < 0) {
                  sign2 = -1;
                }
                switch (angleSlice) {
                  case 1:
                    return sign2;
                  case 2:
                    return 0;
                  case 3:
                    return -sign2;
                }
                return Math.sin(angle2);
              },
              removeFromArray: function(array, value) {
                var idx = array.indexOf(value);
                if (idx !== -1) {
                  array.splice(idx, 1);
                }
                return array;
              },
              getRandomInt: function(min, max2) {
                return Math.floor(Math.random() * (max2 - min + 1)) + min;
              },
              degreesToRadians: function(degrees) {
                return degrees * PiBy180;
              },
              radiansToDegrees: function(radians) {
                return radians / PiBy180;
              },
              rotatePoint: function(point, origin, radians) {
                var newPoint = new fabric.Point(point.x - origin.x, point.y - origin.y), v = fabric.util.rotateVector(newPoint, radians);
                return new fabric.Point(v.x, v.y).addEquals(origin);
              },
              rotateVector: function(vector, radians) {
                var sin = fabric.util.sin(radians), cos = fabric.util.cos(radians), rx = vector.x * cos - vector.y * sin, ry = vector.x * sin + vector.y * cos;
                return {
                  x: rx,
                  y: ry
                };
              },
              transformPoint: function(p, t, ignoreOffset) {
                if (ignoreOffset) {
                  return new fabric.Point(
                    t[0] * p.x + t[2] * p.y,
                    t[1] * p.x + t[3] * p.y
                  );
                }
                return new fabric.Point(
                  t[0] * p.x + t[2] * p.y + t[4],
                  t[1] * p.x + t[3] * p.y + t[5]
                );
              },
              makeBoundingBoxFromPoints: function(points, transform2) {
                if (transform2) {
                  for (var i = 0; i < points.length; i++) {
                    points[i] = fabric.util.transformPoint(points[i], transform2);
                  }
                }
                var xPoints = [points[0].x, points[1].x, points[2].x, points[3].x], minX = fabric.util.array.min(xPoints), maxX = fabric.util.array.max(xPoints), width = maxX - minX, yPoints = [points[0].y, points[1].y, points[2].y, points[3].y], minY = fabric.util.array.min(yPoints), maxY = fabric.util.array.max(yPoints), height = maxY - minY;
                return {
                  left: minX,
                  top: minY,
                  width,
                  height
                };
              },
              invertTransform: function(t) {
                var a2 = 1 / (t[0] * t[3] - t[1] * t[2]), r = [a2 * t[3], -a2 * t[1], -a2 * t[2], a2 * t[0]], o = fabric.util.transformPoint({ x: t[4], y: t[5] }, r, true);
                r[4] = -o.x;
                r[5] = -o.y;
                return r;
              },
              toFixed: function(number, fractionDigits) {
                return parseFloat(Number(number).toFixed(fractionDigits));
              },
              parseUnit: function(value, fontSize2) {
                var unit = /\D{0,2}$/.exec(value), number = parseFloat(value);
                if (!fontSize2) {
                  fontSize2 = fabric.Text.DEFAULT_SVG_FONT_SIZE;
                }
                switch (unit[0]) {
                  case "mm":
                    return number * fabric.DPI / 25.4;
                  case "cm":
                    return number * fabric.DPI / 2.54;
                  case "in":
                    return number * fabric.DPI;
                  case "pt":
                    return number * fabric.DPI / 72;
                  case "pc":
                    return number * fabric.DPI / 72 * 12;
                  case "em":
                    return number * fontSize2;
                  default:
                    return number;
                }
              },
              falseFunction: function() {
                return false;
              },
              getKlass: function(type, namespace) {
                type = fabric.util.string.camelize(type.charAt(0).toUpperCase() + type.slice(1));
                return fabric.util.resolveNamespace(namespace)[type];
              },
              getSvgAttributes: function(type) {
                var attributes = [
                  "instantiated_by_use",
                  "style",
                  "id",
                  "class"
                ];
                switch (type) {
                  case "linearGradient":
                    attributes = attributes.concat(["x1", "y1", "x2", "y2", "gradientUnits", "gradientTransform"]);
                    break;
                  case "radialGradient":
                    attributes = attributes.concat(["gradientUnits", "gradientTransform", "cx", "cy", "r", "fx", "fy", "fr"]);
                    break;
                  case "stop":
                    attributes = attributes.concat(["offset", "stop-color", "stop-opacity"]);
                    break;
                }
                return attributes;
              },
              resolveNamespace: function(namespace) {
                if (!namespace) {
                  return fabric;
                }
                var parts = namespace.split("."), len = parts.length, i, obj = global2 || fabric.window;
                for (i = 0; i < len; ++i) {
                  obj = obj[parts[i]];
                }
                return obj;
              },
              loadImage: function(url, callback, context, crossOrigin) {
                if (!url) {
                  callback && callback.call(context, url);
                  return;
                }
                var img = fabric.util.createImage();
                var onLoadCallback = function() {
                  callback && callback.call(context, img, false);
                  img = img.onload = img.onerror = null;
                };
                img.onload = onLoadCallback;
                img.onerror = function() {
                  fabric.log("Error loading " + img.src);
                  callback && callback.call(context, null, true);
                  img = img.onload = img.onerror = null;
                };
                if (url.indexOf("data") !== 0 && crossOrigin !== void 0 && crossOrigin !== null) {
                  img.crossOrigin = crossOrigin;
                }
                if (url.substring(0, 14) === "data:image/svg") {
                  img.onload = null;
                  fabric.util.loadImageInDom(img, onLoadCallback);
                }
                img.src = url;
              },
              loadImageInDom: function(img, onLoadCallback) {
                var div = fabric.document.createElement("div");
                div.style.width = div.style.height = "1px";
                div.style.left = div.style.top = "-100%";
                div.style.position = "absolute";
                div.appendChild(img);
                fabric.document.querySelector("body").appendChild(div);
                img.onload = function() {
                  onLoadCallback();
                  div.parentNode.removeChild(div);
                  div = null;
                };
              },
              enlivenObjects: function(objects, callback, namespace, reviver) {
                objects = objects || [];
                var enlivenedObjects = [], numLoadedObjects = 0, numTotalObjects = objects.length;
                function onLoaded() {
                  if (++numLoadedObjects === numTotalObjects) {
                    callback && callback(enlivenedObjects.filter(function(obj) {
                      return obj;
                    }));
                  }
                }
                if (!numTotalObjects) {
                  callback && callback(enlivenedObjects);
                  return;
                }
                objects.forEach(function(o, index2) {
                  if (!o || !o.type) {
                    onLoaded();
                    return;
                  }
                  var klass = fabric.util.getKlass(o.type, namespace);
                  klass.fromObject(o, function(obj, error) {
                    error || (enlivenedObjects[index2] = obj);
                    reviver && reviver(o, obj, error);
                    onLoaded();
                  });
                });
              },
              enlivenPatterns: function(patterns, callback) {
                patterns = patterns || [];
                function onLoaded() {
                  if (++numLoadedPatterns === numPatterns) {
                    callback && callback(enlivenedPatterns);
                  }
                }
                var enlivenedPatterns = [], numLoadedPatterns = 0, numPatterns = patterns.length;
                if (!numPatterns) {
                  callback && callback(enlivenedPatterns);
                  return;
                }
                patterns.forEach(function(p, index2) {
                  if (p && p.source) {
                    new fabric.Pattern(p, function(pattern) {
                      enlivenedPatterns[index2] = pattern;
                      onLoaded();
                    });
                  } else {
                    enlivenedPatterns[index2] = p;
                    onLoaded();
                  }
                });
              },
              groupSVGElements: function(elements, options, path) {
                var object;
                if (elements && elements.length === 1) {
                  return elements[0];
                }
                if (options) {
                  if (options.width && options.height) {
                    options.centerPoint = {
                      x: options.width / 2,
                      y: options.height / 2
                    };
                  } else {
                    delete options.width;
                    delete options.height;
                  }
                }
                object = new fabric.Group(elements, options);
                if (typeof path !== "undefined") {
                  object.sourcePath = path;
                }
                return object;
              },
              populateWithProperties: function(source2, destination, properties) {
                if (properties && Object.prototype.toString.call(properties) === "[object Array]") {
                  for (var i = 0, len = properties.length; i < len; i++) {
                    if (properties[i] in source2) {
                      destination[properties[i]] = source2[properties[i]];
                    }
                  }
                }
              },
              drawDashedLine: function(ctx, x, y, x2, y2, da) {
                var dx = x2 - x, dy = y2 - y, len = sqrt2(dx * dx + dy * dy), rot = atan2(dy, dx), dc = da.length, di = 0, draw = true;
                ctx.save();
                ctx.translate(x, y);
                ctx.moveTo(0, 0);
                ctx.rotate(rot);
                x = 0;
                while (len > x) {
                  x += da[di++ % dc];
                  if (x > len) {
                    x = len;
                  }
                  ctx[draw ? "lineTo" : "moveTo"](x, 0);
                  draw = !draw;
                }
                ctx.restore();
              },
              createCanvasElement: function() {
                return fabric.document.createElement("canvas");
              },
              copyCanvasElement: function(canvas) {
                var newCanvas = fabric.util.createCanvasElement();
                newCanvas.width = canvas.width;
                newCanvas.height = canvas.height;
                newCanvas.getContext("2d").drawImage(canvas, 0, 0);
                return newCanvas;
              },
              toDataURL: function(canvasEl, format, quality) {
                return canvasEl.toDataURL("image/" + format, quality);
              },
              createImage: function() {
                return fabric.document.createElement("img");
              },
              multiplyTransformMatrices: function(a2, b, is2x2) {
                return [
                  a2[0] * b[0] + a2[2] * b[1],
                  a2[1] * b[0] + a2[3] * b[1],
                  a2[0] * b[2] + a2[2] * b[3],
                  a2[1] * b[2] + a2[3] * b[3],
                  is2x2 ? 0 : a2[0] * b[4] + a2[2] * b[5] + a2[4],
                  is2x2 ? 0 : a2[1] * b[4] + a2[3] * b[5] + a2[5]
                ];
              },
              qrDecompose: function(a2) {
                var angle2 = atan2(a2[1], a2[0]), denom = pow(a2[0], 2) + pow(a2[1], 2), scaleX = sqrt2(denom), scaleY = (a2[0] * a2[3] - a2[2] * a2[1]) / scaleX, skewX = atan2(a2[0] * a2[2] + a2[1] * a2[3], denom);
                return {
                  angle: angle2 / PiBy180,
                  scaleX,
                  scaleY,
                  skewX: skewX / PiBy180,
                  skewY: 0,
                  translateX: a2[4],
                  translateY: a2[5]
                };
              },
              calcRotateMatrix: function(options) {
                if (!options.angle) {
                  return fabric.iMatrix.concat();
                }
                var theta = fabric.util.degreesToRadians(options.angle), cos = fabric.util.cos(theta), sin = fabric.util.sin(theta);
                return [cos, sin, -sin, cos, 0, 0];
              },
              calcDimensionsMatrix: function(options) {
                var scaleX = typeof options.scaleX === "undefined" ? 1 : options.scaleX, scaleY = typeof options.scaleY === "undefined" ? 1 : options.scaleY, scaleMatrix2 = [
                  options.flipX ? -scaleX : scaleX,
                  0,
                  0,
                  options.flipY ? -scaleY : scaleY,
                  0,
                  0
                ], multiply3 = fabric.util.multiplyTransformMatrices, degreesToRadians = fabric.util.degreesToRadians;
                if (options.skewX) {
                  scaleMatrix2 = multiply3(
                    scaleMatrix2,
                    [1, 0, Math.tan(degreesToRadians(options.skewX)), 1],
                    true
                  );
                }
                if (options.skewY) {
                  scaleMatrix2 = multiply3(
                    scaleMatrix2,
                    [1, Math.tan(degreesToRadians(options.skewY)), 0, 1],
                    true
                  );
                }
                return scaleMatrix2;
              },
              composeMatrix: function(options) {
                var matrix2 = [1, 0, 0, 1, options.translateX || 0, options.translateY || 0], multiply3 = fabric.util.multiplyTransformMatrices;
                if (options.angle) {
                  matrix2 = multiply3(matrix2, fabric.util.calcRotateMatrix(options));
                }
                if (options.scaleX !== 1 || options.scaleY !== 1 || options.skewX || options.skewY || options.flipX || options.flipY) {
                  matrix2 = multiply3(matrix2, fabric.util.calcDimensionsMatrix(options));
                }
                return matrix2;
              },
              resetObjectTransform: function(target) {
                target.scaleX = 1;
                target.scaleY = 1;
                target.skewX = 0;
                target.skewY = 0;
                target.flipX = false;
                target.flipY = false;
                target.rotate(0);
              },
              saveObjectTransform: function(target) {
                return {
                  scaleX: target.scaleX,
                  scaleY: target.scaleY,
                  skewX: target.skewX,
                  skewY: target.skewY,
                  angle: target.angle,
                  left: target.left,
                  flipX: target.flipX,
                  flipY: target.flipY,
                  top: target.top
                };
              },
              isTransparent: function(ctx, x, y, tolerance) {
                if (tolerance > 0) {
                  if (x > tolerance) {
                    x -= tolerance;
                  } else {
                    x = 0;
                  }
                  if (y > tolerance) {
                    y -= tolerance;
                  } else {
                    y = 0;
                  }
                }
                var _isTransparent = true, i, temp, imageData = ctx.getImageData(x, y, tolerance * 2 || 1, tolerance * 2 || 1), l = imageData.data.length;
                for (i = 3; i < l; i += 4) {
                  temp = imageData.data[i];
                  _isTransparent = temp <= 0;
                  if (_isTransparent === false) {
                    break;
                  }
                }
                imageData = null;
                return _isTransparent;
              },
              parsePreserveAspectRatioAttribute: function(attribute) {
                var meetOrSlice = "meet", alignX = "Mid", alignY = "Mid", aspectRatioAttrs = attribute.split(" "), align;
                if (aspectRatioAttrs && aspectRatioAttrs.length) {
                  meetOrSlice = aspectRatioAttrs.pop();
                  if (meetOrSlice !== "meet" && meetOrSlice !== "slice") {
                    align = meetOrSlice;
                    meetOrSlice = "meet";
                  } else if (aspectRatioAttrs.length) {
                    align = aspectRatioAttrs.pop();
                  }
                }
                alignX = align !== "none" ? align.slice(1, 4) : "none";
                alignY = align !== "none" ? align.slice(5, 8) : "none";
                return {
                  meetOrSlice,
                  alignX,
                  alignY
                };
              },
              clearFabricFontCache: function(fontFamily2) {
                fontFamily2 = (fontFamily2 || "").toLowerCase();
                if (!fontFamily2) {
                  fabric.charWidthsCache = {};
                } else if (fabric.charWidthsCache[fontFamily2]) {
                  delete fabric.charWidthsCache[fontFamily2];
                }
              },
              limitDimsByArea: function(ar, maximumArea) {
                var roughWidth = Math.sqrt(maximumArea * ar), perfLimitSizeY = Math.floor(maximumArea / roughWidth);
                return { x: Math.floor(roughWidth), y: perfLimitSizeY };
              },
              capValue: function(min, value, max2) {
                return Math.max(min, Math.min(value, max2));
              },
              findScaleToFit: function(source2, destination) {
                return Math.min(destination.width / source2.width, destination.height / source2.height);
              },
              findScaleToCover: function(source2, destination) {
                return Math.max(destination.width / source2.width, destination.height / source2.height);
              },
              matrixToSVG: function(transform2) {
                return "matrix(" + transform2.map(function(value) {
                  return fabric.util.toFixed(value, fabric.Object.NUM_FRACTION_DIGITS);
                }).join(" ") + ")";
              },
              removeTransformFromObject: function(object, transform2) {
                var inverted = fabric.util.invertTransform(transform2), finalTransform = fabric.util.multiplyTransformMatrices(inverted, object.calcOwnMatrix());
                fabric.util.applyTransformToObject(object, finalTransform);
              },
              addTransformToObject: function(object, transform2) {
                fabric.util.applyTransformToObject(
                  object,
                  fabric.util.multiplyTransformMatrices(transform2, object.calcOwnMatrix())
                );
              },
              applyTransformToObject: function(object, transform2) {
                var options = fabric.util.qrDecompose(transform2), center = new fabric.Point(options.translateX, options.translateY);
                object.flipX = false;
                object.flipY = false;
                object.set("scaleX", options.scaleX);
                object.set("scaleY", options.scaleY);
                object.skewX = options.skewX;
                object.skewY = options.skewY;
                object.angle = options.angle;
                object.setPositionByOrigin(center, "center", "center");
              },
              sizeAfterTransform: function(width, height, options) {
                var dimX = width / 2, dimY = height / 2, points = [
                  {
                    x: -dimX,
                    y: -dimY
                  },
                  {
                    x: dimX,
                    y: -dimY
                  },
                  {
                    x: -dimX,
                    y: dimY
                  },
                  {
                    x: dimX,
                    y: dimY
                  }
                ], transformMatrix = fabric.util.calcDimensionsMatrix(options), bbox = fabric.util.makeBoundingBoxFromPoints(points, transformMatrix);
                return {
                  x: bbox.width,
                  y: bbox.height
                };
              }
            };
          })(exports2);
          (function() {
            var _join = Array.prototype.join, commandLengths = {
              m: 2,
              l: 2,
              h: 1,
              v: 1,
              c: 6,
              s: 4,
              q: 4,
              t: 2,
              a: 7
            }, repeatedCommands = {
              m: "l",
              M: "L"
            };
            function segmentToBezier(th2, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY) {
              var costh2 = fabric.util.cos(th2), sinth2 = fabric.util.sin(th2), costh3 = fabric.util.cos(th3), sinth3 = fabric.util.sin(th3), toX = cosTh * rx * costh3 - sinTh * ry * sinth3 + cx1, toY = sinTh * rx * costh3 + cosTh * ry * sinth3 + cy1, cp1X = fromX + mT * (-cosTh * rx * sinth2 - sinTh * ry * costh2), cp1Y = fromY + mT * (-sinTh * rx * sinth2 + cosTh * ry * costh2), cp2X = toX + mT * (cosTh * rx * sinth3 + sinTh * ry * costh3), cp2Y = toY + mT * (sinTh * rx * sinth3 - cosTh * ry * costh3);
              return [
                "C",
                cp1X,
                cp1Y,
                cp2X,
                cp2Y,
                toX,
                toY
              ];
            }
            function arcToSegments(toX, toY, rx, ry, large, sweep, rotateX) {
              var PI = Math.PI, th = rotateX * PI / 180, sinTh = fabric.util.sin(th), cosTh = fabric.util.cos(th), fromX = 0, fromY = 0;
              rx = Math.abs(rx);
              ry = Math.abs(ry);
              var px = -cosTh * toX * 0.5 - sinTh * toY * 0.5, py = -cosTh * toY * 0.5 + sinTh * toX * 0.5, rx2 = rx * rx, ry2 = ry * ry, py2 = py * py, px2 = px * px, pl = rx2 * ry2 - rx2 * py2 - ry2 * px2, root = 0;
              if (pl < 0) {
                var s = Math.sqrt(1 - pl / (rx2 * ry2));
                rx *= s;
                ry *= s;
              } else {
                root = (large === sweep ? -1 : 1) * Math.sqrt(pl / (rx2 * py2 + ry2 * px2));
              }
              var cx = root * rx * py / ry, cy = -root * ry * px / rx, cx1 = cosTh * cx - sinTh * cy + toX * 0.5, cy1 = sinTh * cx + cosTh * cy + toY * 0.5, mTheta = calcVectorAngle(1, 0, (px - cx) / rx, (py - cy) / ry), dtheta = calcVectorAngle((px - cx) / rx, (py - cy) / ry, (-px - cx) / rx, (-py - cy) / ry);
              if (sweep === 0 && dtheta > 0) {
                dtheta -= 2 * PI;
              } else if (sweep === 1 && dtheta < 0) {
                dtheta += 2 * PI;
              }
              var segments = Math.ceil(Math.abs(dtheta / PI * 2)), result = [], mDelta = dtheta / segments, mT = 8 / 3 * Math.sin(mDelta / 4) * Math.sin(mDelta / 4) / Math.sin(mDelta / 2), th3 = mTheta + mDelta;
              for (var i = 0; i < segments; i++) {
                result[i] = segmentToBezier(mTheta, th3, cosTh, sinTh, rx, ry, cx1, cy1, mT, fromX, fromY);
                fromX = result[i][5];
                fromY = result[i][6];
                mTheta = th3;
                th3 += mDelta;
              }
              return result;
            }
            function calcVectorAngle(ux, uy, vx, vy) {
              var ta = Math.atan2(uy, ux), tb = Math.atan2(vy, vx);
              if (tb >= ta) {
                return tb - ta;
              } else {
                return 2 * Math.PI - (ta - tb);
              }
            }
            function getBoundsOfCurve(x0, y0, x1, y1, x2, y2, x3, y3) {
              var argsString;
              if (fabric.cachesBoundsOfCurve) {
                argsString = _join.call(arguments);
                if (fabric.boundsOfCurveCache[argsString]) {
                  return fabric.boundsOfCurveCache[argsString];
                }
              }
              var sqrt2 = Math.sqrt, min = Math.min, max2 = Math.max, abs2 = Math.abs, tvalues = [], bounds = [[], []], a2, b, c, t, t1, t2, b2ac, sqrtb2ac;
              b = 6 * x0 - 12 * x1 + 6 * x2;
              a2 = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
              c = 3 * x1 - 3 * x0;
              for (var i = 0; i < 2; ++i) {
                if (i > 0) {
                  b = 6 * y0 - 12 * y1 + 6 * y2;
                  a2 = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
                  c = 3 * y1 - 3 * y0;
                }
                if (abs2(a2) < 1e-12) {
                  if (abs2(b) < 1e-12) {
                    continue;
                  }
                  t = -c / b;
                  if (0 < t && t < 1) {
                    tvalues.push(t);
                  }
                  continue;
                }
                b2ac = b * b - 4 * c * a2;
                if (b2ac < 0) {
                  continue;
                }
                sqrtb2ac = sqrt2(b2ac);
                t1 = (-b + sqrtb2ac) / (2 * a2);
                if (0 < t1 && t1 < 1) {
                  tvalues.push(t1);
                }
                t2 = (-b - sqrtb2ac) / (2 * a2);
                if (0 < t2 && t2 < 1) {
                  tvalues.push(t2);
                }
              }
              var x, y, j2 = tvalues.length, jlen = j2, mt;
              while (j2--) {
                t = tvalues[j2];
                mt = 1 - t;
                x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
                bounds[0][j2] = x;
                y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
                bounds[1][j2] = y;
              }
              bounds[0][jlen] = x0;
              bounds[1][jlen] = y0;
              bounds[0][jlen + 1] = x3;
              bounds[1][jlen + 1] = y3;
              var result = [
                {
                  x: min.apply(null, bounds[0]),
                  y: min.apply(null, bounds[1])
                },
                {
                  x: max2.apply(null, bounds[0]),
                  y: max2.apply(null, bounds[1])
                }
              ];
              if (fabric.cachesBoundsOfCurve) {
                fabric.boundsOfCurveCache[argsString] = result;
              }
              return result;
            }
            function fromArcToBeziers(fx, fy, coords) {
              var rx = coords[1], ry = coords[2], rot = coords[3], large = coords[4], sweep = coords[5], tx = coords[6], ty = coords[7], segsNorm = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);
              for (var i = 0, len = segsNorm.length; i < len; i++) {
                segsNorm[i][1] += fx;
                segsNorm[i][2] += fy;
                segsNorm[i][3] += fx;
                segsNorm[i][4] += fy;
                segsNorm[i][5] += fx;
                segsNorm[i][6] += fy;
              }
              return segsNorm;
            }
            function makePathSimpler(path) {
              var x = 0, y = 0, len = path.length, x1 = 0, y1 = 0, current, i, converted, destinationPath = [], previous, controlX, controlY;
              for (i = 0; i < len; ++i) {
                converted = false;
                current = path[i].slice(0);
                switch (current[0]) {
                  case "l":
                    current[0] = "L";
                    current[1] += x;
                    current[2] += y;
                  case "L":
                    x = current[1];
                    y = current[2];
                    break;
                  case "h":
                    current[1] += x;
                  case "H":
                    current[0] = "L";
                    current[2] = y;
                    x = current[1];
                    break;
                  case "v":
                    current[1] += y;
                  case "V":
                    current[0] = "L";
                    y = current[1];
                    current[1] = x;
                    current[2] = y;
                    break;
                  case "m":
                    current[0] = "M";
                    current[1] += x;
                    current[2] += y;
                  case "M":
                    x = current[1];
                    y = current[2];
                    x1 = current[1];
                    y1 = current[2];
                    break;
                  case "c":
                    current[0] = "C";
                    current[1] += x;
                    current[2] += y;
                    current[3] += x;
                    current[4] += y;
                    current[5] += x;
                    current[6] += y;
                  case "C":
                    controlX = current[3];
                    controlY = current[4];
                    x = current[5];
                    y = current[6];
                    break;
                  case "s":
                    current[0] = "S";
                    current[1] += x;
                    current[2] += y;
                    current[3] += x;
                    current[4] += y;
                  case "S":
                    if (previous === "C") {
                      controlX = 2 * x - controlX;
                      controlY = 2 * y - controlY;
                    } else {
                      controlX = x;
                      controlY = y;
                    }
                    x = current[3];
                    y = current[4];
                    current[0] = "C";
                    current[5] = current[3];
                    current[6] = current[4];
                    current[3] = current[1];
                    current[4] = current[2];
                    current[1] = controlX;
                    current[2] = controlY;
                    controlX = current[3];
                    controlY = current[4];
                    break;
                  case "q":
                    current[0] = "Q";
                    current[1] += x;
                    current[2] += y;
                    current[3] += x;
                    current[4] += y;
                  case "Q":
                    controlX = current[1];
                    controlY = current[2];
                    x = current[3];
                    y = current[4];
                    break;
                  case "t":
                    current[0] = "T";
                    current[1] += x;
                    current[2] += y;
                  case "T":
                    if (previous === "Q") {
                      controlX = 2 * x - controlX;
                      controlY = 2 * y - controlY;
                    } else {
                      controlX = x;
                      controlY = y;
                    }
                    current[0] = "Q";
                    x = current[1];
                    y = current[2];
                    current[1] = controlX;
                    current[2] = controlY;
                    current[3] = x;
                    current[4] = y;
                    break;
                  case "a":
                    current[0] = "A";
                    current[6] += x;
                    current[7] += y;
                  case "A":
                    converted = true;
                    destinationPath = destinationPath.concat(fromArcToBeziers(x, y, current));
                    x = current[6];
                    y = current[7];
                    break;
                  case "z":
                  case "Z":
                    x = x1;
                    y = y1;
                    break;
                }
                if (!converted) {
                  destinationPath.push(current);
                }
                previous = current[0];
              }
              return destinationPath;
            }
            function calcLineLength(x1, y1, x2, y2) {
              return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
            }
            function CB1(t) {
              return t * t * t;
            }
            function CB2(t) {
              return 3 * t * t * (1 - t);
            }
            function CB3(t) {
              return 3 * t * (1 - t) * (1 - t);
            }
            function CB4(t) {
              return (1 - t) * (1 - t) * (1 - t);
            }
            function getPointOnCubicBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
              return function(pct) {
                var c1 = CB1(pct), c2 = CB2(pct), c3 = CB3(pct), c4 = CB4(pct);
                return {
                  x: p4x * c1 + p3x * c2 + p2x * c3 + p1x * c4,
                  y: p4y * c1 + p3y * c2 + p2y * c3 + p1y * c4
                };
              };
            }
            function getTangentCubicIterator(p1x, p1y, p2x, p2y, p3x, p3y, p4x, p4y) {
              return function(pct) {
                var invT = 1 - pct, tangentX = 3 * invT * invT * (p2x - p1x) + 6 * invT * pct * (p3x - p2x) + 3 * pct * pct * (p4x - p3x), tangentY = 3 * invT * invT * (p2y - p1y) + 6 * invT * pct * (p3y - p2y) + 3 * pct * pct * (p4y - p3y);
                return Math.atan2(tangentY, tangentX);
              };
            }
            function QB1(t) {
              return t * t;
            }
            function QB2(t) {
              return 2 * t * (1 - t);
            }
            function QB3(t) {
              return (1 - t) * (1 - t);
            }
            function getPointOnQuadraticBezierIterator(p1x, p1y, p2x, p2y, p3x, p3y) {
              return function(pct) {
                var c1 = QB1(pct), c2 = QB2(pct), c3 = QB3(pct);
                return {
                  x: p3x * c1 + p2x * c2 + p1x * c3,
                  y: p3y * c1 + p2y * c2 + p1y * c3
                };
              };
            }
            function getTangentQuadraticIterator(p1x, p1y, p2x, p2y, p3x, p3y) {
              return function(pct) {
                var invT = 1 - pct, tangentX = 2 * invT * (p2x - p1x) + 2 * pct * (p3x - p2x), tangentY = 2 * invT * (p2y - p1y) + 2 * pct * (p3y - p2y);
                return Math.atan2(tangentY, tangentX);
              };
            }
            function pathIterator(iterator, x1, y1) {
              var tempP = { x: x1, y: y1 }, p, tmpLen = 0, perc;
              for (perc = 1; perc <= 100; perc += 1) {
                p = iterator(perc / 100);
                tmpLen += calcLineLength(tempP.x, tempP.y, p.x, p.y);
                tempP = p;
              }
              return tmpLen;
            }
            function findPercentageForDistance(segInfo, distance2) {
              var perc = 0, tmpLen = 0, iterator = segInfo.iterator, tempP = { x: segInfo.x, y: segInfo.y }, p, nextLen, nextStep = 0.01, angleFinder = segInfo.angleFinder, lastPerc;
              while (tmpLen < distance2 && perc <= 1 && nextStep > 1e-4) {
                p = iterator(perc);
                lastPerc = perc;
                nextLen = calcLineLength(tempP.x, tempP.y, p.x, p.y);
                if (nextLen + tmpLen > distance2) {
                  nextStep /= 2;
                  perc -= nextStep;
                } else {
                  tempP = p;
                  perc += nextStep;
                  tmpLen += nextLen;
                }
              }
              p.angle = angleFinder(lastPerc);
              return p;
            }
            function getPathSegmentsInfo(path) {
              var totalLength = 0, len = path.length, current, x1 = 0, y1 = 0, x2 = 0, y2 = 0, info = [], iterator, tempInfo, angleFinder;
              for (var i = 0; i < len; i++) {
                current = path[i];
                tempInfo = {
                  x: x1,
                  y: y1,
                  command: current[0]
                };
                switch (current[0]) {
                  case "M":
                    tempInfo.length = 0;
                    x2 = x1 = current[1];
                    y2 = y1 = current[2];
                    break;
                  case "L":
                    tempInfo.length = calcLineLength(x1, y1, current[1], current[2]);
                    x1 = current[1];
                    y1 = current[2];
                    break;
                  case "C":
                    iterator = getPointOnCubicBezierIterator(
                      x1,
                      y1,
                      current[1],
                      current[2],
                      current[3],
                      current[4],
                      current[5],
                      current[6]
                    );
                    angleFinder = getTangentCubicIterator(
                      x1,
                      y1,
                      current[1],
                      current[2],
                      current[3],
                      current[4],
                      current[5],
                      current[6]
                    );
                    tempInfo.iterator = iterator;
                    tempInfo.angleFinder = angleFinder;
                    tempInfo.length = pathIterator(iterator, x1, y1);
                    x1 = current[5];
                    y1 = current[6];
                    break;
                  case "Q":
                    iterator = getPointOnQuadraticBezierIterator(
                      x1,
                      y1,
                      current[1],
                      current[2],
                      current[3],
                      current[4]
                    );
                    angleFinder = getTangentQuadraticIterator(
                      x1,
                      y1,
                      current[1],
                      current[2],
                      current[3],
                      current[4]
                    );
                    tempInfo.iterator = iterator;
                    tempInfo.angleFinder = angleFinder;
                    tempInfo.length = pathIterator(iterator, x1, y1);
                    x1 = current[3];
                    y1 = current[4];
                    break;
                  case "Z":
                  case "z":
                    tempInfo.destX = x2;
                    tempInfo.destY = y2;
                    tempInfo.length = calcLineLength(x1, y1, x2, y2);
                    x1 = x2;
                    y1 = y2;
                    break;
                }
                totalLength += tempInfo.length;
                info.push(tempInfo);
              }
              info.push({ length: totalLength, x: x1, y: y1 });
              return info;
            }
            function getPointOnPath(path, distance2, infos) {
              if (!infos) {
                infos = getPathSegmentsInfo(path);
              }
              var i = 0;
              while (distance2 - infos[i].length > 0 && i < infos.length - 2) {
                distance2 -= infos[i].length;
                i++;
              }
              var segInfo = infos[i], segPercent = distance2 / segInfo.length, command = segInfo.command, segment = path[i], info;
              switch (command) {
                case "M":
                  return { x: segInfo.x, y: segInfo.y, angle: 0 };
                case "Z":
                case "z":
                  info = new fabric.Point(segInfo.x, segInfo.y).lerp(
                    new fabric.Point(segInfo.destX, segInfo.destY),
                    segPercent
                  );
                  info.angle = Math.atan2(segInfo.destY - segInfo.y, segInfo.destX - segInfo.x);
                  return info;
                case "L":
                  info = new fabric.Point(segInfo.x, segInfo.y).lerp(
                    new fabric.Point(segment[1], segment[2]),
                    segPercent
                  );
                  info.angle = Math.atan2(segment[2] - segInfo.y, segment[1] - segInfo.x);
                  return info;
                case "C":
                  return findPercentageForDistance(segInfo, distance2);
                case "Q":
                  return findPercentageForDistance(segInfo, distance2);
              }
            }
            function parsePath(pathString) {
              var result = [], coords = [], currentPath, parsed, re = fabric.rePathCommand, rNumber = "[-+]?(?:\\d*\\.\\d+|\\d+\\.?)(?:[eE][-+]?\\d+)?\\s*", rNumberCommaWsp = "(" + rNumber + ")" + fabric.commaWsp, rFlagCommaWsp = "([01])" + fabric.commaWsp + "?", rArcSeq = rNumberCommaWsp + "?" + rNumberCommaWsp + "?" + rNumberCommaWsp + rFlagCommaWsp + rFlagCommaWsp + rNumberCommaWsp + "?(" + rNumber + ")", regArcArgumentSequence = new RegExp(rArcSeq, "g"), match, coordsStr, path;
              if (!pathString || !pathString.match) {
                return result;
              }
              path = pathString.match(/[mzlhvcsqta][^mzlhvcsqta]*/gi);
              for (var i = 0, coordsParsed, len = path.length; i < len; i++) {
                currentPath = path[i];
                coordsStr = currentPath.slice(1).trim();
                coords.length = 0;
                var command = currentPath.charAt(0);
                coordsParsed = [command];
                if (command.toLowerCase() === "a") {
                  for (var args; args = regArcArgumentSequence.exec(coordsStr); ) {
                    for (var j2 = 1; j2 < args.length; j2++) {
                      coords.push(args[j2]);
                    }
                  }
                } else {
                  while (match = re.exec(coordsStr)) {
                    coords.push(match[0]);
                  }
                }
                for (var j2 = 0, jlen = coords.length; j2 < jlen; j2++) {
                  parsed = parseFloat(coords[j2]);
                  if (!isNaN(parsed)) {
                    coordsParsed.push(parsed);
                  }
                }
                var commandLength = commandLengths[command.toLowerCase()], repeatedCommand = repeatedCommands[command] || command;
                if (coordsParsed.length - 1 > commandLength) {
                  for (var k = 1, klen = coordsParsed.length; k < klen; k += commandLength) {
                    result.push([command].concat(coordsParsed.slice(k, k + commandLength)));
                    command = repeatedCommand;
                  }
                } else {
                  result.push(coordsParsed);
                }
              }
              return result;
            }
            function getSmoothPathFromPoints(points, correction) {
              var path = [], i, p1 = new fabric.Point(points[0].x, points[0].y), p2 = new fabric.Point(points[1].x, points[1].y), len = points.length, multSignX = 1, multSignY = 0, manyPoints = len > 2;
              correction = correction || 0;
              if (manyPoints) {
                multSignX = points[2].x < p2.x ? -1 : points[2].x === p2.x ? 0 : 1;
                multSignY = points[2].y < p2.y ? -1 : points[2].y === p2.y ? 0 : 1;
              }
              path.push(["M", p1.x - multSignX * correction, p1.y - multSignY * correction]);
              for (i = 1; i < len; i++) {
                if (!p1.eq(p2)) {
                  var midPoint = p1.midPointFrom(p2);
                  path.push(["Q", p1.x, p1.y, midPoint.x, midPoint.y]);
                }
                p1 = points[i];
                if (i + 1 < points.length) {
                  p2 = points[i + 1];
                }
              }
              if (manyPoints) {
                multSignX = p1.x > points[i - 2].x ? 1 : p1.x === points[i - 2].x ? 0 : -1;
                multSignY = p1.y > points[i - 2].y ? 1 : p1.y === points[i - 2].y ? 0 : -1;
              }
              path.push(["L", p1.x + multSignX * correction, p1.y + multSignY * correction]);
              return path;
            }
            function transformPath2(path, transform2, pathOffset) {
              if (pathOffset) {
                transform2 = fabric.util.multiplyTransformMatrices(
                  transform2,
                  [1, 0, 0, 1, -pathOffset.x, -pathOffset.y]
                );
              }
              return path.map(function(pathSegment) {
                var newSegment = pathSegment.slice(0), point = {};
                for (var i = 1; i < pathSegment.length - 1; i += 2) {
                  point.x = pathSegment[i];
                  point.y = pathSegment[i + 1];
                  point = fabric.util.transformPoint(point, transform2);
                  newSegment[i] = point.x;
                  newSegment[i + 1] = point.y;
                }
                return newSegment;
              });
            }
            function getBoundsOfArc(fx, fy, rx, ry, rot, large, sweep, tx, ty) {
              var fromX = 0, fromY = 0, bound, bounds = [], segs = arcToSegments(tx - fx, ty - fy, rx, ry, large, sweep, rot);
              for (var i = 0, len = segs.length; i < len; i++) {
                bound = getBoundsOfCurve(fromX, fromY, segs[i][1], segs[i][2], segs[i][3], segs[i][4], segs[i][5], segs[i][6]);
                bounds.push({ x: bound[0].x + fx, y: bound[0].y + fy });
                bounds.push({ x: bound[1].x + fx, y: bound[1].y + fy });
                fromX = segs[i][5];
                fromY = segs[i][6];
              }
              return bounds;
            }
            function drawArc(ctx, fx, fy, coords) {
              coords = coords.slice(0).unshift("X");
              var beziers = fromArcToBeziers(fx, fy, coords);
              beziers.forEach(function(bezier2) {
                ctx.bezierCurveTo.apply(ctx, bezier2.slice(1));
              });
            }
            fabric.util.joinPath = function(pathData) {
              return pathData.map(function(segment) {
                return segment.join(" ");
              }).join(" ");
            };
            fabric.util.parsePath = parsePath;
            fabric.util.makePathSimpler = makePathSimpler;
            fabric.util.getSmoothPathFromPoints = getSmoothPathFromPoints;
            fabric.util.getPathSegmentsInfo = getPathSegmentsInfo;
            fabric.util.getBoundsOfCurve = getBoundsOfCurve;
            fabric.util.getPointOnPath = getPointOnPath;
            fabric.util.transformPath = transformPath2;
            fabric.util.fromArcToBeizers = fromArcToBeziers;
            fabric.util.getBoundsOfArc = getBoundsOfArc;
            fabric.util.drawArc = drawArc;
          })();
          (function() {
            var slice = Array.prototype.slice;
            function invoke(array, method) {
              var args = slice.call(arguments, 2), result = [];
              for (var i = 0, len = array.length; i < len; i++) {
                result[i] = args.length ? array[i][method].apply(array[i], args) : array[i][method].call(array[i]);
              }
              return result;
            }
            function max2(array, byProperty) {
              return find2(array, byProperty, function(value1, value2) {
                return value1 >= value2;
              });
            }
            function min(array, byProperty) {
              return find2(array, byProperty, function(value1, value2) {
                return value1 < value2;
              });
            }
            function fill(array, value) {
              var k = array.length;
              while (k--) {
                array[k] = value;
              }
              return array;
            }
            function find2(array, byProperty, condition) {
              if (!array || array.length === 0) {
                return;
              }
              var i = array.length - 1, result = byProperty ? array[i][byProperty] : array[i];
              if (byProperty) {
                while (i--) {
                  if (condition(array[i][byProperty], result)) {
                    result = array[i][byProperty];
                  }
                }
              } else {
                while (i--) {
                  if (condition(array[i], result)) {
                    result = array[i];
                  }
                }
              }
              return result;
            }
            fabric.util.array = {
              fill,
              invoke,
              min,
              max: max2
            };
          })();
          (function() {
            function extend2(destination, source2, deep) {
              if (deep) {
                if (!fabric.isLikelyNode && source2 instanceof Element) {
                  destination = source2;
                } else if (source2 instanceof Array) {
                  destination = [];
                  for (var i = 0, len = source2.length; i < len; i++) {
                    destination[i] = extend2({}, source2[i], deep);
                  }
                } else if (source2 && typeof source2 === "object") {
                  for (var property in source2) {
                    if (property === "canvas" || property === "group") {
                      destination[property] = null;
                    } else if (source2.hasOwnProperty(property)) {
                      destination[property] = extend2({}, source2[property], deep);
                    }
                  }
                } else {
                  destination = source2;
                }
              } else {
                for (var property in source2) {
                  destination[property] = source2[property];
                }
              }
              return destination;
            }
            function clone2(object, deep) {
              return extend2({}, object, deep);
            }
            fabric.util.object = {
              extend: extend2,
              clone: clone2
            };
            fabric.util.object.extend(fabric.util, fabric.Observable);
          })();
          (function() {
            function camelize2(string) {
              return string.replace(/-+(.)?/g, function(match, character) {
                return character ? character.toUpperCase() : "";
              });
            }
            function capitalize2(string, firstLetterOnly) {
              return string.charAt(0).toUpperCase() + (firstLetterOnly ? string.slice(1) : string.slice(1).toLowerCase());
            }
            function escapeXml(string) {
              return string.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            }
            function graphemeSplit(textstring) {
              var i = 0, chr, graphemes = [];
              for (i = 0, chr; i < textstring.length; i++) {
                if ((chr = getWholeChar(textstring, i)) === false) {
                  continue;
                }
                graphemes.push(chr);
              }
              return graphemes;
            }
            function getWholeChar(str, i) {
              var code = str.charCodeAt(i);
              if (isNaN(code)) {
                return "";
              }
              if (code < 55296 || code > 57343) {
                return str.charAt(i);
              }
              if (55296 <= code && code <= 56319) {
                if (str.length <= i + 1) {
                  throw "High surrogate without following low surrogate";
                }
                var next = str.charCodeAt(i + 1);
                if (56320 > next || next > 57343) {
                  throw "High surrogate without following low surrogate";
                }
                return str.charAt(i) + str.charAt(i + 1);
              }
              if (i === 0) {
                throw "Low surrogate without preceding high surrogate";
              }
              var prev = str.charCodeAt(i - 1);
              if (55296 > prev || prev > 56319) {
                throw "Low surrogate without preceding high surrogate";
              }
              return false;
            }
            fabric.util.string = {
              camelize: camelize2,
              capitalize: capitalize2,
              escapeXml,
              graphemeSplit
            };
          })();
          (function() {
            var slice = Array.prototype.slice, emptyFunction = function() {
            }, IS_DONTENUM_BUGGY = function() {
              for (var p in { toString: 1 }) {
                if (p === "toString") {
                  return false;
                }
              }
              return true;
            }(), addMethods = function(klass, source2, parent) {
              for (var property in source2) {
                if (property in klass.prototype && typeof klass.prototype[property] === "function" && (source2[property] + "").indexOf("callSuper") > -1) {
                  klass.prototype[property] = function(property2) {
                    return function() {
                      var superclass = this.constructor.superclass;
                      this.constructor.superclass = parent;
                      var returnValue = source2[property2].apply(this, arguments);
                      this.constructor.superclass = superclass;
                      if (property2 !== "initialize") {
                        return returnValue;
                      }
                    };
                  }(property);
                } else {
                  klass.prototype[property] = source2[property];
                }
                if (IS_DONTENUM_BUGGY) {
                  if (source2.toString !== Object.prototype.toString) {
                    klass.prototype.toString = source2.toString;
                  }
                  if (source2.valueOf !== Object.prototype.valueOf) {
                    klass.prototype.valueOf = source2.valueOf;
                  }
                }
              }
            };
            function Subclass() {
            }
            function callSuper(methodName) {
              var parentMethod = null, _this = this;
              while (_this.constructor.superclass) {
                var superClassMethod = _this.constructor.superclass.prototype[methodName];
                if (_this[methodName] !== superClassMethod) {
                  parentMethod = superClassMethod;
                  break;
                }
                _this = _this.constructor.superclass.prototype;
              }
              if (!parentMethod) {
                return console.log("tried to callSuper " + methodName + ", method not found in prototype chain", this);
              }
              return arguments.length > 1 ? parentMethod.apply(this, slice.call(arguments, 1)) : parentMethod.call(this);
            }
            function createClass() {
              var parent = null, properties = slice.call(arguments, 0);
              if (typeof properties[0] === "function") {
                parent = properties.shift();
              }
              function klass() {
                this.initialize.apply(this, arguments);
              }
              klass.superclass = parent;
              klass.subclasses = [];
              if (parent) {
                Subclass.prototype = parent.prototype;
                klass.prototype = new Subclass();
                parent.subclasses.push(klass);
              }
              for (var i = 0, length = properties.length; i < length; i++) {
                addMethods(klass, properties[i], parent);
              }
              if (!klass.prototype.initialize) {
                klass.prototype.initialize = emptyFunction;
              }
              klass.prototype.constructor = klass;
              klass.prototype.callSuper = callSuper;
              return klass;
            }
            fabric.util.createClass = createClass;
          })();
          (function() {
            var couldUseAttachEvent = !!fabric.document.createElement("div").attachEvent, touchEvents = ["touchstart", "touchmove", "touchend"];
            fabric.util.addListener = function(element, eventName, handler, options) {
              element && element.addEventListener(eventName, handler, couldUseAttachEvent ? false : options);
            };
            fabric.util.removeListener = function(element, eventName, handler, options) {
              element && element.removeEventListener(eventName, handler, couldUseAttachEvent ? false : options);
            };
            function getTouchInfo(event) {
              var touchProp = event.changedTouches;
              if (touchProp && touchProp[0]) {
                return touchProp[0];
              }
              return event;
            }
            fabric.util.getPointer = function(event) {
              var element = event.target, scroll = fabric.util.getScrollLeftTop(element), _evt = getTouchInfo(event);
              return {
                x: _evt.clientX + scroll.left,
                y: _evt.clientY + scroll.top
              };
            };
            fabric.util.isTouchEvent = function(event) {
              return touchEvents.indexOf(event.type) > -1 || event.pointerType === "touch";
            };
          })();
          (function() {
            function setStyle(element, styles) {
              var elementStyle = element.style;
              if (!elementStyle) {
                return element;
              }
              if (typeof styles === "string") {
                element.style.cssText += ";" + styles;
                return styles.indexOf("opacity") > -1 ? setOpacity(element, styles.match(/opacity:\s*(\d?\.?\d*)/)[1]) : element;
              }
              for (var property in styles) {
                if (property === "opacity") {
                  setOpacity(element, styles[property]);
                } else {
                  var normalizedProperty = property === "float" || property === "cssFloat" ? typeof elementStyle.styleFloat === "undefined" ? "cssFloat" : "styleFloat" : property;
                  elementStyle[normalizedProperty] = styles[property];
                }
              }
              return element;
            }
            var parseEl = fabric.document.createElement("div"), supportsOpacity = typeof parseEl.style.opacity === "string", supportsFilters = typeof parseEl.style.filter === "string", reOpacity = /alpha\s*\(\s*opacity\s*=\s*([^\)]+)\)/, setOpacity = function(element) {
              return element;
            };
            if (supportsOpacity) {
              setOpacity = function(element, value) {
                element.style.opacity = value;
                return element;
              };
            } else if (supportsFilters) {
              setOpacity = function(element, value) {
                var es = element.style;
                if (element.currentStyle && !element.currentStyle.hasLayout) {
                  es.zoom = 1;
                }
                if (reOpacity.test(es.filter)) {
                  value = value >= 0.9999 ? "" : "alpha(opacity=" + value * 100 + ")";
                  es.filter = es.filter.replace(reOpacity, value);
                } else {
                  es.filter += " alpha(opacity=" + value * 100 + ")";
                }
                return element;
              };
            }
            fabric.util.setStyle = setStyle;
          })();
          (function() {
            var _slice = Array.prototype.slice;
            function getById(id) {
              return typeof id === "string" ? fabric.document.getElementById(id) : id;
            }
            var sliceCanConvertNodelists, toArray3 = function(arrayLike) {
              return _slice.call(arrayLike, 0);
            };
            try {
              sliceCanConvertNodelists = toArray3(fabric.document.childNodes) instanceof Array;
            } catch (err) {
            }
            if (!sliceCanConvertNodelists) {
              toArray3 = function(arrayLike) {
                var arr2 = new Array(arrayLike.length), i = arrayLike.length;
                while (i--) {
                  arr2[i] = arrayLike[i];
                }
                return arr2;
              };
            }
            function makeElement(tagName, attributes) {
              var el = fabric.document.createElement(tagName);
              for (var prop in attributes) {
                if (prop === "class") {
                  el.className = attributes[prop];
                } else if (prop === "for") {
                  el.htmlFor = attributes[prop];
                } else {
                  el.setAttribute(prop, attributes[prop]);
                }
              }
              return el;
            }
            function addClass2(element, className) {
              if (element && (" " + element.className + " ").indexOf(" " + className + " ") === -1) {
                element.className += (element.className ? " " : "") + className;
              }
            }
            function wrapElement(element, wrapper, attributes) {
              if (typeof wrapper === "string") {
                wrapper = makeElement(wrapper, attributes);
              }
              if (element.parentNode) {
                element.parentNode.replaceChild(wrapper, element);
              }
              wrapper.appendChild(element);
              return wrapper;
            }
            function getScrollLeftTop(element) {
              var left = 0, top = 0, docElement = fabric.document.documentElement, body = fabric.document.body || {
                scrollLeft: 0,
                scrollTop: 0
              };
              while (element && (element.parentNode || element.host)) {
                element = element.parentNode || element.host;
                if (element === fabric.document) {
                  left = body.scrollLeft || docElement.scrollLeft || 0;
                  top = body.scrollTop || docElement.scrollTop || 0;
                } else {
                  left += element.scrollLeft || 0;
                  top += element.scrollTop || 0;
                }
                if (element.nodeType === 1 && element.style.position === "fixed") {
                  break;
                }
              }
              return { left, top };
            }
            function getElementOffset(element) {
              var docElem, doc2 = element && element.ownerDocument, box = { left: 0, top: 0 }, offset = { left: 0, top: 0 }, scrollLeftTop, offsetAttributes = {
                borderLeftWidth: "left",
                borderTopWidth: "top",
                paddingLeft: "left",
                paddingTop: "top"
              };
              if (!doc2) {
                return offset;
              }
              for (var attr in offsetAttributes) {
                offset[offsetAttributes[attr]] += parseInt(getElementStyle(element, attr), 10) || 0;
              }
              docElem = doc2.documentElement;
              if (typeof element.getBoundingClientRect !== "undefined") {
                box = element.getBoundingClientRect();
              }
              scrollLeftTop = getScrollLeftTop(element);
              return {
                left: box.left + scrollLeftTop.left - (docElem.clientLeft || 0) + offset.left,
                top: box.top + scrollLeftTop.top - (docElem.clientTop || 0) + offset.top
              };
            }
            var getElementStyle;
            if (fabric.document.defaultView && fabric.document.defaultView.getComputedStyle) {
              getElementStyle = function(element, attr) {
                var style = fabric.document.defaultView.getComputedStyle(element, null);
                return style ? style[attr] : void 0;
              };
            } else {
              getElementStyle = function(element, attr) {
                var value = element.style[attr];
                if (!value && element.currentStyle) {
                  value = element.currentStyle[attr];
                }
                return value;
              };
            }
            (function() {
              var style = fabric.document.documentElement.style, selectProp = "userSelect" in style ? "userSelect" : "MozUserSelect" in style ? "MozUserSelect" : "WebkitUserSelect" in style ? "WebkitUserSelect" : "KhtmlUserSelect" in style ? "KhtmlUserSelect" : "";
              function makeElementUnselectable(element) {
                if (typeof element.onselectstart !== "undefined") {
                  element.onselectstart = fabric.util.falseFunction;
                }
                if (selectProp) {
                  element.style[selectProp] = "none";
                } else if (typeof element.unselectable === "string") {
                  element.unselectable = "on";
                }
                return element;
              }
              function makeElementSelectable(element) {
                if (typeof element.onselectstart !== "undefined") {
                  element.onselectstart = null;
                }
                if (selectProp) {
                  element.style[selectProp] = "";
                } else if (typeof element.unselectable === "string") {
                  element.unselectable = "";
                }
                return element;
              }
              fabric.util.makeElementUnselectable = makeElementUnselectable;
              fabric.util.makeElementSelectable = makeElementSelectable;
            })();
            function getNodeCanvas(element) {
              var impl = fabric.jsdomImplForWrapper(element);
              return impl._canvas || impl._image;
            }
            function cleanUpJsdomNode(element) {
              if (!fabric.isLikelyNode) {
                return;
              }
              var impl = fabric.jsdomImplForWrapper(element);
              if (impl) {
                impl._image = null;
                impl._canvas = null;
                impl._currentSrc = null;
                impl._attributes = null;
                impl._classList = null;
              }
            }
            function setImageSmoothing(ctx, value) {
              ctx.imageSmoothingEnabled = ctx.imageSmoothingEnabled || ctx.webkitImageSmoothingEnabled || ctx.mozImageSmoothingEnabled || ctx.msImageSmoothingEnabled || ctx.oImageSmoothingEnabled;
              ctx.imageSmoothingEnabled = value;
            }
            fabric.util.setImageSmoothing = setImageSmoothing;
            fabric.util.getById = getById;
            fabric.util.toArray = toArray3;
            fabric.util.addClass = addClass2;
            fabric.util.makeElement = makeElement;
            fabric.util.wrapElement = wrapElement;
            fabric.util.getScrollLeftTop = getScrollLeftTop;
            fabric.util.getElementOffset = getElementOffset;
            fabric.util.getNodeCanvas = getNodeCanvas;
            fabric.util.cleanUpJsdomNode = cleanUpJsdomNode;
          })();
          (function() {
            function addParamToUrl(url, param) {
              return url + (/\?/.test(url) ? "&" : "?") + param;
            }
            function emptyFn() {
            }
            function request2(url, options) {
              options || (options = {});
              var method = options.method ? options.method.toUpperCase() : "GET", onComplete = options.onComplete || function() {
              }, xhr2 = new fabric.window.XMLHttpRequest(), body = options.body || options.parameters;
              xhr2.onreadystatechange = function() {
                if (xhr2.readyState === 4) {
                  onComplete(xhr2);
                  xhr2.onreadystatechange = emptyFn;
                }
              };
              if (method === "GET") {
                body = null;
                if (typeof options.parameters === "string") {
                  url = addParamToUrl(url, options.parameters);
                }
              }
              xhr2.open(method, url, true);
              if (method === "POST" || method === "PUT") {
                xhr2.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
              }
              xhr2.send(body);
              return xhr2;
            }
            fabric.util.request = request2;
          })();
          fabric.log = console.log;
          fabric.warn = console.warn;
          (function() {
            function noop() {
              return false;
            }
            function defaultEasing(t, b, c, d) {
              return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
            }
            function animate(options) {
              var cancel = false;
              requestAnimFrame(function(timestamp) {
                options || (options = {});
                var start = timestamp || +new Date(), duration2 = options.duration || 500, finish = start + duration2, time2, onChange = options.onChange || noop, abort = options.abort || noop, onComplete = options.onComplete || noop, easing = options.easing || defaultEasing, startValue = "startValue" in options ? options.startValue : 0, endValue = "endValue" in options ? options.endValue : 100, byValue = options.byValue || endValue - startValue;
                options.onStart && options.onStart();
                (function tick(ticktime) {
                  time2 = ticktime || +new Date();
                  var currentTime = time2 > finish ? duration2 : time2 - start, timePerc = currentTime / duration2, current = easing(currentTime, startValue, byValue, duration2), valuePerc = Math.abs((current - startValue) / byValue);
                  if (cancel) {
                    return;
                  }
                  if (abort(current, valuePerc, timePerc)) {
                    onComplete(endValue, 1, 1);
                    return;
                  }
                  if (time2 > finish) {
                    onChange(endValue, 1, 1);
                    onComplete(endValue, 1, 1);
                    return;
                  } else {
                    onChange(current, valuePerc, timePerc);
                    requestAnimFrame(tick);
                  }
                })(start);
              });
              return function() {
                cancel = true;
              };
            }
            var _requestAnimFrame = fabric.window.requestAnimationFrame || fabric.window.webkitRequestAnimationFrame || fabric.window.mozRequestAnimationFrame || fabric.window.oRequestAnimationFrame || fabric.window.msRequestAnimationFrame || function(callback) {
              return fabric.window.setTimeout(callback, 1e3 / 60);
            };
            var _cancelAnimFrame = fabric.window.cancelAnimationFrame || fabric.window.clearTimeout;
            function requestAnimFrame() {
              return _requestAnimFrame.apply(fabric.window, arguments);
            }
            function cancelAnimFrame() {
              return _cancelAnimFrame.apply(fabric.window, arguments);
            }
            fabric.util.animate = animate;
            fabric.util.requestAnimFrame = requestAnimFrame;
            fabric.util.cancelAnimFrame = cancelAnimFrame;
          })();
          (function() {
            function calculateColor(begin, end, pos) {
              var color2 = "rgba(" + parseInt(begin[0] + pos * (end[0] - begin[0]), 10) + "," + parseInt(begin[1] + pos * (end[1] - begin[1]), 10) + "," + parseInt(begin[2] + pos * (end[2] - begin[2]), 10);
              color2 += "," + (begin && end ? parseFloat(begin[3] + pos * (end[3] - begin[3])) : 1);
              color2 += ")";
              return color2;
            }
            function animateColor(fromColor, toColor, duration2, options) {
              var startColor = new fabric.Color(fromColor).getSource(), endColor = new fabric.Color(toColor).getSource(), originalOnComplete = options.onComplete, originalOnChange = options.onChange;
              options = options || {};
              return fabric.util.animate(fabric.util.object.extend(options, {
                duration: duration2 || 500,
                startValue: startColor,
                endValue: endColor,
                byValue: endColor,
                easing: function(currentTime, startValue, byValue, duration3) {
                  var posValue = options.colorEasing ? options.colorEasing(currentTime, duration3) : 1 - Math.cos(currentTime / duration3 * (Math.PI / 2));
                  return calculateColor(startValue, byValue, posValue);
                },
                onComplete: function(current, valuePerc, timePerc) {
                  if (originalOnComplete) {
                    return originalOnComplete(
                      calculateColor(endColor, endColor, 0),
                      valuePerc,
                      timePerc
                    );
                  }
                },
                onChange: function(current, valuePerc, timePerc) {
                  if (originalOnChange) {
                    if (Array.isArray(current)) {
                      return originalOnChange(
                        calculateColor(current, current, 0),
                        valuePerc,
                        timePerc
                      );
                    }
                    originalOnChange(current, valuePerc, timePerc);
                  }
                }
              }));
            }
            fabric.util.animateColor = animateColor;
          })();
          (function() {
            function normalize2(a2, c, p, s) {
              if (a2 < Math.abs(c)) {
                a2 = c;
                s = p / 4;
              } else {
                if (c === 0 && a2 === 0) {
                  s = p / (2 * Math.PI) * Math.asin(1);
                } else {
                  s = p / (2 * Math.PI) * Math.asin(c / a2);
                }
              }
              return { a: a2, c, p, s };
            }
            function elastic(opts, t, d) {
              return opts.a * Math.pow(2, 10 * (t -= 1)) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p);
            }
            function easeOutCubic(t, b, c, d) {
              return c * ((t = t / d - 1) * t * t + 1) + b;
            }
            function easeInOutCubic(t, b, c, d) {
              t /= d / 2;
              if (t < 1) {
                return c / 2 * t * t * t + b;
              }
              return c / 2 * ((t -= 2) * t * t + 2) + b;
            }
            function easeInQuart(t, b, c, d) {
              return c * (t /= d) * t * t * t + b;
            }
            function easeOutQuart(t, b, c, d) {
              return -c * ((t = t / d - 1) * t * t * t - 1) + b;
            }
            function easeInOutQuart(t, b, c, d) {
              t /= d / 2;
              if (t < 1) {
                return c / 2 * t * t * t * t + b;
              }
              return -c / 2 * ((t -= 2) * t * t * t - 2) + b;
            }
            function easeInQuint(t, b, c, d) {
              return c * (t /= d) * t * t * t * t + b;
            }
            function easeOutQuint(t, b, c, d) {
              return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
            }
            function easeInOutQuint(t, b, c, d) {
              t /= d / 2;
              if (t < 1) {
                return c / 2 * t * t * t * t * t + b;
              }
              return c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
            }
            function easeInSine(t, b, c, d) {
              return -c * Math.cos(t / d * (Math.PI / 2)) + c + b;
            }
            function easeOutSine(t, b, c, d) {
              return c * Math.sin(t / d * (Math.PI / 2)) + b;
            }
            function easeInOutSine(t, b, c, d) {
              return -c / 2 * (Math.cos(Math.PI * t / d) - 1) + b;
            }
            function easeInExpo(t, b, c, d) {
              return t === 0 ? b : c * Math.pow(2, 10 * (t / d - 1)) + b;
            }
            function easeOutExpo(t, b, c, d) {
              return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
            }
            function easeInOutExpo(t, b, c, d) {
              if (t === 0) {
                return b;
              }
              if (t === d) {
                return b + c;
              }
              t /= d / 2;
              if (t < 1) {
                return c / 2 * Math.pow(2, 10 * (t - 1)) + b;
              }
              return c / 2 * (-Math.pow(2, -10 * --t) + 2) + b;
            }
            function easeInCirc(t, b, c, d) {
              return -c * (Math.sqrt(1 - (t /= d) * t) - 1) + b;
            }
            function easeOutCirc(t, b, c, d) {
              return c * Math.sqrt(1 - (t = t / d - 1) * t) + b;
            }
            function easeInOutCirc(t, b, c, d) {
              t /= d / 2;
              if (t < 1) {
                return -c / 2 * (Math.sqrt(1 - t * t) - 1) + b;
              }
              return c / 2 * (Math.sqrt(1 - (t -= 2) * t) + 1) + b;
            }
            function easeInElastic(t, b, c, d) {
              var s = 1.70158, p = 0, a2 = c;
              if (t === 0) {
                return b;
              }
              t /= d;
              if (t === 1) {
                return b + c;
              }
              if (!p) {
                p = d * 0.3;
              }
              var opts = normalize2(a2, c, p, s);
              return -elastic(opts, t, d) + b;
            }
            function easeOutElastic(t, b, c, d) {
              var s = 1.70158, p = 0, a2 = c;
              if (t === 0) {
                return b;
              }
              t /= d;
              if (t === 1) {
                return b + c;
              }
              if (!p) {
                p = d * 0.3;
              }
              var opts = normalize2(a2, c, p, s);
              return opts.a * Math.pow(2, -10 * t) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p) + opts.c + b;
            }
            function easeInOutElastic(t, b, c, d) {
              var s = 1.70158, p = 0, a2 = c;
              if (t === 0) {
                return b;
              }
              t /= d / 2;
              if (t === 2) {
                return b + c;
              }
              if (!p) {
                p = d * (0.3 * 1.5);
              }
              var opts = normalize2(a2, c, p, s);
              if (t < 1) {
                return -0.5 * elastic(opts, t, d) + b;
              }
              return opts.a * Math.pow(2, -10 * (t -= 1)) * Math.sin((t * d - opts.s) * (2 * Math.PI) / opts.p) * 0.5 + opts.c + b;
            }
            function easeInBack(t, b, c, d, s) {
              if (s === void 0) {
                s = 1.70158;
              }
              return c * (t /= d) * t * ((s + 1) * t - s) + b;
            }
            function easeOutBack(t, b, c, d, s) {
              if (s === void 0) {
                s = 1.70158;
              }
              return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
            }
            function easeInOutBack(t, b, c, d, s) {
              if (s === void 0) {
                s = 1.70158;
              }
              t /= d / 2;
              if (t < 1) {
                return c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b;
              }
              return c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
            }
            function easeInBounce(t, b, c, d) {
              return c - easeOutBounce(d - t, 0, c, d) + b;
            }
            function easeOutBounce(t, b, c, d) {
              if ((t /= d) < 1 / 2.75) {
                return c * (7.5625 * t * t) + b;
              } else if (t < 2 / 2.75) {
                return c * (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) + b;
              } else if (t < 2.5 / 2.75) {
                return c * (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) + b;
              } else {
                return c * (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375) + b;
              }
            }
            function easeInOutBounce(t, b, c, d) {
              if (t < d / 2) {
                return easeInBounce(t * 2, 0, c, d) * 0.5 + b;
              }
              return easeOutBounce(t * 2 - d, 0, c, d) * 0.5 + c * 0.5 + b;
            }
            fabric.util.ease = {
              easeInQuad: function(t, b, c, d) {
                return c * (t /= d) * t + b;
              },
              easeOutQuad: function(t, b, c, d) {
                return -c * (t /= d) * (t - 2) + b;
              },
              easeInOutQuad: function(t, b, c, d) {
                t /= d / 2;
                if (t < 1) {
                  return c / 2 * t * t + b;
                }
                return -c / 2 * (--t * (t - 2) - 1) + b;
              },
              easeInCubic: function(t, b, c, d) {
                return c * (t /= d) * t * t + b;
              },
              easeOutCubic,
              easeInOutCubic,
              easeInQuart,
              easeOutQuart,
              easeInOutQuart,
              easeInQuint,
              easeOutQuint,
              easeInOutQuint,
              easeInSine,
              easeOutSine,
              easeInOutSine,
              easeInExpo,
              easeOutExpo,
              easeInOutExpo,
              easeInCirc,
              easeOutCirc,
              easeInOutCirc,
              easeInElastic,
              easeOutElastic,
              easeInOutElastic,
              easeInBack,
              easeOutBack,
              easeInOutBack,
              easeInBounce,
              easeOutBounce,
              easeInOutBounce
            };
          })();
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), extend2 = fabric2.util.object.extend, clone2 = fabric2.util.object.clone, toFixed2 = fabric2.util.toFixed, parseUnit = fabric2.util.parseUnit, multiplyTransformMatrices = fabric2.util.multiplyTransformMatrices, svgValidTagNames = [
              "path",
              "circle",
              "polygon",
              "polyline",
              "ellipse",
              "rect",
              "line",
              "image",
              "text"
            ], svgViewBoxElements = ["symbol", "image", "marker", "pattern", "view", "svg"], svgInvalidAncestors = ["pattern", "defs", "symbol", "metadata", "clipPath", "mask", "desc"], svgValidParents = ["symbol", "g", "a", "svg", "clipPath", "defs"], attributesMap = {
              cx: "left",
              x: "left",
              r: "radius",
              cy: "top",
              y: "top",
              display: "visible",
              visibility: "visible",
              transform: "transformMatrix",
              "fill-opacity": "fillOpacity",
              "fill-rule": "fillRule",
              "font-family": "fontFamily",
              "font-size": "fontSize",
              "font-style": "fontStyle",
              "font-weight": "fontWeight",
              "letter-spacing": "charSpacing",
              "paint-order": "paintFirst",
              "stroke-dasharray": "strokeDashArray",
              "stroke-dashoffset": "strokeDashOffset",
              "stroke-linecap": "strokeLineCap",
              "stroke-linejoin": "strokeLineJoin",
              "stroke-miterlimit": "strokeMiterLimit",
              "stroke-opacity": "strokeOpacity",
              "stroke-width": "strokeWidth",
              "text-decoration": "textDecoration",
              "text-anchor": "textAnchor",
              opacity: "opacity",
              "clip-path": "clipPath",
              "clip-rule": "clipRule",
              "vector-effect": "strokeUniform",
              "image-rendering": "imageSmoothing"
            }, colorAttributes = {
              stroke: "strokeOpacity",
              fill: "fillOpacity"
            }, fSize = "font-size", cPath = "clip-path";
            fabric2.svgValidTagNamesRegEx = getSvgRegex(svgValidTagNames);
            fabric2.svgViewBoxElementsRegEx = getSvgRegex(svgViewBoxElements);
            fabric2.svgInvalidAncestorsRegEx = getSvgRegex(svgInvalidAncestors);
            fabric2.svgValidParentsRegEx = getSvgRegex(svgValidParents);
            fabric2.cssRules = {};
            fabric2.gradientDefs = {};
            fabric2.clipPaths = {};
            function normalizeAttr(attr) {
              if (attr in attributesMap) {
                return attributesMap[attr];
              }
              return attr;
            }
            function normalizeValue(attr, value, parentAttributes, fontSize2) {
              var isArray2 = Object.prototype.toString.call(value) === "[object Array]", parsed;
              if ((attr === "fill" || attr === "stroke") && value === "none") {
                value = "";
              } else if (attr === "strokeUniform") {
                return value === "non-scaling-stroke";
              } else if (attr === "strokeDashArray") {
                if (value === "none") {
                  value = null;
                } else {
                  value = value.replace(/,/g, " ").split(/\s+/).map(parseFloat);
                }
              } else if (attr === "transformMatrix") {
                if (parentAttributes && parentAttributes.transformMatrix) {
                  value = multiplyTransformMatrices(
                    parentAttributes.transformMatrix,
                    fabric2.parseTransformAttribute(value)
                  );
                } else {
                  value = fabric2.parseTransformAttribute(value);
                }
              } else if (attr === "visible") {
                value = value !== "none" && value !== "hidden";
                if (parentAttributes && parentAttributes.visible === false) {
                  value = false;
                }
              } else if (attr === "opacity") {
                value = parseFloat(value);
                if (parentAttributes && typeof parentAttributes.opacity !== "undefined") {
                  value *= parentAttributes.opacity;
                }
              } else if (attr === "textAnchor") {
                value = value === "start" ? "left" : value === "end" ? "right" : "center";
              } else if (attr === "charSpacing") {
                parsed = parseUnit(value, fontSize2) / fontSize2 * 1e3;
              } else if (attr === "paintFirst") {
                var fillIndex = value.indexOf("fill");
                var strokeIndex = value.indexOf("stroke");
                var value = "fill";
                if (fillIndex > -1 && strokeIndex > -1 && strokeIndex < fillIndex) {
                  value = "stroke";
                } else if (fillIndex === -1 && strokeIndex > -1) {
                  value = "stroke";
                }
              } else if (attr === "href" || attr === "xlink:href" || attr === "font") {
                return value;
              } else if (attr === "imageSmoothing") {
                return value === "optimizeQuality";
              } else {
                parsed = isArray2 ? value.map(parseUnit) : parseUnit(value, fontSize2);
              }
              return !isArray2 && isNaN(parsed) ? value : parsed;
            }
            function getSvgRegex(arr2) {
              return new RegExp("^(" + arr2.join("|") + ")\\b", "i");
            }
            function _setStrokeFillOpacity(attributes) {
              for (var attr in colorAttributes) {
                if (typeof attributes[colorAttributes[attr]] === "undefined" || attributes[attr] === "") {
                  continue;
                }
                if (typeof attributes[attr] === "undefined") {
                  if (!fabric2.Object.prototype[attr]) {
                    continue;
                  }
                  attributes[attr] = fabric2.Object.prototype[attr];
                }
                if (attributes[attr].indexOf("url(") === 0) {
                  continue;
                }
                var color2 = new fabric2.Color(attributes[attr]);
                attributes[attr] = color2.setAlpha(toFixed2(color2.getAlpha() * attributes[colorAttributes[attr]], 2)).toRgba();
              }
              return attributes;
            }
            function _getMultipleNodes(doc2, nodeNames) {
              var nodeName, nodeArray = [], nodeList, i, len;
              for (i = 0, len = nodeNames.length; i < len; i++) {
                nodeName = nodeNames[i];
                nodeList = doc2.getElementsByTagName(nodeName);
                nodeArray = nodeArray.concat(Array.prototype.slice.call(nodeList));
              }
              return nodeArray;
            }
            fabric2.parseTransformAttribute = function() {
              function rotateMatrix(matrix3, args) {
                var cos = fabric2.util.cos(args[0]), sin = fabric2.util.sin(args[0]), x = 0, y = 0;
                if (args.length === 3) {
                  x = args[1];
                  y = args[2];
                }
                matrix3[0] = cos;
                matrix3[1] = sin;
                matrix3[2] = -sin;
                matrix3[3] = cos;
                matrix3[4] = x - (cos * x - sin * y);
                matrix3[5] = y - (sin * x + cos * y);
              }
              function scaleMatrix2(matrix3, args) {
                var multiplierX = args[0], multiplierY = args.length === 2 ? args[1] : args[0];
                matrix3[0] = multiplierX;
                matrix3[3] = multiplierY;
              }
              function skewMatrix(matrix3, args, pos) {
                matrix3[pos] = Math.tan(fabric2.util.degreesToRadians(args[0]));
              }
              function translateMatrix(matrix3, args) {
                matrix3[4] = args[0];
                if (args.length === 2) {
                  matrix3[5] = args[1];
                }
              }
              var iMatrix = fabric2.iMatrix, number = fabric2.reNum, commaWsp = fabric2.commaWsp, skewX = "(?:(skewX)\\s*\\(\\s*(" + number + ")\\s*\\))", skewY = "(?:(skewY)\\s*\\(\\s*(" + number + ")\\s*\\))", rotate2 = "(?:(rotate)\\s*\\(\\s*(" + number + ")(?:" + commaWsp + "(" + number + ")" + commaWsp + "(" + number + "))?\\s*\\))", scale = "(?:(scale)\\s*\\(\\s*(" + number + ")(?:" + commaWsp + "(" + number + "))?\\s*\\))", translate = "(?:(translate)\\s*\\(\\s*(" + number + ")(?:" + commaWsp + "(" + number + "))?\\s*\\))", matrix2 = "(?:(matrix)\\s*\\(\\s*(" + number + ")" + commaWsp + "(" + number + ")" + commaWsp + "(" + number + ")" + commaWsp + "(" + number + ")" + commaWsp + "(" + number + ")" + commaWsp + "(" + number + ")\\s*\\))", transform2 = "(?:" + matrix2 + "|" + translate + "|" + scale + "|" + rotate2 + "|" + skewX + "|" + skewY + ")", transforms = "(?:" + transform2 + "(?:" + commaWsp + "*" + transform2 + ")*)", transformList = "^\\s*(?:" + transforms + "?)\\s*$", reTransformList = new RegExp(transformList), reTransform = new RegExp(transform2, "g");
              return function(attributeValue) {
                var matrix3 = iMatrix.concat(), matrices = [];
                if (!attributeValue || attributeValue && !reTransformList.test(attributeValue)) {
                  return matrix3;
                }
                attributeValue.replace(reTransform, function(match) {
                  var m = new RegExp(transform2).exec(match).filter(function(match2) {
                    return !!match2;
                  }), operation = m[1], args = m.slice(2).map(parseFloat);
                  switch (operation) {
                    case "translate":
                      translateMatrix(matrix3, args);
                      break;
                    case "rotate":
                      args[0] = fabric2.util.degreesToRadians(args[0]);
                      rotateMatrix(matrix3, args);
                      break;
                    case "scale":
                      scaleMatrix2(matrix3, args);
                      break;
                    case "skewX":
                      skewMatrix(matrix3, args, 2);
                      break;
                    case "skewY":
                      skewMatrix(matrix3, args, 1);
                      break;
                    case "matrix":
                      matrix3 = args;
                      break;
                  }
                  matrices.push(matrix3.concat());
                  matrix3 = iMatrix.concat();
                });
                var combinedMatrix = matrices[0];
                while (matrices.length > 1) {
                  matrices.shift();
                  combinedMatrix = fabric2.util.multiplyTransformMatrices(combinedMatrix, matrices[0]);
                }
                return combinedMatrix;
              };
            }();
            function parseStyleString(style, oStyle) {
              var attr, value;
              style.replace(/;\s*$/, "").split(";").forEach(function(chunk) {
                var pair = chunk.split(":");
                attr = pair[0].trim().toLowerCase();
                value = pair[1].trim();
                oStyle[attr] = value;
              });
            }
            function parseStyleObject(style, oStyle) {
              var attr, value;
              for (var prop in style) {
                if (typeof style[prop] === "undefined") {
                  continue;
                }
                attr = prop.toLowerCase();
                value = style[prop];
                oStyle[attr] = value;
              }
            }
            function getGlobalStylesForElement(element, svgUid) {
              var styles = {};
              for (var rule in fabric2.cssRules[svgUid]) {
                if (elementMatchesRule(element, rule.split(" "))) {
                  for (var property in fabric2.cssRules[svgUid][rule]) {
                    styles[property] = fabric2.cssRules[svgUid][rule][property];
                  }
                }
              }
              return styles;
            }
            function elementMatchesRule(element, selectors) {
              var firstMatching, parentMatching = true;
              firstMatching = selectorMatches(element, selectors.pop());
              if (firstMatching && selectors.length) {
                parentMatching = doesSomeParentMatch(element, selectors);
              }
              return firstMatching && parentMatching && selectors.length === 0;
            }
            function doesSomeParentMatch(element, selectors) {
              var selector, parentMatching = true;
              while (element.parentNode && element.parentNode.nodeType === 1 && selectors.length) {
                if (parentMatching) {
                  selector = selectors.pop();
                }
                element = element.parentNode;
                parentMatching = selectorMatches(element, selector);
              }
              return selectors.length === 0;
            }
            function selectorMatches(element, selector) {
              var nodeName = element.nodeName, classNames = element.getAttribute("class"), id = element.getAttribute("id"), matcher, i;
              matcher = new RegExp("^" + nodeName, "i");
              selector = selector.replace(matcher, "");
              if (id && selector.length) {
                matcher = new RegExp("#" + id + "(?![a-zA-Z\\-]+)", "i");
                selector = selector.replace(matcher, "");
              }
              if (classNames && selector.length) {
                classNames = classNames.split(" ");
                for (i = classNames.length; i--; ) {
                  matcher = new RegExp("\\." + classNames[i] + "(?![a-zA-Z\\-]+)", "i");
                  selector = selector.replace(matcher, "");
                }
              }
              return selector.length === 0;
            }
            function elementById(doc2, id) {
              var el;
              doc2.getElementById && (el = doc2.getElementById(id));
              if (el) {
                return el;
              }
              var node, i, len, nodelist = doc2.getElementsByTagName("*");
              for (i = 0, len = nodelist.length; i < len; i++) {
                node = nodelist[i];
                if (id === node.getAttribute("id")) {
                  return node;
                }
              }
            }
            function parseUseDirectives(doc2) {
              var nodelist = _getMultipleNodes(doc2, ["use", "svg:use"]), i = 0;
              while (nodelist.length && i < nodelist.length) {
                var el = nodelist[i], xlinkAttribute = el.getAttribute("xlink:href") || el.getAttribute("href");
                if (xlinkAttribute === null) {
                  return;
                }
                var xlink = xlinkAttribute.substr(1), x = el.getAttribute("x") || 0, y = el.getAttribute("y") || 0, el2 = elementById(doc2, xlink).cloneNode(true), currentTrans = (el2.getAttribute("transform") || "") + " translate(" + x + ", " + y + ")", parentNode, oldLength = nodelist.length, attr, j2, attrs, len, namespace = fabric2.svgNS;
                applyViewboxTransform(el2);
                if (/^svg$/i.test(el2.nodeName)) {
                  var el3 = el2.ownerDocument.createElementNS(namespace, "g");
                  for (j2 = 0, attrs = el2.attributes, len = attrs.length; j2 < len; j2++) {
                    attr = attrs.item(j2);
                    el3.setAttributeNS(namespace, attr.nodeName, attr.nodeValue);
                  }
                  while (el2.firstChild) {
                    el3.appendChild(el2.firstChild);
                  }
                  el2 = el3;
                }
                for (j2 = 0, attrs = el.attributes, len = attrs.length; j2 < len; j2++) {
                  attr = attrs.item(j2);
                  if (attr.nodeName === "x" || attr.nodeName === "y" || attr.nodeName === "xlink:href" || attr.nodeName === "href") {
                    continue;
                  }
                  if (attr.nodeName === "transform") {
                    currentTrans = attr.nodeValue + " " + currentTrans;
                  } else {
                    el2.setAttribute(attr.nodeName, attr.nodeValue);
                  }
                }
                el2.setAttribute("transform", currentTrans);
                el2.setAttribute("instantiated_by_use", "1");
                el2.removeAttribute("id");
                parentNode = el.parentNode;
                parentNode.replaceChild(el2, el);
                if (nodelist.length === oldLength) {
                  i++;
                }
              }
            }
            var reViewBoxAttrValue = new RegExp(
              "^\\s*(" + fabric2.reNum + "+)\\s*,?\\s*(" + fabric2.reNum + "+)\\s*,?\\s*(" + fabric2.reNum + "+)\\s*,?\\s*(" + fabric2.reNum + "+)\\s*$"
            );
            function applyViewboxTransform(element) {
              if (!fabric2.svgViewBoxElementsRegEx.test(element.nodeName)) {
                return {};
              }
              var viewBoxAttr = element.getAttribute("viewBox"), scaleX = 1, scaleY = 1, minX = 0, minY = 0, viewBoxWidth, viewBoxHeight, matrix2, el, widthAttr = element.getAttribute("width"), heightAttr = element.getAttribute("height"), x = element.getAttribute("x") || 0, y = element.getAttribute("y") || 0, preserveAspectRatio = element.getAttribute("preserveAspectRatio") || "", missingViewBox = !viewBoxAttr || !(viewBoxAttr = viewBoxAttr.match(reViewBoxAttrValue)), missingDimAttr = !widthAttr || !heightAttr || widthAttr === "100%" || heightAttr === "100%", toBeParsed = missingViewBox && missingDimAttr, parsedDim = {}, translateMatrix = "", widthDiff = 0, heightDiff = 0;
              parsedDim.width = 0;
              parsedDim.height = 0;
              parsedDim.toBeParsed = toBeParsed;
              if (missingViewBox) {
                if ((x || y) && element.parentNode && element.parentNode.nodeName !== "#document") {
                  translateMatrix = " translate(" + parseUnit(x) + " " + parseUnit(y) + ") ";
                  matrix2 = (element.getAttribute("transform") || "") + translateMatrix;
                  element.setAttribute("transform", matrix2);
                  element.removeAttribute("x");
                  element.removeAttribute("y");
                }
              }
              if (toBeParsed) {
                return parsedDim;
              }
              if (missingViewBox) {
                parsedDim.width = parseUnit(widthAttr);
                parsedDim.height = parseUnit(heightAttr);
                return parsedDim;
              }
              minX = -parseFloat(viewBoxAttr[1]);
              minY = -parseFloat(viewBoxAttr[2]);
              viewBoxWidth = parseFloat(viewBoxAttr[3]);
              viewBoxHeight = parseFloat(viewBoxAttr[4]);
              parsedDim.minX = minX;
              parsedDim.minY = minY;
              parsedDim.viewBoxWidth = viewBoxWidth;
              parsedDim.viewBoxHeight = viewBoxHeight;
              if (!missingDimAttr) {
                parsedDim.width = parseUnit(widthAttr);
                parsedDim.height = parseUnit(heightAttr);
                scaleX = parsedDim.width / viewBoxWidth;
                scaleY = parsedDim.height / viewBoxHeight;
              } else {
                parsedDim.width = viewBoxWidth;
                parsedDim.height = viewBoxHeight;
              }
              preserveAspectRatio = fabric2.util.parsePreserveAspectRatioAttribute(preserveAspectRatio);
              if (preserveAspectRatio.alignX !== "none") {
                if (preserveAspectRatio.meetOrSlice === "meet") {
                  scaleY = scaleX = scaleX > scaleY ? scaleY : scaleX;
                }
                if (preserveAspectRatio.meetOrSlice === "slice") {
                  scaleY = scaleX = scaleX > scaleY ? scaleX : scaleY;
                }
                widthDiff = parsedDim.width - viewBoxWidth * scaleX;
                heightDiff = parsedDim.height - viewBoxHeight * scaleX;
                if (preserveAspectRatio.alignX === "Mid") {
                  widthDiff /= 2;
                }
                if (preserveAspectRatio.alignY === "Mid") {
                  heightDiff /= 2;
                }
                if (preserveAspectRatio.alignX === "Min") {
                  widthDiff = 0;
                }
                if (preserveAspectRatio.alignY === "Min") {
                  heightDiff = 0;
                }
              }
              if (scaleX === 1 && scaleY === 1 && minX === 0 && minY === 0 && x === 0 && y === 0) {
                return parsedDim;
              }
              if ((x || y) && element.parentNode.nodeName !== "#document") {
                translateMatrix = " translate(" + parseUnit(x) + " " + parseUnit(y) + ") ";
              }
              matrix2 = translateMatrix + " matrix(" + scaleX + " 0 0 " + scaleY + " " + (minX * scaleX + widthDiff) + " " + (minY * scaleY + heightDiff) + ") ";
              if (element.nodeName === "svg") {
                el = element.ownerDocument.createElementNS(fabric2.svgNS, "g");
                while (element.firstChild) {
                  el.appendChild(element.firstChild);
                }
                element.appendChild(el);
              } else {
                el = element;
                el.removeAttribute("x");
                el.removeAttribute("y");
                matrix2 = el.getAttribute("transform") + matrix2;
              }
              el.setAttribute("transform", matrix2);
              return parsedDim;
            }
            function hasAncestorWithNodeName(element, nodeName) {
              while (element && (element = element.parentNode)) {
                if (element.nodeName && nodeName.test(element.nodeName.replace("svg:", "")) && !element.getAttribute("instantiated_by_use")) {
                  return true;
                }
              }
              return false;
            }
            fabric2.parseSVGDocument = function(doc2, callback, reviver, parsingOptions) {
              if (!doc2) {
                return;
              }
              parseUseDirectives(doc2);
              var svgUid = fabric2.Object.__uid++, i, len, options = applyViewboxTransform(doc2), descendants = fabric2.util.toArray(doc2.getElementsByTagName("*"));
              options.crossOrigin = parsingOptions && parsingOptions.crossOrigin;
              options.svgUid = svgUid;
              if (descendants.length === 0 && fabric2.isLikelyNode) {
                descendants = doc2.selectNodes('//*[name(.)!="svg"]');
                var arr2 = [];
                for (i = 0, len = descendants.length; i < len; i++) {
                  arr2[i] = descendants[i];
                }
                descendants = arr2;
              }
              var elements = descendants.filter(function(el) {
                applyViewboxTransform(el);
                return fabric2.svgValidTagNamesRegEx.test(el.nodeName.replace("svg:", "")) && !hasAncestorWithNodeName(el, fabric2.svgInvalidAncestorsRegEx);
              });
              if (!elements || elements && !elements.length) {
                callback && callback([], {});
                return;
              }
              var clipPaths = {};
              descendants.filter(function(el) {
                return el.nodeName.replace("svg:", "") === "clipPath";
              }).forEach(function(el) {
                var id = el.getAttribute("id");
                clipPaths[id] = fabric2.util.toArray(el.getElementsByTagName("*")).filter(function(el2) {
                  return fabric2.svgValidTagNamesRegEx.test(el2.nodeName.replace("svg:", ""));
                });
              });
              fabric2.gradientDefs[svgUid] = fabric2.getGradientDefs(doc2);
              fabric2.cssRules[svgUid] = fabric2.getCSSRules(doc2);
              fabric2.clipPaths[svgUid] = clipPaths;
              fabric2.parseElements(elements, function(instances, elements2) {
                if (callback) {
                  callback(instances, options, elements2, descendants);
                  delete fabric2.gradientDefs[svgUid];
                  delete fabric2.cssRules[svgUid];
                  delete fabric2.clipPaths[svgUid];
                }
              }, clone2(options), reviver, parsingOptions);
            };
            function recursivelyParseGradientsXlink(doc2, gradient) {
              var gradientsAttrs = ["gradientTransform", "x1", "x2", "y1", "y2", "gradientUnits", "cx", "cy", "r", "fx", "fy"], xlinkAttr = "xlink:href", xLink = gradient.getAttribute(xlinkAttr).substr(1), referencedGradient = elementById(doc2, xLink);
              if (referencedGradient && referencedGradient.getAttribute(xlinkAttr)) {
                recursivelyParseGradientsXlink(doc2, referencedGradient);
              }
              gradientsAttrs.forEach(function(attr) {
                if (referencedGradient && !gradient.hasAttribute(attr) && referencedGradient.hasAttribute(attr)) {
                  gradient.setAttribute(attr, referencedGradient.getAttribute(attr));
                }
              });
              if (!gradient.children.length) {
                var referenceClone = referencedGradient.cloneNode(true);
                while (referenceClone.firstChild) {
                  gradient.appendChild(referenceClone.firstChild);
                }
              }
              gradient.removeAttribute(xlinkAttr);
            }
            var reFontDeclaration = new RegExp(
              "(normal|italic)?\\s*(normal|small-caps)?\\s*(normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900)?\\s*(" + fabric2.reNum + "(?:px|cm|mm|em|pt|pc|in)*)(?:\\/(normal|" + fabric2.reNum + "))?\\s+(.*)"
            );
            extend2(fabric2, {
              parseFontDeclaration: function(value, oStyle) {
                var match = value.match(reFontDeclaration);
                if (!match) {
                  return;
                }
                var fontStyle2 = match[1], fontWeight2 = match[3], fontSize2 = match[4], lineHeight2 = match[5], fontFamily2 = match[6];
                if (fontStyle2) {
                  oStyle.fontStyle = fontStyle2;
                }
                if (fontWeight2) {
                  oStyle.fontWeight = isNaN(parseFloat(fontWeight2)) ? fontWeight2 : parseFloat(fontWeight2);
                }
                if (fontSize2) {
                  oStyle.fontSize = parseUnit(fontSize2);
                }
                if (fontFamily2) {
                  oStyle.fontFamily = fontFamily2;
                }
                if (lineHeight2) {
                  oStyle.lineHeight = lineHeight2 === "normal" ? 1 : lineHeight2;
                }
              },
              getGradientDefs: function(doc2) {
                var tagArray = [
                  "linearGradient",
                  "radialGradient",
                  "svg:linearGradient",
                  "svg:radialGradient"
                ], elList = _getMultipleNodes(doc2, tagArray), el, j2 = 0, gradientDefs = {};
                j2 = elList.length;
                while (j2--) {
                  el = elList[j2];
                  if (el.getAttribute("xlink:href")) {
                    recursivelyParseGradientsXlink(doc2, el);
                  }
                  gradientDefs[el.getAttribute("id")] = el;
                }
                return gradientDefs;
              },
              parseAttributes: function(element, attributes, svgUid) {
                if (!element) {
                  return;
                }
                var value, parentAttributes = {}, fontSize2, parentFontSize;
                if (typeof svgUid === "undefined") {
                  svgUid = element.getAttribute("svgUid");
                }
                if (element.parentNode && fabric2.svgValidParentsRegEx.test(element.parentNode.nodeName)) {
                  parentAttributes = fabric2.parseAttributes(element.parentNode, attributes, svgUid);
                }
                var ownAttributes = attributes.reduce(function(memo, attr2) {
                  value = element.getAttribute(attr2);
                  if (value) {
                    memo[attr2] = value;
                  }
                  return memo;
                }, {});
                var cssAttrs = extend2(
                  getGlobalStylesForElement(element, svgUid),
                  fabric2.parseStyleAttribute(element)
                );
                ownAttributes = extend2(
                  ownAttributes,
                  cssAttrs
                );
                if (cssAttrs[cPath]) {
                  element.setAttribute(cPath, cssAttrs[cPath]);
                }
                fontSize2 = parentFontSize = parentAttributes.fontSize || fabric2.Text.DEFAULT_SVG_FONT_SIZE;
                if (ownAttributes[fSize]) {
                  ownAttributes[fSize] = fontSize2 = parseUnit(ownAttributes[fSize], parentFontSize);
                }
                var normalizedAttr, normalizedValue, normalizedStyle = {};
                for (var attr in ownAttributes) {
                  normalizedAttr = normalizeAttr(attr);
                  normalizedValue = normalizeValue(normalizedAttr, ownAttributes[attr], parentAttributes, fontSize2);
                  normalizedStyle[normalizedAttr] = normalizedValue;
                }
                if (normalizedStyle && normalizedStyle.font) {
                  fabric2.parseFontDeclaration(normalizedStyle.font, normalizedStyle);
                }
                var mergedAttrs = extend2(parentAttributes, normalizedStyle);
                return fabric2.svgValidParentsRegEx.test(element.nodeName) ? mergedAttrs : _setStrokeFillOpacity(mergedAttrs);
              },
              parseElements: function(elements, callback, options, reviver, parsingOptions) {
                new fabric2.ElementsParser(elements, callback, options, reviver, parsingOptions).parse();
              },
              parseStyleAttribute: function(element) {
                var oStyle = {}, style = element.getAttribute("style");
                if (!style) {
                  return oStyle;
                }
                if (typeof style === "string") {
                  parseStyleString(style, oStyle);
                } else {
                  parseStyleObject(style, oStyle);
                }
                return oStyle;
              },
              parsePointsAttribute: function(points) {
                if (!points) {
                  return null;
                }
                points = points.replace(/,/g, " ").trim();
                points = points.split(/\s+/);
                var parsedPoints = [], i, len;
                for (i = 0, len = points.length; i < len; i += 2) {
                  parsedPoints.push({
                    x: parseFloat(points[i]),
                    y: parseFloat(points[i + 1])
                  });
                }
                return parsedPoints;
              },
              getCSSRules: function(doc2) {
                var styles = doc2.getElementsByTagName("style"), i, len, allRules = {}, rules;
                for (i = 0, len = styles.length; i < len; i++) {
                  var styleContents = styles[i].textContent;
                  styleContents = styleContents.replace(/\/\*[\s\S]*?\*\//g, "");
                  if (styleContents.trim() === "") {
                    continue;
                  }
                  rules = styleContents.match(/[^{]*\{[\s\S]*?\}/g);
                  rules = rules.map(function(rule) {
                    return rule.trim();
                  });
                  rules.forEach(function(rule) {
                    var match = rule.match(/([\s\S]*?)\s*\{([^}]*)\}/), ruleObj = {}, declaration = match[2].trim(), propertyValuePairs = declaration.replace(/;$/, "").split(/\s*;\s*/);
                    for (i = 0, len = propertyValuePairs.length; i < len; i++) {
                      var pair = propertyValuePairs[i].split(/\s*:\s*/), property = pair[0], value = pair[1];
                      ruleObj[property] = value;
                    }
                    rule = match[1];
                    rule.split(",").forEach(function(_rule) {
                      _rule = _rule.replace(/^svg/i, "").trim();
                      if (_rule === "") {
                        return;
                      }
                      if (allRules[_rule]) {
                        fabric2.util.object.extend(allRules[_rule], ruleObj);
                      } else {
                        allRules[_rule] = fabric2.util.object.clone(ruleObj);
                      }
                    });
                  });
                }
                return allRules;
              },
              loadSVGFromURL: function(url, callback, reviver, options) {
                url = url.replace(/^\n\s*/, "").trim();
                new fabric2.util.request(url, {
                  method: "get",
                  onComplete
                });
                function onComplete(r) {
                  var xml = r.responseXML;
                  if (!xml || !xml.documentElement) {
                    callback && callback(null);
                    return false;
                  }
                  fabric2.parseSVGDocument(xml.documentElement, function(results, _options, elements, allElements) {
                    callback && callback(results, _options, elements, allElements);
                  }, reviver, options);
                }
              },
              loadSVGFromString: function(string, callback, reviver, options) {
                var parser = new fabric2.window.DOMParser(), doc2 = parser.parseFromString(string.trim(), "text/xml");
                fabric2.parseSVGDocument(doc2.documentElement, function(results, _options, elements, allElements) {
                  callback(results, _options, elements, allElements);
                }, reviver, options);
              }
            });
          })(exports2);
          fabric.ElementsParser = function(elements, callback, options, reviver, parsingOptions, doc2) {
            this.elements = elements;
            this.callback = callback;
            this.options = options;
            this.reviver = reviver;
            this.svgUid = options && options.svgUid || 0;
            this.parsingOptions = parsingOptions;
            this.regexUrl = /^url\(['"]?#([^'"]+)['"]?\)/g;
            this.doc = doc2;
          };
          (function(proto) {
            proto.parse = function() {
              this.instances = new Array(this.elements.length);
              this.numElements = this.elements.length;
              this.createObjects();
            };
            proto.createObjects = function() {
              var _this = this;
              this.elements.forEach(function(element, i) {
                element.setAttribute("svgUid", _this.svgUid);
                _this.createObject(element, i);
              });
            };
            proto.findTag = function(el) {
              return fabric[fabric.util.string.capitalize(el.tagName.replace("svg:", ""))];
            };
            proto.createObject = function(el, index2) {
              var klass = this.findTag(el);
              if (klass && klass.fromElement) {
                try {
                  klass.fromElement(el, this.createCallback(index2, el), this.options);
                } catch (err) {
                  fabric.log(err);
                }
              } else {
                this.checkIfDone();
              }
            };
            proto.createCallback = function(index2, el) {
              var _this = this;
              return function(obj) {
                var _options;
                _this.resolveGradient(obj, el, "fill");
                _this.resolveGradient(obj, el, "stroke");
                if (obj instanceof fabric.Image && obj._originalElement) {
                  _options = obj.parsePreserveAspectRatioAttribute(el);
                }
                obj._removeTransformMatrix(_options);
                _this.resolveClipPath(obj, el);
                _this.reviver && _this.reviver(el, obj);
                _this.instances[index2] = obj;
                _this.checkIfDone();
              };
            };
            proto.extractPropertyDefinition = function(obj, property, storage) {
              var value = obj[property], regex2 = this.regexUrl;
              if (!regex2.test(value)) {
                return;
              }
              regex2.lastIndex = 0;
              var id = regex2.exec(value)[1];
              regex2.lastIndex = 0;
              return fabric[storage][this.svgUid][id];
            };
            proto.resolveGradient = function(obj, el, property) {
              var gradientDef = this.extractPropertyDefinition(obj, property, "gradientDefs");
              if (gradientDef) {
                var opacityAttr = el.getAttribute(property + "-opacity");
                var gradient = fabric.Gradient.fromElement(gradientDef, obj, opacityAttr, this.options);
                obj.set(property, gradient);
              }
            };
            proto.createClipPathCallback = function(obj, container) {
              return function(_newObj) {
                _newObj._removeTransformMatrix();
                _newObj.fillRule = _newObj.clipRule;
                container.push(_newObj);
              };
            };
            proto.resolveClipPath = function(obj, usingElement) {
              var clipPath = this.extractPropertyDefinition(obj, "clipPath", "clipPaths"), element, klass, objTransformInv, container, gTransform, options;
              if (clipPath) {
                container = [];
                objTransformInv = fabric.util.invertTransform(obj.calcTransformMatrix());
                var clipPathTag = clipPath[0].parentNode;
                var clipPathOwner = usingElement;
                while (clipPathOwner.parentNode && clipPathOwner.getAttribute("clip-path") !== obj.clipPath) {
                  clipPathOwner = clipPathOwner.parentNode;
                }
                clipPathOwner.parentNode.appendChild(clipPathTag);
                for (var i = 0; i < clipPath.length; i++) {
                  element = clipPath[i];
                  klass = this.findTag(element);
                  klass.fromElement(
                    element,
                    this.createClipPathCallback(obj, container),
                    this.options
                  );
                }
                if (container.length === 1) {
                  clipPath = container[0];
                } else {
                  clipPath = new fabric.Group(container);
                }
                gTransform = fabric.util.multiplyTransformMatrices(
                  objTransformInv,
                  clipPath.calcTransformMatrix()
                );
                if (clipPath.clipPath) {
                  this.resolveClipPath(clipPath, clipPathOwner);
                }
                var options = fabric.util.qrDecompose(gTransform);
                clipPath.flipX = false;
                clipPath.flipY = false;
                clipPath.set("scaleX", options.scaleX);
                clipPath.set("scaleY", options.scaleY);
                clipPath.angle = options.angle;
                clipPath.skewX = options.skewX;
                clipPath.skewY = 0;
                clipPath.setPositionByOrigin({ x: options.translateX, y: options.translateY }, "center", "center");
                obj.clipPath = clipPath;
              } else {
                delete obj.clipPath;
              }
            };
            proto.checkIfDone = function() {
              if (--this.numElements === 0) {
                this.instances = this.instances.filter(function(el) {
                  return el != null;
                });
                this.callback(this.instances, this.elements);
              }
            };
          })(fabric.ElementsParser.prototype);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {});
            if (fabric2.Point) {
              fabric2.warn("fabric.Point is already defined");
              return;
            }
            fabric2.Point = Point;
            function Point(x, y) {
              this.x = x;
              this.y = y;
            }
            Point.prototype = {
              type: "point",
              constructor: Point,
              add: function(that) {
                return new Point(this.x + that.x, this.y + that.y);
              },
              addEquals: function(that) {
                this.x += that.x;
                this.y += that.y;
                return this;
              },
              scalarAdd: function(scalar) {
                return new Point(this.x + scalar, this.y + scalar);
              },
              scalarAddEquals: function(scalar) {
                this.x += scalar;
                this.y += scalar;
                return this;
              },
              subtract: function(that) {
                return new Point(this.x - that.x, this.y - that.y);
              },
              subtractEquals: function(that) {
                this.x -= that.x;
                this.y -= that.y;
                return this;
              },
              scalarSubtract: function(scalar) {
                return new Point(this.x - scalar, this.y - scalar);
              },
              scalarSubtractEquals: function(scalar) {
                this.x -= scalar;
                this.y -= scalar;
                return this;
              },
              multiply: function(scalar) {
                return new Point(this.x * scalar, this.y * scalar);
              },
              multiplyEquals: function(scalar) {
                this.x *= scalar;
                this.y *= scalar;
                return this;
              },
              divide: function(scalar) {
                return new Point(this.x / scalar, this.y / scalar);
              },
              divideEquals: function(scalar) {
                this.x /= scalar;
                this.y /= scalar;
                return this;
              },
              eq: function(that) {
                return this.x === that.x && this.y === that.y;
              },
              lt: function(that) {
                return this.x < that.x && this.y < that.y;
              },
              lte: function(that) {
                return this.x <= that.x && this.y <= that.y;
              },
              gt: function(that) {
                return this.x > that.x && this.y > that.y;
              },
              gte: function(that) {
                return this.x >= that.x && this.y >= that.y;
              },
              lerp: function(that, t) {
                if (typeof t === "undefined") {
                  t = 0.5;
                }
                t = Math.max(Math.min(1, t), 0);
                return new Point(this.x + (that.x - this.x) * t, this.y + (that.y - this.y) * t);
              },
              distanceFrom: function(that) {
                var dx = this.x - that.x, dy = this.y - that.y;
                return Math.sqrt(dx * dx + dy * dy);
              },
              midPointFrom: function(that) {
                return this.lerp(that);
              },
              min: function(that) {
                return new Point(Math.min(this.x, that.x), Math.min(this.y, that.y));
              },
              max: function(that) {
                return new Point(Math.max(this.x, that.x), Math.max(this.y, that.y));
              },
              toString: function() {
                return this.x + "," + this.y;
              },
              setXY: function(x, y) {
                this.x = x;
                this.y = y;
                return this;
              },
              setX: function(x) {
                this.x = x;
                return this;
              },
              setY: function(y) {
                this.y = y;
                return this;
              },
              setFromPoint: function(that) {
                this.x = that.x;
                this.y = that.y;
                return this;
              },
              swap: function(that) {
                var x = this.x, y = this.y;
                this.x = that.x;
                this.y = that.y;
                that.x = x;
                that.y = y;
              },
              clone: function() {
                return new Point(this.x, this.y);
              }
            };
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {});
            if (fabric2.Intersection) {
              fabric2.warn("fabric.Intersection is already defined");
              return;
            }
            function Intersection(status) {
              this.status = status;
              this.points = [];
            }
            fabric2.Intersection = Intersection;
            fabric2.Intersection.prototype = {
              constructor: Intersection,
              appendPoint: function(point) {
                this.points.push(point);
                return this;
              },
              appendPoints: function(points) {
                this.points = this.points.concat(points);
                return this;
              }
            };
            fabric2.Intersection.intersectLineLine = function(a1, a2, b1, b2) {
              var result, uaT = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x), ubT = (a2.x - a1.x) * (a1.y - b1.y) - (a2.y - a1.y) * (a1.x - b1.x), uB = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
              if (uB !== 0) {
                var ua = uaT / uB, ub = ubT / uB;
                if (0 <= ua && ua <= 1 && 0 <= ub && ub <= 1) {
                  result = new Intersection("Intersection");
                  result.appendPoint(new fabric2.Point(a1.x + ua * (a2.x - a1.x), a1.y + ua * (a2.y - a1.y)));
                } else {
                  result = new Intersection();
                }
              } else {
                if (uaT === 0 || ubT === 0) {
                  result = new Intersection("Coincident");
                } else {
                  result = new Intersection("Parallel");
                }
              }
              return result;
            };
            fabric2.Intersection.intersectLinePolygon = function(a1, a2, points) {
              var result = new Intersection(), length = points.length, b1, b2, inter, i;
              for (i = 0; i < length; i++) {
                b1 = points[i];
                b2 = points[(i + 1) % length];
                inter = Intersection.intersectLineLine(a1, a2, b1, b2);
                result.appendPoints(inter.points);
              }
              if (result.points.length > 0) {
                result.status = "Intersection";
              }
              return result;
            };
            fabric2.Intersection.intersectPolygonPolygon = function(points1, points2) {
              var result = new Intersection(), length = points1.length, i;
              for (i = 0; i < length; i++) {
                var a1 = points1[i], a2 = points1[(i + 1) % length], inter = Intersection.intersectLinePolygon(a1, a2, points2);
                result.appendPoints(inter.points);
              }
              if (result.points.length > 0) {
                result.status = "Intersection";
              }
              return result;
            };
            fabric2.Intersection.intersectPolygonRectangle = function(points, r1, r2) {
              var min = r1.min(r2), max2 = r1.max(r2), topRight = new fabric2.Point(max2.x, min.y), bottomLeft = new fabric2.Point(min.x, max2.y), inter1 = Intersection.intersectLinePolygon(min, topRight, points), inter2 = Intersection.intersectLinePolygon(topRight, max2, points), inter3 = Intersection.intersectLinePolygon(max2, bottomLeft, points), inter4 = Intersection.intersectLinePolygon(bottomLeft, min, points), result = new Intersection();
              result.appendPoints(inter1.points);
              result.appendPoints(inter2.points);
              result.appendPoints(inter3.points);
              result.appendPoints(inter4.points);
              if (result.points.length > 0) {
                result.status = "Intersection";
              }
              return result;
            };
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {});
            if (fabric2.Color) {
              fabric2.warn("fabric.Color is already defined.");
              return;
            }
            function Color(color2) {
              if (!color2) {
                this.setSource([0, 0, 0, 1]);
              } else {
                this._tryParsingColor(color2);
              }
            }
            fabric2.Color = Color;
            fabric2.Color.prototype = {
              _tryParsingColor: function(color2) {
                var source2;
                if (color2 in Color.colorNameMap) {
                  color2 = Color.colorNameMap[color2];
                }
                if (color2 === "transparent") {
                  source2 = [255, 255, 255, 0];
                }
                if (!source2) {
                  source2 = Color.sourceFromHex(color2);
                }
                if (!source2) {
                  source2 = Color.sourceFromRgb(color2);
                }
                if (!source2) {
                  source2 = Color.sourceFromHsl(color2);
                }
                if (!source2) {
                  source2 = [0, 0, 0, 1];
                }
                if (source2) {
                  this.setSource(source2);
                }
              },
              _rgbToHsl: function(r, g, b) {
                r /= 255;
                g /= 255;
                b /= 255;
                var h2, s, l, max2 = fabric2.util.array.max([r, g, b]), min = fabric2.util.array.min([r, g, b]);
                l = (max2 + min) / 2;
                if (max2 === min) {
                  h2 = s = 0;
                } else {
                  var d = max2 - min;
                  s = l > 0.5 ? d / (2 - max2 - min) : d / (max2 + min);
                  switch (max2) {
                    case r:
                      h2 = (g - b) / d + (g < b ? 6 : 0);
                      break;
                    case g:
                      h2 = (b - r) / d + 2;
                      break;
                    case b:
                      h2 = (r - g) / d + 4;
                      break;
                  }
                  h2 /= 6;
                }
                return [
                  Math.round(h2 * 360),
                  Math.round(s * 100),
                  Math.round(l * 100)
                ];
              },
              getSource: function() {
                return this._source;
              },
              setSource: function(source2) {
                this._source = source2;
              },
              toRgb: function() {
                var source2 = this.getSource();
                return "rgb(" + source2[0] + "," + source2[1] + "," + source2[2] + ")";
              },
              toRgba: function() {
                var source2 = this.getSource();
                return "rgba(" + source2[0] + "," + source2[1] + "," + source2[2] + "," + source2[3] + ")";
              },
              toHsl: function() {
                var source2 = this.getSource(), hsl2 = this._rgbToHsl(source2[0], source2[1], source2[2]);
                return "hsl(" + hsl2[0] + "," + hsl2[1] + "%," + hsl2[2] + "%)";
              },
              toHsla: function() {
                var source2 = this.getSource(), hsl2 = this._rgbToHsl(source2[0], source2[1], source2[2]);
                return "hsla(" + hsl2[0] + "," + hsl2[1] + "%," + hsl2[2] + "%," + source2[3] + ")";
              },
              toHex: function() {
                var source2 = this.getSource(), r, g, b;
                r = source2[0].toString(16);
                r = r.length === 1 ? "0" + r : r;
                g = source2[1].toString(16);
                g = g.length === 1 ? "0" + g : g;
                b = source2[2].toString(16);
                b = b.length === 1 ? "0" + b : b;
                return r.toUpperCase() + g.toUpperCase() + b.toUpperCase();
              },
              toHexa: function() {
                var source2 = this.getSource(), a2;
                a2 = Math.round(source2[3] * 255);
                a2 = a2.toString(16);
                a2 = a2.length === 1 ? "0" + a2 : a2;
                return this.toHex() + a2.toUpperCase();
              },
              getAlpha: function() {
                return this.getSource()[3];
              },
              setAlpha: function(alpha) {
                var source2 = this.getSource();
                source2[3] = alpha;
                this.setSource(source2);
                return this;
              },
              toGrayscale: function() {
                var source2 = this.getSource(), average2 = parseInt((source2[0] * 0.3 + source2[1] * 0.59 + source2[2] * 0.11).toFixed(0), 10), currentAlpha = source2[3];
                this.setSource([average2, average2, average2, currentAlpha]);
                return this;
              },
              toBlackWhite: function(threshold) {
                var source2 = this.getSource(), average2 = (source2[0] * 0.3 + source2[1] * 0.59 + source2[2] * 0.11).toFixed(0), currentAlpha = source2[3];
                threshold = threshold || 127;
                average2 = Number(average2) < Number(threshold) ? 0 : 255;
                this.setSource([average2, average2, average2, currentAlpha]);
                return this;
              },
              overlayWith: function(otherColor) {
                if (!(otherColor instanceof Color)) {
                  otherColor = new Color(otherColor);
                }
                var result = [], alpha = this.getAlpha(), otherAlpha = 0.5, source2 = this.getSource(), otherSource = otherColor.getSource(), i;
                for (i = 0; i < 3; i++) {
                  result.push(Math.round(source2[i] * (1 - otherAlpha) + otherSource[i] * otherAlpha));
                }
                result[3] = alpha;
                this.setSource(result);
                return this;
              }
            };
            fabric2.Color.reRGBa = /^rgba?\(\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*,\s*(\d{1,3}(?:\.\d+)?\%?)\s*(?:\s*,\s*((?:\d*\.?\d+)?)\s*)?\)$/i;
            fabric2.Color.reHSLa = /^hsla?\(\s*(\d{1,3})\s*,\s*(\d{1,3}\%)\s*,\s*(\d{1,3}\%)\s*(?:\s*,\s*(\d+(?:\.\d+)?)\s*)?\)$/i;
            fabric2.Color.reHex = /^#?([0-9a-f]{8}|[0-9a-f]{6}|[0-9a-f]{4}|[0-9a-f]{3})$/i;
            fabric2.Color.colorNameMap = {
              aliceblue: "#F0F8FF",
              antiquewhite: "#FAEBD7",
              aqua: "#00FFFF",
              aquamarine: "#7FFFD4",
              azure: "#F0FFFF",
              beige: "#F5F5DC",
              bisque: "#FFE4C4",
              black: "#000000",
              blanchedalmond: "#FFEBCD",
              blue: "#0000FF",
              blueviolet: "#8A2BE2",
              brown: "#A52A2A",
              burlywood: "#DEB887",
              cadetblue: "#5F9EA0",
              chartreuse: "#7FFF00",
              chocolate: "#D2691E",
              coral: "#FF7F50",
              cornflowerblue: "#6495ED",
              cornsilk: "#FFF8DC",
              crimson: "#DC143C",
              cyan: "#00FFFF",
              darkblue: "#00008B",
              darkcyan: "#008B8B",
              darkgoldenrod: "#B8860B",
              darkgray: "#A9A9A9",
              darkgrey: "#A9A9A9",
              darkgreen: "#006400",
              darkkhaki: "#BDB76B",
              darkmagenta: "#8B008B",
              darkolivegreen: "#556B2F",
              darkorange: "#FF8C00",
              darkorchid: "#9932CC",
              darkred: "#8B0000",
              darksalmon: "#E9967A",
              darkseagreen: "#8FBC8F",
              darkslateblue: "#483D8B",
              darkslategray: "#2F4F4F",
              darkslategrey: "#2F4F4F",
              darkturquoise: "#00CED1",
              darkviolet: "#9400D3",
              deeppink: "#FF1493",
              deepskyblue: "#00BFFF",
              dimgray: "#696969",
              dimgrey: "#696969",
              dodgerblue: "#1E90FF",
              firebrick: "#B22222",
              floralwhite: "#FFFAF0",
              forestgreen: "#228B22",
              fuchsia: "#FF00FF",
              gainsboro: "#DCDCDC",
              ghostwhite: "#F8F8FF",
              gold: "#FFD700",
              goldenrod: "#DAA520",
              gray: "#808080",
              grey: "#808080",
              green: "#008000",
              greenyellow: "#ADFF2F",
              honeydew: "#F0FFF0",
              hotpink: "#FF69B4",
              indianred: "#CD5C5C",
              indigo: "#4B0082",
              ivory: "#FFFFF0",
              khaki: "#F0E68C",
              lavender: "#E6E6FA",
              lavenderblush: "#FFF0F5",
              lawngreen: "#7CFC00",
              lemonchiffon: "#FFFACD",
              lightblue: "#ADD8E6",
              lightcoral: "#F08080",
              lightcyan: "#E0FFFF",
              lightgoldenrodyellow: "#FAFAD2",
              lightgray: "#D3D3D3",
              lightgrey: "#D3D3D3",
              lightgreen: "#90EE90",
              lightpink: "#FFB6C1",
              lightsalmon: "#FFA07A",
              lightseagreen: "#20B2AA",
              lightskyblue: "#87CEFA",
              lightslategray: "#778899",
              lightslategrey: "#778899",
              lightsteelblue: "#B0C4DE",
              lightyellow: "#FFFFE0",
              lime: "#00FF00",
              limegreen: "#32CD32",
              linen: "#FAF0E6",
              magenta: "#FF00FF",
              maroon: "#800000",
              mediumaquamarine: "#66CDAA",
              mediumblue: "#0000CD",
              mediumorchid: "#BA55D3",
              mediumpurple: "#9370DB",
              mediumseagreen: "#3CB371",
              mediumslateblue: "#7B68EE",
              mediumspringgreen: "#00FA9A",
              mediumturquoise: "#48D1CC",
              mediumvioletred: "#C71585",
              midnightblue: "#191970",
              mintcream: "#F5FFFA",
              mistyrose: "#FFE4E1",
              moccasin: "#FFE4B5",
              navajowhite: "#FFDEAD",
              navy: "#000080",
              oldlace: "#FDF5E6",
              olive: "#808000",
              olivedrab: "#6B8E23",
              orange: "#FFA500",
              orangered: "#FF4500",
              orchid: "#DA70D6",
              palegoldenrod: "#EEE8AA",
              palegreen: "#98FB98",
              paleturquoise: "#AFEEEE",
              palevioletred: "#DB7093",
              papayawhip: "#FFEFD5",
              peachpuff: "#FFDAB9",
              peru: "#CD853F",
              pink: "#FFC0CB",
              plum: "#DDA0DD",
              powderblue: "#B0E0E6",
              purple: "#800080",
              rebeccapurple: "#663399",
              red: "#FF0000",
              rosybrown: "#BC8F8F",
              royalblue: "#4169E1",
              saddlebrown: "#8B4513",
              salmon: "#FA8072",
              sandybrown: "#F4A460",
              seagreen: "#2E8B57",
              seashell: "#FFF5EE",
              sienna: "#A0522D",
              silver: "#C0C0C0",
              skyblue: "#87CEEB",
              slateblue: "#6A5ACD",
              slategray: "#708090",
              slategrey: "#708090",
              snow: "#FFFAFA",
              springgreen: "#00FF7F",
              steelblue: "#4682B4",
              tan: "#D2B48C",
              teal: "#008080",
              thistle: "#D8BFD8",
              tomato: "#FF6347",
              turquoise: "#40E0D0",
              violet: "#EE82EE",
              wheat: "#F5DEB3",
              white: "#FFFFFF",
              whitesmoke: "#F5F5F5",
              yellow: "#FFFF00",
              yellowgreen: "#9ACD32"
            };
            function hue2rgb2(p, q2, t) {
              if (t < 0) {
                t += 1;
              }
              if (t > 1) {
                t -= 1;
              }
              if (t < 1 / 6) {
                return p + (q2 - p) * 6 * t;
              }
              if (t < 1 / 2) {
                return q2;
              }
              if (t < 2 / 3) {
                return p + (q2 - p) * (2 / 3 - t) * 6;
              }
              return p;
            }
            fabric2.Color.fromRgb = function(color2) {
              return Color.fromSource(Color.sourceFromRgb(color2));
            };
            fabric2.Color.sourceFromRgb = function(color2) {
              var match = color2.match(Color.reRGBa);
              if (match) {
                var r = parseInt(match[1], 10) / (/%$/.test(match[1]) ? 100 : 1) * (/%$/.test(match[1]) ? 255 : 1), g = parseInt(match[2], 10) / (/%$/.test(match[2]) ? 100 : 1) * (/%$/.test(match[2]) ? 255 : 1), b = parseInt(match[3], 10) / (/%$/.test(match[3]) ? 100 : 1) * (/%$/.test(match[3]) ? 255 : 1);
                return [
                  parseInt(r, 10),
                  parseInt(g, 10),
                  parseInt(b, 10),
                  match[4] ? parseFloat(match[4]) : 1
                ];
              }
            };
            fabric2.Color.fromRgba = Color.fromRgb;
            fabric2.Color.fromHsl = function(color2) {
              return Color.fromSource(Color.sourceFromHsl(color2));
            };
            fabric2.Color.sourceFromHsl = function(color2) {
              var match = color2.match(Color.reHSLa);
              if (!match) {
                return;
              }
              var h2 = (parseFloat(match[1]) % 360 + 360) % 360 / 360, s = parseFloat(match[2]) / (/%$/.test(match[2]) ? 100 : 1), l = parseFloat(match[3]) / (/%$/.test(match[3]) ? 100 : 1), r, g, b;
              if (s === 0) {
                r = g = b = l;
              } else {
                var q2 = l <= 0.5 ? l * (s + 1) : l + s - l * s, p = l * 2 - q2;
                r = hue2rgb2(p, q2, h2 + 1 / 3);
                g = hue2rgb2(p, q2, h2);
                b = hue2rgb2(p, q2, h2 - 1 / 3);
              }
              return [
                Math.round(r * 255),
                Math.round(g * 255),
                Math.round(b * 255),
                match[4] ? parseFloat(match[4]) : 1
              ];
            };
            fabric2.Color.fromHsla = Color.fromHsl;
            fabric2.Color.fromHex = function(color2) {
              return Color.fromSource(Color.sourceFromHex(color2));
            };
            fabric2.Color.sourceFromHex = function(color2) {
              if (color2.match(Color.reHex)) {
                var value = color2.slice(color2.indexOf("#") + 1), isShortNotation = value.length === 3 || value.length === 4, isRGBa = value.length === 8 || value.length === 4, r = isShortNotation ? value.charAt(0) + value.charAt(0) : value.substring(0, 2), g = isShortNotation ? value.charAt(1) + value.charAt(1) : value.substring(2, 4), b = isShortNotation ? value.charAt(2) + value.charAt(2) : value.substring(4, 6), a2 = isRGBa ? isShortNotation ? value.charAt(3) + value.charAt(3) : value.substring(6, 8) : "FF";
                return [
                  parseInt(r, 16),
                  parseInt(g, 16),
                  parseInt(b, 16),
                  parseFloat((parseInt(a2, 16) / 255).toFixed(2))
                ];
              }
            };
            fabric2.Color.fromSource = function(source2) {
              var oColor = new Color();
              oColor.setSource(source2);
              return oColor;
            };
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), scaleMap = ["e", "se", "s", "sw", "w", "nw", "n", "ne", "e"], skewMap = ["ns", "nesw", "ew", "nwse"], controls = {}, LEFT = "left", TOP = "top", RIGHT = "right", BOTTOM = "bottom", CENTER = "center", opposite = {
              top: BOTTOM,
              bottom: TOP,
              left: RIGHT,
              right: LEFT,
              center: CENTER
            }, radiansToDegrees = fabric2.util.radiansToDegrees, sign2 = Math.sign || function(x) {
              return (x > 0) - (x < 0) || +x;
            };
            function findCornerQuadrant(fabricObject, control) {
              var cornerAngle = fabricObject.angle + radiansToDegrees(Math.atan2(control.y, control.x)) + 360;
              return Math.round(cornerAngle % 360 / 45);
            }
            function fireEvent(eventName, options) {
              var target = options.transform.target, canvas = target.canvas, canvasOptions = fabric2.util.object.clone(options);
              canvasOptions.target = target;
              canvas && canvas.fire("object:" + eventName, canvasOptions);
              target.fire(eventName, options);
            }
            function scaleIsProportional(eventData, fabricObject) {
              var canvas = fabricObject.canvas, uniScaleKey = canvas.uniScaleKey, uniformIsToggled = eventData[uniScaleKey];
              return canvas.uniformScaling && !uniformIsToggled || !canvas.uniformScaling && uniformIsToggled;
            }
            function isTransformCentered(transform2) {
              return transform2.originX === CENTER && transform2.originY === CENTER;
            }
            function scalingIsForbidden(fabricObject, by, scaleProportionally) {
              var lockX = fabricObject.lockScalingX, lockY = fabricObject.lockScalingY;
              if (lockX && lockY) {
                return true;
              }
              if (!by && (lockX || lockY) && scaleProportionally) {
                return true;
              }
              if (lockX && by === "x") {
                return true;
              }
              if (lockY && by === "y") {
                return true;
              }
              return false;
            }
            function scaleCursorStyleHandler(eventData, control, fabricObject) {
              var notAllowed = "not-allowed", scaleProportionally = scaleIsProportional(eventData, fabricObject), by = "";
              if (control.x !== 0 && control.y === 0) {
                by = "x";
              } else if (control.x === 0 && control.y !== 0) {
                by = "y";
              }
              if (scalingIsForbidden(fabricObject, by, scaleProportionally)) {
                return notAllowed;
              }
              var n = findCornerQuadrant(fabricObject, control);
              return scaleMap[n] + "-resize";
            }
            function skewCursorStyleHandler(eventData, control, fabricObject) {
              var notAllowed = "not-allowed";
              if (control.x !== 0 && fabricObject.lockSkewingY) {
                return notAllowed;
              }
              if (control.y !== 0 && fabricObject.lockSkewingX) {
                return notAllowed;
              }
              var n = findCornerQuadrant(fabricObject, control) % 4;
              return skewMap[n] + "-resize";
            }
            function scaleSkewCursorStyleHandler(eventData, control, fabricObject) {
              if (eventData[fabricObject.canvas.altActionKey]) {
                return controls.skewCursorStyleHandler(eventData, control, fabricObject);
              }
              return controls.scaleCursorStyleHandler(eventData, control, fabricObject);
            }
            function scaleOrSkewActionName(eventData, control, fabricObject) {
              var isAlternative = eventData[fabricObject.canvas.altActionKey];
              if (control.x === 0) {
                return isAlternative ? "skewX" : "scaleY";
              }
              if (control.y === 0) {
                return isAlternative ? "skewY" : "scaleX";
              }
            }
            function rotationStyleHandler(eventData, control, fabricObject) {
              if (fabricObject.lockRotation) {
                return "not-allowed";
              }
              return control.cursorStyle;
            }
            function commonEventInfo(eventData, transform2, x, y) {
              return {
                e: eventData,
                transform: transform2,
                pointer: {
                  x,
                  y
                }
              };
            }
            function wrapWithFixedAnchor(actionHandler) {
              return function(eventData, transform2, x, y) {
                var target = transform2.target, centerPoint = target.getCenterPoint(), constraint = target.translateToOriginPoint(centerPoint, transform2.originX, transform2.originY), actionPerformed = actionHandler(eventData, transform2, x, y);
                target.setPositionByOrigin(constraint, transform2.originX, transform2.originY);
                return actionPerformed;
              };
            }
            function wrapWithFireEvent(eventName, actionHandler) {
              return function(eventData, transform2, x, y) {
                var actionPerformed = actionHandler(eventData, transform2, x, y);
                if (actionPerformed) {
                  fireEvent(eventName, commonEventInfo(eventData, transform2, x, y));
                }
                return actionPerformed;
              };
            }
            function getLocalPoint(transform2, originX, originY, x, y) {
              var target = transform2.target, control = target.controls[transform2.corner], zoom = target.canvas.getZoom(), padding = target.padding / zoom, localPoint = target.toLocalPoint(new fabric2.Point(x, y), originX, originY);
              if (localPoint.x >= padding) {
                localPoint.x -= padding;
              }
              if (localPoint.x <= -padding) {
                localPoint.x += padding;
              }
              if (localPoint.y >= padding) {
                localPoint.y -= padding;
              }
              if (localPoint.y <= padding) {
                localPoint.y += padding;
              }
              localPoint.x -= control.offsetX;
              localPoint.y -= control.offsetY;
              return localPoint;
            }
            function targetHasOneFlip(target) {
              return target.flipX !== target.flipY;
            }
            function compensateScaleForSkew(target, oppositeSkew, scaleToCompensate, axis, reference) {
              if (target[oppositeSkew] !== 0) {
                var newDim = target._getTransformedDimensions()[axis];
                var newValue = reference / newDim * target[scaleToCompensate];
                target.set(scaleToCompensate, newValue);
              }
            }
            function skewObjectX(eventData, transform2, x, y) {
              var target = transform2.target, dimNoSkew = target._getTransformedDimensions(0, target.skewY), localPoint = getLocalPoint(transform2, transform2.originX, transform2.originY, x, y), totalSkewSize = Math.abs(localPoint.x * 2) - dimNoSkew.x, currentSkew = target.skewX, newSkew;
              if (totalSkewSize < 2) {
                newSkew = 0;
              } else {
                newSkew = radiansToDegrees(
                  Math.atan2(totalSkewSize / target.scaleX, dimNoSkew.y / target.scaleY)
                );
                if (transform2.originX === LEFT && transform2.originY === BOTTOM) {
                  newSkew = -newSkew;
                }
                if (transform2.originX === RIGHT && transform2.originY === TOP) {
                  newSkew = -newSkew;
                }
                if (targetHasOneFlip(target)) {
                  newSkew = -newSkew;
                }
              }
              var hasSkewed = currentSkew !== newSkew;
              if (hasSkewed) {
                var dimBeforeSkewing = target._getTransformedDimensions().y;
                target.set("skewX", newSkew);
                compensateScaleForSkew(target, "skewY", "scaleY", "y", dimBeforeSkewing);
              }
              return hasSkewed;
            }
            function skewObjectY(eventData, transform2, x, y) {
              var target = transform2.target, dimNoSkew = target._getTransformedDimensions(target.skewX, 0), localPoint = getLocalPoint(transform2, transform2.originX, transform2.originY, x, y), totalSkewSize = Math.abs(localPoint.y * 2) - dimNoSkew.y, currentSkew = target.skewY, newSkew;
              if (totalSkewSize < 2) {
                newSkew = 0;
              } else {
                newSkew = radiansToDegrees(
                  Math.atan2(totalSkewSize / target.scaleY, dimNoSkew.x / target.scaleX)
                );
                if (transform2.originX === LEFT && transform2.originY === BOTTOM) {
                  newSkew = -newSkew;
                }
                if (transform2.originX === RIGHT && transform2.originY === TOP) {
                  newSkew = -newSkew;
                }
                if (targetHasOneFlip(target)) {
                  newSkew = -newSkew;
                }
              }
              var hasSkewed = currentSkew !== newSkew;
              if (hasSkewed) {
                var dimBeforeSkewing = target._getTransformedDimensions().x;
                target.set("skewY", newSkew);
                compensateScaleForSkew(target, "skewX", "scaleX", "x", dimBeforeSkewing);
              }
              return hasSkewed;
            }
            function skewHandlerX(eventData, transform2, x, y) {
              var target = transform2.target, currentSkew = target.skewX, originX, originY = transform2.originY;
              if (target.lockSkewingX) {
                return false;
              }
              if (currentSkew === 0) {
                var localPointFromCenter = getLocalPoint(transform2, CENTER, CENTER, x, y);
                if (localPointFromCenter.x > 0) {
                  originX = LEFT;
                } else {
                  originX = RIGHT;
                }
              } else {
                if (currentSkew > 0) {
                  originX = originY === TOP ? LEFT : RIGHT;
                }
                if (currentSkew < 0) {
                  originX = originY === TOP ? RIGHT : LEFT;
                }
                if (targetHasOneFlip(target)) {
                  originX = originX === LEFT ? RIGHT : LEFT;
                }
              }
              transform2.originX = originX;
              var finalHandler = wrapWithFireEvent("skewing", wrapWithFixedAnchor(skewObjectX));
              return finalHandler(eventData, transform2, x, y);
            }
            function skewHandlerY(eventData, transform2, x, y) {
              var target = transform2.target, currentSkew = target.skewY, originY, originX = transform2.originX;
              if (target.lockSkewingY) {
                return false;
              }
              if (currentSkew === 0) {
                var localPointFromCenter = getLocalPoint(transform2, CENTER, CENTER, x, y);
                if (localPointFromCenter.y > 0) {
                  originY = TOP;
                } else {
                  originY = BOTTOM;
                }
              } else {
                if (currentSkew > 0) {
                  originY = originX === LEFT ? TOP : BOTTOM;
                }
                if (currentSkew < 0) {
                  originY = originX === LEFT ? BOTTOM : TOP;
                }
                if (targetHasOneFlip(target)) {
                  originY = originY === TOP ? BOTTOM : TOP;
                }
              }
              transform2.originY = originY;
              var finalHandler = wrapWithFireEvent("skewing", wrapWithFixedAnchor(skewObjectY));
              return finalHandler(eventData, transform2, x, y);
            }
            function rotationWithSnapping(eventData, transform2, x, y) {
              var t = transform2, target = t.target, pivotPoint = target.translateToOriginPoint(target.getCenterPoint(), t.originX, t.originY);
              if (target.lockRotation) {
                return false;
              }
              var lastAngle = Math.atan2(t.ey - pivotPoint.y, t.ex - pivotPoint.x), curAngle = Math.atan2(y - pivotPoint.y, x - pivotPoint.x), angle2 = radiansToDegrees(curAngle - lastAngle + t.theta), hasRotated = true;
              if (target.snapAngle > 0) {
                var snapAngle = target.snapAngle, snapThreshold = target.snapThreshold || snapAngle, rightAngleLocked = Math.ceil(angle2 / snapAngle) * snapAngle, leftAngleLocked = Math.floor(angle2 / snapAngle) * snapAngle;
                if (Math.abs(angle2 - leftAngleLocked) < snapThreshold) {
                  angle2 = leftAngleLocked;
                } else if (Math.abs(angle2 - rightAngleLocked) < snapThreshold) {
                  angle2 = rightAngleLocked;
                }
              }
              if (angle2 < 0) {
                angle2 = 360 + angle2;
              }
              angle2 %= 360;
              hasRotated = target.angle !== angle2;
              target.angle = angle2;
              return hasRotated;
            }
            function scaleObject(eventData, transform2, x, y, options) {
              options = options || {};
              var target = transform2.target, lockScalingX = target.lockScalingX, lockScalingY = target.lockScalingY, by = options.by, newPoint, scaleX, scaleY, dim, scaleProportionally = scaleIsProportional(eventData, target), forbidScaling = scalingIsForbidden(target, by, scaleProportionally), signX, signY, gestureScale = transform2.gestureScale;
              if (forbidScaling) {
                return false;
              }
              if (gestureScale) {
                scaleX = transform2.scaleX * gestureScale;
                scaleY = transform2.scaleY * gestureScale;
              } else {
                newPoint = getLocalPoint(transform2, transform2.originX, transform2.originY, x, y);
                signX = by !== "y" ? sign2(newPoint.x) : 1;
                signY = by !== "x" ? sign2(newPoint.y) : 1;
                if (!transform2.signX) {
                  transform2.signX = signX;
                }
                if (!transform2.signY) {
                  transform2.signY = signY;
                }
                if (target.lockScalingFlip && (transform2.signX !== signX || transform2.signY !== signY)) {
                  return false;
                }
                dim = target._getTransformedDimensions();
                if (scaleProportionally && !by) {
                  var distance2 = Math.abs(newPoint.x) + Math.abs(newPoint.y), original = transform2.original, originalDistance = Math.abs(dim.x * original.scaleX / target.scaleX) + Math.abs(dim.y * original.scaleY / target.scaleY), scale = distance2 / originalDistance;
                  scaleX = original.scaleX * scale;
                  scaleY = original.scaleY * scale;
                } else {
                  scaleX = Math.abs(newPoint.x * target.scaleX / dim.x);
                  scaleY = Math.abs(newPoint.y * target.scaleY / dim.y);
                }
                if (isTransformCentered(transform2)) {
                  scaleX *= 2;
                  scaleY *= 2;
                }
                if (transform2.signX !== signX && by !== "y") {
                  transform2.originX = opposite[transform2.originX];
                  scaleX *= -1;
                  transform2.signX = signX;
                }
                if (transform2.signY !== signY && by !== "x") {
                  transform2.originY = opposite[transform2.originY];
                  scaleY *= -1;
                  transform2.signY = signY;
                }
              }
              var oldScaleX = target.scaleX, oldScaleY = target.scaleY;
              if (!by) {
                !lockScalingX && target.set("scaleX", scaleX);
                !lockScalingY && target.set("scaleY", scaleY);
              } else {
                by === "x" && target.set("scaleX", scaleX);
                by === "y" && target.set("scaleY", scaleY);
              }
              return oldScaleX !== target.scaleX || oldScaleY !== target.scaleY;
            }
            function scaleObjectFromCorner(eventData, transform2, x, y) {
              return scaleObject(eventData, transform2, x, y);
            }
            function scaleObjectX(eventData, transform2, x, y) {
              return scaleObject(eventData, transform2, x, y, { by: "x" });
            }
            function scaleObjectY(eventData, transform2, x, y) {
              return scaleObject(eventData, transform2, x, y, { by: "y" });
            }
            function scalingYOrSkewingX(eventData, transform2, x, y) {
              if (eventData[transform2.target.canvas.altActionKey]) {
                return controls.skewHandlerX(eventData, transform2, x, y);
              }
              return controls.scalingY(eventData, transform2, x, y);
            }
            function scalingXOrSkewingY(eventData, transform2, x, y) {
              if (eventData[transform2.target.canvas.altActionKey]) {
                return controls.skewHandlerY(eventData, transform2, x, y);
              }
              return controls.scalingX(eventData, transform2, x, y);
            }
            function changeWidth(eventData, transform2, x, y) {
              var target = transform2.target, localPoint = getLocalPoint(transform2, transform2.originX, transform2.originY, x, y), strokePadding = target.strokeWidth / (target.strokeUniform ? target.scaleX : 1), multiplier = isTransformCentered(transform2) ? 2 : 1, oldWidth = target.width, newWidth = Math.abs(localPoint.x * multiplier / target.scaleX) - strokePadding;
              target.set("width", Math.max(newWidth, 0));
              return oldWidth !== newWidth;
            }
            function dragHandler(eventData, transform2, x, y) {
              var target = transform2.target, newLeft = x - transform2.offsetX, newTop = y - transform2.offsetY, moveX = !target.get("lockMovementX") && target.left !== newLeft, moveY = !target.get("lockMovementY") && target.top !== newTop;
              moveX && target.set("left", newLeft);
              moveY && target.set("top", newTop);
              if (moveX || moveY) {
                fireEvent("moving", commonEventInfo(eventData, transform2, x, y));
              }
              return moveX || moveY;
            }
            controls.scaleCursorStyleHandler = scaleCursorStyleHandler;
            controls.skewCursorStyleHandler = skewCursorStyleHandler;
            controls.scaleSkewCursorStyleHandler = scaleSkewCursorStyleHandler;
            controls.rotationWithSnapping = wrapWithFireEvent("rotating", wrapWithFixedAnchor(rotationWithSnapping));
            controls.scalingEqually = wrapWithFireEvent("scaling", wrapWithFixedAnchor(scaleObjectFromCorner));
            controls.scalingX = wrapWithFireEvent("scaling", wrapWithFixedAnchor(scaleObjectX));
            controls.scalingY = wrapWithFireEvent("scaling", wrapWithFixedAnchor(scaleObjectY));
            controls.scalingYOrSkewingX = scalingYOrSkewingX;
            controls.scalingXOrSkewingY = scalingXOrSkewingY;
            controls.changeWidth = wrapWithFireEvent("resizing", wrapWithFixedAnchor(changeWidth));
            controls.skewHandlerX = skewHandlerX;
            controls.skewHandlerY = skewHandlerY;
            controls.dragHandler = dragHandler;
            controls.scaleOrSkewActionName = scaleOrSkewActionName;
            controls.rotationStyleHandler = rotationStyleHandler;
            controls.fireEvent = fireEvent;
            controls.wrapWithFixedAnchor = wrapWithFixedAnchor;
            controls.wrapWithFireEvent = wrapWithFireEvent;
            controls.getLocalPoint = getLocalPoint;
            fabric2.controlsUtils = controls;
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), degreesToRadians = fabric2.util.degreesToRadians, controls = fabric2.controlsUtils;
            function renderCircleControl(ctx, left, top, styleOverride, fabricObject) {
              styleOverride = styleOverride || {};
              var xSize = this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize, ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize, transparentCorners = typeof styleOverride.transparentCorners !== "undefined" ? styleOverride.transparentCorners : fabricObject.transparentCorners, methodName = transparentCorners ? "stroke" : "fill", stroke = !transparentCorners && (styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor), myLeft = left, myTop = top, size;
              ctx.save();
              ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor;
              ctx.strokeStyle = styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor;
              if (xSize > ySize) {
                size = xSize;
                ctx.scale(1, ySize / xSize);
                myTop = top * xSize / ySize;
              } else if (ySize > xSize) {
                size = ySize;
                ctx.scale(xSize / ySize, 1);
                myLeft = left * ySize / xSize;
              } else {
                size = xSize;
              }
              ctx.lineWidth = 1;
              ctx.beginPath();
              ctx.arc(myLeft, myTop, size / 2, 0, 2 * Math.PI, false);
              ctx[methodName]();
              if (stroke) {
                ctx.stroke();
              }
              ctx.restore();
            }
            function renderSquareControl(ctx, left, top, styleOverride, fabricObject) {
              styleOverride = styleOverride || {};
              var xSize = this.sizeX || styleOverride.cornerSize || fabricObject.cornerSize, ySize = this.sizeY || styleOverride.cornerSize || fabricObject.cornerSize, transparentCorners = typeof styleOverride.transparentCorners !== "undefined" ? styleOverride.transparentCorners : fabricObject.transparentCorners, methodName = transparentCorners ? "stroke" : "fill", stroke = !transparentCorners && (styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor), xSizeBy2 = xSize / 2, ySizeBy2 = ySize / 2;
              ctx.save();
              ctx.fillStyle = styleOverride.cornerColor || fabricObject.cornerColor;
              ctx.strokeStyle = styleOverride.cornerStrokeColor || fabricObject.cornerStrokeColor;
              ctx.lineWidth = 1;
              ctx.translate(left, top);
              ctx.rotate(degreesToRadians(fabricObject.angle));
              ctx[methodName + "Rect"](-xSizeBy2, -ySizeBy2, xSize, ySize);
              if (stroke) {
                ctx.strokeRect(-xSizeBy2, -ySizeBy2, xSize, ySize);
              }
              ctx.restore();
            }
            controls.renderCircleControl = renderCircleControl;
            controls.renderSquareControl = renderSquareControl;
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {});
            function Control2(options) {
              for (var i in options) {
                this[i] = options[i];
              }
            }
            fabric2.Control = Control2;
            fabric2.Control.prototype = {
              visible: true,
              actionName: "scale",
              angle: 0,
              x: 0,
              y: 0,
              offsetX: 0,
              offsetY: 0,
              sizeX: null,
              sizeY: null,
              touchSizeX: null,
              touchSizeY: null,
              cursorStyle: "crosshair",
              withConnection: false,
              actionHandler: function() {
              },
              mouseDownHandler: function() {
              },
              mouseUpHandler: function() {
              },
              getActionHandler: function() {
                return this.actionHandler;
              },
              getMouseDownHandler: function() {
                return this.mouseDownHandler;
              },
              getMouseUpHandler: function() {
                return this.mouseUpHandler;
              },
              cursorStyleHandler: function(eventData, control) {
                return control.cursorStyle;
              },
              getActionName: function(eventData, control) {
                return control.actionName;
              },
              getVisibility: function(fabricObject, controlKey) {
                var objectVisibility = fabricObject._controlsVisibility;
                if (objectVisibility && typeof objectVisibility[controlKey] !== "undefined") {
                  return objectVisibility[controlKey];
                }
                return this.visible;
              },
              setVisibility: function(visibility2) {
                this.visible = visibility2;
              },
              positionHandler: function(dim, finalMatrix) {
                var point = fabric2.util.transformPoint({
                  x: this.x * dim.x + this.offsetX,
                  y: this.y * dim.y + this.offsetY
                }, finalMatrix);
                return point;
              },
              calcCornerCoords: function(objectAngle, objectCornerSize, centerX, centerY, isTouch) {
                var cosHalfOffset, sinHalfOffset, cosHalfOffsetComp, sinHalfOffsetComp, xSize = isTouch ? this.touchSizeX : this.sizeX, ySize = isTouch ? this.touchSizeY : this.sizeY;
                if (xSize && ySize && xSize !== ySize) {
                  var controlTriangleAngle = Math.atan2(ySize, xSize);
                  var cornerHypotenuse = Math.sqrt(xSize * xSize + ySize * ySize) / 2;
                  var newTheta = controlTriangleAngle - fabric2.util.degreesToRadians(objectAngle);
                  var newThetaComp = Math.PI / 2 - controlTriangleAngle - fabric2.util.degreesToRadians(objectAngle);
                  cosHalfOffset = cornerHypotenuse * fabric2.util.cos(newTheta);
                  sinHalfOffset = cornerHypotenuse * fabric2.util.sin(newTheta);
                  cosHalfOffsetComp = cornerHypotenuse * fabric2.util.cos(newThetaComp);
                  sinHalfOffsetComp = cornerHypotenuse * fabric2.util.sin(newThetaComp);
                } else {
                  var cornerSize = xSize && ySize ? xSize : objectCornerSize;
                  cornerHypotenuse = cornerSize * 0.7071067812;
                  var newTheta = fabric2.util.degreesToRadians(45 - objectAngle);
                  cosHalfOffset = cosHalfOffsetComp = cornerHypotenuse * fabric2.util.cos(newTheta);
                  sinHalfOffset = sinHalfOffsetComp = cornerHypotenuse * fabric2.util.sin(newTheta);
                }
                return {
                  tl: {
                    x: centerX - sinHalfOffsetComp,
                    y: centerY - cosHalfOffsetComp
                  },
                  tr: {
                    x: centerX + cosHalfOffset,
                    y: centerY - sinHalfOffset
                  },
                  bl: {
                    x: centerX - cosHalfOffset,
                    y: centerY + sinHalfOffset
                  },
                  br: {
                    x: centerX + sinHalfOffsetComp,
                    y: centerY + cosHalfOffsetComp
                  }
                };
              },
              render: function(ctx, left, top, styleOverride, fabricObject) {
                styleOverride = styleOverride || {};
                switch (styleOverride.cornerStyle || fabricObject.cornerStyle) {
                  case "circle":
                    fabric2.controlsUtils.renderCircleControl.call(this, ctx, left, top, styleOverride, fabricObject);
                    break;
                  default:
                    fabric2.controlsUtils.renderSquareControl.call(this, ctx, left, top, styleOverride, fabricObject);
                }
              }
            };
          })(exports2);
          (function() {
            function getColorStop(el, multiplier) {
              var style = el.getAttribute("style"), offset = el.getAttribute("offset") || 0, color2, colorAlpha, opacity2, i;
              offset = parseFloat(offset) / (/%$/.test(offset) ? 100 : 1);
              offset = offset < 0 ? 0 : offset > 1 ? 1 : offset;
              if (style) {
                var keyValuePairs = style.split(/\s*;\s*/);
                if (keyValuePairs[keyValuePairs.length - 1] === "") {
                  keyValuePairs.pop();
                }
                for (i = keyValuePairs.length; i--; ) {
                  var split = keyValuePairs[i].split(/\s*:\s*/), key = split[0].trim(), value = split[1].trim();
                  if (key === "stop-color") {
                    color2 = value;
                  } else if (key === "stop-opacity") {
                    opacity2 = value;
                  }
                }
              }
              if (!color2) {
                color2 = el.getAttribute("stop-color") || "rgb(0,0,0)";
              }
              if (!opacity2) {
                opacity2 = el.getAttribute("stop-opacity");
              }
              color2 = new fabric.Color(color2);
              colorAlpha = color2.getAlpha();
              opacity2 = isNaN(parseFloat(opacity2)) ? 1 : parseFloat(opacity2);
              opacity2 *= colorAlpha * multiplier;
              return {
                offset,
                color: color2.toRgb(),
                opacity: opacity2
              };
            }
            function getLinearCoords(el) {
              return {
                x1: el.getAttribute("x1") || 0,
                y1: el.getAttribute("y1") || 0,
                x2: el.getAttribute("x2") || "100%",
                y2: el.getAttribute("y2") || 0
              };
            }
            function getRadialCoords(el) {
              return {
                x1: el.getAttribute("fx") || el.getAttribute("cx") || "50%",
                y1: el.getAttribute("fy") || el.getAttribute("cy") || "50%",
                r1: 0,
                x2: el.getAttribute("cx") || "50%",
                y2: el.getAttribute("cy") || "50%",
                r2: el.getAttribute("r") || "50%"
              };
            }
            var clone2 = fabric.util.object.clone;
            fabric.Gradient = fabric.util.createClass({
              offsetX: 0,
              offsetY: 0,
              gradientTransform: null,
              gradientUnits: "pixels",
              type: "linear",
              initialize: function(options) {
                options || (options = {});
                options.coords || (options.coords = {});
                var coords, _this = this;
                Object.keys(options).forEach(function(option2) {
                  _this[option2] = options[option2];
                });
                if (this.id) {
                  this.id += "_" + fabric.Object.__uid++;
                } else {
                  this.id = fabric.Object.__uid++;
                }
                coords = {
                  x1: options.coords.x1 || 0,
                  y1: options.coords.y1 || 0,
                  x2: options.coords.x2 || 0,
                  y2: options.coords.y2 || 0
                };
                if (this.type === "radial") {
                  coords.r1 = options.coords.r1 || 0;
                  coords.r2 = options.coords.r2 || 0;
                }
                this.coords = coords;
                this.colorStops = options.colorStops.slice();
              },
              addColorStop: function(colorStops) {
                for (var position2 in colorStops) {
                  var color2 = new fabric.Color(colorStops[position2]);
                  this.colorStops.push({
                    offset: parseFloat(position2),
                    color: color2.toRgb(),
                    opacity: color2.getAlpha()
                  });
                }
                return this;
              },
              toObject: function(propertiesToInclude) {
                var object = {
                  type: this.type,
                  coords: this.coords,
                  colorStops: this.colorStops,
                  offsetX: this.offsetX,
                  offsetY: this.offsetY,
                  gradientUnits: this.gradientUnits,
                  gradientTransform: this.gradientTransform ? this.gradientTransform.concat() : this.gradientTransform
                };
                fabric.util.populateWithProperties(this, object, propertiesToInclude);
                return object;
              },
              toSVG: function(object, options) {
                var coords = clone2(this.coords, true), i, len, options = options || {}, markup, commonAttributes, colorStops = clone2(this.colorStops, true), needsSwap = coords.r1 > coords.r2, transform2 = this.gradientTransform ? this.gradientTransform.concat() : fabric.iMatrix.concat(), offsetX = -this.offsetX, offsetY = -this.offsetY, withViewport = !!options.additionalTransform, gradientUnits = this.gradientUnits === "pixels" ? "userSpaceOnUse" : "objectBoundingBox";
                colorStops.sort(function(a2, b) {
                  return a2.offset - b.offset;
                });
                if (gradientUnits === "objectBoundingBox") {
                  offsetX /= object.width;
                  offsetY /= object.height;
                } else {
                  offsetX += object.width / 2;
                  offsetY += object.height / 2;
                }
                if (object.type === "path" && this.gradientUnits !== "percentage") {
                  offsetX -= object.pathOffset.x;
                  offsetY -= object.pathOffset.y;
                }
                transform2[4] -= offsetX;
                transform2[5] -= offsetY;
                commonAttributes = 'id="SVGID_' + this.id + '" gradientUnits="' + gradientUnits + '"';
                commonAttributes += ' gradientTransform="' + (withViewport ? options.additionalTransform + " " : "") + fabric.util.matrixToSVG(transform2) + '" ';
                if (this.type === "linear") {
                  markup = [
                    "<linearGradient ",
                    commonAttributes,
                    ' x1="',
                    coords.x1,
                    '" y1="',
                    coords.y1,
                    '" x2="',
                    coords.x2,
                    '" y2="',
                    coords.y2,
                    '">\n'
                  ];
                } else if (this.type === "radial") {
                  markup = [
                    "<radialGradient ",
                    commonAttributes,
                    ' cx="',
                    needsSwap ? coords.x1 : coords.x2,
                    '" cy="',
                    needsSwap ? coords.y1 : coords.y2,
                    '" r="',
                    needsSwap ? coords.r1 : coords.r2,
                    '" fx="',
                    needsSwap ? coords.x2 : coords.x1,
                    '" fy="',
                    needsSwap ? coords.y2 : coords.y1,
                    '">\n'
                  ];
                }
                if (this.type === "radial") {
                  if (needsSwap) {
                    colorStops = colorStops.concat();
                    colorStops.reverse();
                    for (i = 0, len = colorStops.length; i < len; i++) {
                      colorStops[i].offset = 1 - colorStops[i].offset;
                    }
                  }
                  var minRadius = Math.min(coords.r1, coords.r2);
                  if (minRadius > 0) {
                    var maxRadius = Math.max(coords.r1, coords.r2), percentageShift = minRadius / maxRadius;
                    for (i = 0, len = colorStops.length; i < len; i++) {
                      colorStops[i].offset += percentageShift * (1 - colorStops[i].offset);
                    }
                  }
                }
                for (i = 0, len = colorStops.length; i < len; i++) {
                  var colorStop = colorStops[i];
                  markup.push(
                    "<stop ",
                    'offset="',
                    colorStop.offset * 100 + "%",
                    '" style="stop-color:',
                    colorStop.color,
                    typeof colorStop.opacity !== "undefined" ? ";stop-opacity: " + colorStop.opacity : ";",
                    '"/>\n'
                  );
                }
                markup.push(this.type === "linear" ? "</linearGradient>\n" : "</radialGradient>\n");
                return markup.join("");
              },
              toLive: function(ctx) {
                var gradient, coords = fabric.util.object.clone(this.coords), i, len;
                if (!this.type) {
                  return;
                }
                if (this.type === "linear") {
                  gradient = ctx.createLinearGradient(
                    coords.x1,
                    coords.y1,
                    coords.x2,
                    coords.y2
                  );
                } else if (this.type === "radial") {
                  gradient = ctx.createRadialGradient(
                    coords.x1,
                    coords.y1,
                    coords.r1,
                    coords.x2,
                    coords.y2,
                    coords.r2
                  );
                }
                for (i = 0, len = this.colorStops.length; i < len; i++) {
                  var color2 = this.colorStops[i].color, opacity2 = this.colorStops[i].opacity, offset = this.colorStops[i].offset;
                  if (typeof opacity2 !== "undefined") {
                    color2 = new fabric.Color(color2).setAlpha(opacity2).toRgba();
                  }
                  gradient.addColorStop(offset, color2);
                }
                return gradient;
              }
            });
            fabric.util.object.extend(fabric.Gradient, {
              fromElement: function(el, instance, opacityAttr, svgOptions) {
                var multiplier = parseFloat(opacityAttr) / (/%$/.test(opacityAttr) ? 100 : 1);
                multiplier = multiplier < 0 ? 0 : multiplier > 1 ? 1 : multiplier;
                if (isNaN(multiplier)) {
                  multiplier = 1;
                }
                var colorStopEls = el.getElementsByTagName("stop"), type, gradientUnits = el.getAttribute("gradientUnits") === "userSpaceOnUse" ? "pixels" : "percentage", gradientTransform = el.getAttribute("gradientTransform") || "", colorStops = [], coords, i, offsetX = 0, offsetY = 0, transformMatrix;
                if (el.nodeName === "linearGradient" || el.nodeName === "LINEARGRADIENT") {
                  type = "linear";
                  coords = getLinearCoords(el);
                } else {
                  type = "radial";
                  coords = getRadialCoords(el);
                }
                for (i = colorStopEls.length; i--; ) {
                  colorStops.push(getColorStop(colorStopEls[i], multiplier));
                }
                transformMatrix = fabric.parseTransformAttribute(gradientTransform);
                __convertPercentUnitsToValues(instance, coords, svgOptions, gradientUnits);
                if (gradientUnits === "pixels") {
                  offsetX = -instance.left;
                  offsetY = -instance.top;
                }
                var gradient = new fabric.Gradient({
                  id: el.getAttribute("id"),
                  type,
                  coords,
                  colorStops,
                  gradientUnits,
                  gradientTransform: transformMatrix,
                  offsetX,
                  offsetY
                });
                return gradient;
              }
            });
            function __convertPercentUnitsToValues(instance, options, svgOptions, gradientUnits) {
              var propValue, finalValue;
              Object.keys(options).forEach(function(prop) {
                propValue = options[prop];
                if (propValue === "Infinity") {
                  finalValue = 1;
                } else if (propValue === "-Infinity") {
                  finalValue = 0;
                } else {
                  finalValue = parseFloat(options[prop], 10);
                  if (typeof propValue === "string" && /^(\d+\.\d+)%|(\d+)%$/.test(propValue)) {
                    finalValue *= 0.01;
                    if (gradientUnits === "pixels") {
                      if (prop === "x1" || prop === "x2" || prop === "r2") {
                        finalValue *= svgOptions.viewBoxWidth || svgOptions.width;
                      }
                      if (prop === "y1" || prop === "y2") {
                        finalValue *= svgOptions.viewBoxHeight || svgOptions.height;
                      }
                    }
                  }
                }
                options[prop] = finalValue;
              });
            }
          })();
          (function() {
            var toFixed2 = fabric.util.toFixed;
            fabric.Pattern = fabric.util.createClass({
              repeat: "repeat",
              offsetX: 0,
              offsetY: 0,
              crossOrigin: "",
              patternTransform: null,
              initialize: function(options, callback) {
                options || (options = {});
                this.id = fabric.Object.__uid++;
                this.setOptions(options);
                if (!options.source || options.source && typeof options.source !== "string") {
                  callback && callback(this);
                  return;
                } else {
                  var _this = this;
                  this.source = fabric.util.createImage();
                  fabric.util.loadImage(options.source, function(img, isError) {
                    _this.source = img;
                    callback && callback(_this, isError);
                  }, null, this.crossOrigin);
                }
              },
              toObject: function(propertiesToInclude) {
                var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS, source2, object;
                if (typeof this.source.src === "string") {
                  source2 = this.source.src;
                } else if (typeof this.source === "object" && this.source.toDataURL) {
                  source2 = this.source.toDataURL();
                }
                object = {
                  type: "pattern",
                  source: source2,
                  repeat: this.repeat,
                  crossOrigin: this.crossOrigin,
                  offsetX: toFixed2(this.offsetX, NUM_FRACTION_DIGITS),
                  offsetY: toFixed2(this.offsetY, NUM_FRACTION_DIGITS),
                  patternTransform: this.patternTransform ? this.patternTransform.concat() : null
                };
                fabric.util.populateWithProperties(this, object, propertiesToInclude);
                return object;
              },
              toSVG: function(object) {
                var patternSource = typeof this.source === "function" ? this.source() : this.source, patternWidth = patternSource.width / object.width, patternHeight = patternSource.height / object.height, patternOffsetX = this.offsetX / object.width, patternOffsetY = this.offsetY / object.height, patternImgSrc = "";
                if (this.repeat === "repeat-x" || this.repeat === "no-repeat") {
                  patternHeight = 1;
                  if (patternOffsetY) {
                    patternHeight += Math.abs(patternOffsetY);
                  }
                }
                if (this.repeat === "repeat-y" || this.repeat === "no-repeat") {
                  patternWidth = 1;
                  if (patternOffsetX) {
                    patternWidth += Math.abs(patternOffsetX);
                  }
                }
                if (patternSource.src) {
                  patternImgSrc = patternSource.src;
                } else if (patternSource.toDataURL) {
                  patternImgSrc = patternSource.toDataURL();
                }
                return '<pattern id="SVGID_' + this.id + '" x="' + patternOffsetX + '" y="' + patternOffsetY + '" width="' + patternWidth + '" height="' + patternHeight + '">\n<image x="0" y="0" width="' + patternSource.width + '" height="' + patternSource.height + '" xlink:href="' + patternImgSrc + '"></image>\n</pattern>\n';
              },
              setOptions: function(options) {
                for (var prop in options) {
                  this[prop] = options[prop];
                }
              },
              toLive: function(ctx) {
                var source2 = this.source;
                if (!source2) {
                  return "";
                }
                if (typeof source2.src !== "undefined") {
                  if (!source2.complete) {
                    return "";
                  }
                  if (source2.naturalWidth === 0 || source2.naturalHeight === 0) {
                    return "";
                  }
                }
                return ctx.createPattern(source2, this.repeat);
              }
            });
          })();
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), toFixed2 = fabric2.util.toFixed;
            if (fabric2.Shadow) {
              fabric2.warn("fabric.Shadow is already defined.");
              return;
            }
            fabric2.Shadow = fabric2.util.createClass({
              color: "rgb(0,0,0)",
              blur: 0,
              offsetX: 0,
              offsetY: 0,
              affectStroke: false,
              includeDefaultValues: true,
              nonScaling: false,
              initialize: function(options) {
                if (typeof options === "string") {
                  options = this._parseShadow(options);
                }
                for (var prop in options) {
                  this[prop] = options[prop];
                }
                this.id = fabric2.Object.__uid++;
              },
              _parseShadow: function(shadow) {
                var shadowStr = shadow.trim(), offsetsAndBlur = fabric2.Shadow.reOffsetsAndBlur.exec(shadowStr) || [], color2 = shadowStr.replace(fabric2.Shadow.reOffsetsAndBlur, "") || "rgb(0,0,0)";
                return {
                  color: color2.trim(),
                  offsetX: parseFloat(offsetsAndBlur[1], 10) || 0,
                  offsetY: parseFloat(offsetsAndBlur[2], 10) || 0,
                  blur: parseFloat(offsetsAndBlur[3], 10) || 0
                };
              },
              toString: function() {
                return [this.offsetX, this.offsetY, this.blur, this.color].join("px ");
              },
              toSVG: function(object) {
                var fBoxX = 40, fBoxY = 40, NUM_FRACTION_DIGITS = fabric2.Object.NUM_FRACTION_DIGITS, offset = fabric2.util.rotateVector(
                  { x: this.offsetX, y: this.offsetY },
                  fabric2.util.degreesToRadians(-object.angle)
                ), BLUR_BOX = 20, color2 = new fabric2.Color(this.color);
                if (object.width && object.height) {
                  fBoxX = toFixed2((Math.abs(offset.x) + this.blur) / object.width, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
                  fBoxY = toFixed2((Math.abs(offset.y) + this.blur) / object.height, NUM_FRACTION_DIGITS) * 100 + BLUR_BOX;
                }
                if (object.flipX) {
                  offset.x *= -1;
                }
                if (object.flipY) {
                  offset.y *= -1;
                }
                return '<filter id="SVGID_' + this.id + '" y="-' + fBoxY + '%" height="' + (100 + 2 * fBoxY) + '%" x="-' + fBoxX + '%" width="' + (100 + 2 * fBoxX) + '%" >\n	<feGaussianBlur in="SourceAlpha" stdDeviation="' + toFixed2(this.blur ? this.blur / 2 : 0, NUM_FRACTION_DIGITS) + '"></feGaussianBlur>\n	<feOffset dx="' + toFixed2(offset.x, NUM_FRACTION_DIGITS) + '" dy="' + toFixed2(offset.y, NUM_FRACTION_DIGITS) + '" result="oBlur" ></feOffset>\n	<feFlood flood-color="' + color2.toRgb() + '" flood-opacity="' + color2.getAlpha() + '"/>\n	<feComposite in2="oBlur" operator="in" />\n	<feMerge>\n		<feMergeNode></feMergeNode>\n		<feMergeNode in="SourceGraphic"></feMergeNode>\n	</feMerge>\n</filter>\n';
              },
              toObject: function() {
                if (this.includeDefaultValues) {
                  return {
                    color: this.color,
                    blur: this.blur,
                    offsetX: this.offsetX,
                    offsetY: this.offsetY,
                    affectStroke: this.affectStroke,
                    nonScaling: this.nonScaling
                  };
                }
                var obj = {}, proto = fabric2.Shadow.prototype;
                ["color", "blur", "offsetX", "offsetY", "affectStroke", "nonScaling"].forEach(function(prop) {
                  if (this[prop] !== proto[prop]) {
                    obj[prop] = this[prop];
                  }
                }, this);
                return obj;
              }
            });
            fabric2.Shadow.reOffsetsAndBlur = /(?:\s|^)(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(-?\d+(?:\.\d*)?(?:px)?(?:\s?|$))?(\d+(?:\.\d*)?(?:px)?)?(?:\s?|$)(?:$|\s)/;
          })(exports2);
          (function() {
            if (fabric.StaticCanvas) {
              fabric.warn("fabric.StaticCanvas is already defined.");
              return;
            }
            var extend2 = fabric.util.object.extend, getElementOffset = fabric.util.getElementOffset, removeFromArray = fabric.util.removeFromArray, toFixed2 = fabric.util.toFixed, transformPoint = fabric.util.transformPoint, invertTransform = fabric.util.invertTransform, getNodeCanvas = fabric.util.getNodeCanvas, createCanvasElement = fabric.util.createCanvasElement, CANVAS_INIT_ERROR = new Error("Could not initialize `canvas` element");
            fabric.StaticCanvas = fabric.util.createClass(fabric.CommonMethods, {
              initialize: function(el, options) {
                options || (options = {});
                this.renderAndResetBound = this.renderAndReset.bind(this);
                this.requestRenderAllBound = this.requestRenderAll.bind(this);
                this._initStatic(el, options);
              },
              backgroundColor: "",
              backgroundImage: null,
              overlayColor: "",
              overlayImage: null,
              includeDefaultValues: true,
              stateful: false,
              renderOnAddRemove: true,
              controlsAboveOverlay: false,
              allowTouchScrolling: false,
              imageSmoothingEnabled: true,
              viewportTransform: fabric.iMatrix.concat(),
              backgroundVpt: true,
              overlayVpt: true,
              enableRetinaScaling: true,
              vptCoords: {},
              skipOffscreen: true,
              clipPath: void 0,
              _initStatic: function(el, options) {
                var cb = this.requestRenderAllBound;
                this._objects = [];
                this._createLowerCanvas(el);
                this._initOptions(options);
                if (!this.interactive) {
                  this._initRetinaScaling();
                }
                if (options.overlayImage) {
                  this.setOverlayImage(options.overlayImage, cb);
                }
                if (options.backgroundImage) {
                  this.setBackgroundImage(options.backgroundImage, cb);
                }
                if (options.backgroundColor) {
                  this.setBackgroundColor(options.backgroundColor, cb);
                }
                if (options.overlayColor) {
                  this.setOverlayColor(options.overlayColor, cb);
                }
                this.calcOffset();
              },
              _isRetinaScaling: function() {
                return fabric.devicePixelRatio !== 1 && this.enableRetinaScaling;
              },
              getRetinaScaling: function() {
                return this._isRetinaScaling() ? fabric.devicePixelRatio : 1;
              },
              _initRetinaScaling: function() {
                if (!this._isRetinaScaling()) {
                  return;
                }
                var scaleRatio = fabric.devicePixelRatio;
                this.__initRetinaScaling(scaleRatio, this.lowerCanvasEl, this.contextContainer);
                if (this.upperCanvasEl) {
                  this.__initRetinaScaling(scaleRatio, this.upperCanvasEl, this.contextTop);
                }
              },
              __initRetinaScaling: function(scaleRatio, canvas, context) {
                canvas.setAttribute("width", this.width * scaleRatio);
                canvas.setAttribute("height", this.height * scaleRatio);
                context.scale(scaleRatio, scaleRatio);
              },
              calcOffset: function() {
                this._offset = getElementOffset(this.lowerCanvasEl);
                return this;
              },
              setOverlayImage: function(image2, callback, options) {
                return this.__setBgOverlayImage("overlayImage", image2, callback, options);
              },
              setBackgroundImage: function(image2, callback, options) {
                return this.__setBgOverlayImage("backgroundImage", image2, callback, options);
              },
              setOverlayColor: function(overlayColor, callback) {
                return this.__setBgOverlayColor("overlayColor", overlayColor, callback);
              },
              setBackgroundColor: function(backgroundColor2, callback) {
                return this.__setBgOverlayColor("backgroundColor", backgroundColor2, callback);
              },
              __setBgOverlayImage: function(property, image2, callback, options) {
                if (typeof image2 === "string") {
                  fabric.util.loadImage(image2, function(img, isError) {
                    if (img) {
                      var instance = new fabric.Image(img, options);
                      this[property] = instance;
                      instance.canvas = this;
                    }
                    callback && callback(img, isError);
                  }, this, options && options.crossOrigin);
                } else {
                  options && image2.setOptions(options);
                  this[property] = image2;
                  image2 && (image2.canvas = this);
                  callback && callback(image2, false);
                }
                return this;
              },
              __setBgOverlayColor: function(property, color2, callback) {
                this[property] = color2;
                this._initGradient(color2, property);
                this._initPattern(color2, property, callback);
                return this;
              },
              _createCanvasElement: function() {
                var element = createCanvasElement();
                if (!element) {
                  throw CANVAS_INIT_ERROR;
                }
                if (!element.style) {
                  element.style = {};
                }
                if (typeof element.getContext === "undefined") {
                  throw CANVAS_INIT_ERROR;
                }
                return element;
              },
              _initOptions: function(options) {
                var lowerCanvasEl = this.lowerCanvasEl;
                this._setOptions(options);
                this.width = this.width || parseInt(lowerCanvasEl.width, 10) || 0;
                this.height = this.height || parseInt(lowerCanvasEl.height, 10) || 0;
                if (!this.lowerCanvasEl.style) {
                  return;
                }
                lowerCanvasEl.width = this.width;
                lowerCanvasEl.height = this.height;
                lowerCanvasEl.style.width = this.width + "px";
                lowerCanvasEl.style.height = this.height + "px";
                this.viewportTransform = this.viewportTransform.slice();
              },
              _createLowerCanvas: function(canvasEl) {
                if (canvasEl && canvasEl.getContext) {
                  this.lowerCanvasEl = canvasEl;
                } else {
                  this.lowerCanvasEl = fabric.util.getById(canvasEl) || this._createCanvasElement();
                }
                fabric.util.addClass(this.lowerCanvasEl, "lower-canvas");
                this._originalCanvasStyle = this.lowerCanvasEl.style;
                if (this.interactive) {
                  this._applyCanvasStyle(this.lowerCanvasEl);
                }
                this.contextContainer = this.lowerCanvasEl.getContext("2d");
              },
              getWidth: function() {
                return this.width;
              },
              getHeight: function() {
                return this.height;
              },
              setWidth: function(value, options) {
                return this.setDimensions({ width: value }, options);
              },
              setHeight: function(value, options) {
                return this.setDimensions({ height: value }, options);
              },
              setDimensions: function(dimensions, options) {
                var cssValue;
                options = options || {};
                for (var prop in dimensions) {
                  cssValue = dimensions[prop];
                  if (!options.cssOnly) {
                    this._setBackstoreDimension(prop, dimensions[prop]);
                    cssValue += "px";
                    this.hasLostContext = true;
                  }
                  if (!options.backstoreOnly) {
                    this._setCssDimension(prop, cssValue);
                  }
                }
                if (this._isCurrentlyDrawing) {
                  this.freeDrawingBrush && this.freeDrawingBrush._setBrushStyles();
                }
                this._initRetinaScaling();
                this.calcOffset();
                if (!options.cssOnly) {
                  this.requestRenderAll();
                }
                return this;
              },
              _setBackstoreDimension: function(prop, value) {
                this.lowerCanvasEl[prop] = value;
                if (this.upperCanvasEl) {
                  this.upperCanvasEl[prop] = value;
                }
                if (this.cacheCanvasEl) {
                  this.cacheCanvasEl[prop] = value;
                }
                this[prop] = value;
                return this;
              },
              _setCssDimension: function(prop, value) {
                this.lowerCanvasEl.style[prop] = value;
                if (this.upperCanvasEl) {
                  this.upperCanvasEl.style[prop] = value;
                }
                if (this.wrapperEl) {
                  this.wrapperEl.style[prop] = value;
                }
                return this;
              },
              getZoom: function() {
                return this.viewportTransform[0];
              },
              setViewportTransform: function(vpt) {
                var activeObject = this._activeObject, backgroundObject = this.backgroundImage, overlayObject = this.overlayImage, object, i, len;
                this.viewportTransform = vpt;
                for (i = 0, len = this._objects.length; i < len; i++) {
                  object = this._objects[i];
                  object.group || object.setCoords(true);
                }
                if (activeObject) {
                  activeObject.setCoords();
                }
                if (backgroundObject) {
                  backgroundObject.setCoords(true);
                }
                if (overlayObject) {
                  overlayObject.setCoords(true);
                }
                this.calcViewportBoundaries();
                this.renderOnAddRemove && this.requestRenderAll();
                return this;
              },
              zoomToPoint: function(point, value) {
                var before = point, vpt = this.viewportTransform.slice(0);
                point = transformPoint(point, invertTransform(this.viewportTransform));
                vpt[0] = value;
                vpt[3] = value;
                var after = transformPoint(point, vpt);
                vpt[4] += before.x - after.x;
                vpt[5] += before.y - after.y;
                return this.setViewportTransform(vpt);
              },
              setZoom: function(value) {
                this.zoomToPoint(new fabric.Point(0, 0), value);
                return this;
              },
              absolutePan: function(point) {
                var vpt = this.viewportTransform.slice(0);
                vpt[4] = -point.x;
                vpt[5] = -point.y;
                return this.setViewportTransform(vpt);
              },
              relativePan: function(point) {
                return this.absolutePan(new fabric.Point(
                  -point.x - this.viewportTransform[4],
                  -point.y - this.viewportTransform[5]
                ));
              },
              getElement: function() {
                return this.lowerCanvasEl;
              },
              _onObjectAdded: function(obj) {
                this.stateful && obj.setupState();
                obj._set("canvas", this);
                obj.setCoords();
                this.fire("object:added", { target: obj });
                obj.fire("added");
              },
              _onObjectRemoved: function(obj) {
                this.fire("object:removed", { target: obj });
                obj.fire("removed");
                delete obj.canvas;
              },
              clearContext: function(ctx) {
                ctx.clearRect(0, 0, this.width, this.height);
                return this;
              },
              getContext: function() {
                return this.contextContainer;
              },
              clear: function() {
                this.remove.apply(this, this.getObjects());
                this.backgroundImage = null;
                this.overlayImage = null;
                this.backgroundColor = "";
                this.overlayColor = "";
                if (this._hasITextHandlers) {
                  this.off("mouse:up", this._mouseUpITextHandler);
                  this._iTextInstances = null;
                  this._hasITextHandlers = false;
                }
                this.clearContext(this.contextContainer);
                this.fire("canvas:cleared");
                this.renderOnAddRemove && this.requestRenderAll();
                return this;
              },
              renderAll: function() {
                var canvasToDrawOn = this.contextContainer;
                this.renderCanvas(canvasToDrawOn, this._objects);
                return this;
              },
              renderAndReset: function() {
                this.isRendering = 0;
                this.renderAll();
              },
              requestRenderAll: function() {
                if (!this.isRendering) {
                  this.isRendering = fabric.util.requestAnimFrame(this.renderAndResetBound);
                }
                return this;
              },
              calcViewportBoundaries: function() {
                var points = {}, width = this.width, height = this.height, iVpt = invertTransform(this.viewportTransform);
                points.tl = transformPoint({ x: 0, y: 0 }, iVpt);
                points.br = transformPoint({ x: width, y: height }, iVpt);
                points.tr = new fabric.Point(points.br.x, points.tl.y);
                points.bl = new fabric.Point(points.tl.x, points.br.y);
                this.vptCoords = points;
                return points;
              },
              cancelRequestedRender: function() {
                if (this.isRendering) {
                  fabric.util.cancelAnimFrame(this.isRendering);
                  this.isRendering = 0;
                }
              },
              renderCanvas: function(ctx, objects) {
                var v = this.viewportTransform, path = this.clipPath;
                this.cancelRequestedRender();
                this.calcViewportBoundaries();
                this.clearContext(ctx);
                fabric.util.setImageSmoothing(ctx, this.imageSmoothingEnabled);
                this.fire("before:render", { ctx });
                this._renderBackground(ctx);
                ctx.save();
                ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
                this._renderObjects(ctx, objects);
                ctx.restore();
                if (!this.controlsAboveOverlay && this.interactive) {
                  this.drawControls(ctx);
                }
                if (path) {
                  path.canvas = this;
                  path.shouldCache();
                  path._transformDone = true;
                  path.renderCache({ forClipping: true });
                  this.drawClipPathOnCanvas(ctx);
                }
                this._renderOverlay(ctx);
                if (this.controlsAboveOverlay && this.interactive) {
                  this.drawControls(ctx);
                }
                this.fire("after:render", { ctx });
              },
              drawClipPathOnCanvas: function(ctx) {
                var v = this.viewportTransform, path = this.clipPath;
                ctx.save();
                ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
                ctx.globalCompositeOperation = "destination-in";
                path.transform(ctx);
                ctx.scale(1 / path.zoomX, 1 / path.zoomY);
                ctx.drawImage(path._cacheCanvas, -path.cacheTranslationX, -path.cacheTranslationY);
                ctx.restore();
              },
              _renderObjects: function(ctx, objects) {
                var i, len;
                for (i = 0, len = objects.length; i < len; ++i) {
                  objects[i] && objects[i].render(ctx);
                }
              },
              _renderBackgroundOrOverlay: function(ctx, property) {
                var fill = this[property + "Color"], object = this[property + "Image"], v = this.viewportTransform, needsVpt = this[property + "Vpt"];
                if (!fill && !object) {
                  return;
                }
                if (fill) {
                  ctx.save();
                  ctx.beginPath();
                  ctx.moveTo(0, 0);
                  ctx.lineTo(this.width, 0);
                  ctx.lineTo(this.width, this.height);
                  ctx.lineTo(0, this.height);
                  ctx.closePath();
                  ctx.fillStyle = fill.toLive ? fill.toLive(ctx, this) : fill;
                  if (needsVpt) {
                    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
                  }
                  ctx.transform(1, 0, 0, 1, fill.offsetX || 0, fill.offsetY || 0);
                  var m = fill.gradientTransform || fill.patternTransform;
                  m && ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                  ctx.fill();
                  ctx.restore();
                }
                if (object) {
                  ctx.save();
                  if (needsVpt) {
                    ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
                  }
                  object.render(ctx);
                  ctx.restore();
                }
              },
              _renderBackground: function(ctx) {
                this._renderBackgroundOrOverlay(ctx, "background");
              },
              _renderOverlay: function(ctx) {
                this._renderBackgroundOrOverlay(ctx, "overlay");
              },
              getCenter: function() {
                return {
                  top: this.height / 2,
                  left: this.width / 2
                };
              },
              centerObjectH: function(object) {
                return this._centerObject(object, new fabric.Point(this.getCenter().left, object.getCenterPoint().y));
              },
              centerObjectV: function(object) {
                return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, this.getCenter().top));
              },
              centerObject: function(object) {
                var center = this.getCenter();
                return this._centerObject(object, new fabric.Point(center.left, center.top));
              },
              viewportCenterObject: function(object) {
                var vpCenter = this.getVpCenter();
                return this._centerObject(object, vpCenter);
              },
              viewportCenterObjectH: function(object) {
                var vpCenter = this.getVpCenter();
                this._centerObject(object, new fabric.Point(vpCenter.x, object.getCenterPoint().y));
                return this;
              },
              viewportCenterObjectV: function(object) {
                var vpCenter = this.getVpCenter();
                return this._centerObject(object, new fabric.Point(object.getCenterPoint().x, vpCenter.y));
              },
              getVpCenter: function() {
                var center = this.getCenter(), iVpt = invertTransform(this.viewportTransform);
                return transformPoint({ x: center.left, y: center.top }, iVpt);
              },
              _centerObject: function(object, center) {
                object.setPositionByOrigin(center, "center", "center");
                object.setCoords();
                this.renderOnAddRemove && this.requestRenderAll();
                return this;
              },
              toDatalessJSON: function(propertiesToInclude) {
                return this.toDatalessObject(propertiesToInclude);
              },
              toObject: function(propertiesToInclude) {
                return this._toObjectMethod("toObject", propertiesToInclude);
              },
              toDatalessObject: function(propertiesToInclude) {
                return this._toObjectMethod("toDatalessObject", propertiesToInclude);
              },
              _toObjectMethod: function(methodName, propertiesToInclude) {
                var clipPath = this.clipPath, data = {
                  version: fabric.version,
                  objects: this._toObjects(methodName, propertiesToInclude)
                };
                if (clipPath && !clipPath.excludeFromExport) {
                  data.clipPath = this._toObject(this.clipPath, methodName, propertiesToInclude);
                }
                extend2(data, this.__serializeBgOverlay(methodName, propertiesToInclude));
                fabric.util.populateWithProperties(this, data, propertiesToInclude);
                return data;
              },
              _toObjects: function(methodName, propertiesToInclude) {
                return this._objects.filter(function(object) {
                  return !object.excludeFromExport;
                }).map(function(instance) {
                  return this._toObject(instance, methodName, propertiesToInclude);
                }, this);
              },
              _toObject: function(instance, methodName, propertiesToInclude) {
                var originalValue;
                if (!this.includeDefaultValues) {
                  originalValue = instance.includeDefaultValues;
                  instance.includeDefaultValues = false;
                }
                var object = instance[methodName](propertiesToInclude);
                if (!this.includeDefaultValues) {
                  instance.includeDefaultValues = originalValue;
                }
                return object;
              },
              __serializeBgOverlay: function(methodName, propertiesToInclude) {
                var data = {}, bgImage = this.backgroundImage, overlayImage = this.overlayImage, bgColor = this.backgroundColor, overlayColor = this.overlayColor;
                if (bgColor && bgColor.toObject) {
                  if (!bgColor.excludeFromExport) {
                    data.background = bgColor.toObject(propertiesToInclude);
                  }
                } else if (bgColor) {
                  data.background = bgColor;
                }
                if (overlayColor && overlayColor.toObject) {
                  if (!overlayColor.excludeFromExport) {
                    data.overlay = overlayColor.toObject(propertiesToInclude);
                  }
                } else if (overlayColor) {
                  data.overlay = overlayColor;
                }
                if (bgImage && !bgImage.excludeFromExport) {
                  data.backgroundImage = this._toObject(bgImage, methodName, propertiesToInclude);
                }
                if (overlayImage && !overlayImage.excludeFromExport) {
                  data.overlayImage = this._toObject(overlayImage, methodName, propertiesToInclude);
                }
                return data;
              },
              svgViewportTransformation: true,
              toSVG: function(options, reviver) {
                options || (options = {});
                options.reviver = reviver;
                var markup = [];
                this._setSVGPreamble(markup, options);
                this._setSVGHeader(markup, options);
                if (this.clipPath) {
                  markup.push('<g clip-path="url(#' + this.clipPath.clipPathId + ')" >\n');
                }
                this._setSVGBgOverlayColor(markup, "background");
                this._setSVGBgOverlayImage(markup, "backgroundImage", reviver);
                this._setSVGObjects(markup, reviver);
                if (this.clipPath) {
                  markup.push("</g>\n");
                }
                this._setSVGBgOverlayColor(markup, "overlay");
                this._setSVGBgOverlayImage(markup, "overlayImage", reviver);
                markup.push("</svg>");
                return markup.join("");
              },
              _setSVGPreamble: function(markup, options) {
                if (options.suppressPreamble) {
                  return;
                }
                markup.push(
                  '<?xml version="1.0" encoding="',
                  options.encoding || "UTF-8",
                  '" standalone="no" ?>\n',
                  '<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" ',
                  '"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n'
                );
              },
              _setSVGHeader: function(markup, options) {
                var width = options.width || this.width, height = options.height || this.height, vpt, viewBox = 'viewBox="0 0 ' + this.width + " " + this.height + '" ', NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
                if (options.viewBox) {
                  viewBox = 'viewBox="' + options.viewBox.x + " " + options.viewBox.y + " " + options.viewBox.width + " " + options.viewBox.height + '" ';
                } else {
                  if (this.svgViewportTransformation) {
                    vpt = this.viewportTransform;
                    viewBox = 'viewBox="' + toFixed2(-vpt[4] / vpt[0], NUM_FRACTION_DIGITS) + " " + toFixed2(-vpt[5] / vpt[3], NUM_FRACTION_DIGITS) + " " + toFixed2(this.width / vpt[0], NUM_FRACTION_DIGITS) + " " + toFixed2(this.height / vpt[3], NUM_FRACTION_DIGITS) + '" ';
                  }
                }
                markup.push(
                  "<svg ",
                  'xmlns="http://www.w3.org/2000/svg" ',
                  'xmlns:xlink="http://www.w3.org/1999/xlink" ',
                  'version="1.1" ',
                  'width="',
                  width,
                  '" ',
                  'height="',
                  height,
                  '" ',
                  viewBox,
                  'xml:space="preserve">\n',
                  "<desc>Created with Fabric.js ",
                  fabric.version,
                  "</desc>\n",
                  "<defs>\n",
                  this.createSVGFontFacesMarkup(),
                  this.createSVGRefElementsMarkup(),
                  this.createSVGClipPathMarkup(options),
                  "</defs>\n"
                );
              },
              createSVGClipPathMarkup: function(options) {
                var clipPath = this.clipPath;
                if (clipPath) {
                  clipPath.clipPathId = "CLIPPATH_" + fabric.Object.__uid++;
                  return '<clipPath id="' + clipPath.clipPathId + '" >\n' + this.clipPath.toClipPathSVG(options.reviver) + "</clipPath>\n";
                }
                return "";
              },
              createSVGRefElementsMarkup: function() {
                var _this = this, markup = ["background", "overlay"].map(function(prop) {
                  var fill = _this[prop + "Color"];
                  if (fill && fill.toLive) {
                    var shouldTransform = _this[prop + "Vpt"], vpt = _this.viewportTransform, object = {
                      width: _this.width / (shouldTransform ? vpt[0] : 1),
                      height: _this.height / (shouldTransform ? vpt[3] : 1)
                    };
                    return fill.toSVG(
                      object,
                      { additionalTransform: shouldTransform ? fabric.util.matrixToSVG(vpt) : "" }
                    );
                  }
                });
                return markup.join("");
              },
              createSVGFontFacesMarkup: function() {
                var markup = "", fontList2 = {}, obj, fontFamily2, style, row, rowIndex, _char, charIndex, i, len, fontPaths = fabric.fontPaths, objects = [];
                this._objects.forEach(function add2(object) {
                  objects.push(object);
                  if (object._objects) {
                    object._objects.forEach(add2);
                  }
                });
                for (i = 0, len = objects.length; i < len; i++) {
                  obj = objects[i];
                  fontFamily2 = obj.fontFamily;
                  if (obj.type.indexOf("text") === -1 || fontList2[fontFamily2] || !fontPaths[fontFamily2]) {
                    continue;
                  }
                  fontList2[fontFamily2] = true;
                  if (!obj.styles) {
                    continue;
                  }
                  style = obj.styles;
                  for (rowIndex in style) {
                    row = style[rowIndex];
                    for (charIndex in row) {
                      _char = row[charIndex];
                      fontFamily2 = _char.fontFamily;
                      if (!fontList2[fontFamily2] && fontPaths[fontFamily2]) {
                        fontList2[fontFamily2] = true;
                      }
                    }
                  }
                }
                for (var j2 in fontList2) {
                  markup += [
                    "		@font-face {\n",
                    "			font-family: '",
                    j2,
                    "';\n",
                    "			src: url('",
                    fontPaths[j2],
                    "');\n",
                    "		}\n"
                  ].join("");
                }
                if (markup) {
                  markup = [
                    '	<style type="text/css">',
                    "<![CDATA[\n",
                    markup,
                    "]]>",
                    "</style>\n"
                  ].join("");
                }
                return markup;
              },
              _setSVGObjects: function(markup, reviver) {
                var instance, i, len, objects = this._objects;
                for (i = 0, len = objects.length; i < len; i++) {
                  instance = objects[i];
                  if (instance.excludeFromExport) {
                    continue;
                  }
                  this._setSVGObject(markup, instance, reviver);
                }
              },
              _setSVGObject: function(markup, instance, reviver) {
                markup.push(instance.toSVG(reviver));
              },
              _setSVGBgOverlayImage: function(markup, property, reviver) {
                if (this[property] && !this[property].excludeFromExport && this[property].toSVG) {
                  markup.push(this[property].toSVG(reviver));
                }
              },
              _setSVGBgOverlayColor: function(markup, property) {
                var filler = this[property + "Color"], vpt = this.viewportTransform, finalWidth = this.width, finalHeight = this.height;
                if (!filler) {
                  return;
                }
                if (filler.toLive) {
                  var repeat = filler.repeat, iVpt = fabric.util.invertTransform(vpt), shouldInvert = this[property + "Vpt"], additionalTransform = shouldInvert ? fabric.util.matrixToSVG(iVpt) : "";
                  markup.push(
                    '<rect transform="' + additionalTransform + " translate(",
                    finalWidth / 2,
                    ",",
                    finalHeight / 2,
                    ')"',
                    ' x="',
                    filler.offsetX - finalWidth / 2,
                    '" y="',
                    filler.offsetY - finalHeight / 2,
                    '" ',
                    'width="',
                    repeat === "repeat-y" || repeat === "no-repeat" ? filler.source.width : finalWidth,
                    '" height="',
                    repeat === "repeat-x" || repeat === "no-repeat" ? filler.source.height : finalHeight,
                    '" fill="url(#SVGID_' + filler.id + ')"',
                    "></rect>\n"
                  );
                } else {
                  markup.push(
                    '<rect x="0" y="0" width="100%" height="100%" ',
                    'fill="',
                    filler,
                    '"',
                    "></rect>\n"
                  );
                }
              },
              sendToBack: function(object) {
                if (!object) {
                  return this;
                }
                var activeSelection = this._activeObject, i, obj, objs;
                if (object === activeSelection && object.type === "activeSelection") {
                  objs = activeSelection._objects;
                  for (i = objs.length; i--; ) {
                    obj = objs[i];
                    removeFromArray(this._objects, obj);
                    this._objects.unshift(obj);
                  }
                } else {
                  removeFromArray(this._objects, object);
                  this._objects.unshift(object);
                }
                this.renderOnAddRemove && this.requestRenderAll();
                return this;
              },
              bringToFront: function(object) {
                if (!object) {
                  return this;
                }
                var activeSelection = this._activeObject, i, obj, objs;
                if (object === activeSelection && object.type === "activeSelection") {
                  objs = activeSelection._objects;
                  for (i = 0; i < objs.length; i++) {
                    obj = objs[i];
                    removeFromArray(this._objects, obj);
                    this._objects.push(obj);
                  }
                } else {
                  removeFromArray(this._objects, object);
                  this._objects.push(object);
                }
                this.renderOnAddRemove && this.requestRenderAll();
                return this;
              },
              sendBackwards: function(object, intersecting) {
                if (!object) {
                  return this;
                }
                var activeSelection = this._activeObject, i, obj, idx, newIdx, objs, objsMoved = 0;
                if (object === activeSelection && object.type === "activeSelection") {
                  objs = activeSelection._objects;
                  for (i = 0; i < objs.length; i++) {
                    obj = objs[i];
                    idx = this._objects.indexOf(obj);
                    if (idx > 0 + objsMoved) {
                      newIdx = idx - 1;
                      removeFromArray(this._objects, obj);
                      this._objects.splice(newIdx, 0, obj);
                    }
                    objsMoved++;
                  }
                } else {
                  idx = this._objects.indexOf(object);
                  if (idx !== 0) {
                    newIdx = this._findNewLowerIndex(object, idx, intersecting);
                    removeFromArray(this._objects, object);
                    this._objects.splice(newIdx, 0, object);
                  }
                }
                this.renderOnAddRemove && this.requestRenderAll();
                return this;
              },
              _findNewLowerIndex: function(object, idx, intersecting) {
                var newIdx, i;
                if (intersecting) {
                  newIdx = idx;
                  for (i = idx - 1; i >= 0; --i) {
                    var isIntersecting = object.intersectsWithObject(this._objects[i]) || object.isContainedWithinObject(this._objects[i]) || this._objects[i].isContainedWithinObject(object);
                    if (isIntersecting) {
                      newIdx = i;
                      break;
                    }
                  }
                } else {
                  newIdx = idx - 1;
                }
                return newIdx;
              },
              bringForward: function(object, intersecting) {
                if (!object) {
                  return this;
                }
                var activeSelection = this._activeObject, i, obj, idx, newIdx, objs, objsMoved = 0;
                if (object === activeSelection && object.type === "activeSelection") {
                  objs = activeSelection._objects;
                  for (i = objs.length; i--; ) {
                    obj = objs[i];
                    idx = this._objects.indexOf(obj);
                    if (idx < this._objects.length - 1 - objsMoved) {
                      newIdx = idx + 1;
                      removeFromArray(this._objects, obj);
                      this._objects.splice(newIdx, 0, obj);
                    }
                    objsMoved++;
                  }
                } else {
                  idx = this._objects.indexOf(object);
                  if (idx !== this._objects.length - 1) {
                    newIdx = this._findNewUpperIndex(object, idx, intersecting);
                    removeFromArray(this._objects, object);
                    this._objects.splice(newIdx, 0, object);
                  }
                }
                this.renderOnAddRemove && this.requestRenderAll();
                return this;
              },
              _findNewUpperIndex: function(object, idx, intersecting) {
                var newIdx, i, len;
                if (intersecting) {
                  newIdx = idx;
                  for (i = idx + 1, len = this._objects.length; i < len; ++i) {
                    var isIntersecting = object.intersectsWithObject(this._objects[i]) || object.isContainedWithinObject(this._objects[i]) || this._objects[i].isContainedWithinObject(object);
                    if (isIntersecting) {
                      newIdx = i;
                      break;
                    }
                  }
                } else {
                  newIdx = idx + 1;
                }
                return newIdx;
              },
              moveTo: function(object, index2) {
                removeFromArray(this._objects, object);
                this._objects.splice(index2, 0, object);
                return this.renderOnAddRemove && this.requestRenderAll();
              },
              dispose: function() {
                if (this.isRendering) {
                  fabric.util.cancelAnimFrame(this.isRendering);
                  this.isRendering = 0;
                }
                this.forEachObject(function(object) {
                  object.dispose && object.dispose();
                });
                this._objects = [];
                if (this.backgroundImage && this.backgroundImage.dispose) {
                  this.backgroundImage.dispose();
                }
                this.backgroundImage = null;
                if (this.overlayImage && this.overlayImage.dispose) {
                  this.overlayImage.dispose();
                }
                this.overlayImage = null;
                this._iTextInstances = null;
                this.contextContainer = null;
                this.lowerCanvasEl.classList.remove("lower-canvas");
                this.lowerCanvasEl.style = this._originalCanvasStyle;
                delete this._originalCanvasStyle;
                this.lowerCanvasEl.setAttribute("width", this.width);
                this.lowerCanvasEl.setAttribute("height", this.height);
                fabric.util.cleanUpJsdomNode(this.lowerCanvasEl);
                this.lowerCanvasEl = void 0;
                return this;
              },
              toString: function() {
                return "#<fabric.Canvas (" + this.complexity() + "): { objects: " + this._objects.length + " }>";
              }
            });
            extend2(fabric.StaticCanvas.prototype, fabric.Observable);
            extend2(fabric.StaticCanvas.prototype, fabric.Collection);
            extend2(fabric.StaticCanvas.prototype, fabric.DataURLExporter);
            extend2(fabric.StaticCanvas, {
              EMPTY_JSON: '{"objects": [], "background": "white"}',
              supports: function(methodName) {
                var el = createCanvasElement();
                if (!el || !el.getContext) {
                  return null;
                }
                var ctx = el.getContext("2d");
                if (!ctx) {
                  return null;
                }
                switch (methodName) {
                  case "setLineDash":
                    return typeof ctx.setLineDash !== "undefined";
                  default:
                    return null;
                }
              }
            });
            fabric.StaticCanvas.prototype.toJSON = fabric.StaticCanvas.prototype.toObject;
            if (fabric.isLikelyNode) {
              fabric.StaticCanvas.prototype.createPNGStream = function() {
                var impl = getNodeCanvas(this.lowerCanvasEl);
                return impl && impl.createPNGStream();
              };
              fabric.StaticCanvas.prototype.createJPEGStream = function(opts) {
                var impl = getNodeCanvas(this.lowerCanvasEl);
                return impl && impl.createJPEGStream(opts);
              };
            }
          })();
          fabric.BaseBrush = fabric.util.createClass({
            color: "rgb(0, 0, 0)",
            width: 1,
            shadow: null,
            strokeLineCap: "round",
            strokeLineJoin: "round",
            strokeMiterLimit: 10,
            strokeDashArray: null,
            limitedToCanvasSize: false,
            _setBrushStyles: function() {
              var ctx = this.canvas.contextTop;
              ctx.strokeStyle = this.color;
              ctx.lineWidth = this.width;
              ctx.lineCap = this.strokeLineCap;
              ctx.miterLimit = this.strokeMiterLimit;
              ctx.lineJoin = this.strokeLineJoin;
              ctx.setLineDash(this.strokeDashArray || []);
            },
            _saveAndTransform: function(ctx) {
              var v = this.canvas.viewportTransform;
              ctx.save();
              ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
            },
            _setShadow: function() {
              if (!this.shadow) {
                return;
              }
              var canvas = this.canvas, shadow = this.shadow, ctx = canvas.contextTop, zoom = canvas.getZoom();
              if (canvas && canvas._isRetinaScaling()) {
                zoom *= fabric.devicePixelRatio;
              }
              ctx.shadowColor = shadow.color;
              ctx.shadowBlur = shadow.blur * zoom;
              ctx.shadowOffsetX = shadow.offsetX * zoom;
              ctx.shadowOffsetY = shadow.offsetY * zoom;
            },
            needsFullRender: function() {
              var color2 = new fabric.Color(this.color);
              return color2.getAlpha() < 1 || !!this.shadow;
            },
            _resetShadow: function() {
              var ctx = this.canvas.contextTop;
              ctx.shadowColor = "";
              ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
            },
            _isOutSideCanvas: function(pointer) {
              return pointer.x < 0 || pointer.x > this.canvas.getWidth() || pointer.y < 0 || pointer.y > this.canvas.getHeight();
            }
          });
          (function() {
            fabric.PencilBrush = fabric.util.createClass(fabric.BaseBrush, {
              decimate: 0.4,
              initialize: function(canvas) {
                this.canvas = canvas;
                this._points = [];
              },
              _drawSegment: function(ctx, p1, p2) {
                var midPoint = p1.midPointFrom(p2);
                ctx.quadraticCurveTo(p1.x, p1.y, midPoint.x, midPoint.y);
                return midPoint;
              },
              onMouseDown: function(pointer, options) {
                if (!this.canvas._isMainEvent(options.e)) {
                  return;
                }
                this._prepareForDrawing(pointer);
                this._captureDrawingPath(pointer);
                this._render();
              },
              onMouseMove: function(pointer, options) {
                if (!this.canvas._isMainEvent(options.e)) {
                  return;
                }
                if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {
                  return;
                }
                if (this._captureDrawingPath(pointer) && this._points.length > 1) {
                  if (this.needsFullRender()) {
                    this.canvas.clearContext(this.canvas.contextTop);
                    this._render();
                  } else {
                    var points = this._points, length = points.length, ctx = this.canvas.contextTop;
                    this._saveAndTransform(ctx);
                    if (this.oldEnd) {
                      ctx.beginPath();
                      ctx.moveTo(this.oldEnd.x, this.oldEnd.y);
                    }
                    this.oldEnd = this._drawSegment(ctx, points[length - 2], points[length - 1], true);
                    ctx.stroke();
                    ctx.restore();
                  }
                }
              },
              onMouseUp: function(options) {
                if (!this.canvas._isMainEvent(options.e)) {
                  return true;
                }
                this.oldEnd = void 0;
                this._finalizeAndAddPath();
                return false;
              },
              _prepareForDrawing: function(pointer) {
                var p = new fabric.Point(pointer.x, pointer.y);
                this._reset();
                this._addPoint(p);
                this.canvas.contextTop.moveTo(p.x, p.y);
              },
              _addPoint: function(point) {
                if (this._points.length > 1 && point.eq(this._points[this._points.length - 1])) {
                  return false;
                }
                this._points.push(point);
                return true;
              },
              _reset: function() {
                this._points = [];
                this._setBrushStyles();
                this._setShadow();
              },
              _captureDrawingPath: function(pointer) {
                var pointerPoint = new fabric.Point(pointer.x, pointer.y);
                return this._addPoint(pointerPoint);
              },
              _render: function() {
                var ctx = this.canvas.contextTop, i, len, p1 = this._points[0], p2 = this._points[1];
                this._saveAndTransform(ctx);
                ctx.beginPath();
                if (this._points.length === 2 && p1.x === p2.x && p1.y === p2.y) {
                  var width = this.width / 1e3;
                  p1 = new fabric.Point(p1.x, p1.y);
                  p2 = new fabric.Point(p2.x, p2.y);
                  p1.x -= width;
                  p2.x += width;
                }
                ctx.moveTo(p1.x, p1.y);
                for (i = 1, len = this._points.length; i < len; i++) {
                  this._drawSegment(ctx, p1, p2);
                  p1 = this._points[i];
                  p2 = this._points[i + 1];
                }
                ctx.lineTo(p1.x, p1.y);
                ctx.stroke();
                ctx.restore();
              },
              convertPointsToSVGPath: function(points) {
                var correction = this.width / 1e3;
                return fabric.util.getSmoothPathFromPoints(points, correction);
              },
              _isEmptySVGPath: function(pathData) {
                var pathString = fabric.util.joinPath(pathData);
                return pathString === "M 0 0 Q 0 0 0 0 L 0 0";
              },
              createPath: function(pathData) {
                var path = new fabric.Path(pathData, {
                  fill: null,
                  stroke: this.color,
                  strokeWidth: this.width,
                  strokeLineCap: this.strokeLineCap,
                  strokeMiterLimit: this.strokeMiterLimit,
                  strokeLineJoin: this.strokeLineJoin,
                  strokeDashArray: this.strokeDashArray
                });
                if (this.shadow) {
                  this.shadow.affectStroke = true;
                  path.shadow = new fabric.Shadow(this.shadow);
                }
                return path;
              },
              decimatePoints: function(points, distance2) {
                if (points.length <= 2) {
                  return points;
                }
                var zoom = this.canvas.getZoom(), adjustedDistance = Math.pow(distance2 / zoom, 2), i, l = points.length - 1, lastPoint = points[0], newPoints = [lastPoint], cDistance;
                for (i = 1; i < l - 1; i++) {
                  cDistance = Math.pow(lastPoint.x - points[i].x, 2) + Math.pow(lastPoint.y - points[i].y, 2);
                  if (cDistance >= adjustedDistance) {
                    lastPoint = points[i];
                    newPoints.push(lastPoint);
                  }
                }
                newPoints.push(points[l]);
                return newPoints;
              },
              _finalizeAndAddPath: function() {
                var ctx = this.canvas.contextTop;
                ctx.closePath();
                if (this.decimate) {
                  this._points = this.decimatePoints(this._points, this.decimate);
                }
                var pathData = this.convertPointsToSVGPath(this._points);
                if (this._isEmptySVGPath(pathData)) {
                  this.canvas.requestRenderAll();
                  return;
                }
                var path = this.createPath(pathData);
                this.canvas.clearContext(this.canvas.contextTop);
                this.canvas.fire("before:path:created", { path });
                this.canvas.add(path);
                this.canvas.requestRenderAll();
                path.setCoords();
                this._resetShadow();
                this.canvas.fire("path:created", { path });
              }
            });
          })();
          fabric.CircleBrush = fabric.util.createClass(fabric.BaseBrush, {
            width: 10,
            initialize: function(canvas) {
              this.canvas = canvas;
              this.points = [];
            },
            drawDot: function(pointer) {
              var point = this.addPoint(pointer), ctx = this.canvas.contextTop;
              this._saveAndTransform(ctx);
              this.dot(ctx, point);
              ctx.restore();
            },
            dot: function(ctx, point) {
              ctx.fillStyle = point.fill;
              ctx.beginPath();
              ctx.arc(point.x, point.y, point.radius, 0, Math.PI * 2, false);
              ctx.closePath();
              ctx.fill();
            },
            onMouseDown: function(pointer) {
              this.points.length = 0;
              this.canvas.clearContext(this.canvas.contextTop);
              this._setShadow();
              this.drawDot(pointer);
            },
            _render: function() {
              var ctx = this.canvas.contextTop, i, len, points = this.points;
              this._saveAndTransform(ctx);
              for (i = 0, len = points.length; i < len; i++) {
                this.dot(ctx, points[i]);
              }
              ctx.restore();
            },
            onMouseMove: function(pointer) {
              if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {
                return;
              }
              if (this.needsFullRender()) {
                this.canvas.clearContext(this.canvas.contextTop);
                this.addPoint(pointer);
                this._render();
              } else {
                this.drawDot(pointer);
              }
            },
            onMouseUp: function() {
              var originalRenderOnAddRemove = this.canvas.renderOnAddRemove, i, len;
              this.canvas.renderOnAddRemove = false;
              var circles = [];
              for (i = 0, len = this.points.length; i < len; i++) {
                var point = this.points[i], circle = new fabric.Circle({
                  radius: point.radius,
                  left: point.x,
                  top: point.y,
                  originX: "center",
                  originY: "center",
                  fill: point.fill
                });
                this.shadow && (circle.shadow = new fabric.Shadow(this.shadow));
                circles.push(circle);
              }
              var group = new fabric.Group(circles);
              group.canvas = this.canvas;
              this.canvas.fire("before:path:created", { path: group });
              this.canvas.add(group);
              this.canvas.fire("path:created", { path: group });
              this.canvas.clearContext(this.canvas.contextTop);
              this._resetShadow();
              this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
              this.canvas.requestRenderAll();
            },
            addPoint: function(pointer) {
              var pointerPoint = new fabric.Point(pointer.x, pointer.y), circleRadius = fabric.util.getRandomInt(
                Math.max(0, this.width - 20),
                this.width + 20
              ) / 2, circleColor = new fabric.Color(this.color).setAlpha(fabric.util.getRandomInt(0, 100) / 100).toRgba();
              pointerPoint.radius = circleRadius;
              pointerPoint.fill = circleColor;
              this.points.push(pointerPoint);
              return pointerPoint;
            }
          });
          fabric.SprayBrush = fabric.util.createClass(fabric.BaseBrush, {
            width: 10,
            density: 20,
            dotWidth: 1,
            dotWidthVariance: 1,
            randomOpacity: false,
            optimizeOverlapping: true,
            initialize: function(canvas) {
              this.canvas = canvas;
              this.sprayChunks = [];
            },
            onMouseDown: function(pointer) {
              this.sprayChunks.length = 0;
              this.canvas.clearContext(this.canvas.contextTop);
              this._setShadow();
              this.addSprayChunk(pointer);
              this.render(this.sprayChunkPoints);
            },
            onMouseMove: function(pointer) {
              if (this.limitedToCanvasSize === true && this._isOutSideCanvas(pointer)) {
                return;
              }
              this.addSprayChunk(pointer);
              this.render(this.sprayChunkPoints);
            },
            onMouseUp: function() {
              var originalRenderOnAddRemove = this.canvas.renderOnAddRemove;
              this.canvas.renderOnAddRemove = false;
              var rects = [];
              for (var i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
                var sprayChunk = this.sprayChunks[i];
                for (var j2 = 0, jlen = sprayChunk.length; j2 < jlen; j2++) {
                  var rect = new fabric.Rect({
                    width: sprayChunk[j2].width,
                    height: sprayChunk[j2].width,
                    left: sprayChunk[j2].x + 1,
                    top: sprayChunk[j2].y + 1,
                    originX: "center",
                    originY: "center",
                    fill: this.color
                  });
                  rects.push(rect);
                }
              }
              if (this.optimizeOverlapping) {
                rects = this._getOptimizedRects(rects);
              }
              var group = new fabric.Group(rects);
              this.shadow && group.set("shadow", new fabric.Shadow(this.shadow));
              this.canvas.fire("before:path:created", { path: group });
              this.canvas.add(group);
              this.canvas.fire("path:created", { path: group });
              this.canvas.clearContext(this.canvas.contextTop);
              this._resetShadow();
              this.canvas.renderOnAddRemove = originalRenderOnAddRemove;
              this.canvas.requestRenderAll();
            },
            _getOptimizedRects: function(rects) {
              var uniqueRects = {}, key, i, len;
              for (i = 0, len = rects.length; i < len; i++) {
                key = rects[i].left + "" + rects[i].top;
                if (!uniqueRects[key]) {
                  uniqueRects[key] = rects[i];
                }
              }
              var uniqueRectsArray = [];
              for (key in uniqueRects) {
                uniqueRectsArray.push(uniqueRects[key]);
              }
              return uniqueRectsArray;
            },
            render: function(sprayChunk) {
              var ctx = this.canvas.contextTop, i, len;
              ctx.fillStyle = this.color;
              this._saveAndTransform(ctx);
              for (i = 0, len = sprayChunk.length; i < len; i++) {
                var point = sprayChunk[i];
                if (typeof point.opacity !== "undefined") {
                  ctx.globalAlpha = point.opacity;
                }
                ctx.fillRect(point.x, point.y, point.width, point.width);
              }
              ctx.restore();
            },
            _render: function() {
              var ctx = this.canvas.contextTop, i, ilen;
              ctx.fillStyle = this.color;
              this._saveAndTransform(ctx);
              for (i = 0, ilen = this.sprayChunks.length; i < ilen; i++) {
                this.render(this.sprayChunks[i]);
              }
              ctx.restore();
            },
            addSprayChunk: function(pointer) {
              this.sprayChunkPoints = [];
              var x, y, width, radius = this.width / 2, i;
              for (i = 0; i < this.density; i++) {
                x = fabric.util.getRandomInt(pointer.x - radius, pointer.x + radius);
                y = fabric.util.getRandomInt(pointer.y - radius, pointer.y + radius);
                if (this.dotWidthVariance) {
                  width = fabric.util.getRandomInt(
                    Math.max(1, this.dotWidth - this.dotWidthVariance),
                    this.dotWidth + this.dotWidthVariance
                  );
                } else {
                  width = this.dotWidth;
                }
                var point = new fabric.Point(x, y);
                point.width = width;
                if (this.randomOpacity) {
                  point.opacity = fabric.util.getRandomInt(0, 100) / 100;
                }
                this.sprayChunkPoints.push(point);
              }
              this.sprayChunks.push(this.sprayChunkPoints);
            }
          });
          fabric.PatternBrush = fabric.util.createClass(fabric.PencilBrush, {
            getPatternSrc: function() {
              var dotWidth = 20, dotDistance = 5, patternCanvas = fabric.util.createCanvasElement(), patternCtx = patternCanvas.getContext("2d");
              patternCanvas.width = patternCanvas.height = dotWidth + dotDistance;
              patternCtx.fillStyle = this.color;
              patternCtx.beginPath();
              patternCtx.arc(dotWidth / 2, dotWidth / 2, dotWidth / 2, 0, Math.PI * 2, false);
              patternCtx.closePath();
              patternCtx.fill();
              return patternCanvas;
            },
            getPatternSrcFunction: function() {
              return String(this.getPatternSrc).replace("this.color", '"' + this.color + '"');
            },
            getPattern: function() {
              return this.canvas.contextTop.createPattern(this.source || this.getPatternSrc(), "repeat");
            },
            _setBrushStyles: function() {
              this.callSuper("_setBrushStyles");
              this.canvas.contextTop.strokeStyle = this.getPattern();
            },
            createPath: function(pathData) {
              var path = this.callSuper("createPath", pathData), topLeft = path._getLeftTopCoords().scalarAdd(path.strokeWidth / 2);
              path.stroke = new fabric.Pattern({
                source: this.source || this.getPatternSrcFunction(),
                offsetX: -topLeft.x,
                offsetY: -topLeft.y
              });
              return path;
            }
          });
          (function() {
            var getPointer = fabric.util.getPointer, degreesToRadians = fabric.util.degreesToRadians, isTouchEvent = fabric.util.isTouchEvent;
            fabric.Canvas = fabric.util.createClass(fabric.StaticCanvas, {
              initialize: function(el, options) {
                options || (options = {});
                this.renderAndResetBound = this.renderAndReset.bind(this);
                this.requestRenderAllBound = this.requestRenderAll.bind(this);
                this._initStatic(el, options);
                this._initInteractive();
                this._createCacheCanvas();
              },
              uniformScaling: true,
              uniScaleKey: "shiftKey",
              centeredScaling: false,
              centeredRotation: false,
              centeredKey: "altKey",
              altActionKey: "shiftKey",
              interactive: true,
              selection: true,
              selectionKey: "shiftKey",
              altSelectionKey: null,
              selectionColor: "rgba(100, 100, 255, 0.3)",
              selectionDashArray: [],
              selectionBorderColor: "rgba(255, 255, 255, 0.3)",
              selectionLineWidth: 1,
              selectionFullyContained: false,
              hoverCursor: "move",
              moveCursor: "move",
              defaultCursor: "default",
              freeDrawingCursor: "crosshair",
              rotationCursor: "crosshair",
              notAllowedCursor: "not-allowed",
              containerClass: "canvas-container",
              perPixelTargetFind: false,
              targetFindTolerance: 0,
              skipTargetFind: false,
              isDrawingMode: false,
              preserveObjectStacking: false,
              snapAngle: 0,
              snapThreshold: null,
              stopContextMenu: false,
              fireRightClick: false,
              fireMiddleClick: false,
              targets: [],
              _hoveredTarget: null,
              _hoveredTargets: [],
              _initInteractive: function() {
                this._currentTransform = null;
                this._groupSelector = null;
                this._initWrapperElement();
                this._createUpperCanvas();
                this._initEventListeners();
                this._initRetinaScaling();
                this.freeDrawingBrush = fabric.PencilBrush && new fabric.PencilBrush(this);
                this.calcOffset();
              },
              _chooseObjectsToRender: function() {
                var activeObjects = this.getActiveObjects(), object, objsToRender, activeGroupObjects;
                if (activeObjects.length > 0 && !this.preserveObjectStacking) {
                  objsToRender = [];
                  activeGroupObjects = [];
                  for (var i = 0, length = this._objects.length; i < length; i++) {
                    object = this._objects[i];
                    if (activeObjects.indexOf(object) === -1) {
                      objsToRender.push(object);
                    } else {
                      activeGroupObjects.push(object);
                    }
                  }
                  if (activeObjects.length > 1) {
                    this._activeObject._objects = activeGroupObjects;
                  }
                  objsToRender.push.apply(objsToRender, activeGroupObjects);
                } else {
                  objsToRender = this._objects;
                }
                return objsToRender;
              },
              renderAll: function() {
                if (this.contextTopDirty && !this._groupSelector && !this.isDrawingMode) {
                  this.clearContext(this.contextTop);
                  this.contextTopDirty = false;
                }
                if (this.hasLostContext) {
                  this.renderTopLayer(this.contextTop);
                }
                var canvasToDrawOn = this.contextContainer;
                this.renderCanvas(canvasToDrawOn, this._chooseObjectsToRender());
                return this;
              },
              renderTopLayer: function(ctx) {
                ctx.save();
                if (this.isDrawingMode && this._isCurrentlyDrawing) {
                  this.freeDrawingBrush && this.freeDrawingBrush._render();
                  this.contextTopDirty = true;
                }
                if (this.selection && this._groupSelector) {
                  this._drawSelection(ctx);
                  this.contextTopDirty = true;
                }
                ctx.restore();
              },
              renderTop: function() {
                var ctx = this.contextTop;
                this.clearContext(ctx);
                this.renderTopLayer(ctx);
                this.fire("after:render");
                return this;
              },
              _normalizePointer: function(object, pointer) {
                var m = object.calcTransformMatrix(), invertedM = fabric.util.invertTransform(m), vptPointer = this.restorePointerVpt(pointer);
                return fabric.util.transformPoint(vptPointer, invertedM);
              },
              isTargetTransparent: function(target, x, y) {
                if (target.shouldCache() && target._cacheCanvas && target !== this._activeObject) {
                  var normalizedPointer = this._normalizePointer(target, { x, y }), targetRelativeX = Math.max(target.cacheTranslationX + normalizedPointer.x * target.zoomX, 0), targetRelativeY = Math.max(target.cacheTranslationY + normalizedPointer.y * target.zoomY, 0);
                  var isTransparent2 = fabric.util.isTransparent(
                    target._cacheContext,
                    Math.round(targetRelativeX),
                    Math.round(targetRelativeY),
                    this.targetFindTolerance
                  );
                  return isTransparent2;
                }
                var ctx = this.contextCache, originalColor = target.selectionBackgroundColor, v = this.viewportTransform;
                target.selectionBackgroundColor = "";
                this.clearContext(ctx);
                ctx.save();
                ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
                target.render(ctx);
                ctx.restore();
                target.selectionBackgroundColor = originalColor;
                var isTransparent2 = fabric.util.isTransparent(
                  ctx,
                  x,
                  y,
                  this.targetFindTolerance
                );
                return isTransparent2;
              },
              _isSelectionKeyPressed: function(e2) {
                var selectionKeyPressed = false;
                if (Object.prototype.toString.call(this.selectionKey) === "[object Array]") {
                  selectionKeyPressed = !!this.selectionKey.find(function(key) {
                    return e2[key] === true;
                  });
                } else {
                  selectionKeyPressed = e2[this.selectionKey];
                }
                return selectionKeyPressed;
              },
              _shouldClearSelection: function(e2, target) {
                var activeObjects = this.getActiveObjects(), activeObject = this._activeObject;
                return !target || target && activeObject && activeObjects.length > 1 && activeObjects.indexOf(target) === -1 && activeObject !== target && !this._isSelectionKeyPressed(e2) || target && !target.evented || target && !target.selectable && activeObject && activeObject !== target;
              },
              _shouldCenterTransform: function(target, action, altKey) {
                if (!target) {
                  return;
                }
                var centerTransform;
                if (action === "scale" || action === "scaleX" || action === "scaleY" || action === "resizing") {
                  centerTransform = this.centeredScaling || target.centeredScaling;
                } else if (action === "rotate") {
                  centerTransform = this.centeredRotation || target.centeredRotation;
                }
                return centerTransform ? !altKey : altKey;
              },
              _getOriginFromCorner: function(target, corner) {
                var origin = {
                  x: target.originX,
                  y: target.originY
                };
                if (corner === "ml" || corner === "tl" || corner === "bl") {
                  origin.x = "right";
                } else if (corner === "mr" || corner === "tr" || corner === "br") {
                  origin.x = "left";
                }
                if (corner === "tl" || corner === "mt" || corner === "tr") {
                  origin.y = "bottom";
                } else if (corner === "bl" || corner === "mb" || corner === "br") {
                  origin.y = "top";
                }
                return origin;
              },
              _getActionFromCorner: function(alreadySelected, corner, e2, target) {
                if (!corner || !alreadySelected) {
                  return "drag";
                }
                var control = target.controls[corner];
                return control.getActionName(e2, control, target);
              },
              _setupCurrentTransform: function(e2, target, alreadySelected) {
                if (!target) {
                  return;
                }
                var pointer = this.getPointer(e2), corner = target.__corner, control = target.controls[corner], actionHandler = alreadySelected && corner ? control.getActionHandler(e2, target, control) : fabric.controlsUtils.dragHandler, action = this._getActionFromCorner(alreadySelected, corner, e2, target), origin = this._getOriginFromCorner(target, corner), altKey = e2[this.centeredKey], transform2 = {
                  target,
                  action,
                  actionHandler,
                  corner,
                  scaleX: target.scaleX,
                  scaleY: target.scaleY,
                  skewX: target.skewX,
                  skewY: target.skewY,
                  offsetX: pointer.x - target.left,
                  offsetY: pointer.y - target.top,
                  originX: origin.x,
                  originY: origin.y,
                  ex: pointer.x,
                  ey: pointer.y,
                  lastX: pointer.x,
                  lastY: pointer.y,
                  theta: degreesToRadians(target.angle),
                  width: target.width * target.scaleX,
                  shiftKey: e2.shiftKey,
                  altKey,
                  original: fabric.util.saveObjectTransform(target)
                };
                if (this._shouldCenterTransform(target, action, altKey)) {
                  transform2.originX = "center";
                  transform2.originY = "center";
                }
                transform2.original.originX = origin.x;
                transform2.original.originY = origin.y;
                this._currentTransform = transform2;
                this._beforeTransform(e2);
              },
              setCursor: function(value) {
                this.upperCanvasEl.style.cursor = value;
              },
              _drawSelection: function(ctx) {
                var selector = this._groupSelector, viewportStart = new fabric.Point(selector.ex, selector.ey), start = fabric.util.transformPoint(viewportStart, this.viewportTransform), viewportExtent = new fabric.Point(selector.ex + selector.left, selector.ey + selector.top), extent = fabric.util.transformPoint(viewportExtent, this.viewportTransform), minX = Math.min(start.x, extent.x), minY = Math.min(start.y, extent.y), maxX = Math.max(start.x, extent.x), maxY = Math.max(start.y, extent.y), strokeOffset = this.selectionLineWidth / 2;
                if (this.selectionColor) {
                  ctx.fillStyle = this.selectionColor;
                  ctx.fillRect(minX, minY, maxX - minX, maxY - minY);
                }
                if (!this.selectionLineWidth || !this.selectionBorderColor) {
                  return;
                }
                ctx.lineWidth = this.selectionLineWidth;
                ctx.strokeStyle = this.selectionBorderColor;
                minX += strokeOffset;
                minY += strokeOffset;
                maxX -= strokeOffset;
                maxY -= strokeOffset;
                fabric.Object.prototype._setLineDash.call(this, ctx, this.selectionDashArray);
                ctx.strokeRect(minX, minY, maxX - minX, maxY - minY);
              },
              findTarget: function(e2, skipGroup) {
                if (this.skipTargetFind) {
                  return;
                }
                var ignoreZoom = true, pointer = this.getPointer(e2, ignoreZoom), activeObject = this._activeObject, aObjects = this.getActiveObjects(), activeTarget, activeTargetSubs, isTouch = isTouchEvent(e2), shouldLookForActive = aObjects.length > 1 && !skipGroup || aObjects.length === 1;
                this.targets = [];
                if (shouldLookForActive && activeObject._findTargetCorner(pointer, isTouch)) {
                  return activeObject;
                }
                if (aObjects.length > 1 && !skipGroup && activeObject === this._searchPossibleTargets([activeObject], pointer)) {
                  return activeObject;
                }
                if (aObjects.length === 1 && activeObject === this._searchPossibleTargets([activeObject], pointer)) {
                  if (!this.preserveObjectStacking) {
                    return activeObject;
                  } else {
                    activeTarget = activeObject;
                    activeTargetSubs = this.targets;
                    this.targets = [];
                  }
                }
                var target = this._searchPossibleTargets(this._objects, pointer);
                if (e2[this.altSelectionKey] && target && activeTarget && target !== activeTarget) {
                  target = activeTarget;
                  this.targets = activeTargetSubs;
                }
                return target;
              },
              _checkTarget: function(pointer, obj, globalPointer) {
                if (obj && obj.visible && obj.evented && obj.containsPoint(pointer)) {
                  if ((this.perPixelTargetFind || obj.perPixelTargetFind) && !obj.isEditing) {
                    var isTransparent2 = this.isTargetTransparent(obj, globalPointer.x, globalPointer.y);
                    if (!isTransparent2) {
                      return true;
                    }
                  } else {
                    return true;
                  }
                }
              },
              _searchPossibleTargets: function(objects, pointer) {
                var target, i = objects.length, subTarget;
                while (i--) {
                  var objToCheck = objects[i];
                  var pointerToUse = objToCheck.group ? this._normalizePointer(objToCheck.group, pointer) : pointer;
                  if (this._checkTarget(pointerToUse, objToCheck, pointer)) {
                    target = objects[i];
                    if (target.subTargetCheck && target instanceof fabric.Group) {
                      subTarget = this._searchPossibleTargets(target._objects, pointer);
                      subTarget && this.targets.push(subTarget);
                    }
                    break;
                  }
                }
                return target;
              },
              restorePointerVpt: function(pointer) {
                return fabric.util.transformPoint(
                  pointer,
                  fabric.util.invertTransform(this.viewportTransform)
                );
              },
              getPointer: function(e2, ignoreZoom) {
                if (this._absolutePointer && !ignoreZoom) {
                  return this._absolutePointer;
                }
                if (this._pointer && ignoreZoom) {
                  return this._pointer;
                }
                var pointer = getPointer(e2), upperCanvasEl = this.upperCanvasEl, bounds = upperCanvasEl.getBoundingClientRect(), boundsWidth = bounds.width || 0, boundsHeight = bounds.height || 0, cssScale;
                if (!boundsWidth || !boundsHeight) {
                  if ("top" in bounds && "bottom" in bounds) {
                    boundsHeight = Math.abs(bounds.top - bounds.bottom);
                  }
                  if ("right" in bounds && "left" in bounds) {
                    boundsWidth = Math.abs(bounds.right - bounds.left);
                  }
                }
                this.calcOffset();
                pointer.x = pointer.x - this._offset.left;
                pointer.y = pointer.y - this._offset.top;
                if (!ignoreZoom) {
                  pointer = this.restorePointerVpt(pointer);
                }
                var retinaScaling = this.getRetinaScaling();
                if (retinaScaling !== 1) {
                  pointer.x /= retinaScaling;
                  pointer.y /= retinaScaling;
                }
                if (boundsWidth === 0 || boundsHeight === 0) {
                  cssScale = { width: 1, height: 1 };
                } else {
                  cssScale = {
                    width: upperCanvasEl.width / boundsWidth,
                    height: upperCanvasEl.height / boundsHeight
                  };
                }
                return {
                  x: pointer.x * cssScale.width,
                  y: pointer.y * cssScale.height
                };
              },
              _createUpperCanvas: function() {
                var lowerCanvasClass = this.lowerCanvasEl.className.replace(/\s*lower-canvas\s*/, ""), lowerCanvasEl = this.lowerCanvasEl, upperCanvasEl = this.upperCanvasEl;
                if (upperCanvasEl) {
                  upperCanvasEl.className = "";
                } else {
                  upperCanvasEl = this._createCanvasElement();
                  this.upperCanvasEl = upperCanvasEl;
                }
                fabric.util.addClass(upperCanvasEl, "upper-canvas " + lowerCanvasClass);
                this.wrapperEl.appendChild(upperCanvasEl);
                this._copyCanvasStyle(lowerCanvasEl, upperCanvasEl);
                this._applyCanvasStyle(upperCanvasEl);
                this.contextTop = upperCanvasEl.getContext("2d");
              },
              _createCacheCanvas: function() {
                this.cacheCanvasEl = this._createCanvasElement();
                this.cacheCanvasEl.setAttribute("width", this.width);
                this.cacheCanvasEl.setAttribute("height", this.height);
                this.contextCache = this.cacheCanvasEl.getContext("2d");
              },
              _initWrapperElement: function() {
                this.wrapperEl = fabric.util.wrapElement(this.lowerCanvasEl, "div", {
                  "class": this.containerClass
                });
                fabric.util.setStyle(this.wrapperEl, {
                  width: this.width + "px",
                  height: this.height + "px",
                  position: "relative"
                });
                fabric.util.makeElementUnselectable(this.wrapperEl);
              },
              _applyCanvasStyle: function(element) {
                var width = this.width || element.width, height = this.height || element.height;
                fabric.util.setStyle(element, {
                  position: "absolute",
                  width: width + "px",
                  height: height + "px",
                  left: 0,
                  top: 0,
                  "touch-action": this.allowTouchScrolling ? "manipulation" : "none",
                  "-ms-touch-action": this.allowTouchScrolling ? "manipulation" : "none"
                });
                element.width = width;
                element.height = height;
                fabric.util.makeElementUnselectable(element);
              },
              _copyCanvasStyle: function(fromEl, toEl) {
                toEl.style.cssText = fromEl.style.cssText;
              },
              getSelectionContext: function() {
                return this.contextTop;
              },
              getSelectionElement: function() {
                return this.upperCanvasEl;
              },
              getActiveObject: function() {
                return this._activeObject;
              },
              getActiveObjects: function() {
                var active = this._activeObject;
                if (active) {
                  if (active.type === "activeSelection" && active._objects) {
                    return active._objects.slice(0);
                  } else {
                    return [active];
                  }
                }
                return [];
              },
              _onObjectRemoved: function(obj) {
                if (obj === this._activeObject) {
                  this.fire("before:selection:cleared", { target: obj });
                  this._discardActiveObject();
                  this.fire("selection:cleared", { target: obj });
                  obj.fire("deselected");
                }
                if (obj === this._hoveredTarget) {
                  this._hoveredTarget = null;
                  this._hoveredTargets = [];
                }
                this.callSuper("_onObjectRemoved", obj);
              },
              _fireSelectionEvents: function(oldObjects, e2) {
                var somethingChanged = false, objects = this.getActiveObjects(), added = [], removed = [];
                oldObjects.forEach(function(oldObject) {
                  if (objects.indexOf(oldObject) === -1) {
                    somethingChanged = true;
                    oldObject.fire("deselected", {
                      e: e2,
                      target: oldObject
                    });
                    removed.push(oldObject);
                  }
                });
                objects.forEach(function(object) {
                  if (oldObjects.indexOf(object) === -1) {
                    somethingChanged = true;
                    object.fire("selected", {
                      e: e2,
                      target: object
                    });
                    added.push(object);
                  }
                });
                if (oldObjects.length > 0 && objects.length > 0) {
                  somethingChanged && this.fire("selection:updated", {
                    e: e2,
                    selected: added,
                    deselected: removed,
                    updated: added[0] || removed[0],
                    target: this._activeObject
                  });
                } else if (objects.length > 0) {
                  this.fire("selection:created", {
                    e: e2,
                    selected: added,
                    target: this._activeObject
                  });
                } else if (oldObjects.length > 0) {
                  this.fire("selection:cleared", {
                    e: e2,
                    deselected: removed
                  });
                }
              },
              setActiveObject: function(object, e2) {
                var currentActives = this.getActiveObjects();
                this._setActiveObject(object, e2);
                this._fireSelectionEvents(currentActives, e2);
                return this;
              },
              _setActiveObject: function(object, e2) {
                if (this._activeObject === object) {
                  return false;
                }
                if (!this._discardActiveObject(e2, object)) {
                  return false;
                }
                if (object.onSelect({ e: e2 })) {
                  return false;
                }
                this._activeObject = object;
                return true;
              },
              _discardActiveObject: function(e2, object) {
                var obj = this._activeObject;
                if (obj) {
                  if (obj.onDeselect({ e: e2, object })) {
                    return false;
                  }
                  this._activeObject = null;
                }
                return true;
              },
              discardActiveObject: function(e2) {
                var currentActives = this.getActiveObjects(), activeObject = this.getActiveObject();
                if (currentActives.length) {
                  this.fire("before:selection:cleared", { target: activeObject, e: e2 });
                }
                this._discardActiveObject(e2);
                this._fireSelectionEvents(currentActives, e2);
                return this;
              },
              dispose: function() {
                var wrapper = this.wrapperEl;
                this.removeListeners();
                wrapper.removeChild(this.upperCanvasEl);
                wrapper.removeChild(this.lowerCanvasEl);
                this.contextCache = null;
                this.contextTop = null;
                ["upperCanvasEl", "cacheCanvasEl"].forEach(function(element) {
                  fabric.util.cleanUpJsdomNode(this[element]);
                  this[element] = void 0;
                }.bind(this));
                if (wrapper.parentNode) {
                  wrapper.parentNode.replaceChild(this.lowerCanvasEl, this.wrapperEl);
                }
                delete this.wrapperEl;
                fabric.StaticCanvas.prototype.dispose.call(this);
                return this;
              },
              clear: function() {
                this.discardActiveObject();
                this.clearContext(this.contextTop);
                return this.callSuper("clear");
              },
              drawControls: function(ctx) {
                var activeObject = this._activeObject;
                if (activeObject) {
                  activeObject._renderControls(ctx);
                }
              },
              _toObject: function(instance, methodName, propertiesToInclude) {
                var originalProperties = this._realizeGroupTransformOnObject(instance), object = this.callSuper("_toObject", instance, methodName, propertiesToInclude);
                this._unwindGroupTransformOnObject(instance, originalProperties);
                return object;
              },
              _realizeGroupTransformOnObject: function(instance) {
                if (instance.group && instance.group.type === "activeSelection" && this._activeObject === instance.group) {
                  var layoutProps = ["angle", "flipX", "flipY", "left", "scaleX", "scaleY", "skewX", "skewY", "top"];
                  var originalValues = {};
                  layoutProps.forEach(function(prop2) {
                    originalValues[prop2] = instance[prop2];
                  });
                  fabric.util.addTransformToObject(instance, this._activeObject.calcOwnMatrix());
                  return originalValues;
                } else {
                  return null;
                }
              },
              _unwindGroupTransformOnObject: function(instance, originalValues) {
                if (originalValues) {
                  instance.set(originalValues);
                }
              },
              _setSVGObject: function(markup, instance, reviver) {
                var originalProperties = this._realizeGroupTransformOnObject(instance);
                this.callSuper("_setSVGObject", markup, instance, reviver);
                this._unwindGroupTransformOnObject(instance, originalProperties);
              },
              setViewportTransform: function(vpt) {
                if (this.renderOnAddRemove && this._activeObject && this._activeObject.isEditing) {
                  this._activeObject.clearContextTop();
                }
                fabric.StaticCanvas.prototype.setViewportTransform.call(this, vpt);
              }
            });
            for (var prop in fabric.StaticCanvas) {
              if (prop !== "prototype") {
                fabric.Canvas[prop] = fabric.StaticCanvas[prop];
              }
            }
          })();
          (function() {
            var addListener = fabric.util.addListener, removeListener = fabric.util.removeListener, RIGHT_CLICK = 3, MIDDLE_CLICK = 2, LEFT_CLICK = 1, addEventOptions = { passive: false };
            function checkClick(e2, value) {
              return e2.button && e2.button === value - 1;
            }
            fabric.util.object.extend(fabric.Canvas.prototype, {
              mainTouchId: null,
              _initEventListeners: function() {
                this.removeListeners();
                this._bindEvents();
                this.addOrRemove(addListener, "add");
              },
              _getEventPrefix: function() {
                return this.enablePointerEvents ? "pointer" : "mouse";
              },
              addOrRemove: function(functor, eventjsFunctor) {
                var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();
                functor(fabric.window, "resize", this._onResize);
                functor(canvasElement, eventTypePrefix + "down", this._onMouseDown);
                functor(canvasElement, eventTypePrefix + "move", this._onMouseMove, addEventOptions);
                functor(canvasElement, eventTypePrefix + "out", this._onMouseOut);
                functor(canvasElement, eventTypePrefix + "enter", this._onMouseEnter);
                functor(canvasElement, "wheel", this._onMouseWheel);
                functor(canvasElement, "contextmenu", this._onContextMenu);
                functor(canvasElement, "dblclick", this._onDoubleClick);
                functor(canvasElement, "dragover", this._onDragOver);
                functor(canvasElement, "dragenter", this._onDragEnter);
                functor(canvasElement, "dragleave", this._onDragLeave);
                functor(canvasElement, "drop", this._onDrop);
                if (!this.enablePointerEvents) {
                  functor(canvasElement, "touchstart", this._onTouchStart, addEventOptions);
                }
                if (typeof eventjs !== "undefined" && eventjsFunctor in eventjs) {
                  eventjs[eventjsFunctor](canvasElement, "gesture", this._onGesture);
                  eventjs[eventjsFunctor](canvasElement, "drag", this._onDrag);
                  eventjs[eventjsFunctor](canvasElement, "orientation", this._onOrientationChange);
                  eventjs[eventjsFunctor](canvasElement, "shake", this._onShake);
                  eventjs[eventjsFunctor](canvasElement, "longpress", this._onLongPress);
                }
              },
              removeListeners: function() {
                this.addOrRemove(removeListener, "remove");
                var eventTypePrefix = this._getEventPrefix();
                removeListener(fabric.document, eventTypePrefix + "up", this._onMouseUp);
                removeListener(fabric.document, "touchend", this._onTouchEnd, addEventOptions);
                removeListener(fabric.document, eventTypePrefix + "move", this._onMouseMove, addEventOptions);
                removeListener(fabric.document, "touchmove", this._onMouseMove, addEventOptions);
              },
              _bindEvents: function() {
                if (this.eventsBound) {
                  return;
                }
                this._onMouseDown = this._onMouseDown.bind(this);
                this._onTouchStart = this._onTouchStart.bind(this);
                this._onMouseMove = this._onMouseMove.bind(this);
                this._onMouseUp = this._onMouseUp.bind(this);
                this._onTouchEnd = this._onTouchEnd.bind(this);
                this._onResize = this._onResize.bind(this);
                this._onGesture = this._onGesture.bind(this);
                this._onDrag = this._onDrag.bind(this);
                this._onShake = this._onShake.bind(this);
                this._onLongPress = this._onLongPress.bind(this);
                this._onOrientationChange = this._onOrientationChange.bind(this);
                this._onMouseWheel = this._onMouseWheel.bind(this);
                this._onMouseOut = this._onMouseOut.bind(this);
                this._onMouseEnter = this._onMouseEnter.bind(this);
                this._onContextMenu = this._onContextMenu.bind(this);
                this._onDoubleClick = this._onDoubleClick.bind(this);
                this._onDragOver = this._onDragOver.bind(this);
                this._onDragEnter = this._simpleEventHandler.bind(this, "dragenter");
                this._onDragLeave = this._simpleEventHandler.bind(this, "dragleave");
                this._onDrop = this._simpleEventHandler.bind(this, "drop");
                this.eventsBound = true;
              },
              _onGesture: function(e2, self2) {
                this.__onTransformGesture && this.__onTransformGesture(e2, self2);
              },
              _onDrag: function(e2, self2) {
                this.__onDrag && this.__onDrag(e2, self2);
              },
              _onMouseWheel: function(e2) {
                this.__onMouseWheel(e2);
              },
              _onMouseOut: function(e2) {
                var target = this._hoveredTarget;
                this.fire("mouse:out", { target, e: e2 });
                this._hoveredTarget = null;
                target && target.fire("mouseout", { e: e2 });
                var _this = this;
                this._hoveredTargets.forEach(function(_target) {
                  _this.fire("mouse:out", { target, e: e2 });
                  _target && target.fire("mouseout", { e: e2 });
                });
                this._hoveredTargets = [];
                if (this._iTextInstances) {
                  this._iTextInstances.forEach(function(obj) {
                    if (obj.isEditing) {
                      obj.hiddenTextarea.focus();
                    }
                  });
                }
              },
              _onMouseEnter: function(e2) {
                if (!this._currentTransform && !this.findTarget(e2)) {
                  this.fire("mouse:over", { target: null, e: e2 });
                  this._hoveredTarget = null;
                  this._hoveredTargets = [];
                }
              },
              _onOrientationChange: function(e2, self2) {
                this.__onOrientationChange && this.__onOrientationChange(e2, self2);
              },
              _onShake: function(e2, self2) {
                this.__onShake && this.__onShake(e2, self2);
              },
              _onLongPress: function(e2, self2) {
                this.__onLongPress && this.__onLongPress(e2, self2);
              },
              _onDragOver: function(e2) {
                e2.preventDefault();
                var target = this._simpleEventHandler("dragover", e2);
                this._fireEnterLeaveEvents(target, e2);
              },
              _onContextMenu: function(e2) {
                if (this.stopContextMenu) {
                  e2.stopPropagation();
                  e2.preventDefault();
                }
                return false;
              },
              _onDoubleClick: function(e2) {
                this._cacheTransformEventData(e2);
                this._handleEvent(e2, "dblclick");
                this._resetTransformEventData(e2);
              },
              getPointerId: function(evt) {
                var changedTouches = evt.changedTouches;
                if (changedTouches) {
                  return changedTouches[0] && changedTouches[0].identifier;
                }
                if (this.enablePointerEvents) {
                  return evt.pointerId;
                }
                return -1;
              },
              _isMainEvent: function(evt) {
                if (evt.isPrimary === true) {
                  return true;
                }
                if (evt.isPrimary === false) {
                  return false;
                }
                if (evt.type === "touchend" && evt.touches.length === 0) {
                  return true;
                }
                if (evt.changedTouches) {
                  return evt.changedTouches[0].identifier === this.mainTouchId;
                }
                return true;
              },
              _onTouchStart: function(e2) {
                e2.preventDefault();
                if (this.mainTouchId === null) {
                  this.mainTouchId = this.getPointerId(e2);
                }
                this.__onMouseDown(e2);
                this._resetTransformEventData();
                var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();
                addListener(fabric.document, "touchend", this._onTouchEnd, addEventOptions);
                addListener(fabric.document, "touchmove", this._onMouseMove, addEventOptions);
                removeListener(canvasElement, eventTypePrefix + "down", this._onMouseDown);
              },
              _onMouseDown: function(e2) {
                this.__onMouseDown(e2);
                this._resetTransformEventData();
                var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();
                removeListener(canvasElement, eventTypePrefix + "move", this._onMouseMove, addEventOptions);
                addListener(fabric.document, eventTypePrefix + "up", this._onMouseUp);
                addListener(fabric.document, eventTypePrefix + "move", this._onMouseMove, addEventOptions);
              },
              _onTouchEnd: function(e2) {
                if (e2.touches.length > 0) {
                  return;
                }
                this.__onMouseUp(e2);
                this._resetTransformEventData();
                this.mainTouchId = null;
                var eventTypePrefix = this._getEventPrefix();
                removeListener(fabric.document, "touchend", this._onTouchEnd, addEventOptions);
                removeListener(fabric.document, "touchmove", this._onMouseMove, addEventOptions);
                var _this = this;
                if (this._willAddMouseDown) {
                  clearTimeout(this._willAddMouseDown);
                }
                this._willAddMouseDown = setTimeout(function() {
                  addListener(_this.upperCanvasEl, eventTypePrefix + "down", _this._onMouseDown);
                  _this._willAddMouseDown = 0;
                }, 400);
              },
              _onMouseUp: function(e2) {
                this.__onMouseUp(e2);
                this._resetTransformEventData();
                var canvasElement = this.upperCanvasEl, eventTypePrefix = this._getEventPrefix();
                if (this._isMainEvent(e2)) {
                  removeListener(fabric.document, eventTypePrefix + "up", this._onMouseUp);
                  removeListener(fabric.document, eventTypePrefix + "move", this._onMouseMove, addEventOptions);
                  addListener(canvasElement, eventTypePrefix + "move", this._onMouseMove, addEventOptions);
                }
              },
              _onMouseMove: function(e2) {
                !this.allowTouchScrolling && e2.preventDefault && e2.preventDefault();
                this.__onMouseMove(e2);
              },
              _onResize: function() {
                this.calcOffset();
              },
              _shouldRender: function(target) {
                var activeObject = this._activeObject;
                if (!!activeObject !== !!target || activeObject && target && activeObject !== target) {
                  return true;
                } else if (activeObject && activeObject.isEditing) {
                  return false;
                }
                return false;
              },
              __onMouseUp: function(e2) {
                var target, transform2 = this._currentTransform, groupSelector = this._groupSelector, shouldRender = false, isClick = !groupSelector || groupSelector.left === 0 && groupSelector.top === 0;
                this._cacheTransformEventData(e2);
                target = this._target;
                this._handleEvent(e2, "up:before");
                if (checkClick(e2, RIGHT_CLICK)) {
                  if (this.fireRightClick) {
                    this._handleEvent(e2, "up", RIGHT_CLICK, isClick);
                  }
                  return;
                }
                if (checkClick(e2, MIDDLE_CLICK)) {
                  if (this.fireMiddleClick) {
                    this._handleEvent(e2, "up", MIDDLE_CLICK, isClick);
                  }
                  this._resetTransformEventData();
                  return;
                }
                if (this.isDrawingMode && this._isCurrentlyDrawing) {
                  this._onMouseUpInDrawingMode(e2);
                  return;
                }
                if (!this._isMainEvent(e2)) {
                  return;
                }
                if (transform2) {
                  this._finalizeCurrentTransform(e2);
                  shouldRender = transform2.actionPerformed;
                }
                if (!isClick) {
                  var targetWasActive = target === this._activeObject;
                  this._maybeGroupObjects(e2);
                  if (!shouldRender) {
                    shouldRender = this._shouldRender(target) || !targetWasActive && target === this._activeObject;
                  }
                }
                if (target) {
                  if (target.selectable && target !== this._activeObject && target.activeOn === "up") {
                    this.setActiveObject(target, e2);
                    shouldRender = true;
                  } else {
                    var corner = target._findTargetCorner(
                      this.getPointer(e2, true),
                      fabric.util.isTouchEvent(e2)
                    );
                    var control = target.controls[corner], mouseUpHandler = control && control.getMouseUpHandler(e2, target, control);
                    if (mouseUpHandler) {
                      var pointer = this.getPointer(e2);
                      mouseUpHandler(e2, transform2, pointer.x, pointer.y);
                    }
                  }
                  target.isMoving = false;
                }
                this._setCursorFromEvent(e2, target);
                this._handleEvent(e2, "up", LEFT_CLICK, isClick);
                this._groupSelector = null;
                this._currentTransform = null;
                target && (target.__corner = 0);
                if (shouldRender) {
                  this.requestRenderAll();
                } else if (!isClick) {
                  this.renderTop();
                }
              },
              _simpleEventHandler: function(eventType, e2) {
                var target = this.findTarget(e2), targets = this.targets, options = {
                  e: e2,
                  target,
                  subTargets: targets
                };
                this.fire(eventType, options);
                target && target.fire(eventType, options);
                if (!targets) {
                  return target;
                }
                for (var i = 0; i < targets.length; i++) {
                  targets[i].fire(eventType, options);
                }
                return target;
              },
              _handleEvent: function(e2, eventType, button, isClick) {
                var target = this._target, targets = this.targets || [], options = {
                  e: e2,
                  target,
                  subTargets: targets,
                  button: button || LEFT_CLICK,
                  isClick: isClick || false,
                  pointer: this._pointer,
                  absolutePointer: this._absolutePointer,
                  transform: this._currentTransform
                };
                if (eventType === "up") {
                  options.currentTarget = this.findTarget(e2);
                  options.currentSubTargets = this.targets;
                }
                this.fire("mouse:" + eventType, options);
                target && target.fire("mouse" + eventType, options);
                for (var i = 0; i < targets.length; i++) {
                  targets[i].fire("mouse" + eventType, options);
                }
              },
              _finalizeCurrentTransform: function(e2) {
                var transform2 = this._currentTransform, target = transform2.target, eventName, options = {
                  e: e2,
                  target,
                  transform: transform2,
                  action: transform2.action
                };
                if (target._scaling) {
                  target._scaling = false;
                }
                target.setCoords();
                if (transform2.actionPerformed || this.stateful && target.hasStateChanged()) {
                  if (transform2.actionPerformed) {
                    eventName = this._addEventOptions(options, transform2);
                    this._fire(eventName, options);
                  }
                  this._fire("modified", options);
                }
              },
              _addEventOptions: function(options, transform2) {
                var eventName, by;
                switch (transform2.action) {
                  case "scaleX":
                    eventName = "scaled";
                    by = "x";
                    break;
                  case "scaleY":
                    eventName = "scaled";
                    by = "y";
                    break;
                  case "skewX":
                    eventName = "skewed";
                    by = "x";
                    break;
                  case "skewY":
                    eventName = "skewed";
                    by = "y";
                    break;
                  case "scale":
                    eventName = "scaled";
                    by = "equally";
                    break;
                  case "rotate":
                    eventName = "rotated";
                    break;
                  case "drag":
                    eventName = "moved";
                    break;
                }
                options.by = by;
                return eventName;
              },
              _onMouseDownInDrawingMode: function(e2) {
                this._isCurrentlyDrawing = true;
                if (this.getActiveObject()) {
                  this.discardActiveObject(e2).requestRenderAll();
                }
                var pointer = this.getPointer(e2);
                this.freeDrawingBrush.onMouseDown(pointer, { e: e2, pointer });
                this._handleEvent(e2, "down");
              },
              _onMouseMoveInDrawingMode: function(e2) {
                if (this._isCurrentlyDrawing) {
                  var pointer = this.getPointer(e2);
                  this.freeDrawingBrush.onMouseMove(pointer, { e: e2, pointer });
                }
                this.setCursor(this.freeDrawingCursor);
                this._handleEvent(e2, "move");
              },
              _onMouseUpInDrawingMode: function(e2) {
                var pointer = this.getPointer(e2);
                this._isCurrentlyDrawing = this.freeDrawingBrush.onMouseUp({ e: e2, pointer });
                this._handleEvent(e2, "up");
              },
              __onMouseDown: function(e2) {
                this._cacheTransformEventData(e2);
                this._handleEvent(e2, "down:before");
                var target = this._target;
                if (checkClick(e2, RIGHT_CLICK)) {
                  if (this.fireRightClick) {
                    this._handleEvent(e2, "down", RIGHT_CLICK);
                  }
                  return;
                }
                if (checkClick(e2, MIDDLE_CLICK)) {
                  if (this.fireMiddleClick) {
                    this._handleEvent(e2, "down", MIDDLE_CLICK);
                  }
                  return;
                }
                if (this.isDrawingMode) {
                  this._onMouseDownInDrawingMode(e2);
                  return;
                }
                if (!this._isMainEvent(e2)) {
                  return;
                }
                if (this._currentTransform) {
                  return;
                }
                var pointer = this._pointer;
                this._previousPointer = pointer;
                var shouldRender = this._shouldRender(target), shouldGroup = this._shouldGroup(e2, target);
                if (this._shouldClearSelection(e2, target)) {
                  this.discardActiveObject(e2);
                } else if (shouldGroup) {
                  this._handleGrouping(e2, target);
                  target = this._activeObject;
                }
                if (this.selection && (!target || !target.selectable && !target.isEditing && target !== this._activeObject)) {
                  this._groupSelector = {
                    ex: this._absolutePointer.x,
                    ey: this._absolutePointer.y,
                    top: 0,
                    left: 0
                  };
                }
                if (target) {
                  var alreadySelected = target === this._activeObject;
                  if (target.selectable && target.activeOn === "down") {
                    this.setActiveObject(target, e2);
                  }
                  var corner = target._findTargetCorner(
                    this.getPointer(e2, true),
                    fabric.util.isTouchEvent(e2)
                  );
                  target.__corner = corner;
                  if (target === this._activeObject && (corner || !shouldGroup)) {
                    this._setupCurrentTransform(e2, target, alreadySelected);
                    var control = target.controls[corner], pointer = this.getPointer(e2), mouseDownHandler = control && control.getMouseDownHandler(e2, target, control);
                    if (mouseDownHandler) {
                      mouseDownHandler(e2, this._currentTransform, pointer.x, pointer.y);
                    }
                  }
                }
                this._handleEvent(e2, "down");
                (shouldRender || shouldGroup) && this.requestRenderAll();
              },
              _resetTransformEventData: function() {
                this._target = null;
                this._pointer = null;
                this._absolutePointer = null;
              },
              _cacheTransformEventData: function(e2) {
                this._resetTransformEventData();
                this._pointer = this.getPointer(e2, true);
                this._absolutePointer = this.restorePointerVpt(this._pointer);
                this._target = this._currentTransform ? this._currentTransform.target : this.findTarget(e2) || null;
              },
              _beforeTransform: function(e2) {
                var t = this._currentTransform;
                this.stateful && t.target.saveState();
                this.fire("before:transform", {
                  e: e2,
                  transform: t
                });
              },
              __onMouseMove: function(e2) {
                this._handleEvent(e2, "move:before");
                this._cacheTransformEventData(e2);
                var target, pointer;
                if (this.isDrawingMode) {
                  this._onMouseMoveInDrawingMode(e2);
                  return;
                }
                if (!this._isMainEvent(e2)) {
                  return;
                }
                var groupSelector = this._groupSelector;
                if (groupSelector) {
                  pointer = this._absolutePointer;
                  groupSelector.left = pointer.x - groupSelector.ex;
                  groupSelector.top = pointer.y - groupSelector.ey;
                  this.renderTop();
                } else if (!this._currentTransform) {
                  target = this.findTarget(e2) || null;
                  this._setCursorFromEvent(e2, target);
                  this._fireOverOutEvents(target, e2);
                } else {
                  this._transformObject(e2);
                }
                this._handleEvent(e2, "move");
                this._resetTransformEventData();
              },
              _fireOverOutEvents: function(target, e2) {
                var _hoveredTarget = this._hoveredTarget, _hoveredTargets = this._hoveredTargets, targets = this.targets, length = Math.max(_hoveredTargets.length, targets.length);
                this.fireSyntheticInOutEvents(target, e2, {
                  oldTarget: _hoveredTarget,
                  evtOut: "mouseout",
                  canvasEvtOut: "mouse:out",
                  evtIn: "mouseover",
                  canvasEvtIn: "mouse:over"
                });
                for (var i = 0; i < length; i++) {
                  this.fireSyntheticInOutEvents(targets[i], e2, {
                    oldTarget: _hoveredTargets[i],
                    evtOut: "mouseout",
                    evtIn: "mouseover"
                  });
                }
                this._hoveredTarget = target;
                this._hoveredTargets = this.targets.concat();
              },
              _fireEnterLeaveEvents: function(target, e2) {
                var _draggedoverTarget = this._draggedoverTarget, _hoveredTargets = this._hoveredTargets, targets = this.targets, length = Math.max(_hoveredTargets.length, targets.length);
                this.fireSyntheticInOutEvents(target, e2, {
                  oldTarget: _draggedoverTarget,
                  evtOut: "dragleave",
                  evtIn: "dragenter"
                });
                for (var i = 0; i < length; i++) {
                  this.fireSyntheticInOutEvents(targets[i], e2, {
                    oldTarget: _hoveredTargets[i],
                    evtOut: "dragleave",
                    evtIn: "dragenter"
                  });
                }
                this._draggedoverTarget = target;
              },
              fireSyntheticInOutEvents: function(target, e2, config2) {
                var inOpt, outOpt, oldTarget = config2.oldTarget, outFires, inFires, targetChanged = oldTarget !== target, canvasEvtIn = config2.canvasEvtIn, canvasEvtOut = config2.canvasEvtOut;
                if (targetChanged) {
                  inOpt = { e: e2, target, previousTarget: oldTarget };
                  outOpt = { e: e2, target: oldTarget, nextTarget: target };
                }
                inFires = target && targetChanged;
                outFires = oldTarget && targetChanged;
                if (outFires) {
                  canvasEvtOut && this.fire(canvasEvtOut, outOpt);
                  oldTarget.fire(config2.evtOut, outOpt);
                }
                if (inFires) {
                  canvasEvtIn && this.fire(canvasEvtIn, inOpt);
                  target.fire(config2.evtIn, inOpt);
                }
              },
              __onMouseWheel: function(e2) {
                this._cacheTransformEventData(e2);
                this._handleEvent(e2, "wheel");
                this._resetTransformEventData();
              },
              _transformObject: function(e2) {
                var pointer = this.getPointer(e2), transform2 = this._currentTransform;
                transform2.reset = false;
                transform2.shiftKey = e2.shiftKey;
                transform2.altKey = e2[this.centeredKey];
                this._performTransformAction(e2, transform2, pointer);
                transform2.actionPerformed && this.requestRenderAll();
              },
              _performTransformAction: function(e2, transform2, pointer) {
                var x = pointer.x, y = pointer.y, action = transform2.action, actionPerformed = false, actionHandler = transform2.actionHandler;
                if (actionHandler) {
                  actionPerformed = actionHandler(e2, transform2, x, y);
                }
                if (action === "drag" && actionPerformed) {
                  transform2.target.isMoving = true;
                  this.setCursor(transform2.target.moveCursor || this.moveCursor);
                }
                transform2.actionPerformed = transform2.actionPerformed || actionPerformed;
              },
              _fire: fabric.controlsUtils.fireEvent,
              _setCursorFromEvent: function(e2, target) {
                if (!target) {
                  this.setCursor(this.defaultCursor);
                  return false;
                }
                var hoverCursor = target.hoverCursor || this.hoverCursor, activeSelection = this._activeObject && this._activeObject.type === "activeSelection" ? this._activeObject : null, corner = (!activeSelection || !activeSelection.contains(target)) && target._findTargetCorner(this.getPointer(e2, true));
                if (!corner) {
                  if (target.subTargetCheck) {
                    this.targets.concat().reverse().map(function(_target) {
                      hoverCursor = _target.hoverCursor || hoverCursor;
                    });
                  }
                  this.setCursor(hoverCursor);
                } else {
                  this.setCursor(this.getCornerCursor(corner, target, e2));
                }
              },
              getCornerCursor: function(corner, target, e2) {
                var control = target.controls[corner];
                return control.cursorStyleHandler(e2, control, target);
              }
            });
          })();
          (function() {
            var min = Math.min, max2 = Math.max;
            fabric.util.object.extend(fabric.Canvas.prototype, {
              _shouldGroup: function(e2, target) {
                var activeObject = this._activeObject;
                return activeObject && this._isSelectionKeyPressed(e2) && target && target.selectable && this.selection && (activeObject !== target || activeObject.type === "activeSelection") && !target.onSelect({ e: e2 });
              },
              _handleGrouping: function(e2, target) {
                var activeObject = this._activeObject;
                if (activeObject.__corner) {
                  return;
                }
                if (target === activeObject) {
                  target = this.findTarget(e2, true);
                  if (!target || !target.selectable) {
                    return;
                  }
                }
                if (activeObject && activeObject.type === "activeSelection") {
                  this._updateActiveSelection(target, e2);
                } else {
                  this._createActiveSelection(target, e2);
                }
              },
              _updateActiveSelection: function(target, e2) {
                var activeSelection = this._activeObject, currentActiveObjects = activeSelection._objects.slice(0);
                if (activeSelection.contains(target)) {
                  activeSelection.removeWithUpdate(target);
                  this._hoveredTarget = target;
                  this._hoveredTargets = this.targets.concat();
                  if (activeSelection.size() === 1) {
                    this._setActiveObject(activeSelection.item(0), e2);
                  }
                } else {
                  activeSelection.addWithUpdate(target);
                  this._hoveredTarget = activeSelection;
                  this._hoveredTargets = this.targets.concat();
                }
                this._fireSelectionEvents(currentActiveObjects, e2);
              },
              _createActiveSelection: function(target, e2) {
                var currentActives = this.getActiveObjects(), group = this._createGroup(target);
                this._hoveredTarget = group;
                this._setActiveObject(group, e2);
                this._fireSelectionEvents(currentActives, e2);
              },
              _createGroup: function(target) {
                var objects = this._objects, isActiveLower = objects.indexOf(this._activeObject) < objects.indexOf(target), groupObjects = isActiveLower ? [this._activeObject, target] : [target, this._activeObject];
                this._activeObject.isEditing && this._activeObject.exitEditing();
                return new fabric.ActiveSelection(groupObjects, {
                  canvas: this
                });
              },
              _groupSelectedObjects: function(e2) {
                var group = this._collectObjects(e2), aGroup;
                if (group.length === 1) {
                  this.setActiveObject(group[0], e2);
                } else if (group.length > 1) {
                  aGroup = new fabric.ActiveSelection(group.reverse(), {
                    canvas: this
                  });
                  this.setActiveObject(aGroup, e2);
                }
              },
              _collectObjects: function(e2) {
                var group = [], currentObject, x1 = this._groupSelector.ex, y1 = this._groupSelector.ey, x2 = x1 + this._groupSelector.left, y2 = y1 + this._groupSelector.top, selectionX1Y1 = new fabric.Point(min(x1, x2), min(y1, y2)), selectionX2Y2 = new fabric.Point(max2(x1, x2), max2(y1, y2)), allowIntersect = !this.selectionFullyContained, isClick = x1 === x2 && y1 === y2;
                for (var i = this._objects.length; i--; ) {
                  currentObject = this._objects[i];
                  if (!currentObject || !currentObject.selectable || !currentObject.visible) {
                    continue;
                  }
                  if (allowIntersect && currentObject.intersectsWithRect(selectionX1Y1, selectionX2Y2, true) || currentObject.isContainedWithinRect(selectionX1Y1, selectionX2Y2, true) || allowIntersect && currentObject.containsPoint(selectionX1Y1, null, true) || allowIntersect && currentObject.containsPoint(selectionX2Y2, null, true)) {
                    group.push(currentObject);
                    if (isClick) {
                      break;
                    }
                  }
                }
                if (group.length > 1) {
                  group = group.filter(function(object) {
                    return !object.onSelect({ e: e2 });
                  });
                }
                return group;
              },
              _maybeGroupObjects: function(e2) {
                if (this.selection && this._groupSelector) {
                  this._groupSelectedObjects(e2);
                }
                this.setCursor(this.defaultCursor);
                this._groupSelector = null;
              }
            });
          })();
          (function() {
            fabric.util.object.extend(fabric.StaticCanvas.prototype, {
              toDataURL: function(options) {
                options || (options = {});
                var format = options.format || "png", quality = options.quality || 1, multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? this.getRetinaScaling() : 1), canvasEl = this.toCanvasElement(multiplier, options);
                return fabric.util.toDataURL(canvasEl, format, quality);
              },
              toCanvasElement: function(multiplier, cropping) {
                multiplier = multiplier || 1;
                cropping = cropping || {};
                var scaledWidth = (cropping.width || this.width) * multiplier, scaledHeight = (cropping.height || this.height) * multiplier, zoom = this.getZoom(), originalWidth = this.width, originalHeight = this.height, newZoom = zoom * multiplier, vp = this.viewportTransform, translateX = (vp[4] - (cropping.left || 0)) * multiplier, translateY = (vp[5] - (cropping.top || 0)) * multiplier, originalInteractive = this.interactive, newVp = [newZoom, 0, 0, newZoom, translateX, translateY], originalRetina = this.enableRetinaScaling, canvasEl = fabric.util.createCanvasElement(), originalContextTop = this.contextTop;
                canvasEl.width = scaledWidth;
                canvasEl.height = scaledHeight;
                this.contextTop = null;
                this.enableRetinaScaling = false;
                this.interactive = false;
                this.viewportTransform = newVp;
                this.width = scaledWidth;
                this.height = scaledHeight;
                this.calcViewportBoundaries();
                this.renderCanvas(canvasEl.getContext("2d"), this._objects);
                this.viewportTransform = vp;
                this.width = originalWidth;
                this.height = originalHeight;
                this.calcViewportBoundaries();
                this.interactive = originalInteractive;
                this.enableRetinaScaling = originalRetina;
                this.contextTop = originalContextTop;
                return canvasEl;
              }
            });
          })();
          fabric.util.object.extend(fabric.StaticCanvas.prototype, {
            loadFromJSON: function(json, callback, reviver) {
              if (!json) {
                return;
              }
              var serialized = typeof json === "string" ? JSON.parse(json) : fabric.util.object.clone(json);
              var _this = this, clipPath = serialized.clipPath, renderOnAddRemove = this.renderOnAddRemove;
              this.renderOnAddRemove = false;
              delete serialized.clipPath;
              this._enlivenObjects(serialized.objects, function(enlivenedObjects) {
                _this.clear();
                _this._setBgOverlay(serialized, function() {
                  if (clipPath) {
                    _this._enlivenObjects([clipPath], function(enlivenedCanvasClip) {
                      _this.clipPath = enlivenedCanvasClip[0];
                      _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);
                    });
                  } else {
                    _this.__setupCanvas.call(_this, serialized, enlivenedObjects, renderOnAddRemove, callback);
                  }
                });
              }, reviver);
              return this;
            },
            __setupCanvas: function(serialized, enlivenedObjects, renderOnAddRemove, callback) {
              var _this = this;
              enlivenedObjects.forEach(function(obj, index2) {
                _this.insertAt(obj, index2);
              });
              this.renderOnAddRemove = renderOnAddRemove;
              delete serialized.objects;
              delete serialized.backgroundImage;
              delete serialized.overlayImage;
              delete serialized.background;
              delete serialized.overlay;
              this._setOptions(serialized);
              this.renderAll();
              callback && callback();
            },
            _setBgOverlay: function(serialized, callback) {
              var loaded = {
                backgroundColor: false,
                overlayColor: false,
                backgroundImage: false,
                overlayImage: false
              };
              if (!serialized.backgroundImage && !serialized.overlayImage && !serialized.background && !serialized.overlay) {
                callback && callback();
                return;
              }
              var cbIfLoaded = function() {
                if (loaded.backgroundImage && loaded.overlayImage && loaded.backgroundColor && loaded.overlayColor) {
                  callback && callback();
                }
              };
              this.__setBgOverlay("backgroundImage", serialized.backgroundImage, loaded, cbIfLoaded);
              this.__setBgOverlay("overlayImage", serialized.overlayImage, loaded, cbIfLoaded);
              this.__setBgOverlay("backgroundColor", serialized.background, loaded, cbIfLoaded);
              this.__setBgOverlay("overlayColor", serialized.overlay, loaded, cbIfLoaded);
            },
            __setBgOverlay: function(property, value, loaded, callback) {
              var _this = this;
              if (!value) {
                loaded[property] = true;
                callback && callback();
                return;
              }
              if (property === "backgroundImage" || property === "overlayImage") {
                fabric.util.enlivenObjects([value], function(enlivedObject) {
                  _this[property] = enlivedObject[0];
                  loaded[property] = true;
                  callback && callback();
                });
              } else {
                this["set" + fabric.util.string.capitalize(property, true)](value, function() {
                  loaded[property] = true;
                  callback && callback();
                });
              }
            },
            _enlivenObjects: function(objects, callback, reviver) {
              if (!objects || objects.length === 0) {
                callback && callback([]);
                return;
              }
              fabric.util.enlivenObjects(objects, function(enlivenedObjects) {
                callback && callback(enlivenedObjects);
              }, null, reviver);
            },
            _toDataURL: function(format, callback) {
              this.clone(function(clone2) {
                callback(clone2.toDataURL(format));
              });
            },
            _toDataURLWithMultiplier: function(format, multiplier, callback) {
              this.clone(function(clone2) {
                callback(clone2.toDataURLWithMultiplier(format, multiplier));
              });
            },
            clone: function(callback, properties) {
              var data = JSON.stringify(this.toJSON(properties));
              this.cloneWithoutData(function(clone2) {
                clone2.loadFromJSON(data, function() {
                  callback && callback(clone2);
                });
              });
            },
            cloneWithoutData: function(callback) {
              var el = fabric.util.createCanvasElement();
              el.width = this.width;
              el.height = this.height;
              var clone2 = new fabric.Canvas(el);
              if (this.backgroundImage) {
                clone2.setBackgroundImage(this.backgroundImage.src, function() {
                  clone2.renderAll();
                  callback && callback(clone2);
                });
                clone2.backgroundImageOpacity = this.backgroundImageOpacity;
                clone2.backgroundImageStretch = this.backgroundImageStretch;
              } else {
                callback && callback(clone2);
              }
            }
          });
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), extend2 = fabric2.util.object.extend, clone2 = fabric2.util.object.clone, toFixed2 = fabric2.util.toFixed, capitalize2 = fabric2.util.string.capitalize, degreesToRadians = fabric2.util.degreesToRadians, objectCaching = !fabric2.isLikelyNode, ALIASING_LIMIT = 2;
            if (fabric2.Object) {
              return;
            }
            fabric2.Object = fabric2.util.createClass(fabric2.CommonMethods, {
              type: "object",
              originX: "left",
              originY: "top",
              top: 0,
              left: 0,
              width: 0,
              height: 0,
              scaleX: 1,
              scaleY: 1,
              flipX: false,
              flipY: false,
              opacity: 1,
              angle: 0,
              skewX: 0,
              skewY: 0,
              cornerSize: 13,
              touchCornerSize: 24,
              transparentCorners: true,
              hoverCursor: null,
              moveCursor: null,
              padding: 0,
              borderColor: "rgb(178,204,255)",
              borderDashArray: null,
              cornerColor: "rgb(178,204,255)",
              cornerStrokeColor: null,
              cornerStyle: "rect",
              cornerDashArray: null,
              centeredScaling: false,
              centeredRotation: true,
              fill: "rgb(0,0,0)",
              fillRule: "nonzero",
              globalCompositeOperation: "source-over",
              backgroundColor: "",
              selectionBackgroundColor: "",
              stroke: null,
              strokeWidth: 1,
              strokeDashArray: null,
              strokeDashOffset: 0,
              strokeLineCap: "butt",
              strokeLineJoin: "miter",
              strokeMiterLimit: 4,
              shadow: null,
              borderOpacityWhenMoving: 0.4,
              borderScaleFactor: 1,
              minScaleLimit: 0,
              selectable: true,
              evented: true,
              visible: true,
              hasControls: true,
              hasBorders: true,
              perPixelTargetFind: false,
              includeDefaultValues: true,
              lockMovementX: false,
              lockMovementY: false,
              lockRotation: false,
              lockScalingX: false,
              lockScalingY: false,
              lockSkewingX: false,
              lockSkewingY: false,
              lockScalingFlip: false,
              excludeFromExport: false,
              objectCaching,
              statefullCache: false,
              noScaleCache: true,
              strokeUniform: false,
              dirty: true,
              __corner: 0,
              paintFirst: "fill",
              activeOn: "down",
              stateProperties: "top left width height scaleX scaleY flipX flipY originX originY transformMatrix stroke strokeWidth strokeDashArray strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit angle opacity fill globalCompositeOperation shadow visible backgroundColor skewX skewY fillRule paintFirst clipPath strokeUniform".split(" "),
              cacheProperties: "fill stroke strokeWidth strokeDashArray width height paintFirst strokeUniform strokeLineCap strokeDashOffset strokeLineJoin strokeMiterLimit backgroundColor clipPath".split(" "),
              colorProperties: "fill stroke backgroundColor".split(" "),
              clipPath: void 0,
              inverted: false,
              absolutePositioned: false,
              initialize: function(options) {
                if (options) {
                  this.setOptions(options);
                }
              },
              _createCacheCanvas: function() {
                this._cacheProperties = {};
                this._cacheCanvas = fabric2.util.createCanvasElement();
                this._cacheContext = this._cacheCanvas.getContext("2d");
                this._updateCacheCanvas();
                this.dirty = true;
              },
              _limitCacheSize: function(dims) {
                var perfLimitSizeTotal = fabric2.perfLimitSizeTotal, width = dims.width, height = dims.height, max2 = fabric2.maxCacheSideLimit, min = fabric2.minCacheSideLimit;
                if (width <= max2 && height <= max2 && width * height <= perfLimitSizeTotal) {
                  if (width < min) {
                    dims.width = min;
                  }
                  if (height < min) {
                    dims.height = min;
                  }
                  return dims;
                }
                var ar = width / height, limitedDims = fabric2.util.limitDimsByArea(ar, perfLimitSizeTotal), capValue = fabric2.util.capValue, x = capValue(min, limitedDims.x, max2), y = capValue(min, limitedDims.y, max2);
                if (width > x) {
                  dims.zoomX /= width / x;
                  dims.width = x;
                  dims.capped = true;
                }
                if (height > y) {
                  dims.zoomY /= height / y;
                  dims.height = y;
                  dims.capped = true;
                }
                return dims;
              },
              _getCacheCanvasDimensions: function() {
                var objectScale = this.getTotalObjectScaling(), dim = this._getTransformedDimensions(0, 0), neededX = dim.x * objectScale.scaleX / this.scaleX, neededY = dim.y * objectScale.scaleY / this.scaleY;
                return {
                  width: neededX + ALIASING_LIMIT,
                  height: neededY + ALIASING_LIMIT,
                  zoomX: objectScale.scaleX,
                  zoomY: objectScale.scaleY,
                  x: neededX,
                  y: neededY
                };
              },
              _updateCacheCanvas: function() {
                var targetCanvas = this.canvas;
                if (this.noScaleCache && targetCanvas && targetCanvas._currentTransform) {
                  var target = targetCanvas._currentTransform.target, action = targetCanvas._currentTransform.action;
                  if (this === target && action.slice && action.slice(0, 5) === "scale") {
                    return false;
                  }
                }
                var canvas = this._cacheCanvas, dims = this._limitCacheSize(this._getCacheCanvasDimensions()), minCacheSize = fabric2.minCacheSideLimit, width = dims.width, height = dims.height, drawingWidth, drawingHeight, zoomX = dims.zoomX, zoomY = dims.zoomY, dimensionsChanged = width !== this.cacheWidth || height !== this.cacheHeight, zoomChanged = this.zoomX !== zoomX || this.zoomY !== zoomY, shouldRedraw = dimensionsChanged || zoomChanged, additionalWidth = 0, additionalHeight = 0, shouldResizeCanvas = false;
                if (dimensionsChanged) {
                  var canvasWidth = this._cacheCanvas.width, canvasHeight = this._cacheCanvas.height, sizeGrowing = width > canvasWidth || height > canvasHeight, sizeShrinking = (width < canvasWidth * 0.9 || height < canvasHeight * 0.9) && canvasWidth > minCacheSize && canvasHeight > minCacheSize;
                  shouldResizeCanvas = sizeGrowing || sizeShrinking;
                  if (sizeGrowing && !dims.capped && (width > minCacheSize || height > minCacheSize)) {
                    additionalWidth = width * 0.1;
                    additionalHeight = height * 0.1;
                  }
                }
                if (this instanceof fabric2.Text && this.path) {
                  shouldRedraw = true;
                  shouldResizeCanvas = true;
                  additionalWidth += this.getHeightOfLine(0) * this.zoomX;
                  additionalHeight += this.getHeightOfLine(0) * this.zoomY;
                }
                if (shouldRedraw) {
                  if (shouldResizeCanvas) {
                    canvas.width = Math.ceil(width + additionalWidth);
                    canvas.height = Math.ceil(height + additionalHeight);
                  } else {
                    this._cacheContext.setTransform(1, 0, 0, 1, 0, 0);
                    this._cacheContext.clearRect(0, 0, canvas.width, canvas.height);
                  }
                  drawingWidth = dims.x / 2;
                  drawingHeight = dims.y / 2;
                  this.cacheTranslationX = Math.round(canvas.width / 2 - drawingWidth) + drawingWidth;
                  this.cacheTranslationY = Math.round(canvas.height / 2 - drawingHeight) + drawingHeight;
                  this.cacheWidth = width;
                  this.cacheHeight = height;
                  this._cacheContext.translate(this.cacheTranslationX, this.cacheTranslationY);
                  this._cacheContext.scale(zoomX, zoomY);
                  this.zoomX = zoomX;
                  this.zoomY = zoomY;
                  return true;
                }
                return false;
              },
              setOptions: function(options) {
                this._setOptions(options);
                this._initGradient(options.fill, "fill");
                this._initGradient(options.stroke, "stroke");
                this._initPattern(options.fill, "fill");
                this._initPattern(options.stroke, "stroke");
              },
              transform: function(ctx) {
                var needFullTransform = this.group && !this.group._transformDone || this.group && this.canvas && ctx === this.canvas.contextTop;
                var m = this.calcTransformMatrix(!needFullTransform);
                ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
              },
              toObject: function(propertiesToInclude) {
                var NUM_FRACTION_DIGITS = fabric2.Object.NUM_FRACTION_DIGITS, object = {
                  type: this.type,
                  version: fabric2.version,
                  originX: this.originX,
                  originY: this.originY,
                  left: toFixed2(this.left, NUM_FRACTION_DIGITS),
                  top: toFixed2(this.top, NUM_FRACTION_DIGITS),
                  width: toFixed2(this.width, NUM_FRACTION_DIGITS),
                  height: toFixed2(this.height, NUM_FRACTION_DIGITS),
                  fill: this.fill && this.fill.toObject ? this.fill.toObject() : this.fill,
                  stroke: this.stroke && this.stroke.toObject ? this.stroke.toObject() : this.stroke,
                  strokeWidth: toFixed2(this.strokeWidth, NUM_FRACTION_DIGITS),
                  strokeDashArray: this.strokeDashArray ? this.strokeDashArray.concat() : this.strokeDashArray,
                  strokeLineCap: this.strokeLineCap,
                  strokeDashOffset: this.strokeDashOffset,
                  strokeLineJoin: this.strokeLineJoin,
                  strokeUniform: this.strokeUniform,
                  strokeMiterLimit: toFixed2(this.strokeMiterLimit, NUM_FRACTION_DIGITS),
                  scaleX: toFixed2(this.scaleX, NUM_FRACTION_DIGITS),
                  scaleY: toFixed2(this.scaleY, NUM_FRACTION_DIGITS),
                  angle: toFixed2(this.angle, NUM_FRACTION_DIGITS),
                  flipX: this.flipX,
                  flipY: this.flipY,
                  opacity: toFixed2(this.opacity, NUM_FRACTION_DIGITS),
                  shadow: this.shadow && this.shadow.toObject ? this.shadow.toObject() : this.shadow,
                  visible: this.visible,
                  backgroundColor: this.backgroundColor,
                  fillRule: this.fillRule,
                  paintFirst: this.paintFirst,
                  globalCompositeOperation: this.globalCompositeOperation,
                  skewX: toFixed2(this.skewX, NUM_FRACTION_DIGITS),
                  skewY: toFixed2(this.skewY, NUM_FRACTION_DIGITS)
                };
                if (this.clipPath && !this.clipPath.excludeFromExport) {
                  object.clipPath = this.clipPath.toObject(propertiesToInclude);
                  object.clipPath.inverted = this.clipPath.inverted;
                  object.clipPath.absolutePositioned = this.clipPath.absolutePositioned;
                }
                fabric2.util.populateWithProperties(this, object, propertiesToInclude);
                if (!this.includeDefaultValues) {
                  object = this._removeDefaultValues(object);
                }
                return object;
              },
              toDatalessObject: function(propertiesToInclude) {
                return this.toObject(propertiesToInclude);
              },
              _removeDefaultValues: function(object) {
                var prototype = fabric2.util.getKlass(object.type).prototype, stateProperties = prototype.stateProperties;
                stateProperties.forEach(function(prop) {
                  if (prop === "left" || prop === "top") {
                    return;
                  }
                  if (object[prop] === prototype[prop]) {
                    delete object[prop];
                  }
                  var isArray2 = Object.prototype.toString.call(object[prop]) === "[object Array]" && Object.prototype.toString.call(prototype[prop]) === "[object Array]";
                  if (isArray2 && object[prop].length === 0 && prototype[prop].length === 0) {
                    delete object[prop];
                  }
                });
                return object;
              },
              toString: function() {
                return "#<fabric." + capitalize2(this.type) + ">";
              },
              getObjectScaling: function() {
                if (!this.group) {
                  return {
                    scaleX: this.scaleX,
                    scaleY: this.scaleY
                  };
                }
                var options = fabric2.util.qrDecompose(this.calcTransformMatrix());
                return { scaleX: Math.abs(options.scaleX), scaleY: Math.abs(options.scaleY) };
              },
              getTotalObjectScaling: function() {
                var scale = this.getObjectScaling(), scaleX = scale.scaleX, scaleY = scale.scaleY;
                if (this.canvas) {
                  var zoom = this.canvas.getZoom();
                  var retina = this.canvas.getRetinaScaling();
                  scaleX *= zoom * retina;
                  scaleY *= zoom * retina;
                }
                return { scaleX, scaleY };
              },
              getObjectOpacity: function() {
                var opacity2 = this.opacity;
                if (this.group) {
                  opacity2 *= this.group.getObjectOpacity();
                }
                return opacity2;
              },
              _set: function(key, value) {
                var shouldConstrainValue = key === "scaleX" || key === "scaleY", isChanged = this[key] !== value, groupNeedsUpdate = false;
                if (shouldConstrainValue) {
                  value = this._constrainScale(value);
                }
                if (key === "scaleX" && value < 0) {
                  this.flipX = !this.flipX;
                  value *= -1;
                } else if (key === "scaleY" && value < 0) {
                  this.flipY = !this.flipY;
                  value *= -1;
                } else if (key === "shadow" && value && !(value instanceof fabric2.Shadow)) {
                  value = new fabric2.Shadow(value);
                } else if (key === "dirty" && this.group) {
                  this.group.set("dirty", value);
                }
                this[key] = value;
                if (isChanged) {
                  groupNeedsUpdate = this.group && this.group.isOnACache();
                  if (this.cacheProperties.indexOf(key) > -1) {
                    this.dirty = true;
                    groupNeedsUpdate && this.group.set("dirty", true);
                  } else if (groupNeedsUpdate && this.stateProperties.indexOf(key) > -1) {
                    this.group.set("dirty", true);
                  }
                }
                return this;
              },
              setOnGroup: function() {
              },
              getViewportTransform: function() {
                if (this.canvas && this.canvas.viewportTransform) {
                  return this.canvas.viewportTransform;
                }
                return fabric2.iMatrix.concat();
              },
              isNotVisible: function() {
                return this.opacity === 0 || !this.width && !this.height && this.strokeWidth === 0 || !this.visible;
              },
              render: function(ctx) {
                if (this.isNotVisible()) {
                  return;
                }
                if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
                  return;
                }
                ctx.save();
                this._setupCompositeOperation(ctx);
                this.drawSelectionBackground(ctx);
                this.transform(ctx);
                this._setOpacity(ctx);
                this._setShadow(ctx, this);
                if (this.shouldCache()) {
                  this.renderCache();
                  this.drawCacheOnCanvas(ctx);
                } else {
                  this._removeCacheCanvas();
                  this.dirty = false;
                  this.drawObject(ctx);
                  if (this.objectCaching && this.statefullCache) {
                    this.saveState({ propertySet: "cacheProperties" });
                  }
                }
                ctx.restore();
              },
              renderCache: function(options) {
                options = options || {};
                if (!this._cacheCanvas) {
                  this._createCacheCanvas();
                }
                if (this.isCacheDirty()) {
                  this.statefullCache && this.saveState({ propertySet: "cacheProperties" });
                  this.drawObject(this._cacheContext, options.forClipping);
                  this.dirty = false;
                }
              },
              _removeCacheCanvas: function() {
                this._cacheCanvas = null;
                this.cacheWidth = 0;
                this.cacheHeight = 0;
              },
              hasStroke: function() {
                return this.stroke && this.stroke !== "transparent" && this.strokeWidth !== 0;
              },
              hasFill: function() {
                return this.fill && this.fill !== "transparent";
              },
              needsItsOwnCache: function() {
                if (this.paintFirst === "stroke" && this.hasFill() && this.hasStroke() && typeof this.shadow === "object") {
                  return true;
                }
                if (this.clipPath) {
                  return true;
                }
                return false;
              },
              shouldCache: function() {
                this.ownCaching = this.needsItsOwnCache() || this.objectCaching && (!this.group || !this.group.isOnACache());
                return this.ownCaching;
              },
              willDrawShadow: function() {
                return !!this.shadow && (this.shadow.offsetX !== 0 || this.shadow.offsetY !== 0);
              },
              drawClipPathOnCache: function(ctx) {
                var path = this.clipPath;
                ctx.save();
                if (path.inverted) {
                  ctx.globalCompositeOperation = "destination-out";
                } else {
                  ctx.globalCompositeOperation = "destination-in";
                }
                if (path.absolutePositioned) {
                  var m = fabric2.util.invertTransform(this.calcTransformMatrix());
                  ctx.transform(m[0], m[1], m[2], m[3], m[4], m[5]);
                }
                path.transform(ctx);
                ctx.scale(1 / path.zoomX, 1 / path.zoomY);
                ctx.drawImage(path._cacheCanvas, -path.cacheTranslationX, -path.cacheTranslationY);
                ctx.restore();
              },
              drawObject: function(ctx, forClipping) {
                var originalFill = this.fill, originalStroke = this.stroke;
                if (forClipping) {
                  this.fill = "black";
                  this.stroke = "";
                  this._setClippingProperties(ctx);
                } else {
                  this._renderBackground(ctx);
                }
                this._render(ctx);
                this._drawClipPath(ctx);
                this.fill = originalFill;
                this.stroke = originalStroke;
              },
              _drawClipPath: function(ctx) {
                var path = this.clipPath;
                if (!path) {
                  return;
                }
                path.canvas = this.canvas;
                path.shouldCache();
                path._transformDone = true;
                path.renderCache({ forClipping: true });
                this.drawClipPathOnCache(ctx);
              },
              drawCacheOnCanvas: function(ctx) {
                ctx.scale(1 / this.zoomX, 1 / this.zoomY);
                ctx.drawImage(this._cacheCanvas, -this.cacheTranslationX, -this.cacheTranslationY);
              },
              isCacheDirty: function(skipCanvas) {
                if (this.isNotVisible()) {
                  return false;
                }
                if (this._cacheCanvas && !skipCanvas && this._updateCacheCanvas()) {
                  return true;
                } else {
                  if (this.dirty || this.clipPath && this.clipPath.absolutePositioned || this.statefullCache && this.hasStateChanged("cacheProperties")) {
                    if (this._cacheCanvas && !skipCanvas) {
                      var width = this.cacheWidth / this.zoomX;
                      var height = this.cacheHeight / this.zoomY;
                      this._cacheContext.clearRect(-width / 2, -height / 2, width, height);
                    }
                    return true;
                  }
                }
                return false;
              },
              _renderBackground: function(ctx) {
                if (!this.backgroundColor) {
                  return;
                }
                var dim = this._getNonTransformedDimensions();
                ctx.fillStyle = this.backgroundColor;
                ctx.fillRect(
                  -dim.x / 2,
                  -dim.y / 2,
                  dim.x,
                  dim.y
                );
                this._removeShadow(ctx);
              },
              _setOpacity: function(ctx) {
                if (this.group && !this.group._transformDone) {
                  ctx.globalAlpha = this.getObjectOpacity();
                } else {
                  ctx.globalAlpha *= this.opacity;
                }
              },
              _setStrokeStyles: function(ctx, decl) {
                var stroke = decl.stroke;
                if (stroke) {
                  ctx.lineWidth = decl.strokeWidth;
                  ctx.lineCap = decl.strokeLineCap;
                  ctx.lineDashOffset = decl.strokeDashOffset;
                  ctx.lineJoin = decl.strokeLineJoin;
                  ctx.miterLimit = decl.strokeMiterLimit;
                  if (stroke.toLive) {
                    if (stroke.gradientUnits === "percentage" || stroke.gradientTransform || stroke.patternTransform) {
                      this._applyPatternForTransformedGradient(ctx, stroke);
                    } else {
                      ctx.strokeStyle = stroke.toLive(ctx, this);
                      this._applyPatternGradientTransform(ctx, stroke);
                    }
                  } else {
                    ctx.strokeStyle = decl.stroke;
                  }
                }
              },
              _setFillStyles: function(ctx, decl) {
                var fill = decl.fill;
                if (fill) {
                  if (fill.toLive) {
                    ctx.fillStyle = fill.toLive(ctx, this);
                    this._applyPatternGradientTransform(ctx, decl.fill);
                  } else {
                    ctx.fillStyle = fill;
                  }
                }
              },
              _setClippingProperties: function(ctx) {
                ctx.globalAlpha = 1;
                ctx.strokeStyle = "transparent";
                ctx.fillStyle = "#000000";
              },
              _setLineDash: function(ctx, dashArray) {
                if (!dashArray || dashArray.length === 0) {
                  return;
                }
                if (1 & dashArray.length) {
                  dashArray.push.apply(dashArray, dashArray);
                }
                ctx.setLineDash(dashArray);
              },
              _renderControls: function(ctx, styleOverride) {
                var vpt = this.getViewportTransform(), matrix2 = this.calcTransformMatrix(), options, drawBorders, drawControls;
                styleOverride = styleOverride || {};
                drawBorders = typeof styleOverride.hasBorders !== "undefined" ? styleOverride.hasBorders : this.hasBorders;
                drawControls = typeof styleOverride.hasControls !== "undefined" ? styleOverride.hasControls : this.hasControls;
                matrix2 = fabric2.util.multiplyTransformMatrices(vpt, matrix2);
                options = fabric2.util.qrDecompose(matrix2);
                ctx.save();
                ctx.translate(options.translateX, options.translateY);
                ctx.lineWidth = 1 * this.borderScaleFactor;
                if (!this.group) {
                  ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
                }
                ctx.rotate(degreesToRadians(options.angle));
                if (styleOverride.forActiveSelection || this.group) {
                  drawBorders && this.drawBordersInGroup(ctx, options, styleOverride);
                } else {
                  drawBorders && this.drawBorders(ctx, styleOverride);
                }
                drawControls && this.drawControls(ctx, styleOverride);
                ctx.restore();
              },
              _setShadow: function(ctx) {
                if (!this.shadow) {
                  return;
                }
                var shadow = this.shadow, canvas = this.canvas, scaling, multX = canvas && canvas.viewportTransform[0] || 1, multY = canvas && canvas.viewportTransform[3] || 1;
                if (shadow.nonScaling) {
                  scaling = { scaleX: 1, scaleY: 1 };
                } else {
                  scaling = this.getObjectScaling();
                }
                if (canvas && canvas._isRetinaScaling()) {
                  multX *= fabric2.devicePixelRatio;
                  multY *= fabric2.devicePixelRatio;
                }
                ctx.shadowColor = shadow.color;
                ctx.shadowBlur = shadow.blur * fabric2.browserShadowBlurConstant * (multX + multY) * (scaling.scaleX + scaling.scaleY) / 4;
                ctx.shadowOffsetX = shadow.offsetX * multX * scaling.scaleX;
                ctx.shadowOffsetY = shadow.offsetY * multY * scaling.scaleY;
              },
              _removeShadow: function(ctx) {
                if (!this.shadow) {
                  return;
                }
                ctx.shadowColor = "";
                ctx.shadowBlur = ctx.shadowOffsetX = ctx.shadowOffsetY = 0;
              },
              _applyPatternGradientTransform: function(ctx, filler) {
                if (!filler || !filler.toLive) {
                  return { offsetX: 0, offsetY: 0 };
                }
                var t = filler.gradientTransform || filler.patternTransform;
                var offsetX = -this.width / 2 + filler.offsetX || 0, offsetY = -this.height / 2 + filler.offsetY || 0;
                if (filler.gradientUnits === "percentage") {
                  ctx.transform(this.width, 0, 0, this.height, offsetX, offsetY);
                } else {
                  ctx.transform(1, 0, 0, 1, offsetX, offsetY);
                }
                if (t) {
                  ctx.transform(t[0], t[1], t[2], t[3], t[4], t[5]);
                }
                return { offsetX, offsetY };
              },
              _renderPaintInOrder: function(ctx) {
                if (this.paintFirst === "stroke") {
                  this._renderStroke(ctx);
                  this._renderFill(ctx);
                } else {
                  this._renderFill(ctx);
                  this._renderStroke(ctx);
                }
              },
              _render: function() {
              },
              _renderFill: function(ctx) {
                if (!this.fill) {
                  return;
                }
                ctx.save();
                this._setFillStyles(ctx, this);
                if (this.fillRule === "evenodd") {
                  ctx.fill("evenodd");
                } else {
                  ctx.fill();
                }
                ctx.restore();
              },
              _renderStroke: function(ctx) {
                if (!this.stroke || this.strokeWidth === 0) {
                  return;
                }
                if (this.shadow && !this.shadow.affectStroke) {
                  this._removeShadow(ctx);
                }
                ctx.save();
                if (this.strokeUniform && this.group) {
                  var scaling = this.getObjectScaling();
                  ctx.scale(1 / scaling.scaleX, 1 / scaling.scaleY);
                } else if (this.strokeUniform) {
                  ctx.scale(1 / this.scaleX, 1 / this.scaleY);
                }
                this._setLineDash(ctx, this.strokeDashArray);
                this._setStrokeStyles(ctx, this);
                ctx.stroke();
                ctx.restore();
              },
              _applyPatternForTransformedGradient: function(ctx, filler) {
                var dims = this._limitCacheSize(this._getCacheCanvasDimensions()), pCanvas = fabric2.util.createCanvasElement(), pCtx, retinaScaling = this.canvas.getRetinaScaling(), width = dims.x / this.scaleX / retinaScaling, height = dims.y / this.scaleY / retinaScaling;
                pCanvas.width = width;
                pCanvas.height = height;
                pCtx = pCanvas.getContext("2d");
                pCtx.beginPath();
                pCtx.moveTo(0, 0);
                pCtx.lineTo(width, 0);
                pCtx.lineTo(width, height);
                pCtx.lineTo(0, height);
                pCtx.closePath();
                pCtx.translate(width / 2, height / 2);
                pCtx.scale(
                  dims.zoomX / this.scaleX / retinaScaling,
                  dims.zoomY / this.scaleY / retinaScaling
                );
                this._applyPatternGradientTransform(pCtx, filler);
                pCtx.fillStyle = filler.toLive(ctx);
                pCtx.fill();
                ctx.translate(-this.width / 2 - this.strokeWidth / 2, -this.height / 2 - this.strokeWidth / 2);
                ctx.scale(
                  retinaScaling * this.scaleX / dims.zoomX,
                  retinaScaling * this.scaleY / dims.zoomY
                );
                ctx.strokeStyle = pCtx.createPattern(pCanvas, "no-repeat");
              },
              _findCenterFromElement: function() {
                return { x: this.left + this.width / 2, y: this.top + this.height / 2 };
              },
              _assignTransformMatrixProps: function() {
                if (this.transformMatrix) {
                  var options = fabric2.util.qrDecompose(this.transformMatrix);
                  this.flipX = false;
                  this.flipY = false;
                  this.set("scaleX", options.scaleX);
                  this.set("scaleY", options.scaleY);
                  this.angle = options.angle;
                  this.skewX = options.skewX;
                  this.skewY = 0;
                }
              },
              _removeTransformMatrix: function(preserveAspectRatioOptions) {
                var center = this._findCenterFromElement();
                if (this.transformMatrix) {
                  this._assignTransformMatrixProps();
                  center = fabric2.util.transformPoint(center, this.transformMatrix);
                }
                this.transformMatrix = null;
                if (preserveAspectRatioOptions) {
                  this.scaleX *= preserveAspectRatioOptions.scaleX;
                  this.scaleY *= preserveAspectRatioOptions.scaleY;
                  this.cropX = preserveAspectRatioOptions.cropX;
                  this.cropY = preserveAspectRatioOptions.cropY;
                  center.x += preserveAspectRatioOptions.offsetLeft;
                  center.y += preserveAspectRatioOptions.offsetTop;
                  this.width = preserveAspectRatioOptions.width;
                  this.height = preserveAspectRatioOptions.height;
                }
                this.setPositionByOrigin(center, "center", "center");
              },
              clone: function(callback, propertiesToInclude) {
                var objectForm = this.toObject(propertiesToInclude);
                if (this.constructor.fromObject) {
                  this.constructor.fromObject(objectForm, callback);
                } else {
                  fabric2.Object._fromObject("Object", objectForm, callback);
                }
              },
              cloneAsImage: function(callback, options) {
                var canvasEl = this.toCanvasElement(options);
                if (callback) {
                  callback(new fabric2.Image(canvasEl));
                }
                return this;
              },
              toCanvasElement: function(options) {
                options || (options = {});
                var utils2 = fabric2.util, origParams = utils2.saveObjectTransform(this), originalGroup = this.group, originalShadow = this.shadow, abs2 = Math.abs, multiplier = (options.multiplier || 1) * (options.enableRetinaScaling ? fabric2.devicePixelRatio : 1);
                delete this.group;
                if (options.withoutTransform) {
                  utils2.resetObjectTransform(this);
                }
                if (options.withoutShadow) {
                  this.shadow = null;
                }
                var el = fabric2.util.createCanvasElement(), boundingRect = this.getBoundingRect(true, true), shadow = this.shadow, scaling, shadowOffset = { x: 0, y: 0 }, shadowBlur, width, height;
                if (shadow) {
                  shadowBlur = shadow.blur;
                  if (shadow.nonScaling) {
                    scaling = { scaleX: 1, scaleY: 1 };
                  } else {
                    scaling = this.getObjectScaling();
                  }
                  shadowOffset.x = 2 * Math.round(abs2(shadow.offsetX) + shadowBlur) * abs2(scaling.scaleX);
                  shadowOffset.y = 2 * Math.round(abs2(shadow.offsetY) + shadowBlur) * abs2(scaling.scaleY);
                }
                width = boundingRect.width + shadowOffset.x;
                height = boundingRect.height + shadowOffset.y;
                el.width = Math.ceil(width);
                el.height = Math.ceil(height);
                var canvas = new fabric2.StaticCanvas(el, {
                  enableRetinaScaling: false,
                  renderOnAddRemove: false,
                  skipOffscreen: false
                });
                if (options.format === "jpeg") {
                  canvas.backgroundColor = "#fff";
                }
                this.setPositionByOrigin(new fabric2.Point(canvas.width / 2, canvas.height / 2), "center", "center");
                var originalCanvas = this.canvas;
                canvas.add(this);
                var canvasEl = canvas.toCanvasElement(multiplier || 1, options);
                this.shadow = originalShadow;
                this.set("canvas", originalCanvas);
                if (originalGroup) {
                  this.group = originalGroup;
                }
                this.set(origParams).setCoords();
                canvas._objects = [];
                canvas.dispose();
                canvas = null;
                return canvasEl;
              },
              toDataURL: function(options) {
                options || (options = {});
                return fabric2.util.toDataURL(this.toCanvasElement(options), options.format || "png", options.quality || 1);
              },
              isType: function(type) {
                return this.type === type;
              },
              complexity: function() {
                return 1;
              },
              toJSON: function(propertiesToInclude) {
                return this.toObject(propertiesToInclude);
              },
              rotate: function(angle2) {
                var shouldCenterOrigin = (this.originX !== "center" || this.originY !== "center") && this.centeredRotation;
                if (shouldCenterOrigin) {
                  this._setOriginToCenter();
                }
                this.set("angle", angle2);
                if (shouldCenterOrigin) {
                  this._resetOrigin();
                }
                return this;
              },
              centerH: function() {
                this.canvas && this.canvas.centerObjectH(this);
                return this;
              },
              viewportCenterH: function() {
                this.canvas && this.canvas.viewportCenterObjectH(this);
                return this;
              },
              centerV: function() {
                this.canvas && this.canvas.centerObjectV(this);
                return this;
              },
              viewportCenterV: function() {
                this.canvas && this.canvas.viewportCenterObjectV(this);
                return this;
              },
              center: function() {
                this.canvas && this.canvas.centerObject(this);
                return this;
              },
              viewportCenter: function() {
                this.canvas && this.canvas.viewportCenterObject(this);
                return this;
              },
              getLocalPointer: function(e2, pointer) {
                pointer = pointer || this.canvas.getPointer(e2);
                var pClicked = new fabric2.Point(pointer.x, pointer.y), objectLeftTop = this._getLeftTopCoords();
                if (this.angle) {
                  pClicked = fabric2.util.rotatePoint(
                    pClicked,
                    objectLeftTop,
                    degreesToRadians(-this.angle)
                  );
                }
                return {
                  x: pClicked.x - objectLeftTop.x,
                  y: pClicked.y - objectLeftTop.y
                };
              },
              _setupCompositeOperation: function(ctx) {
                if (this.globalCompositeOperation) {
                  ctx.globalCompositeOperation = this.globalCompositeOperation;
                }
              }
            });
            fabric2.util.createAccessors && fabric2.util.createAccessors(fabric2.Object);
            extend2(fabric2.Object.prototype, fabric2.Observable);
            fabric2.Object.NUM_FRACTION_DIGITS = 2;
            fabric2.Object._fromObject = function(className, object, callback, extraParam) {
              var klass = fabric2[className];
              object = clone2(object, true);
              fabric2.util.enlivenPatterns([object.fill, object.stroke], function(patterns) {
                if (typeof patterns[0] !== "undefined") {
                  object.fill = patterns[0];
                }
                if (typeof patterns[1] !== "undefined") {
                  object.stroke = patterns[1];
                }
                fabric2.util.enlivenObjects([object.clipPath], function(enlivedProps) {
                  object.clipPath = enlivedProps[0];
                  var instance = extraParam ? new klass(object[extraParam], object) : new klass(object);
                  callback && callback(instance);
                });
              });
            };
            fabric2.Object.__uid = 0;
          })(exports2);
          (function() {
            var degreesToRadians = fabric.util.degreesToRadians, originXOffset = {
              left: -0.5,
              center: 0,
              right: 0.5
            }, originYOffset = {
              top: -0.5,
              center: 0,
              bottom: 0.5
            };
            fabric.util.object.extend(fabric.Object.prototype, {
              translateToGivenOrigin: function(point, fromOriginX, fromOriginY, toOriginX, toOriginY) {
                var x = point.x, y = point.y, offsetX, offsetY, dim;
                if (typeof fromOriginX === "string") {
                  fromOriginX = originXOffset[fromOriginX];
                } else {
                  fromOriginX -= 0.5;
                }
                if (typeof toOriginX === "string") {
                  toOriginX = originXOffset[toOriginX];
                } else {
                  toOriginX -= 0.5;
                }
                offsetX = toOriginX - fromOriginX;
                if (typeof fromOriginY === "string") {
                  fromOriginY = originYOffset[fromOriginY];
                } else {
                  fromOriginY -= 0.5;
                }
                if (typeof toOriginY === "string") {
                  toOriginY = originYOffset[toOriginY];
                } else {
                  toOriginY -= 0.5;
                }
                offsetY = toOriginY - fromOriginY;
                if (offsetX || offsetY) {
                  dim = this._getTransformedDimensions();
                  x = point.x + offsetX * dim.x;
                  y = point.y + offsetY * dim.y;
                }
                return new fabric.Point(x, y);
              },
              translateToCenterPoint: function(point, originX, originY) {
                var p = this.translateToGivenOrigin(point, originX, originY, "center", "center");
                if (this.angle) {
                  return fabric.util.rotatePoint(p, point, degreesToRadians(this.angle));
                }
                return p;
              },
              translateToOriginPoint: function(center, originX, originY) {
                var p = this.translateToGivenOrigin(center, "center", "center", originX, originY);
                if (this.angle) {
                  return fabric.util.rotatePoint(p, center, degreesToRadians(this.angle));
                }
                return p;
              },
              getCenterPoint: function() {
                var leftTop = new fabric.Point(this.left, this.top);
                return this.translateToCenterPoint(leftTop, this.originX, this.originY);
              },
              getPointByOrigin: function(originX, originY) {
                var center = this.getCenterPoint();
                return this.translateToOriginPoint(center, originX, originY);
              },
              toLocalPoint: function(point, originX, originY) {
                var center = this.getCenterPoint(), p, p2;
                if (typeof originX !== "undefined" && typeof originY !== "undefined") {
                  p = this.translateToGivenOrigin(center, "center", "center", originX, originY);
                } else {
                  p = new fabric.Point(this.left, this.top);
                }
                p2 = new fabric.Point(point.x, point.y);
                if (this.angle) {
                  p2 = fabric.util.rotatePoint(p2, center, -degreesToRadians(this.angle));
                }
                return p2.subtractEquals(p);
              },
              setPositionByOrigin: function(pos, originX, originY) {
                var center = this.translateToCenterPoint(pos, originX, originY), position2 = this.translateToOriginPoint(center, this.originX, this.originY);
                this.set("left", position2.x);
                this.set("top", position2.y);
              },
              adjustPosition: function(to) {
                var angle2 = degreesToRadians(this.angle), hypotFull = this.getScaledWidth(), xFull = fabric.util.cos(angle2) * hypotFull, yFull = fabric.util.sin(angle2) * hypotFull, offsetFrom, offsetTo;
                if (typeof this.originX === "string") {
                  offsetFrom = originXOffset[this.originX];
                } else {
                  offsetFrom = this.originX - 0.5;
                }
                if (typeof to === "string") {
                  offsetTo = originXOffset[to];
                } else {
                  offsetTo = to - 0.5;
                }
                this.left += xFull * (offsetTo - offsetFrom);
                this.top += yFull * (offsetTo - offsetFrom);
                this.setCoords();
                this.originX = to;
              },
              _setOriginToCenter: function() {
                this._originalOriginX = this.originX;
                this._originalOriginY = this.originY;
                var center = this.getCenterPoint();
                this.originX = "center";
                this.originY = "center";
                this.left = center.x;
                this.top = center.y;
              },
              _resetOrigin: function() {
                var originPoint = this.translateToOriginPoint(
                  this.getCenterPoint(),
                  this._originalOriginX,
                  this._originalOriginY
                );
                this.originX = this._originalOriginX;
                this.originY = this._originalOriginY;
                this.left = originPoint.x;
                this.top = originPoint.y;
                this._originalOriginX = null;
                this._originalOriginY = null;
              },
              _getLeftTopCoords: function() {
                return this.translateToOriginPoint(this.getCenterPoint(), "left", "top");
              }
            });
          })();
          (function() {
            function arrayFromCoords(coords) {
              return [
                new fabric.Point(coords.tl.x, coords.tl.y),
                new fabric.Point(coords.tr.x, coords.tr.y),
                new fabric.Point(coords.br.x, coords.br.y),
                new fabric.Point(coords.bl.x, coords.bl.y)
              ];
            }
            var util = fabric.util, degreesToRadians = util.degreesToRadians, multiplyMatrices = util.multiplyTransformMatrices, transformPoint = util.transformPoint;
            util.object.extend(fabric.Object.prototype, {
              oCoords: null,
              aCoords: null,
              lineCoords: null,
              ownMatrixCache: null,
              matrixCache: null,
              controls: {},
              _getCoords: function(absolute, calculate2) {
                if (calculate2) {
                  return absolute ? this.calcACoords() : this.calcLineCoords();
                }
                if (!this.aCoords || !this.lineCoords) {
                  this.setCoords(true);
                }
                return absolute ? this.aCoords : this.lineCoords;
              },
              getCoords: function(absolute, calculate2) {
                return arrayFromCoords(this._getCoords(absolute, calculate2));
              },
              intersectsWithRect: function(pointTL, pointBR, absolute, calculate2) {
                var coords = this.getCoords(absolute, calculate2), intersection = fabric.Intersection.intersectPolygonRectangle(
                  coords,
                  pointTL,
                  pointBR
                );
                return intersection.status === "Intersection";
              },
              intersectsWithObject: function(other, absolute, calculate2) {
                var intersection = fabric.Intersection.intersectPolygonPolygon(
                  this.getCoords(absolute, calculate2),
                  other.getCoords(absolute, calculate2)
                );
                return intersection.status === "Intersection" || other.isContainedWithinObject(this, absolute, calculate2) || this.isContainedWithinObject(other, absolute, calculate2);
              },
              isContainedWithinObject: function(other, absolute, calculate2) {
                var points = this.getCoords(absolute, calculate2), otherCoords = absolute ? other.aCoords : other.lineCoords, i = 0, lines = other._getImageLines(otherCoords);
                for (; i < 4; i++) {
                  if (!other.containsPoint(points[i], lines)) {
                    return false;
                  }
                }
                return true;
              },
              isContainedWithinRect: function(pointTL, pointBR, absolute, calculate2) {
                var boundingRect = this.getBoundingRect(absolute, calculate2);
                return boundingRect.left >= pointTL.x && boundingRect.left + boundingRect.width <= pointBR.x && boundingRect.top >= pointTL.y && boundingRect.top + boundingRect.height <= pointBR.y;
              },
              containsPoint: function(point, lines, absolute, calculate2) {
                var coords = this._getCoords(absolute, calculate2), lines = lines || this._getImageLines(coords), xPoints = this._findCrossPoints(point, lines);
                return xPoints !== 0 && xPoints % 2 === 1;
              },
              isOnScreen: function(calculate2) {
                if (!this.canvas) {
                  return false;
                }
                var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
                var points = this.getCoords(true, calculate2);
                if (points.some(function(point) {
                  return point.x <= pointBR.x && point.x >= pointTL.x && point.y <= pointBR.y && point.y >= pointTL.y;
                })) {
                  return true;
                }
                if (this.intersectsWithRect(pointTL, pointBR, true, calculate2)) {
                  return true;
                }
                return this._containsCenterOfCanvas(pointTL, pointBR, calculate2);
              },
              _containsCenterOfCanvas: function(pointTL, pointBR, calculate2) {
                var centerPoint = { x: (pointTL.x + pointBR.x) / 2, y: (pointTL.y + pointBR.y) / 2 };
                if (this.containsPoint(centerPoint, null, true, calculate2)) {
                  return true;
                }
                return false;
              },
              isPartiallyOnScreen: function(calculate2) {
                if (!this.canvas) {
                  return false;
                }
                var pointTL = this.canvas.vptCoords.tl, pointBR = this.canvas.vptCoords.br;
                if (this.intersectsWithRect(pointTL, pointBR, true, calculate2)) {
                  return true;
                }
                var allPointsAreOutside = this.getCoords(true, calculate2).every(function(point) {
                  return (point.x >= pointBR.x || point.x <= pointTL.x) && (point.y >= pointBR.y || point.y <= pointTL.y);
                });
                return allPointsAreOutside && this._containsCenterOfCanvas(pointTL, pointBR, calculate2);
              },
              _getImageLines: function(oCoords) {
                var lines = {
                  topline: {
                    o: oCoords.tl,
                    d: oCoords.tr
                  },
                  rightline: {
                    o: oCoords.tr,
                    d: oCoords.br
                  },
                  bottomline: {
                    o: oCoords.br,
                    d: oCoords.bl
                  },
                  leftline: {
                    o: oCoords.bl,
                    d: oCoords.tl
                  }
                };
                return lines;
              },
              _findCrossPoints: function(point, lines) {
                var b1, b2, a1, a2, xi, xcount = 0, iLine;
                for (var lineKey in lines) {
                  iLine = lines[lineKey];
                  if (iLine.o.y < point.y && iLine.d.y < point.y) {
                    continue;
                  }
                  if (iLine.o.y >= point.y && iLine.d.y >= point.y) {
                    continue;
                  }
                  if (iLine.o.x === iLine.d.x && iLine.o.x >= point.x) {
                    xi = iLine.o.x;
                  } else {
                    b1 = 0;
                    b2 = (iLine.d.y - iLine.o.y) / (iLine.d.x - iLine.o.x);
                    a1 = point.y - b1 * point.x;
                    a2 = iLine.o.y - b2 * iLine.o.x;
                    xi = -(a1 - a2) / (b1 - b2);
                  }
                  if (xi >= point.x) {
                    xcount += 1;
                  }
                  if (xcount === 2) {
                    break;
                  }
                }
                return xcount;
              },
              getBoundingRect: function(absolute, calculate2) {
                var coords = this.getCoords(absolute, calculate2);
                return util.makeBoundingBoxFromPoints(coords);
              },
              getScaledWidth: function() {
                return this._getTransformedDimensions().x;
              },
              getScaledHeight: function() {
                return this._getTransformedDimensions().y;
              },
              _constrainScale: function(value) {
                if (Math.abs(value) < this.minScaleLimit) {
                  if (value < 0) {
                    return -this.minScaleLimit;
                  } else {
                    return this.minScaleLimit;
                  }
                } else if (value === 0) {
                  return 1e-4;
                }
                return value;
              },
              scale: function(value) {
                this._set("scaleX", value);
                this._set("scaleY", value);
                return this.setCoords();
              },
              scaleToWidth: function(value, absolute) {
                var boundingRectFactor = this.getBoundingRect(absolute).width / this.getScaledWidth();
                return this.scale(value / this.width / boundingRectFactor);
              },
              scaleToHeight: function(value, absolute) {
                var boundingRectFactor = this.getBoundingRect(absolute).height / this.getScaledHeight();
                return this.scale(value / this.height / boundingRectFactor);
              },
              calcCoords: function(absolute) {
                if (absolute) {
                  return this.calcACoords();
                }
                return this.calcOCoords();
              },
              calcLineCoords: function() {
                var vpt = this.getViewportTransform(), padding = this.padding, angle2 = degreesToRadians(this.angle), cos = util.cos(angle2), sin = util.sin(angle2), cosP = cos * padding, sinP = sin * padding, cosPSinP = cosP + sinP, cosPMinusSinP = cosP - sinP, aCoords = this.calcACoords();
                var lineCoords = {
                  tl: transformPoint(aCoords.tl, vpt),
                  tr: transformPoint(aCoords.tr, vpt),
                  bl: transformPoint(aCoords.bl, vpt),
                  br: transformPoint(aCoords.br, vpt)
                };
                if (padding) {
                  lineCoords.tl.x -= cosPMinusSinP;
                  lineCoords.tl.y -= cosPSinP;
                  lineCoords.tr.x += cosPSinP;
                  lineCoords.tr.y -= cosPMinusSinP;
                  lineCoords.bl.x -= cosPSinP;
                  lineCoords.bl.y += cosPMinusSinP;
                  lineCoords.br.x += cosPMinusSinP;
                  lineCoords.br.y += cosPSinP;
                }
                return lineCoords;
              },
              calcOCoords: function() {
                var rotateMatrix = this._calcRotateMatrix(), translateMatrix = this._calcTranslateMatrix(), vpt = this.getViewportTransform(), startMatrix = multiplyMatrices(vpt, translateMatrix), finalMatrix = multiplyMatrices(startMatrix, rotateMatrix), finalMatrix = multiplyMatrices(finalMatrix, [1 / vpt[0], 0, 0, 1 / vpt[3], 0, 0]), dim = this._calculateCurrentDimensions(), coords = {};
                this.forEachControl(function(control, key, fabricObject) {
                  coords[key] = control.positionHandler(dim, finalMatrix, fabricObject);
                });
                return coords;
              },
              calcACoords: function() {
                var rotateMatrix = this._calcRotateMatrix(), translateMatrix = this._calcTranslateMatrix(), finalMatrix = multiplyMatrices(translateMatrix, rotateMatrix), dim = this._getTransformedDimensions(), w = dim.x / 2, h2 = dim.y / 2;
                return {
                  tl: transformPoint({ x: -w, y: -h2 }, finalMatrix),
                  tr: transformPoint({ x: w, y: -h2 }, finalMatrix),
                  bl: transformPoint({ x: -w, y: h2 }, finalMatrix),
                  br: transformPoint({ x: w, y: h2 }, finalMatrix)
                };
              },
              setCoords: function(skipCorners) {
                this.aCoords = this.calcACoords();
                this.lineCoords = this.group ? this.aCoords : this.calcLineCoords();
                if (skipCorners) {
                  return this;
                }
                this.oCoords = this.calcOCoords();
                this._setCornerCoords && this._setCornerCoords();
                return this;
              },
              _calcRotateMatrix: function() {
                return util.calcRotateMatrix(this);
              },
              _calcTranslateMatrix: function() {
                var center = this.getCenterPoint();
                return [1, 0, 0, 1, center.x, center.y];
              },
              transformMatrixKey: function(skipGroup) {
                var sep = "_", prefix2 = "";
                if (!skipGroup && this.group) {
                  prefix2 = this.group.transformMatrixKey(skipGroup) + sep;
                }
                return prefix2 + this.top + sep + this.left + sep + this.scaleX + sep + this.scaleY + sep + this.skewX + sep + this.skewY + sep + this.angle + sep + this.originX + sep + this.originY + sep + this.width + sep + this.height + sep + this.strokeWidth + this.flipX + this.flipY;
              },
              calcTransformMatrix: function(skipGroup) {
                var matrix2 = this.calcOwnMatrix();
                if (skipGroup || !this.group) {
                  return matrix2;
                }
                var key = this.transformMatrixKey(skipGroup), cache = this.matrixCache || (this.matrixCache = {});
                if (cache.key === key) {
                  return cache.value;
                }
                if (this.group) {
                  matrix2 = multiplyMatrices(this.group.calcTransformMatrix(false), matrix2);
                }
                cache.key = key;
                cache.value = matrix2;
                return matrix2;
              },
              calcOwnMatrix: function() {
                var key = this.transformMatrixKey(true), cache = this.ownMatrixCache || (this.ownMatrixCache = {});
                if (cache.key === key) {
                  return cache.value;
                }
                var tMatrix = this._calcTranslateMatrix(), options = {
                  angle: this.angle,
                  translateX: tMatrix[4],
                  translateY: tMatrix[5],
                  scaleX: this.scaleX,
                  scaleY: this.scaleY,
                  skewX: this.skewX,
                  skewY: this.skewY,
                  flipX: this.flipX,
                  flipY: this.flipY
                };
                cache.key = key;
                cache.value = util.composeMatrix(options);
                return cache.value;
              },
              _calcDimensionsTransformMatrix: function(skewX, skewY, flipping) {
                return util.calcDimensionsMatrix({
                  skewX,
                  skewY,
                  scaleX: this.scaleX * (flipping && this.flipX ? -1 : 1),
                  scaleY: this.scaleY * (flipping && this.flipY ? -1 : 1)
                });
              },
              _getNonTransformedDimensions: function() {
                var strokeWidth = this.strokeWidth, w = this.width + strokeWidth, h2 = this.height + strokeWidth;
                return { x: w, y: h2 };
              },
              _getTransformedDimensions: function(skewX, skewY) {
                if (typeof skewX === "undefined") {
                  skewX = this.skewX;
                }
                if (typeof skewY === "undefined") {
                  skewY = this.skewY;
                }
                var dimensions, dimX, dimY, noSkew = skewX === 0 && skewY === 0;
                if (this.strokeUniform) {
                  dimX = this.width;
                  dimY = this.height;
                } else {
                  dimensions = this._getNonTransformedDimensions();
                  dimX = dimensions.x;
                  dimY = dimensions.y;
                }
                if (noSkew) {
                  return this._finalizeDimensions(dimX * this.scaleX, dimY * this.scaleY);
                }
                var bbox = util.sizeAfterTransform(dimX, dimY, {
                  scaleX: this.scaleX,
                  scaleY: this.scaleY,
                  skewX,
                  skewY
                });
                return this._finalizeDimensions(bbox.x, bbox.y);
              },
              _finalizeDimensions: function(width, height) {
                return this.strokeUniform ? { x: width + this.strokeWidth, y: height + this.strokeWidth } : { x: width, y: height };
              },
              _calculateCurrentDimensions: function() {
                var vpt = this.getViewportTransform(), dim = this._getTransformedDimensions(), p = transformPoint(dim, vpt, true);
                return p.scalarAdd(2 * this.padding);
              }
            });
          })();
          fabric.util.object.extend(fabric.Object.prototype, {
            sendToBack: function() {
              if (this.group) {
                fabric.StaticCanvas.prototype.sendToBack.call(this.group, this);
              } else if (this.canvas) {
                this.canvas.sendToBack(this);
              }
              return this;
            },
            bringToFront: function() {
              if (this.group) {
                fabric.StaticCanvas.prototype.bringToFront.call(this.group, this);
              } else if (this.canvas) {
                this.canvas.bringToFront(this);
              }
              return this;
            },
            sendBackwards: function(intersecting) {
              if (this.group) {
                fabric.StaticCanvas.prototype.sendBackwards.call(this.group, this, intersecting);
              } else if (this.canvas) {
                this.canvas.sendBackwards(this, intersecting);
              }
              return this;
            },
            bringForward: function(intersecting) {
              if (this.group) {
                fabric.StaticCanvas.prototype.bringForward.call(this.group, this, intersecting);
              } else if (this.canvas) {
                this.canvas.bringForward(this, intersecting);
              }
              return this;
            },
            moveTo: function(index2) {
              if (this.group && this.group.type !== "activeSelection") {
                fabric.StaticCanvas.prototype.moveTo.call(this.group, this, index2);
              } else if (this.canvas) {
                this.canvas.moveTo(this, index2);
              }
              return this;
            }
          });
          (function() {
            function getSvgColorString(prop, value) {
              if (!value) {
                return prop + ": none; ";
              } else if (value.toLive) {
                return prop + ": url(#SVGID_" + value.id + "); ";
              } else {
                var color2 = new fabric.Color(value), str = prop + ": " + color2.toRgb() + "; ", opacity2 = color2.getAlpha();
                if (opacity2 !== 1) {
                  str += prop + "-opacity: " + opacity2.toString() + "; ";
                }
                return str;
              }
            }
            var toFixed2 = fabric.util.toFixed;
            fabric.util.object.extend(fabric.Object.prototype, {
              getSvgStyles: function(skipShadow) {
                var fillRule = this.fillRule ? this.fillRule : "nonzero", strokeWidth = this.strokeWidth ? this.strokeWidth : "0", strokeDashArray = this.strokeDashArray ? this.strokeDashArray.join(" ") : "none", strokeDashOffset = this.strokeDashOffset ? this.strokeDashOffset : "0", strokeLineCap = this.strokeLineCap ? this.strokeLineCap : "butt", strokeLineJoin = this.strokeLineJoin ? this.strokeLineJoin : "miter", strokeMiterLimit = this.strokeMiterLimit ? this.strokeMiterLimit : "4", opacity2 = typeof this.opacity !== "undefined" ? this.opacity : "1", visibility2 = this.visible ? "" : " visibility: hidden;", filter = skipShadow ? "" : this.getSvgFilter(), fill = getSvgColorString("fill", this.fill), stroke = getSvgColorString("stroke", this.stroke);
                return [
                  stroke,
                  "stroke-width: ",
                  strokeWidth,
                  "; ",
                  "stroke-dasharray: ",
                  strokeDashArray,
                  "; ",
                  "stroke-linecap: ",
                  strokeLineCap,
                  "; ",
                  "stroke-dashoffset: ",
                  strokeDashOffset,
                  "; ",
                  "stroke-linejoin: ",
                  strokeLineJoin,
                  "; ",
                  "stroke-miterlimit: ",
                  strokeMiterLimit,
                  "; ",
                  fill,
                  "fill-rule: ",
                  fillRule,
                  "; ",
                  "opacity: ",
                  opacity2,
                  ";",
                  filter,
                  visibility2
                ].join("");
              },
              getSvgSpanStyles: function(style, useWhiteSpace) {
                var term = "; ";
                var fontFamily2 = style.fontFamily ? "font-family: " + (style.fontFamily.indexOf("'") === -1 && style.fontFamily.indexOf('"') === -1 ? "'" + style.fontFamily + "'" : style.fontFamily) + term : "";
                var strokeWidth = style.strokeWidth ? "stroke-width: " + style.strokeWidth + term : "", fontFamily2 = fontFamily2, fontSize2 = style.fontSize ? "font-size: " + style.fontSize + "px" + term : "", fontStyle2 = style.fontStyle ? "font-style: " + style.fontStyle + term : "", fontWeight2 = style.fontWeight ? "font-weight: " + style.fontWeight + term : "", fill = style.fill ? getSvgColorString("fill", style.fill) : "", stroke = style.stroke ? getSvgColorString("stroke", style.stroke) : "", textDecoration = this.getSvgTextDecoration(style), deltaY = style.deltaY ? "baseline-shift: " + -style.deltaY + "; " : "";
                if (textDecoration) {
                  textDecoration = "text-decoration: " + textDecoration + term;
                }
                return [
                  stroke,
                  strokeWidth,
                  fontFamily2,
                  fontSize2,
                  fontStyle2,
                  fontWeight2,
                  textDecoration,
                  fill,
                  deltaY,
                  useWhiteSpace ? "white-space: pre; " : ""
                ].join("");
              },
              getSvgTextDecoration: function(style) {
                return ["overline", "underline", "line-through"].filter(function(decoration) {
                  return style[decoration.replace("-", "")];
                }).join(" ");
              },
              getSvgFilter: function() {
                return this.shadow ? "filter: url(#SVGID_" + this.shadow.id + ");" : "";
              },
              getSvgCommons: function() {
                return [
                  this.id ? 'id="' + this.id + '" ' : "",
                  this.clipPath ? 'clip-path="url(#' + this.clipPath.clipPathId + ')" ' : ""
                ].join("");
              },
              getSvgTransform: function(full, additionalTransform) {
                var transform2 = full ? this.calcTransformMatrix() : this.calcOwnMatrix(), svgTransform = 'transform="' + fabric.util.matrixToSVG(transform2);
                return svgTransform + (additionalTransform || "") + '" ';
              },
              _setSVGBg: function(textBgRects) {
                if (this.backgroundColor) {
                  var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
                  textBgRects.push(
                    "		<rect ",
                    this._getFillAttributes(this.backgroundColor),
                    ' x="',
                    toFixed2(-this.width / 2, NUM_FRACTION_DIGITS),
                    '" y="',
                    toFixed2(-this.height / 2, NUM_FRACTION_DIGITS),
                    '" width="',
                    toFixed2(this.width, NUM_FRACTION_DIGITS),
                    '" height="',
                    toFixed2(this.height, NUM_FRACTION_DIGITS),
                    '"></rect>\n'
                  );
                }
              },
              toSVG: function(reviver) {
                return this._createBaseSVGMarkup(this._toSVG(reviver), { reviver });
              },
              toClipPathSVG: function(reviver) {
                return "	" + this._createBaseClipPathSVGMarkup(this._toSVG(reviver), { reviver });
              },
              _createBaseClipPathSVGMarkup: function(objectMarkup, options) {
                options = options || {};
                var reviver = options.reviver, additionalTransform = options.additionalTransform || "", commonPieces = [
                  this.getSvgTransform(true, additionalTransform),
                  this.getSvgCommons()
                ].join(""), index2 = objectMarkup.indexOf("COMMON_PARTS");
                objectMarkup[index2] = commonPieces;
                return reviver ? reviver(objectMarkup.join("")) : objectMarkup.join("");
              },
              _createBaseSVGMarkup: function(objectMarkup, options) {
                options = options || {};
                var noStyle = options.noStyle, reviver = options.reviver, styleInfo = noStyle ? "" : 'style="' + this.getSvgStyles() + '" ', shadowInfo = options.withShadow ? 'style="' + this.getSvgFilter() + '" ' : "", clipPath = this.clipPath, vectorEffect = this.strokeUniform ? 'vector-effect="non-scaling-stroke" ' : "", absoluteClipPath = clipPath && clipPath.absolutePositioned, stroke = this.stroke, fill = this.fill, shadow = this.shadow, commonPieces, markup = [], clipPathMarkup, index2 = objectMarkup.indexOf("COMMON_PARTS"), additionalTransform = options.additionalTransform;
                if (clipPath) {
                  clipPath.clipPathId = "CLIPPATH_" + fabric.Object.__uid++;
                  clipPathMarkup = '<clipPath id="' + clipPath.clipPathId + '" >\n' + clipPath.toClipPathSVG(reviver) + "</clipPath>\n";
                }
                if (absoluteClipPath) {
                  markup.push(
                    "<g ",
                    shadowInfo,
                    this.getSvgCommons(),
                    " >\n"
                  );
                }
                markup.push(
                  "<g ",
                  this.getSvgTransform(false),
                  !absoluteClipPath ? shadowInfo + this.getSvgCommons() : "",
                  " >\n"
                );
                commonPieces = [
                  styleInfo,
                  vectorEffect,
                  noStyle ? "" : this.addPaintOrder(),
                  " ",
                  additionalTransform ? 'transform="' + additionalTransform + '" ' : ""
                ].join("");
                objectMarkup[index2] = commonPieces;
                if (fill && fill.toLive) {
                  markup.push(fill.toSVG(this));
                }
                if (stroke && stroke.toLive) {
                  markup.push(stroke.toSVG(this));
                }
                if (shadow) {
                  markup.push(shadow.toSVG(this));
                }
                if (clipPath) {
                  markup.push(clipPathMarkup);
                }
                markup.push(objectMarkup.join(""));
                markup.push("</g>\n");
                absoluteClipPath && markup.push("</g>\n");
                return reviver ? reviver(markup.join("")) : markup.join("");
              },
              addPaintOrder: function() {
                return this.paintFirst !== "fill" ? ' paint-order="' + this.paintFirst + '" ' : "";
              }
            });
          })();
          (function() {
            var extend2 = fabric.util.object.extend, originalSet = "stateProperties";
            function saveProps(origin, destination, props2) {
              var tmpObj = {}, deep = true;
              props2.forEach(function(prop) {
                tmpObj[prop] = origin[prop];
              });
              extend2(origin[destination], tmpObj, deep);
            }
            function _isEqual(origValue, currentValue, firstPass) {
              if (origValue === currentValue) {
                return true;
              } else if (Array.isArray(origValue)) {
                if (!Array.isArray(currentValue) || origValue.length !== currentValue.length) {
                  return false;
                }
                for (var i = 0, len = origValue.length; i < len; i++) {
                  if (!_isEqual(origValue[i], currentValue[i])) {
                    return false;
                  }
                }
                return true;
              } else if (origValue && typeof origValue === "object") {
                var keys2 = Object.keys(origValue), key;
                if (!currentValue || typeof currentValue !== "object" || !firstPass && keys2.length !== Object.keys(currentValue).length) {
                  return false;
                }
                for (var i = 0, len = keys2.length; i < len; i++) {
                  key = keys2[i];
                  if (key === "canvas" || key === "group") {
                    continue;
                  }
                  if (!_isEqual(origValue[key], currentValue[key])) {
                    return false;
                  }
                }
                return true;
              }
            }
            fabric.util.object.extend(fabric.Object.prototype, {
              hasStateChanged: function(propertySet) {
                propertySet = propertySet || originalSet;
                var dashedPropertySet = "_" + propertySet;
                if (Object.keys(this[dashedPropertySet]).length < this[propertySet].length) {
                  return true;
                }
                return !_isEqual(this[dashedPropertySet], this, true);
              },
              saveState: function(options) {
                var propertySet = options && options.propertySet || originalSet, destination = "_" + propertySet;
                if (!this[destination]) {
                  return this.setupState(options);
                }
                saveProps(this, destination, this[propertySet]);
                if (options && options.stateProperties) {
                  saveProps(this, destination, options.stateProperties);
                }
                return this;
              },
              setupState: function(options) {
                options = options || {};
                var propertySet = options.propertySet || originalSet;
                options.propertySet = propertySet;
                this["_" + propertySet] = {};
                this.saveState(options);
                return this;
              }
            });
          })();
          (function() {
            var degreesToRadians = fabric.util.degreesToRadians;
            fabric.util.object.extend(fabric.Object.prototype, {
              _findTargetCorner: function(pointer, forTouch) {
                if (!this.hasControls || this.group || (!this.canvas || this.canvas._activeObject !== this)) {
                  return false;
                }
                var ex = pointer.x, ey = pointer.y, xPoints, lines, keys2 = Object.keys(this.oCoords), j2 = keys2.length - 1, i;
                this.__corner = 0;
                for (; j2 >= 0; j2--) {
                  i = keys2[j2];
                  if (!this.isControlVisible(i)) {
                    continue;
                  }
                  lines = this._getImageLines(forTouch ? this.oCoords[i].touchCorner : this.oCoords[i].corner);
                  xPoints = this._findCrossPoints({ x: ex, y: ey }, lines);
                  if (xPoints !== 0 && xPoints % 2 === 1) {
                    this.__corner = i;
                    return i;
                  }
                }
                return false;
              },
              forEachControl: function(fn2) {
                for (var i in this.controls) {
                  fn2(this.controls[i], i, this);
                }
              },
              _setCornerCoords: function() {
                var coords = this.oCoords;
                for (var control in coords) {
                  var controlObject = this.controls[control];
                  coords[control].corner = controlObject.calcCornerCoords(
                    this.angle,
                    this.cornerSize,
                    coords[control].x,
                    coords[control].y,
                    false
                  );
                  coords[control].touchCorner = controlObject.calcCornerCoords(
                    this.angle,
                    this.touchCornerSize,
                    coords[control].x,
                    coords[control].y,
                    true
                  );
                }
              },
              drawSelectionBackground: function(ctx) {
                if (!this.selectionBackgroundColor || this.canvas && !this.canvas.interactive || this.canvas && this.canvas._activeObject !== this) {
                  return this;
                }
                ctx.save();
                var center = this.getCenterPoint(), wh = this._calculateCurrentDimensions(), vpt = this.canvas.viewportTransform;
                ctx.translate(center.x, center.y);
                ctx.scale(1 / vpt[0], 1 / vpt[3]);
                ctx.rotate(degreesToRadians(this.angle));
                ctx.fillStyle = this.selectionBackgroundColor;
                ctx.fillRect(-wh.x / 2, -wh.y / 2, wh.x, wh.y);
                ctx.restore();
                return this;
              },
              drawBorders: function(ctx, styleOverride) {
                styleOverride = styleOverride || {};
                var wh = this._calculateCurrentDimensions(), strokeWidth = this.borderScaleFactor, width = wh.x + strokeWidth, height = wh.y + strokeWidth, hasControls = typeof styleOverride.hasControls !== "undefined" ? styleOverride.hasControls : this.hasControls, shouldStroke = false;
                ctx.save();
                ctx.strokeStyle = styleOverride.borderColor || this.borderColor;
                this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray);
                ctx.strokeRect(
                  -width / 2,
                  -height / 2,
                  width,
                  height
                );
                if (hasControls) {
                  ctx.beginPath();
                  this.forEachControl(function(control, key, fabricObject) {
                    if (control.withConnection && control.getVisibility(fabricObject, key)) {
                      shouldStroke = true;
                      ctx.moveTo(control.x * width, control.y * height);
                      ctx.lineTo(
                        control.x * width + control.offsetX,
                        control.y * height + control.offsetY
                      );
                    }
                  });
                  if (shouldStroke) {
                    ctx.stroke();
                  }
                }
                ctx.restore();
                return this;
              },
              drawBordersInGroup: function(ctx, options, styleOverride) {
                styleOverride = styleOverride || {};
                var bbox = fabric.util.sizeAfterTransform(this.width, this.height, options), strokeWidth = this.strokeWidth, strokeUniform = this.strokeUniform, borderScaleFactor = this.borderScaleFactor, width = bbox.x + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleX) + borderScaleFactor, height = bbox.y + strokeWidth * (strokeUniform ? this.canvas.getZoom() : options.scaleY) + borderScaleFactor;
                ctx.save();
                this._setLineDash(ctx, styleOverride.borderDashArray || this.borderDashArray);
                ctx.strokeStyle = styleOverride.borderColor || this.borderColor;
                ctx.strokeRect(
                  -width / 2,
                  -height / 2,
                  width,
                  height
                );
                ctx.restore();
                return this;
              },
              drawControls: function(ctx, styleOverride) {
                styleOverride = styleOverride || {};
                ctx.save();
                var retinaScaling = this.canvas.getRetinaScaling(), matrix2, p;
                ctx.setTransform(retinaScaling, 0, 0, retinaScaling, 0, 0);
                ctx.strokeStyle = ctx.fillStyle = styleOverride.cornerColor || this.cornerColor;
                if (!this.transparentCorners) {
                  ctx.strokeStyle = styleOverride.cornerStrokeColor || this.cornerStrokeColor;
                }
                this._setLineDash(ctx, styleOverride.cornerDashArray || this.cornerDashArray);
                this.setCoords();
                if (this.group) {
                  matrix2 = this.group.calcTransformMatrix();
                }
                this.forEachControl(function(control, key, fabricObject) {
                  p = fabricObject.oCoords[key];
                  if (control.getVisibility(fabricObject, key)) {
                    if (matrix2) {
                      p = fabric.util.transformPoint(p, matrix2);
                    }
                    control.render(ctx, p.x, p.y, styleOverride, fabricObject);
                  }
                });
                ctx.restore();
                return this;
              },
              isControlVisible: function(controlKey) {
                return this.controls[controlKey] && this.controls[controlKey].getVisibility(this, controlKey);
              },
              setControlVisible: function(controlKey, visible) {
                if (!this._controlsVisibility) {
                  this._controlsVisibility = {};
                }
                this._controlsVisibility[controlKey] = visible;
                return this;
              },
              setControlsVisibility: function(options) {
                options || (options = {});
                for (var p in options) {
                  this.setControlVisible(p, options[p]);
                }
                return this;
              },
              onDeselect: function() {
              },
              onSelect: function() {
              }
            });
          })();
          fabric.util.object.extend(fabric.StaticCanvas.prototype, {
            FX_DURATION: 500,
            fxCenterObjectH: function(object, callbacks) {
              callbacks = callbacks || {};
              var empty = function() {
              }, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;
              fabric.util.animate({
                startValue: object.left,
                endValue: this.getCenter().left,
                duration: this.FX_DURATION,
                onChange: function(value) {
                  object.set("left", value);
                  _this.requestRenderAll();
                  onChange();
                },
                onComplete: function() {
                  object.setCoords();
                  onComplete();
                }
              });
              return this;
            },
            fxCenterObjectV: function(object, callbacks) {
              callbacks = callbacks || {};
              var empty = function() {
              }, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;
              fabric.util.animate({
                startValue: object.top,
                endValue: this.getCenter().top,
                duration: this.FX_DURATION,
                onChange: function(value) {
                  object.set("top", value);
                  _this.requestRenderAll();
                  onChange();
                },
                onComplete: function() {
                  object.setCoords();
                  onComplete();
                }
              });
              return this;
            },
            fxRemove: function(object, callbacks) {
              callbacks = callbacks || {};
              var empty = function() {
              }, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;
              fabric.util.animate({
                startValue: object.opacity,
                endValue: 0,
                duration: this.FX_DURATION,
                onChange: function(value) {
                  object.set("opacity", value);
                  _this.requestRenderAll();
                  onChange();
                },
                onComplete: function() {
                  _this.remove(object);
                  onComplete();
                }
              });
              return this;
            }
          });
          fabric.util.object.extend(fabric.Object.prototype, {
            animate: function() {
              if (arguments[0] && typeof arguments[0] === "object") {
                var propsToAnimate = [], prop, skipCallbacks;
                for (prop in arguments[0]) {
                  propsToAnimate.push(prop);
                }
                for (var i = 0, len = propsToAnimate.length; i < len; i++) {
                  prop = propsToAnimate[i];
                  skipCallbacks = i !== len - 1;
                  this._animate(prop, arguments[0][prop], arguments[1], skipCallbacks);
                }
              } else {
                this._animate.apply(this, arguments);
              }
              return this;
            },
            _animate: function(property, to, options, skipCallbacks) {
              var _this = this, propPair;
              to = to.toString();
              if (!options) {
                options = {};
              } else {
                options = fabric.util.object.clone(options);
              }
              if (~property.indexOf(".")) {
                propPair = property.split(".");
              }
              var propIsColor = _this.colorProperties.indexOf(property) > -1 || propPair && _this.colorProperties.indexOf(propPair[1]) > -1;
              var currentValue = propPair ? this.get(propPair[0])[propPair[1]] : this.get(property);
              if (!("from" in options)) {
                options.from = currentValue;
              }
              if (!propIsColor) {
                if (~to.indexOf("=")) {
                  to = currentValue + parseFloat(to.replace("=", ""));
                } else {
                  to = parseFloat(to);
                }
              }
              var _options = {
                startValue: options.from,
                endValue: to,
                byValue: options.by,
                easing: options.easing,
                duration: options.duration,
                abort: options.abort && function(value, valueProgress, timeProgress) {
                  return options.abort.call(_this, value, valueProgress, timeProgress);
                },
                onChange: function(value, valueProgress, timeProgress) {
                  if (propPair) {
                    _this[propPair[0]][propPair[1]] = value;
                  } else {
                    _this.set(property, value);
                  }
                  if (skipCallbacks) {
                    return;
                  }
                  options.onChange && options.onChange(value, valueProgress, timeProgress);
                },
                onComplete: function(value, valueProgress, timeProgress) {
                  if (skipCallbacks) {
                    return;
                  }
                  _this.setCoords();
                  options.onComplete && options.onComplete(value, valueProgress, timeProgress);
                }
              };
              if (propIsColor) {
                return fabric.util.animateColor(_options.startValue, _options.endValue, _options.duration, _options);
              } else {
                return fabric.util.animate(_options);
              }
            }
          });
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), extend2 = fabric2.util.object.extend, clone2 = fabric2.util.object.clone, coordProps = { x1: 1, x2: 1, y1: 1, y2: 1 };
            if (fabric2.Line) {
              fabric2.warn("fabric.Line is already defined");
              return;
            }
            fabric2.Line = fabric2.util.createClass(fabric2.Object, {
              type: "line",
              x1: 0,
              y1: 0,
              x2: 0,
              y2: 0,
              cacheProperties: fabric2.Object.prototype.cacheProperties.concat("x1", "x2", "y1", "y2"),
              initialize: function(points, options) {
                if (!points) {
                  points = [0, 0, 0, 0];
                }
                this.callSuper("initialize", options);
                this.set("x1", points[0]);
                this.set("y1", points[1]);
                this.set("x2", points[2]);
                this.set("y2", points[3]);
                this._setWidthHeight(options);
              },
              _setWidthHeight: function(options) {
                options || (options = {});
                this.width = Math.abs(this.x2 - this.x1);
                this.height = Math.abs(this.y2 - this.y1);
                this.left = "left" in options ? options.left : this._getLeftToOriginX();
                this.top = "top" in options ? options.top : this._getTopToOriginY();
              },
              _set: function(key, value) {
                this.callSuper("_set", key, value);
                if (typeof coordProps[key] !== "undefined") {
                  this._setWidthHeight();
                }
                return this;
              },
              _getLeftToOriginX: makeEdgeToOriginGetter(
                {
                  origin: "originX",
                  axis1: "x1",
                  axis2: "x2",
                  dimension: "width"
                },
                {
                  nearest: "left",
                  center: "center",
                  farthest: "right"
                }
              ),
              _getTopToOriginY: makeEdgeToOriginGetter(
                {
                  origin: "originY",
                  axis1: "y1",
                  axis2: "y2",
                  dimension: "height"
                },
                {
                  nearest: "top",
                  center: "center",
                  farthest: "bottom"
                }
              ),
              _render: function(ctx) {
                ctx.beginPath();
                var p = this.calcLinePoints();
                ctx.moveTo(p.x1, p.y1);
                ctx.lineTo(p.x2, p.y2);
                ctx.lineWidth = this.strokeWidth;
                var origStrokeStyle = ctx.strokeStyle;
                ctx.strokeStyle = this.stroke || ctx.fillStyle;
                this.stroke && this._renderStroke(ctx);
                ctx.strokeStyle = origStrokeStyle;
              },
              _findCenterFromElement: function() {
                return {
                  x: (this.x1 + this.x2) / 2,
                  y: (this.y1 + this.y2) / 2
                };
              },
              toObject: function(propertiesToInclude) {
                return extend2(this.callSuper("toObject", propertiesToInclude), this.calcLinePoints());
              },
              _getNonTransformedDimensions: function() {
                var dim = this.callSuper("_getNonTransformedDimensions");
                if (this.strokeLineCap === "butt") {
                  if (this.width === 0) {
                    dim.y -= this.strokeWidth;
                  }
                  if (this.height === 0) {
                    dim.x -= this.strokeWidth;
                  }
                }
                return dim;
              },
              calcLinePoints: function() {
                var xMult = this.x1 <= this.x2 ? -1 : 1, yMult = this.y1 <= this.y2 ? -1 : 1, x1 = xMult * this.width * 0.5, y1 = yMult * this.height * 0.5, x2 = xMult * this.width * -0.5, y2 = yMult * this.height * -0.5;
                return {
                  x1,
                  x2,
                  y1,
                  y2
                };
              },
              _toSVG: function() {
                var p = this.calcLinePoints();
                return [
                  "<line ",
                  "COMMON_PARTS",
                  'x1="',
                  p.x1,
                  '" y1="',
                  p.y1,
                  '" x2="',
                  p.x2,
                  '" y2="',
                  p.y2,
                  '" />\n'
                ];
              }
            });
            fabric2.Line.ATTRIBUTE_NAMES = fabric2.SHARED_ATTRIBUTES.concat("x1 y1 x2 y2".split(" "));
            fabric2.Line.fromElement = function(element, callback, options) {
              options = options || {};
              var parsedAttributes = fabric2.parseAttributes(element, fabric2.Line.ATTRIBUTE_NAMES), points = [
                parsedAttributes.x1 || 0,
                parsedAttributes.y1 || 0,
                parsedAttributes.x2 || 0,
                parsedAttributes.y2 || 0
              ];
              callback(new fabric2.Line(points, extend2(parsedAttributes, options)));
            };
            fabric2.Line.fromObject = function(object, callback) {
              function _callback(instance) {
                delete instance.points;
                callback && callback(instance);
              }
              var options = clone2(object, true);
              options.points = [object.x1, object.y1, object.x2, object.y2];
              fabric2.Object._fromObject("Line", options, _callback, "points");
            };
            function makeEdgeToOriginGetter(propertyNames, originValues) {
              var origin = propertyNames.origin, axis1 = propertyNames.axis1, axis2 = propertyNames.axis2, dimension = propertyNames.dimension, nearest = originValues.nearest, center = originValues.center, farthest = originValues.farthest;
              return function() {
                switch (this.get(origin)) {
                  case nearest:
                    return Math.min(this.get(axis1), this.get(axis2));
                  case center:
                    return Math.min(this.get(axis1), this.get(axis2)) + 0.5 * this.get(dimension);
                  case farthest:
                    return Math.max(this.get(axis1), this.get(axis2));
                }
              };
            }
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), pi = Math.PI;
            if (fabric2.Circle) {
              fabric2.warn("fabric.Circle is already defined.");
              return;
            }
            fabric2.Circle = fabric2.util.createClass(fabric2.Object, {
              type: "circle",
              radius: 0,
              startAngle: 0,
              endAngle: pi * 2,
              cacheProperties: fabric2.Object.prototype.cacheProperties.concat("radius", "startAngle", "endAngle"),
              _set: function(key, value) {
                this.callSuper("_set", key, value);
                if (key === "radius") {
                  this.setRadius(value);
                }
                return this;
              },
              toObject: function(propertiesToInclude) {
                return this.callSuper("toObject", ["radius", "startAngle", "endAngle"].concat(propertiesToInclude));
              },
              _toSVG: function() {
                var svgString, x = 0, y = 0, angle2 = (this.endAngle - this.startAngle) % (2 * pi);
                if (angle2 === 0) {
                  svgString = [
                    "<circle ",
                    "COMMON_PARTS",
                    'cx="' + x + '" cy="' + y + '" ',
                    'r="',
                    this.radius,
                    '" />\n'
                  ];
                } else {
                  var startX = fabric2.util.cos(this.startAngle) * this.radius, startY = fabric2.util.sin(this.startAngle) * this.radius, endX = fabric2.util.cos(this.endAngle) * this.radius, endY = fabric2.util.sin(this.endAngle) * this.radius, largeFlag = angle2 > pi ? "1" : "0";
                  svgString = [
                    '<path d="M ' + startX + " " + startY,
                    " A " + this.radius + " " + this.radius,
                    " 0 ",
                    +largeFlag + " 1",
                    " " + endX + " " + endY,
                    '" ',
                    "COMMON_PARTS",
                    " />\n"
                  ];
                }
                return svgString;
              },
              _render: function(ctx) {
                ctx.beginPath();
                ctx.arc(
                  0,
                  0,
                  this.radius,
                  this.startAngle,
                  this.endAngle,
                  false
                );
                this._renderPaintInOrder(ctx);
              },
              getRadiusX: function() {
                return this.get("radius") * this.get("scaleX");
              },
              getRadiusY: function() {
                return this.get("radius") * this.get("scaleY");
              },
              setRadius: function(value) {
                this.radius = value;
                return this.set("width", value * 2).set("height", value * 2);
              }
            });
            fabric2.Circle.ATTRIBUTE_NAMES = fabric2.SHARED_ATTRIBUTES.concat("cx cy r".split(" "));
            fabric2.Circle.fromElement = function(element, callback) {
              var parsedAttributes = fabric2.parseAttributes(element, fabric2.Circle.ATTRIBUTE_NAMES);
              if (!isValidRadius(parsedAttributes)) {
                throw new Error("value of `r` attribute is required and can not be negative");
              }
              parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.radius;
              parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.radius;
              callback(new fabric2.Circle(parsedAttributes));
            };
            function isValidRadius(attributes) {
              return "radius" in attributes && attributes.radius >= 0;
            }
            fabric2.Circle.fromObject = function(object, callback) {
              fabric2.Object._fromObject("Circle", object, callback);
            };
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {});
            if (fabric2.Triangle) {
              fabric2.warn("fabric.Triangle is already defined");
              return;
            }
            fabric2.Triangle = fabric2.util.createClass(fabric2.Object, {
              type: "triangle",
              width: 100,
              height: 100,
              _render: function(ctx) {
                var widthBy2 = this.width / 2, heightBy2 = this.height / 2;
                ctx.beginPath();
                ctx.moveTo(-widthBy2, heightBy2);
                ctx.lineTo(0, -heightBy2);
                ctx.lineTo(widthBy2, heightBy2);
                ctx.closePath();
                this._renderPaintInOrder(ctx);
              },
              _toSVG: function() {
                var widthBy2 = this.width / 2, heightBy2 = this.height / 2, points = [
                  -widthBy2 + " " + heightBy2,
                  "0 " + -heightBy2,
                  widthBy2 + " " + heightBy2
                ].join(",");
                return [
                  "<polygon ",
                  "COMMON_PARTS",
                  'points="',
                  points,
                  '" />'
                ];
              }
            });
            fabric2.Triangle.fromObject = function(object, callback) {
              return fabric2.Object._fromObject("Triangle", object, callback);
            };
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), piBy2 = Math.PI * 2;
            if (fabric2.Ellipse) {
              fabric2.warn("fabric.Ellipse is already defined.");
              return;
            }
            fabric2.Ellipse = fabric2.util.createClass(fabric2.Object, {
              type: "ellipse",
              rx: 0,
              ry: 0,
              cacheProperties: fabric2.Object.prototype.cacheProperties.concat("rx", "ry"),
              initialize: function(options) {
                this.callSuper("initialize", options);
                this.set("rx", options && options.rx || 0);
                this.set("ry", options && options.ry || 0);
              },
              _set: function(key, value) {
                this.callSuper("_set", key, value);
                switch (key) {
                  case "rx":
                    this.rx = value;
                    this.set("width", value * 2);
                    break;
                  case "ry":
                    this.ry = value;
                    this.set("height", value * 2);
                    break;
                }
                return this;
              },
              getRx: function() {
                return this.get("rx") * this.get("scaleX");
              },
              getRy: function() {
                return this.get("ry") * this.get("scaleY");
              },
              toObject: function(propertiesToInclude) {
                return this.callSuper("toObject", ["rx", "ry"].concat(propertiesToInclude));
              },
              _toSVG: function() {
                return [
                  "<ellipse ",
                  "COMMON_PARTS",
                  'cx="0" cy="0" ',
                  'rx="',
                  this.rx,
                  '" ry="',
                  this.ry,
                  '" />\n'
                ];
              },
              _render: function(ctx) {
                ctx.beginPath();
                ctx.save();
                ctx.transform(1, 0, 0, this.ry / this.rx, 0, 0);
                ctx.arc(
                  0,
                  0,
                  this.rx,
                  0,
                  piBy2,
                  false
                );
                ctx.restore();
                this._renderPaintInOrder(ctx);
              }
            });
            fabric2.Ellipse.ATTRIBUTE_NAMES = fabric2.SHARED_ATTRIBUTES.concat("cx cy rx ry".split(" "));
            fabric2.Ellipse.fromElement = function(element, callback) {
              var parsedAttributes = fabric2.parseAttributes(element, fabric2.Ellipse.ATTRIBUTE_NAMES);
              parsedAttributes.left = (parsedAttributes.left || 0) - parsedAttributes.rx;
              parsedAttributes.top = (parsedAttributes.top || 0) - parsedAttributes.ry;
              callback(new fabric2.Ellipse(parsedAttributes));
            };
            fabric2.Ellipse.fromObject = function(object, callback) {
              fabric2.Object._fromObject("Ellipse", object, callback);
            };
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), extend2 = fabric2.util.object.extend;
            if (fabric2.Rect) {
              fabric2.warn("fabric.Rect is already defined");
              return;
            }
            fabric2.Rect = fabric2.util.createClass(fabric2.Object, {
              stateProperties: fabric2.Object.prototype.stateProperties.concat("rx", "ry"),
              type: "rect",
              rx: 0,
              ry: 0,
              cacheProperties: fabric2.Object.prototype.cacheProperties.concat("rx", "ry"),
              initialize: function(options) {
                this.callSuper("initialize", options);
                this._initRxRy();
              },
              _initRxRy: function() {
                if (this.rx && !this.ry) {
                  this.ry = this.rx;
                } else if (this.ry && !this.rx) {
                  this.rx = this.ry;
                }
              },
              _render: function(ctx) {
                var rx = this.rx ? Math.min(this.rx, this.width / 2) : 0, ry = this.ry ? Math.min(this.ry, this.height / 2) : 0, w = this.width, h2 = this.height, x = -this.width / 2, y = -this.height / 2, isRounded = rx !== 0 || ry !== 0, k = 1 - 0.5522847498;
                ctx.beginPath();
                ctx.moveTo(x + rx, y);
                ctx.lineTo(x + w - rx, y);
                isRounded && ctx.bezierCurveTo(x + w - k * rx, y, x + w, y + k * ry, x + w, y + ry);
                ctx.lineTo(x + w, y + h2 - ry);
                isRounded && ctx.bezierCurveTo(x + w, y + h2 - k * ry, x + w - k * rx, y + h2, x + w - rx, y + h2);
                ctx.lineTo(x + rx, y + h2);
                isRounded && ctx.bezierCurveTo(x + k * rx, y + h2, x, y + h2 - k * ry, x, y + h2 - ry);
                ctx.lineTo(x, y + ry);
                isRounded && ctx.bezierCurveTo(x, y + k * ry, x + k * rx, y, x + rx, y);
                ctx.closePath();
                this._renderPaintInOrder(ctx);
              },
              toObject: function(propertiesToInclude) {
                return this.callSuper("toObject", ["rx", "ry"].concat(propertiesToInclude));
              },
              _toSVG: function() {
                var x = -this.width / 2, y = -this.height / 2;
                return [
                  "<rect ",
                  "COMMON_PARTS",
                  'x="',
                  x,
                  '" y="',
                  y,
                  '" rx="',
                  this.rx,
                  '" ry="',
                  this.ry,
                  '" width="',
                  this.width,
                  '" height="',
                  this.height,
                  '" />\n'
                ];
              }
            });
            fabric2.Rect.ATTRIBUTE_NAMES = fabric2.SHARED_ATTRIBUTES.concat("x y rx ry width height".split(" "));
            fabric2.Rect.fromElement = function(element, callback, options) {
              if (!element) {
                return callback(null);
              }
              options = options || {};
              var parsedAttributes = fabric2.parseAttributes(element, fabric2.Rect.ATTRIBUTE_NAMES);
              parsedAttributes.left = parsedAttributes.left || 0;
              parsedAttributes.top = parsedAttributes.top || 0;
              parsedAttributes.height = parsedAttributes.height || 0;
              parsedAttributes.width = parsedAttributes.width || 0;
              var rect = new fabric2.Rect(extend2(options ? fabric2.util.object.clone(options) : {}, parsedAttributes));
              rect.visible = rect.visible && rect.width > 0 && rect.height > 0;
              callback(rect);
            };
            fabric2.Rect.fromObject = function(object, callback) {
              return fabric2.Object._fromObject("Rect", object, callback);
            };
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), extend2 = fabric2.util.object.extend, min = fabric2.util.array.min, max2 = fabric2.util.array.max, toFixed2 = fabric2.util.toFixed;
            if (fabric2.Polyline) {
              fabric2.warn("fabric.Polyline is already defined");
              return;
            }
            fabric2.Polyline = fabric2.util.createClass(fabric2.Object, {
              type: "polyline",
              points: null,
              cacheProperties: fabric2.Object.prototype.cacheProperties.concat("points"),
              initialize: function(points, options) {
                options = options || {};
                this.points = points || [];
                this.callSuper("initialize", options);
                this._setPositionDimensions(options);
              },
              _setPositionDimensions: function(options) {
                var calcDim = this._calcDimensions(options), correctLeftTop;
                this.width = calcDim.width;
                this.height = calcDim.height;
                if (!options.fromSVG) {
                  correctLeftTop = this.translateToGivenOrigin(
                    { x: calcDim.left - this.strokeWidth / 2, y: calcDim.top - this.strokeWidth / 2 },
                    "left",
                    "top",
                    this.originX,
                    this.originY
                  );
                }
                if (typeof options.left === "undefined") {
                  this.left = options.fromSVG ? calcDim.left : correctLeftTop.x;
                }
                if (typeof options.top === "undefined") {
                  this.top = options.fromSVG ? calcDim.top : correctLeftTop.y;
                }
                this.pathOffset = {
                  x: calcDim.left + this.width / 2,
                  y: calcDim.top + this.height / 2
                };
              },
              _calcDimensions: function() {
                var points = this.points, minX = min(points, "x") || 0, minY = min(points, "y") || 0, maxX = max2(points, "x") || 0, maxY = max2(points, "y") || 0, width = maxX - minX, height = maxY - minY;
                return {
                  left: minX,
                  top: minY,
                  width,
                  height
                };
              },
              toObject: function(propertiesToInclude) {
                return extend2(this.callSuper("toObject", propertiesToInclude), {
                  points: this.points.concat()
                });
              },
              _toSVG: function() {
                var points = [], diffX = this.pathOffset.x, diffY = this.pathOffset.y, NUM_FRACTION_DIGITS = fabric2.Object.NUM_FRACTION_DIGITS;
                for (var i = 0, len = this.points.length; i < len; i++) {
                  points.push(
                    toFixed2(this.points[i].x - diffX, NUM_FRACTION_DIGITS),
                    ",",
                    toFixed2(this.points[i].y - diffY, NUM_FRACTION_DIGITS),
                    " "
                  );
                }
                return [
                  "<" + this.type + " ",
                  "COMMON_PARTS",
                  'points="',
                  points.join(""),
                  '" />\n'
                ];
              },
              commonRender: function(ctx) {
                var point, len = this.points.length, x = this.pathOffset.x, y = this.pathOffset.y;
                if (!len || isNaN(this.points[len - 1].y)) {
                  return false;
                }
                ctx.beginPath();
                ctx.moveTo(this.points[0].x - x, this.points[0].y - y);
                for (var i = 0; i < len; i++) {
                  point = this.points[i];
                  ctx.lineTo(point.x - x, point.y - y);
                }
                return true;
              },
              _render: function(ctx) {
                if (!this.commonRender(ctx)) {
                  return;
                }
                this._renderPaintInOrder(ctx);
              },
              complexity: function() {
                return this.get("points").length;
              }
            });
            fabric2.Polyline.ATTRIBUTE_NAMES = fabric2.SHARED_ATTRIBUTES.concat();
            fabric2.Polyline.fromElementGenerator = function(_class) {
              return function(element, callback, options) {
                if (!element) {
                  return callback(null);
                }
                options || (options = {});
                var points = fabric2.parsePointsAttribute(element.getAttribute("points")), parsedAttributes = fabric2.parseAttributes(element, fabric2[_class].ATTRIBUTE_NAMES);
                parsedAttributes.fromSVG = true;
                callback(new fabric2[_class](points, extend2(parsedAttributes, options)));
              };
            };
            fabric2.Polyline.fromElement = fabric2.Polyline.fromElementGenerator("Polyline");
            fabric2.Polyline.fromObject = function(object, callback) {
              return fabric2.Object._fromObject("Polyline", object, callback, "points");
            };
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {});
            if (fabric2.Polygon) {
              fabric2.warn("fabric.Polygon is already defined");
              return;
            }
            fabric2.Polygon = fabric2.util.createClass(fabric2.Polyline, {
              type: "polygon",
              _render: function(ctx) {
                if (!this.commonRender(ctx)) {
                  return;
                }
                ctx.closePath();
                this._renderPaintInOrder(ctx);
              }
            });
            fabric2.Polygon.ATTRIBUTE_NAMES = fabric2.SHARED_ATTRIBUTES.concat();
            fabric2.Polygon.fromElement = fabric2.Polyline.fromElementGenerator("Polygon");
            fabric2.Polygon.fromObject = function(object, callback) {
              fabric2.Object._fromObject("Polygon", object, callback, "points");
            };
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), min = fabric2.util.array.min, max2 = fabric2.util.array.max, extend2 = fabric2.util.object.extend, _toString = Object.prototype.toString, toFixed2 = fabric2.util.toFixed;
            if (fabric2.Path) {
              fabric2.warn("fabric.Path is already defined");
              return;
            }
            fabric2.Path = fabric2.util.createClass(fabric2.Object, {
              type: "path",
              path: null,
              cacheProperties: fabric2.Object.prototype.cacheProperties.concat("path", "fillRule"),
              stateProperties: fabric2.Object.prototype.stateProperties.concat("path"),
              initialize: function(path, options) {
                options = options || {};
                this.callSuper("initialize", options);
                if (!path) {
                  path = [];
                }
                var fromArray = _toString.call(path) === "[object Array]";
                this.path = fabric2.util.makePathSimpler(
                  fromArray ? path : fabric2.util.parsePath(path)
                );
                if (!this.path) {
                  return;
                }
                fabric2.Polyline.prototype._setPositionDimensions.call(this, options);
              },
              _renderPathCommands: function(ctx) {
                var current, subpathStartX = 0, subpathStartY = 0, x = 0, y = 0, controlX = 0, controlY = 0, l = -this.pathOffset.x, t = -this.pathOffset.y;
                ctx.beginPath();
                for (var i = 0, len = this.path.length; i < len; ++i) {
                  current = this.path[i];
                  switch (current[0]) {
                    case "L":
                      x = current[1];
                      y = current[2];
                      ctx.lineTo(x + l, y + t);
                      break;
                    case "M":
                      x = current[1];
                      y = current[2];
                      subpathStartX = x;
                      subpathStartY = y;
                      ctx.moveTo(x + l, y + t);
                      break;
                    case "C":
                      x = current[5];
                      y = current[6];
                      controlX = current[3];
                      controlY = current[4];
                      ctx.bezierCurveTo(
                        current[1] + l,
                        current[2] + t,
                        controlX + l,
                        controlY + t,
                        x + l,
                        y + t
                      );
                      break;
                    case "Q":
                      ctx.quadraticCurveTo(
                        current[1] + l,
                        current[2] + t,
                        current[3] + l,
                        current[4] + t
                      );
                      x = current[3];
                      y = current[4];
                      controlX = current[1];
                      controlY = current[2];
                      break;
                    case "z":
                    case "Z":
                      x = subpathStartX;
                      y = subpathStartY;
                      ctx.closePath();
                      break;
                  }
                }
              },
              _render: function(ctx) {
                this._renderPathCommands(ctx);
                this._renderPaintInOrder(ctx);
              },
              toString: function() {
                return "#<fabric.Path (" + this.complexity() + '): { "top": ' + this.top + ', "left": ' + this.left + " }>";
              },
              toObject: function(propertiesToInclude) {
                return extend2(this.callSuper("toObject", propertiesToInclude), {
                  path: this.path.map(function(item) {
                    return item.slice();
                  })
                });
              },
              toDatalessObject: function(propertiesToInclude) {
                var o = this.toObject(["sourcePath"].concat(propertiesToInclude));
                if (o.sourcePath) {
                  delete o.path;
                }
                return o;
              },
              _toSVG: function() {
                var path = fabric2.util.joinPath(this.path);
                return [
                  "<path ",
                  "COMMON_PARTS",
                  'd="',
                  path,
                  '" stroke-linecap="round" ',
                  "/>\n"
                ];
              },
              _getOffsetTransform: function() {
                var digits = fabric2.Object.NUM_FRACTION_DIGITS;
                return " translate(" + toFixed2(-this.pathOffset.x, digits) + ", " + toFixed2(-this.pathOffset.y, digits) + ")";
              },
              toClipPathSVG: function(reviver) {
                var additionalTransform = this._getOffsetTransform();
                return "	" + this._createBaseClipPathSVGMarkup(
                  this._toSVG(),
                  { reviver, additionalTransform }
                );
              },
              toSVG: function(reviver) {
                var additionalTransform = this._getOffsetTransform();
                return this._createBaseSVGMarkup(this._toSVG(), { reviver, additionalTransform });
              },
              complexity: function() {
                return this.path.length;
              },
              _calcDimensions: function() {
                var aX = [], aY = [], current, subpathStartX = 0, subpathStartY = 0, x = 0, y = 0, bounds;
                for (var i = 0, len = this.path.length; i < len; ++i) {
                  current = this.path[i];
                  switch (current[0]) {
                    case "L":
                      x = current[1];
                      y = current[2];
                      bounds = [];
                      break;
                    case "M":
                      x = current[1];
                      y = current[2];
                      subpathStartX = x;
                      subpathStartY = y;
                      bounds = [];
                      break;
                    case "C":
                      bounds = fabric2.util.getBoundsOfCurve(
                        x,
                        y,
                        current[1],
                        current[2],
                        current[3],
                        current[4],
                        current[5],
                        current[6]
                      );
                      x = current[5];
                      y = current[6];
                      break;
                    case "Q":
                      bounds = fabric2.util.getBoundsOfCurve(
                        x,
                        y,
                        current[1],
                        current[2],
                        current[1],
                        current[2],
                        current[3],
                        current[4]
                      );
                      x = current[3];
                      y = current[4];
                      break;
                    case "z":
                    case "Z":
                      x = subpathStartX;
                      y = subpathStartY;
                      break;
                  }
                  bounds.forEach(function(point) {
                    aX.push(point.x);
                    aY.push(point.y);
                  });
                  aX.push(x);
                  aY.push(y);
                }
                var minX = min(aX) || 0, minY = min(aY) || 0, maxX = max2(aX) || 0, maxY = max2(aY) || 0, deltaX = maxX - minX, deltaY = maxY - minY;
                return {
                  left: minX,
                  top: minY,
                  width: deltaX,
                  height: deltaY
                };
              }
            });
            fabric2.Path.fromObject = function(object, callback) {
              if (typeof object.sourcePath === "string") {
                var pathUrl = object.sourcePath;
                fabric2.loadSVGFromURL(pathUrl, function(elements) {
                  var path = elements[0];
                  path.setOptions(object);
                  callback && callback(path);
                });
              } else {
                fabric2.Object._fromObject("Path", object, callback, "path");
              }
            };
            fabric2.Path.ATTRIBUTE_NAMES = fabric2.SHARED_ATTRIBUTES.concat(["d"]);
            fabric2.Path.fromElement = function(element, callback, options) {
              var parsedAttributes = fabric2.parseAttributes(element, fabric2.Path.ATTRIBUTE_NAMES);
              parsedAttributes.fromSVG = true;
              callback(new fabric2.Path(parsedAttributes.d, extend2(parsedAttributes, options)));
            };
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), min = fabric2.util.array.min, max2 = fabric2.util.array.max;
            if (fabric2.Group) {
              return;
            }
            fabric2.Group = fabric2.util.createClass(fabric2.Object, fabric2.Collection, {
              type: "group",
              strokeWidth: 0,
              subTargetCheck: false,
              cacheProperties: [],
              useSetOnGroup: false,
              initialize: function(objects, options, isAlreadyGrouped) {
                options = options || {};
                this._objects = [];
                isAlreadyGrouped && this.callSuper("initialize", options);
                this._objects = objects || [];
                for (var i = this._objects.length; i--; ) {
                  this._objects[i].group = this;
                }
                if (!isAlreadyGrouped) {
                  var center = options && options.centerPoint;
                  if (options.originX !== void 0) {
                    this.originX = options.originX;
                  }
                  if (options.originY !== void 0) {
                    this.originY = options.originY;
                  }
                  center || this._calcBounds();
                  this._updateObjectsCoords(center);
                  delete options.centerPoint;
                  this.callSuper("initialize", options);
                } else {
                  this._updateObjectsACoords();
                }
                this.setCoords();
              },
              _updateObjectsACoords: function() {
                var skipControls = true;
                for (var i = this._objects.length; i--; ) {
                  this._objects[i].setCoords(skipControls);
                }
              },
              _updateObjectsCoords: function(center) {
                var center = center || this.getCenterPoint();
                for (var i = this._objects.length; i--; ) {
                  this._updateObjectCoords(this._objects[i], center);
                }
              },
              _updateObjectCoords: function(object, center) {
                var objectLeft = object.left, objectTop = object.top, skipControls = true;
                object.set({
                  left: objectLeft - center.x,
                  top: objectTop - center.y
                });
                object.group = this;
                object.setCoords(skipControls);
              },
              toString: function() {
                return "#<fabric.Group: (" + this.complexity() + ")>";
              },
              addWithUpdate: function(object) {
                var nested = !!this.group;
                this._restoreObjectsState();
                fabric2.util.resetObjectTransform(this);
                if (object) {
                  if (nested) {
                    fabric2.util.removeTransformFromObject(object, this.group.calcTransformMatrix());
                  }
                  this._objects.push(object);
                  object.group = this;
                  object._set("canvas", this.canvas);
                }
                this._calcBounds();
                this._updateObjectsCoords();
                this.dirty = true;
                if (nested) {
                  this.group.addWithUpdate();
                } else {
                  this.setCoords();
                }
                return this;
              },
              removeWithUpdate: function(object) {
                this._restoreObjectsState();
                fabric2.util.resetObjectTransform(this);
                this.remove(object);
                this._calcBounds();
                this._updateObjectsCoords();
                this.setCoords();
                this.dirty = true;
                return this;
              },
              _onObjectAdded: function(object) {
                this.dirty = true;
                object.group = this;
                object._set("canvas", this.canvas);
              },
              _onObjectRemoved: function(object) {
                this.dirty = true;
                delete object.group;
              },
              _set: function(key, value) {
                var i = this._objects.length;
                if (this.useSetOnGroup) {
                  while (i--) {
                    this._objects[i].setOnGroup(key, value);
                  }
                }
                if (key === "canvas") {
                  while (i--) {
                    this._objects[i]._set(key, value);
                  }
                }
                fabric2.Object.prototype._set.call(this, key, value);
              },
              toObject: function(propertiesToInclude) {
                var _includeDefaultValues = this.includeDefaultValues;
                var objsToObject = this._objects.filter(function(obj2) {
                  return !obj2.excludeFromExport;
                }).map(function(obj2) {
                  var originalDefaults = obj2.includeDefaultValues;
                  obj2.includeDefaultValues = _includeDefaultValues;
                  var _obj = obj2.toObject(propertiesToInclude);
                  obj2.includeDefaultValues = originalDefaults;
                  return _obj;
                });
                var obj = fabric2.Object.prototype.toObject.call(this, propertiesToInclude);
                obj.objects = objsToObject;
                return obj;
              },
              toDatalessObject: function(propertiesToInclude) {
                var objsToObject, sourcePath = this.sourcePath;
                if (sourcePath) {
                  objsToObject = sourcePath;
                } else {
                  var _includeDefaultValues = this.includeDefaultValues;
                  objsToObject = this._objects.map(function(obj2) {
                    var originalDefaults = obj2.includeDefaultValues;
                    obj2.includeDefaultValues = _includeDefaultValues;
                    var _obj = obj2.toDatalessObject(propertiesToInclude);
                    obj2.includeDefaultValues = originalDefaults;
                    return _obj;
                  });
                }
                var obj = fabric2.Object.prototype.toDatalessObject.call(this, propertiesToInclude);
                obj.objects = objsToObject;
                return obj;
              },
              render: function(ctx) {
                this._transformDone = true;
                this.callSuper("render", ctx);
                this._transformDone = false;
              },
              shouldCache: function() {
                var ownCache = fabric2.Object.prototype.shouldCache.call(this);
                if (ownCache) {
                  for (var i = 0, len = this._objects.length; i < len; i++) {
                    if (this._objects[i].willDrawShadow()) {
                      this.ownCaching = false;
                      return false;
                    }
                  }
                }
                return ownCache;
              },
              willDrawShadow: function() {
                if (fabric2.Object.prototype.willDrawShadow.call(this)) {
                  return true;
                }
                for (var i = 0, len = this._objects.length; i < len; i++) {
                  if (this._objects[i].willDrawShadow()) {
                    return true;
                  }
                }
                return false;
              },
              isOnACache: function() {
                return this.ownCaching || this.group && this.group.isOnACache();
              },
              drawObject: function(ctx) {
                for (var i = 0, len = this._objects.length; i < len; i++) {
                  this._objects[i].render(ctx);
                }
                this._drawClipPath(ctx);
              },
              isCacheDirty: function(skipCanvas) {
                if (this.callSuper("isCacheDirty", skipCanvas)) {
                  return true;
                }
                if (!this.statefullCache) {
                  return false;
                }
                for (var i = 0, len = this._objects.length; i < len; i++) {
                  if (this._objects[i].isCacheDirty(true)) {
                    if (this._cacheCanvas) {
                      var x = this.cacheWidth / this.zoomX, y = this.cacheHeight / this.zoomY;
                      this._cacheContext.clearRect(-x / 2, -y / 2, x, y);
                    }
                    return true;
                  }
                }
                return false;
              },
              _restoreObjectsState: function() {
                var groupMatrix = this.calcOwnMatrix();
                this._objects.forEach(function(object) {
                  fabric2.util.addTransformToObject(object, groupMatrix);
                  delete object.group;
                  object.setCoords();
                });
                return this;
              },
              realizeTransform: function(object, parentMatrix) {
                fabric2.util.addTransformToObject(object, parentMatrix);
                return object;
              },
              destroy: function() {
                this._objects.forEach(function(object) {
                  object.set("dirty", true);
                });
                return this._restoreObjectsState();
              },
              toActiveSelection: function() {
                if (!this.canvas) {
                  return;
                }
                var objects = this._objects, canvas = this.canvas;
                this._objects = [];
                var options = this.toObject();
                delete options.objects;
                var activeSelection = new fabric2.ActiveSelection([]);
                activeSelection.set(options);
                activeSelection.type = "activeSelection";
                canvas.remove(this);
                objects.forEach(function(object) {
                  object.group = activeSelection;
                  object.dirty = true;
                  canvas.add(object);
                });
                activeSelection.canvas = canvas;
                activeSelection._objects = objects;
                canvas._activeObject = activeSelection;
                activeSelection.setCoords();
                return activeSelection;
              },
              ungroupOnCanvas: function() {
                return this._restoreObjectsState();
              },
              setObjectsCoords: function() {
                var skipControls = true;
                this.forEachObject(function(object) {
                  object.setCoords(skipControls);
                });
                return this;
              },
              _calcBounds: function(onlyWidthHeight) {
                var aX = [], aY = [], o, prop, coords, props2 = ["tr", "br", "bl", "tl"], i = 0, iLen = this._objects.length, j2, jLen = props2.length;
                for (; i < iLen; ++i) {
                  o = this._objects[i];
                  coords = o.calcACoords();
                  for (j2 = 0; j2 < jLen; j2++) {
                    prop = props2[j2];
                    aX.push(coords[prop].x);
                    aY.push(coords[prop].y);
                  }
                  o.aCoords = coords;
                }
                this._getBounds(aX, aY, onlyWidthHeight);
              },
              _getBounds: function(aX, aY, onlyWidthHeight) {
                var minXY = new fabric2.Point(min(aX), min(aY)), maxXY = new fabric2.Point(max2(aX), max2(aY)), top = minXY.y || 0, left = minXY.x || 0, width = maxXY.x - minXY.x || 0, height = maxXY.y - minXY.y || 0;
                this.width = width;
                this.height = height;
                if (!onlyWidthHeight) {
                  this.setPositionByOrigin({ x: left, y: top }, "left", "top");
                }
              },
              _toSVG: function(reviver) {
                var svgString = ["<g ", "COMMON_PARTS", " >\n"];
                for (var i = 0, len = this._objects.length; i < len; i++) {
                  svgString.push("		", this._objects[i].toSVG(reviver));
                }
                svgString.push("</g>\n");
                return svgString;
              },
              getSvgStyles: function() {
                var opacity2 = typeof this.opacity !== "undefined" && this.opacity !== 1 ? "opacity: " + this.opacity + ";" : "", visibility2 = this.visible ? "" : " visibility: hidden;";
                return [
                  opacity2,
                  this.getSvgFilter(),
                  visibility2
                ].join("");
              },
              toClipPathSVG: function(reviver) {
                var svgString = [];
                for (var i = 0, len = this._objects.length; i < len; i++) {
                  svgString.push("	", this._objects[i].toClipPathSVG(reviver));
                }
                return this._createBaseClipPathSVGMarkup(svgString, { reviver });
              }
            });
            fabric2.Group.fromObject = function(object, callback) {
              var objects = object.objects, options = fabric2.util.object.clone(object, true);
              delete options.objects;
              if (typeof objects === "string") {
                fabric2.loadSVGFromURL(objects, function(elements) {
                  var group = fabric2.util.groupSVGElements(elements, object, objects);
                  group.set(options);
                  callback && callback(group);
                });
                return;
              }
              fabric2.util.enlivenObjects(objects, function(enlivenedObjects) {
                fabric2.util.enlivenObjects([object.clipPath], function(enlivedClipPath) {
                  var options2 = fabric2.util.object.clone(object, true);
                  options2.clipPath = enlivedClipPath[0];
                  delete options2.objects;
                  callback && callback(new fabric2.Group(enlivenedObjects, options2, true));
                });
              });
            };
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {});
            if (fabric2.ActiveSelection) {
              return;
            }
            fabric2.ActiveSelection = fabric2.util.createClass(fabric2.Group, {
              type: "activeSelection",
              initialize: function(objects, options) {
                options = options || {};
                this._objects = objects || [];
                for (var i = this._objects.length; i--; ) {
                  this._objects[i].group = this;
                }
                if (options.originX) {
                  this.originX = options.originX;
                }
                if (options.originY) {
                  this.originY = options.originY;
                }
                this._calcBounds();
                this._updateObjectsCoords();
                fabric2.Object.prototype.initialize.call(this, options);
                this.setCoords();
              },
              toGroup: function() {
                var objects = this._objects.concat();
                this._objects = [];
                var options = fabric2.Object.prototype.toObject.call(this);
                var newGroup = new fabric2.Group([]);
                delete options.type;
                newGroup.set(options);
                objects.forEach(function(object) {
                  object.canvas.remove(object);
                  object.group = newGroup;
                });
                newGroup._objects = objects;
                if (!this.canvas) {
                  return newGroup;
                }
                var canvas = this.canvas;
                canvas.add(newGroup);
                canvas._activeObject = newGroup;
                newGroup.setCoords();
                return newGroup;
              },
              onDeselect: function() {
                this.destroy();
                return false;
              },
              toString: function() {
                return "#<fabric.ActiveSelection: (" + this.complexity() + ")>";
              },
              shouldCache: function() {
                return false;
              },
              isOnACache: function() {
                return false;
              },
              _renderControls: function(ctx, styleOverride, childrenOverride) {
                ctx.save();
                ctx.globalAlpha = this.isMoving ? this.borderOpacityWhenMoving : 1;
                this.callSuper("_renderControls", ctx, styleOverride);
                childrenOverride = childrenOverride || {};
                if (typeof childrenOverride.hasControls === "undefined") {
                  childrenOverride.hasControls = false;
                }
                childrenOverride.forActiveSelection = true;
                for (var i = 0, len = this._objects.length; i < len; i++) {
                  this._objects[i]._renderControls(ctx, childrenOverride);
                }
                ctx.restore();
              }
            });
            fabric2.ActiveSelection.fromObject = function(object, callback) {
              fabric2.util.enlivenObjects(object.objects, function(enlivenedObjects) {
                delete object.objects;
                callback && callback(new fabric2.ActiveSelection(enlivenedObjects, object, true));
              });
            };
          })(exports2);
          (function(global2) {
            var extend2 = fabric.util.object.extend;
            if (!global2.fabric) {
              global2.fabric = {};
            }
            if (global2.fabric.Image) {
              fabric.warn("fabric.Image is already defined.");
              return;
            }
            fabric.Image = fabric.util.createClass(fabric.Object, {
              type: "image",
              strokeWidth: 0,
              srcFromAttribute: false,
              _lastScaleX: 1,
              _lastScaleY: 1,
              _filterScalingX: 1,
              _filterScalingY: 1,
              minimumScaleTrigger: 0.5,
              stateProperties: fabric.Object.prototype.stateProperties.concat("cropX", "cropY"),
              cacheProperties: fabric.Object.prototype.cacheProperties.concat("cropX", "cropY"),
              cacheKey: "",
              cropX: 0,
              cropY: 0,
              imageSmoothing: true,
              initialize: function(element, options) {
                options || (options = {});
                this.filters = [];
                this.cacheKey = "texture" + fabric.Object.__uid++;
                this.callSuper("initialize", options);
                this._initElement(element, options);
              },
              getElement: function() {
                return this._element || {};
              },
              setElement: function(element, options) {
                this.removeTexture(this.cacheKey);
                this.removeTexture(this.cacheKey + "_filtered");
                this._element = element;
                this._originalElement = element;
                this._initConfig(options);
                if (this.filters.length !== 0) {
                  this.applyFilters();
                }
                if (this.resizeFilter) {
                  this.applyResizeFilters();
                }
                return this;
              },
              removeTexture: function(key) {
                var backend = fabric.filterBackend;
                if (backend && backend.evictCachesForKey) {
                  backend.evictCachesForKey(key);
                }
              },
              dispose: function() {
                this.removeTexture(this.cacheKey);
                this.removeTexture(this.cacheKey + "_filtered");
                this._cacheContext = void 0;
                ["_originalElement", "_element", "_filteredEl", "_cacheCanvas"].forEach(function(element) {
                  fabric.util.cleanUpJsdomNode(this[element]);
                  this[element] = void 0;
                }.bind(this));
              },
              getCrossOrigin: function() {
                return this._originalElement && (this._originalElement.crossOrigin || null);
              },
              getOriginalSize: function() {
                var element = this.getElement();
                return {
                  width: element.naturalWidth || element.width,
                  height: element.naturalHeight || element.height
                };
              },
              _stroke: function(ctx) {
                if (!this.stroke || this.strokeWidth === 0) {
                  return;
                }
                var w = this.width / 2, h2 = this.height / 2;
                ctx.beginPath();
                ctx.moveTo(-w, -h2);
                ctx.lineTo(w, -h2);
                ctx.lineTo(w, h2);
                ctx.lineTo(-w, h2);
                ctx.lineTo(-w, -h2);
                ctx.closePath();
              },
              toObject: function(propertiesToInclude) {
                var filters = [];
                this.filters.forEach(function(filterObj) {
                  if (filterObj) {
                    filters.push(filterObj.toObject());
                  }
                });
                var object = extend2(
                  this.callSuper(
                    "toObject",
                    ["cropX", "cropY"].concat(propertiesToInclude)
                  ),
                  {
                    src: this.getSrc(),
                    crossOrigin: this.getCrossOrigin(),
                    filters
                  }
                );
                if (this.resizeFilter) {
                  object.resizeFilter = this.resizeFilter.toObject();
                }
                return object;
              },
              hasCrop: function() {
                return this.cropX || this.cropY || this.width < this._element.width || this.height < this._element.height;
              },
              _toSVG: function() {
                var svgString = [], imageMarkup = [], strokeSvg, element = this._element, x = -this.width / 2, y = -this.height / 2, clipPath = "", imageRendering = "";
                if (!element) {
                  return [];
                }
                if (this.hasCrop()) {
                  var clipPathId = fabric.Object.__uid++;
                  svgString.push(
                    '<clipPath id="imageCrop_' + clipPathId + '">\n',
                    '	<rect x="' + x + '" y="' + y + '" width="' + this.width + '" height="' + this.height + '" />\n',
                    "</clipPath>\n"
                  );
                  clipPath = ' clip-path="url(#imageCrop_' + clipPathId + ')" ';
                }
                if (!this.imageSmoothing) {
                  imageRendering = '" image-rendering="optimizeSpeed';
                }
                imageMarkup.push(
                  "	<image ",
                  "COMMON_PARTS",
                  'xlink:href="',
                  this.getSvgSrc(true),
                  '" x="',
                  x - this.cropX,
                  '" y="',
                  y - this.cropY,
                  '" width="',
                  element.width || element.naturalWidth,
                  '" height="',
                  element.height || element.height,
                  imageRendering,
                  '"',
                  clipPath,
                  "></image>\n"
                );
                if (this.stroke || this.strokeDashArray) {
                  var origFill = this.fill;
                  this.fill = null;
                  strokeSvg = [
                    "	<rect ",
                    'x="',
                    x,
                    '" y="',
                    y,
                    '" width="',
                    this.width,
                    '" height="',
                    this.height,
                    '" style="',
                    this.getSvgStyles(),
                    '"/>\n'
                  ];
                  this.fill = origFill;
                }
                if (this.paintFirst !== "fill") {
                  svgString = svgString.concat(strokeSvg, imageMarkup);
                } else {
                  svgString = svgString.concat(imageMarkup, strokeSvg);
                }
                return svgString;
              },
              getSrc: function(filtered) {
                var element = filtered ? this._element : this._originalElement;
                if (element) {
                  if (element.toDataURL) {
                    return element.toDataURL();
                  }
                  if (this.srcFromAttribute) {
                    return element.getAttribute("src");
                  } else {
                    return element.src;
                  }
                } else {
                  return this.src || "";
                }
              },
              setSrc: function(src, callback, options) {
                fabric.util.loadImage(src, function(img, isError) {
                  this.setElement(img, options);
                  this._setWidthHeight();
                  callback && callback(this, isError);
                }, this, options && options.crossOrigin);
                return this;
              },
              toString: function() {
                return '#<fabric.Image: { src: "' + this.getSrc() + '" }>';
              },
              applyResizeFilters: function() {
                var filter = this.resizeFilter, minimumScale = this.minimumScaleTrigger, objectScale = this.getTotalObjectScaling(), scaleX = objectScale.scaleX, scaleY = objectScale.scaleY, elementToFilter = this._filteredEl || this._originalElement;
                if (this.group) {
                  this.set("dirty", true);
                }
                if (!filter || scaleX > minimumScale && scaleY > minimumScale) {
                  this._element = elementToFilter;
                  this._filterScalingX = 1;
                  this._filterScalingY = 1;
                  this._lastScaleX = scaleX;
                  this._lastScaleY = scaleY;
                  return;
                }
                if (!fabric.filterBackend) {
                  fabric.filterBackend = fabric.initFilterBackend();
                }
                var canvasEl = fabric.util.createCanvasElement(), cacheKey = this._filteredEl ? this.cacheKey + "_filtered" : this.cacheKey, sourceWidth = elementToFilter.width, sourceHeight = elementToFilter.height;
                canvasEl.width = sourceWidth;
                canvasEl.height = sourceHeight;
                this._element = canvasEl;
                this._lastScaleX = filter.scaleX = scaleX;
                this._lastScaleY = filter.scaleY = scaleY;
                fabric.filterBackend.applyFilters(
                  [filter],
                  elementToFilter,
                  sourceWidth,
                  sourceHeight,
                  this._element,
                  cacheKey
                );
                this._filterScalingX = canvasEl.width / this._originalElement.width;
                this._filterScalingY = canvasEl.height / this._originalElement.height;
              },
              applyFilters: function(filters) {
                filters = filters || this.filters || [];
                filters = filters.filter(function(filter) {
                  return filter && !filter.isNeutralState();
                });
                this.set("dirty", true);
                this.removeTexture(this.cacheKey + "_filtered");
                if (filters.length === 0) {
                  this._element = this._originalElement;
                  this._filteredEl = null;
                  this._filterScalingX = 1;
                  this._filterScalingY = 1;
                  return this;
                }
                var imgElement = this._originalElement, sourceWidth = imgElement.naturalWidth || imgElement.width, sourceHeight = imgElement.naturalHeight || imgElement.height;
                if (this._element === this._originalElement) {
                  var canvasEl = fabric.util.createCanvasElement();
                  canvasEl.width = sourceWidth;
                  canvasEl.height = sourceHeight;
                  this._element = canvasEl;
                  this._filteredEl = canvasEl;
                } else {
                  this._element = this._filteredEl;
                  this._filteredEl.getContext("2d").clearRect(0, 0, sourceWidth, sourceHeight);
                  this._lastScaleX = 1;
                  this._lastScaleY = 1;
                }
                if (!fabric.filterBackend) {
                  fabric.filterBackend = fabric.initFilterBackend();
                }
                fabric.filterBackend.applyFilters(
                  filters,
                  this._originalElement,
                  sourceWidth,
                  sourceHeight,
                  this._element,
                  this.cacheKey
                );
                if (this._originalElement.width !== this._element.width || this._originalElement.height !== this._element.height) {
                  this._filterScalingX = this._element.width / this._originalElement.width;
                  this._filterScalingY = this._element.height / this._originalElement.height;
                }
                return this;
              },
              _render: function(ctx) {
                fabric.util.setImageSmoothing(ctx, this.imageSmoothing);
                if (this.isMoving !== true && this.resizeFilter && this._needsResize()) {
                  this.applyResizeFilters();
                }
                this._stroke(ctx);
                this._renderPaintInOrder(ctx);
              },
              drawCacheOnCanvas: function(ctx) {
                fabric.util.setImageSmoothing(ctx, this.imageSmoothing);
                fabric.Object.prototype.drawCacheOnCanvas.call(this, ctx);
              },
              shouldCache: function() {
                return this.needsItsOwnCache();
              },
              _renderFill: function(ctx) {
                var elementToDraw = this._element;
                if (!elementToDraw) {
                  return;
                }
                var scaleX = this._filterScalingX, scaleY = this._filterScalingY, w = this.width, h2 = this.height, min = Math.min, max2 = Math.max, cropX = max2(this.cropX, 0), cropY = max2(this.cropY, 0), elWidth = elementToDraw.naturalWidth || elementToDraw.width, elHeight = elementToDraw.naturalHeight || elementToDraw.height, sX = cropX * scaleX, sY = cropY * scaleY, sW = min(w * scaleX, elWidth - sX), sH = min(h2 * scaleY, elHeight - sY), x = -w / 2, y = -h2 / 2, maxDestW = min(w, elWidth / scaleX - cropX), maxDestH = min(h2, elHeight / scaleY - cropY);
                elementToDraw && ctx.drawImage(elementToDraw, sX, sY, sW, sH, x, y, maxDestW, maxDestH);
              },
              _needsResize: function() {
                var scale = this.getTotalObjectScaling();
                return scale.scaleX !== this._lastScaleX || scale.scaleY !== this._lastScaleY;
              },
              _resetWidthHeight: function() {
                this.set(this.getOriginalSize());
              },
              _initElement: function(element, options) {
                this.setElement(fabric.util.getById(element), options);
                fabric.util.addClass(this.getElement(), fabric.Image.CSS_CANVAS);
              },
              _initConfig: function(options) {
                options || (options = {});
                this.setOptions(options);
                this._setWidthHeight(options);
              },
              _initFilters: function(filters, callback) {
                if (filters && filters.length) {
                  fabric.util.enlivenObjects(filters, function(enlivenedObjects) {
                    callback && callback(enlivenedObjects);
                  }, "fabric.Image.filters");
                } else {
                  callback && callback();
                }
              },
              _setWidthHeight: function(options) {
                options || (options = {});
                var el = this.getElement();
                this.width = options.width || el.naturalWidth || el.width || 0;
                this.height = options.height || el.naturalHeight || el.height || 0;
              },
              parsePreserveAspectRatioAttribute: function() {
                var pAR = fabric.util.parsePreserveAspectRatioAttribute(this.preserveAspectRatio || ""), rWidth = this._element.width, rHeight = this._element.height, scaleX = 1, scaleY = 1, offsetLeft = 0, offsetTop = 0, cropX = 0, cropY = 0, offset, pWidth = this.width, pHeight = this.height, parsedAttributes = { width: pWidth, height: pHeight };
                if (pAR && (pAR.alignX !== "none" || pAR.alignY !== "none")) {
                  if (pAR.meetOrSlice === "meet") {
                    scaleX = scaleY = fabric.util.findScaleToFit(this._element, parsedAttributes);
                    offset = (pWidth - rWidth * scaleX) / 2;
                    if (pAR.alignX === "Min") {
                      offsetLeft = -offset;
                    }
                    if (pAR.alignX === "Max") {
                      offsetLeft = offset;
                    }
                    offset = (pHeight - rHeight * scaleY) / 2;
                    if (pAR.alignY === "Min") {
                      offsetTop = -offset;
                    }
                    if (pAR.alignY === "Max") {
                      offsetTop = offset;
                    }
                  }
                  if (pAR.meetOrSlice === "slice") {
                    scaleX = scaleY = fabric.util.findScaleToCover(this._element, parsedAttributes);
                    offset = rWidth - pWidth / scaleX;
                    if (pAR.alignX === "Mid") {
                      cropX = offset / 2;
                    }
                    if (pAR.alignX === "Max") {
                      cropX = offset;
                    }
                    offset = rHeight - pHeight / scaleY;
                    if (pAR.alignY === "Mid") {
                      cropY = offset / 2;
                    }
                    if (pAR.alignY === "Max") {
                      cropY = offset;
                    }
                    rWidth = pWidth / scaleX;
                    rHeight = pHeight / scaleY;
                  }
                } else {
                  scaleX = pWidth / rWidth;
                  scaleY = pHeight / rHeight;
                }
                return {
                  width: rWidth,
                  height: rHeight,
                  scaleX,
                  scaleY,
                  offsetLeft,
                  offsetTop,
                  cropX,
                  cropY
                };
              }
            });
            fabric.Image.CSS_CANVAS = "canvas-img";
            fabric.Image.prototype.getSvgSrc = fabric.Image.prototype.getSrc;
            fabric.Image.fromObject = function(_object, callback) {
              var object = fabric.util.object.clone(_object);
              fabric.util.loadImage(object.src, function(img, isError) {
                if (isError) {
                  callback && callback(null, true);
                  return;
                }
                fabric.Image.prototype._initFilters.call(object, object.filters, function(filters) {
                  object.filters = filters || [];
                  fabric.Image.prototype._initFilters.call(object, [object.resizeFilter], function(resizeFilters) {
                    object.resizeFilter = resizeFilters[0];
                    fabric.util.enlivenObjects([object.clipPath], function(enlivedProps) {
                      object.clipPath = enlivedProps[0];
                      var image2 = new fabric.Image(img, object);
                      callback(image2, false);
                    });
                  });
                });
              }, null, object.crossOrigin);
            };
            fabric.Image.fromURL = function(url, callback, imgOptions) {
              fabric.util.loadImage(url, function(img, isError) {
                callback && callback(new fabric.Image(img, imgOptions), isError);
              }, null, imgOptions && imgOptions.crossOrigin);
            };
            fabric.Image.ATTRIBUTE_NAMES = fabric.SHARED_ATTRIBUTES.concat(
              "x y width height preserveAspectRatio xlink:href crossOrigin image-rendering".split(" ")
            );
            fabric.Image.fromElement = function(element, callback, options) {
              var parsedAttributes = fabric.parseAttributes(element, fabric.Image.ATTRIBUTE_NAMES);
              fabric.Image.fromURL(
                parsedAttributes["xlink:href"],
                callback,
                extend2(options ? fabric.util.object.clone(options) : {}, parsedAttributes)
              );
            };
          })(exports2);
          fabric.util.object.extend(fabric.Object.prototype, {
            _getAngleValueForStraighten: function() {
              var angle2 = this.angle % 360;
              if (angle2 > 0) {
                return Math.round((angle2 - 1) / 90) * 90;
              }
              return Math.round(angle2 / 90) * 90;
            },
            straighten: function() {
              this.rotate(this._getAngleValueForStraighten());
              return this;
            },
            fxStraighten: function(callbacks) {
              callbacks = callbacks || {};
              var empty = function() {
              }, onComplete = callbacks.onComplete || empty, onChange = callbacks.onChange || empty, _this = this;
              fabric.util.animate({
                startValue: this.get("angle"),
                endValue: this._getAngleValueForStraighten(),
                duration: this.FX_DURATION,
                onChange: function(value) {
                  _this.rotate(value);
                  onChange();
                },
                onComplete: function() {
                  _this.setCoords();
                  onComplete();
                }
              });
              return this;
            }
          });
          fabric.util.object.extend(fabric.StaticCanvas.prototype, {
            straightenObject: function(object) {
              object.straighten();
              this.requestRenderAll();
              return this;
            },
            fxStraightenObject: function(object) {
              object.fxStraighten({
                onChange: this.requestRenderAllBound
              });
              return this;
            }
          });
          (function() {
            function testPrecision(gl, precision) {
              var fragmentSource = "precision " + precision + " float;\nvoid main(){}";
              var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
              gl.shaderSource(fragmentShader, fragmentSource);
              gl.compileShader(fragmentShader);
              if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                return false;
              }
              return true;
            }
            fabric.isWebglSupported = function(tileSize) {
              if (fabric.isLikelyNode) {
                return false;
              }
              tileSize = tileSize || fabric.WebglFilterBackend.prototype.tileSize;
              var canvas = document.createElement("canvas");
              var gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
              var isSupported = false;
              if (gl) {
                fabric.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
                isSupported = fabric.maxTextureSize >= tileSize;
                var precisions = ["highp", "mediump", "lowp"];
                for (var i = 0; i < 3; i++) {
                  if (testPrecision(gl, precisions[i])) {
                    fabric.webGlPrecision = precisions[i];
                    break;
                  }
                }
              }
              this.isSupported = isSupported;
              return isSupported;
            };
            fabric.WebglFilterBackend = WebglFilterBackend;
            function WebglFilterBackend(options) {
              if (options && options.tileSize) {
                this.tileSize = options.tileSize;
              }
              this.setupGLContext(this.tileSize, this.tileSize);
              this.captureGPUInfo();
            }
            WebglFilterBackend.prototype = {
              tileSize: 2048,
              resources: {},
              setupGLContext: function(width, height) {
                this.dispose();
                this.createWebGLCanvas(width, height);
                this.aPosition = new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]);
                this.chooseFastestCopyGLTo2DMethod(width, height);
              },
              chooseFastestCopyGLTo2DMethod: function(width, height) {
                var canMeasurePerf = typeof window.performance !== "undefined", canUseImageData;
                try {
                  new ImageData(1, 1);
                  canUseImageData = true;
                } catch (e2) {
                  canUseImageData = false;
                }
                var canUseArrayBuffer = typeof ArrayBuffer !== "undefined";
                var canUseUint8Clamped = typeof Uint8ClampedArray !== "undefined";
                if (!(canMeasurePerf && canUseImageData && canUseArrayBuffer && canUseUint8Clamped)) {
                  return;
                }
                var targetCanvas = fabric.util.createCanvasElement();
                var imageBuffer = new ArrayBuffer(width * height * 4);
                if (fabric.forceGLPutImageData) {
                  this.imageBuffer = imageBuffer;
                  this.copyGLTo2D = copyGLTo2DPutImageData;
                  return;
                }
                var testContext = {
                  imageBuffer,
                  destinationWidth: width,
                  destinationHeight: height,
                  targetCanvas
                };
                var startTime, drawImageTime, putImageDataTime;
                targetCanvas.width = width;
                targetCanvas.height = height;
                startTime = window.performance.now();
                copyGLTo2DDrawImage.call(testContext, this.gl, testContext);
                drawImageTime = window.performance.now() - startTime;
                startTime = window.performance.now();
                copyGLTo2DPutImageData.call(testContext, this.gl, testContext);
                putImageDataTime = window.performance.now() - startTime;
                if (drawImageTime > putImageDataTime) {
                  this.imageBuffer = imageBuffer;
                  this.copyGLTo2D = copyGLTo2DPutImageData;
                } else {
                  this.copyGLTo2D = copyGLTo2DDrawImage;
                }
              },
              createWebGLCanvas: function(width, height) {
                var canvas = fabric.util.createCanvasElement();
                canvas.width = width;
                canvas.height = height;
                var glOptions = {
                  alpha: true,
                  premultipliedAlpha: false,
                  depth: false,
                  stencil: false,
                  antialias: false
                }, gl = canvas.getContext("webgl", glOptions);
                if (!gl) {
                  gl = canvas.getContext("experimental-webgl", glOptions);
                }
                if (!gl) {
                  return;
                }
                gl.clearColor(0, 0, 0, 0);
                this.canvas = canvas;
                this.gl = gl;
              },
              applyFilters: function(filters, source2, width, height, targetCanvas, cacheKey) {
                var gl = this.gl;
                var cachedTexture;
                if (cacheKey) {
                  cachedTexture = this.getCachedTexture(cacheKey, source2);
                }
                var pipelineState = {
                  originalWidth: source2.width || source2.originalWidth,
                  originalHeight: source2.height || source2.originalHeight,
                  sourceWidth: width,
                  sourceHeight: height,
                  destinationWidth: width,
                  destinationHeight: height,
                  context: gl,
                  sourceTexture: this.createTexture(gl, width, height, !cachedTexture && source2),
                  targetTexture: this.createTexture(gl, width, height),
                  originalTexture: cachedTexture || this.createTexture(gl, width, height, !cachedTexture && source2),
                  passes: filters.length,
                  webgl: true,
                  aPosition: this.aPosition,
                  programCache: this.programCache,
                  pass: 0,
                  filterBackend: this,
                  targetCanvas
                };
                var tempFbo = gl.createFramebuffer();
                gl.bindFramebuffer(gl.FRAMEBUFFER, tempFbo);
                filters.forEach(function(filter) {
                  filter && filter.applyTo(pipelineState);
                });
                resizeCanvasIfNeeded(pipelineState);
                this.copyGLTo2D(gl, pipelineState);
                gl.bindTexture(gl.TEXTURE_2D, null);
                gl.deleteTexture(pipelineState.sourceTexture);
                gl.deleteTexture(pipelineState.targetTexture);
                gl.deleteFramebuffer(tempFbo);
                targetCanvas.getContext("2d").setTransform(1, 0, 0, 1, 0, 0);
                return pipelineState;
              },
              dispose: function() {
                if (this.canvas) {
                  this.canvas = null;
                  this.gl = null;
                }
                this.clearWebGLCaches();
              },
              clearWebGLCaches: function() {
                this.programCache = {};
                this.textureCache = {};
              },
              createTexture: function(gl, width, height, textureImageSource) {
                var texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                if (textureImageSource) {
                  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImageSource);
                } else {
                  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                }
                return texture;
              },
              getCachedTexture: function(uniqueId, textureImageSource) {
                if (this.textureCache[uniqueId]) {
                  return this.textureCache[uniqueId];
                } else {
                  var texture = this.createTexture(
                    this.gl,
                    textureImageSource.width,
                    textureImageSource.height,
                    textureImageSource
                  );
                  this.textureCache[uniqueId] = texture;
                  return texture;
                }
              },
              evictCachesForKey: function(cacheKey) {
                if (this.textureCache[cacheKey]) {
                  this.gl.deleteTexture(this.textureCache[cacheKey]);
                  delete this.textureCache[cacheKey];
                }
              },
              copyGLTo2D: copyGLTo2DDrawImage,
              captureGPUInfo: function() {
                if (this.gpuInfo) {
                  return this.gpuInfo;
                }
                var gl = this.gl, gpuInfo = { renderer: "", vendor: "" };
                if (!gl) {
                  return gpuInfo;
                }
                var ext = gl.getExtension("WEBGL_debug_renderer_info");
                if (ext) {
                  var renderer = gl.getParameter(ext.UNMASKED_RENDERER_WEBGL);
                  var vendor = gl.getParameter(ext.UNMASKED_VENDOR_WEBGL);
                  if (renderer) {
                    gpuInfo.renderer = renderer.toLowerCase();
                  }
                  if (vendor) {
                    gpuInfo.vendor = vendor.toLowerCase();
                  }
                }
                this.gpuInfo = gpuInfo;
                return gpuInfo;
              }
            };
          })();
          function resizeCanvasIfNeeded(pipelineState) {
            var targetCanvas = pipelineState.targetCanvas, width = targetCanvas.width, height = targetCanvas.height, dWidth = pipelineState.destinationWidth, dHeight = pipelineState.destinationHeight;
            if (width !== dWidth || height !== dHeight) {
              targetCanvas.width = dWidth;
              targetCanvas.height = dHeight;
            }
          }
          function copyGLTo2DDrawImage(gl, pipelineState) {
            var glCanvas = gl.canvas, targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext("2d");
            ctx.translate(0, targetCanvas.height);
            ctx.scale(1, -1);
            var sourceY = glCanvas.height - targetCanvas.height;
            ctx.drawImage(
              glCanvas,
              0,
              sourceY,
              targetCanvas.width,
              targetCanvas.height,
              0,
              0,
              targetCanvas.width,
              targetCanvas.height
            );
          }
          function copyGLTo2DPutImageData(gl, pipelineState) {
            var targetCanvas = pipelineState.targetCanvas, ctx = targetCanvas.getContext("2d"), dWidth = pipelineState.destinationWidth, dHeight = pipelineState.destinationHeight, numBytes = dWidth * dHeight * 4;
            var u8 = new Uint8Array(this.imageBuffer, 0, numBytes);
            var u8Clamped = new Uint8ClampedArray(this.imageBuffer, 0, numBytes);
            gl.readPixels(0, 0, dWidth, dHeight, gl.RGBA, gl.UNSIGNED_BYTE, u8);
            var imgData = new ImageData(u8Clamped, dWidth, dHeight);
            ctx.putImageData(imgData, 0, 0);
          }
          (function() {
            var noop = function() {
            };
            fabric.Canvas2dFilterBackend = Canvas2dFilterBackend;
            function Canvas2dFilterBackend() {
            }
            Canvas2dFilterBackend.prototype = {
              evictCachesForKey: noop,
              dispose: noop,
              clearWebGLCaches: noop,
              resources: {},
              applyFilters: function(filters, sourceElement, sourceWidth, sourceHeight, targetCanvas) {
                var ctx = targetCanvas.getContext("2d");
                ctx.drawImage(sourceElement, 0, 0, sourceWidth, sourceHeight);
                var imageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
                var originalImageData = ctx.getImageData(0, 0, sourceWidth, sourceHeight);
                var pipelineState = {
                  sourceWidth,
                  sourceHeight,
                  imageData,
                  originalEl: sourceElement,
                  originalImageData,
                  canvasEl: targetCanvas,
                  ctx,
                  filterBackend: this
                };
                filters.forEach(function(filter) {
                  filter.applyTo(pipelineState);
                });
                if (pipelineState.imageData.width !== sourceWidth || pipelineState.imageData.height !== sourceHeight) {
                  targetCanvas.width = pipelineState.imageData.width;
                  targetCanvas.height = pipelineState.imageData.height;
                }
                ctx.putImageData(pipelineState.imageData, 0, 0);
                return pipelineState;
              }
            };
          })();
          fabric.Image = fabric.Image || {};
          fabric.Image.filters = fabric.Image.filters || {};
          fabric.Image.filters.BaseFilter = fabric.util.createClass({
            type: "BaseFilter",
            vertexSource: "attribute vec2 aPosition;\nvarying vec2 vTexCoord;\nvoid main() {\nvTexCoord = aPosition;\ngl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n}",
            fragmentSource: "precision highp float;\nvarying vec2 vTexCoord;\nuniform sampler2D uTexture;\nvoid main() {\ngl_FragColor = texture2D(uTexture, vTexCoord);\n}",
            initialize: function(options) {
              if (options) {
                this.setOptions(options);
              }
            },
            setOptions: function(options) {
              for (var prop in options) {
                this[prop] = options[prop];
              }
            },
            createProgram: function(gl, fragmentSource, vertexSource) {
              fragmentSource = fragmentSource || this.fragmentSource;
              vertexSource = vertexSource || this.vertexSource;
              if (fabric.webGlPrecision !== "highp") {
                fragmentSource = fragmentSource.replace(
                  /precision highp float/g,
                  "precision " + fabric.webGlPrecision + " float"
                );
              }
              var vertexShader = gl.createShader(gl.VERTEX_SHADER);
              gl.shaderSource(vertexShader, vertexSource);
              gl.compileShader(vertexShader);
              if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
                throw new Error(
                  "Vertex shader compile error for " + this.type + ": " + gl.getShaderInfoLog(vertexShader)
                );
              }
              var fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
              gl.shaderSource(fragmentShader, fragmentSource);
              gl.compileShader(fragmentShader);
              if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
                throw new Error(
                  "Fragment shader compile error for " + this.type + ": " + gl.getShaderInfoLog(fragmentShader)
                );
              }
              var program = gl.createProgram();
              gl.attachShader(program, vertexShader);
              gl.attachShader(program, fragmentShader);
              gl.linkProgram(program);
              if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                throw new Error(
                  'Shader link error for "${this.type}" ' + gl.getProgramInfoLog(program)
                );
              }
              var attributeLocations = this.getAttributeLocations(gl, program);
              var uniformLocations = this.getUniformLocations(gl, program) || {};
              uniformLocations.uStepW = gl.getUniformLocation(program, "uStepW");
              uniformLocations.uStepH = gl.getUniformLocation(program, "uStepH");
              return {
                program,
                attributeLocations,
                uniformLocations
              };
            },
            getAttributeLocations: function(gl, program) {
              return {
                aPosition: gl.getAttribLocation(program, "aPosition")
              };
            },
            getUniformLocations: function() {
              return {};
            },
            sendAttributeData: function(gl, attributeLocations, aPositionData) {
              var attributeLocation = attributeLocations.aPosition;
              var buffer = gl.createBuffer();
              gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
              gl.enableVertexAttribArray(attributeLocation);
              gl.vertexAttribPointer(attributeLocation, 2, gl.FLOAT, false, 0, 0);
              gl.bufferData(gl.ARRAY_BUFFER, aPositionData, gl.STATIC_DRAW);
            },
            _setupFrameBuffer: function(options) {
              var gl = options.context, width, height;
              if (options.passes > 1) {
                width = options.destinationWidth;
                height = options.destinationHeight;
                if (options.sourceWidth !== width || options.sourceHeight !== height) {
                  gl.deleteTexture(options.targetTexture);
                  options.targetTexture = options.filterBackend.createTexture(gl, width, height);
                }
                gl.framebufferTexture2D(
                  gl.FRAMEBUFFER,
                  gl.COLOR_ATTACHMENT0,
                  gl.TEXTURE_2D,
                  options.targetTexture,
                  0
                );
              } else {
                gl.bindFramebuffer(gl.FRAMEBUFFER, null);
                gl.finish();
              }
            },
            _swapTextures: function(options) {
              options.passes--;
              options.pass++;
              var temp = options.targetTexture;
              options.targetTexture = options.sourceTexture;
              options.sourceTexture = temp;
            },
            isNeutralState: function() {
              var main2 = this.mainParameter, _class = fabric.Image.filters[this.type].prototype;
              if (main2) {
                if (Array.isArray(_class[main2])) {
                  for (var i = _class[main2].length; i--; ) {
                    if (this[main2][i] !== _class[main2][i]) {
                      return false;
                    }
                  }
                  return true;
                } else {
                  return _class[main2] === this[main2];
                }
              } else {
                return false;
              }
            },
            applyTo: function(options) {
              if (options.webgl) {
                this._setupFrameBuffer(options);
                this.applyToWebGL(options);
                this._swapTextures(options);
              } else {
                this.applyTo2d(options);
              }
            },
            retrieveShader: function(options) {
              if (!options.programCache.hasOwnProperty(this.type)) {
                options.programCache[this.type] = this.createProgram(options.context);
              }
              return options.programCache[this.type];
            },
            applyToWebGL: function(options) {
              var gl = options.context;
              var shader = this.retrieveShader(options);
              if (options.pass === 0 && options.originalTexture) {
                gl.bindTexture(gl.TEXTURE_2D, options.originalTexture);
              } else {
                gl.bindTexture(gl.TEXTURE_2D, options.sourceTexture);
              }
              gl.useProgram(shader.program);
              this.sendAttributeData(gl, shader.attributeLocations, options.aPosition);
              gl.uniform1f(shader.uniformLocations.uStepW, 1 / options.sourceWidth);
              gl.uniform1f(shader.uniformLocations.uStepH, 1 / options.sourceHeight);
              this.sendUniformData(gl, shader.uniformLocations);
              gl.viewport(0, 0, options.destinationWidth, options.destinationHeight);
              gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            },
            bindAdditionalTexture: function(gl, texture, textureUnit) {
              gl.activeTexture(textureUnit);
              gl.bindTexture(gl.TEXTURE_2D, texture);
              gl.activeTexture(gl.TEXTURE0);
            },
            unbindAdditionalTexture: function(gl, textureUnit) {
              gl.activeTexture(textureUnit);
              gl.bindTexture(gl.TEXTURE_2D, null);
              gl.activeTexture(gl.TEXTURE0);
            },
            getMainParameter: function() {
              return this[this.mainParameter];
            },
            setMainParameter: function(value) {
              this[this.mainParameter] = value;
            },
            sendUniformData: function() {
            },
            createHelpLayer: function(options) {
              if (!options.helpLayer) {
                var helpLayer = document.createElement("canvas");
                helpLayer.width = options.sourceWidth;
                helpLayer.height = options.sourceHeight;
                options.helpLayer = helpLayer;
              }
            },
            toObject: function() {
              var object = { type: this.type }, mainP = this.mainParameter;
              if (mainP) {
                object[mainP] = this[mainP];
              }
              return object;
            },
            toJSON: function() {
              return this.toObject();
            }
          });
          fabric.Image.filters.BaseFilter.fromObject = function(object, callback) {
            var filter = new fabric.Image.filters[object.type](object);
            callback && callback(filter);
            return filter;
          };
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
            filters.ColorMatrix = createClass(filters.BaseFilter, {
              type: "ColorMatrix",
              fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nvarying vec2 vTexCoord;\nuniform mat4 uColorMatrix;\nuniform vec4 uConstants;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor *= uColorMatrix;\ncolor += uConstants;\ngl_FragColor = color;\n}",
              matrix: [
                1,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                1,
                0,
                0,
                0,
                0,
                0,
                1,
                0
              ],
              mainParameter: "matrix",
              colorsOnly: true,
              initialize: function(options) {
                this.callSuper("initialize", options);
                this.matrix = this.matrix.slice(0);
              },
              applyTo2d: function(options) {
                var imageData = options.imageData, data = imageData.data, iLen = data.length, m = this.matrix, r, g, b, a2, i, colorsOnly = this.colorsOnly;
                for (i = 0; i < iLen; i += 4) {
                  r = data[i];
                  g = data[i + 1];
                  b = data[i + 2];
                  if (colorsOnly) {
                    data[i] = r * m[0] + g * m[1] + b * m[2] + m[4] * 255;
                    data[i + 1] = r * m[5] + g * m[6] + b * m[7] + m[9] * 255;
                    data[i + 2] = r * m[10] + g * m[11] + b * m[12] + m[14] * 255;
                  } else {
                    a2 = data[i + 3];
                    data[i] = r * m[0] + g * m[1] + b * m[2] + a2 * m[3] + m[4] * 255;
                    data[i + 1] = r * m[5] + g * m[6] + b * m[7] + a2 * m[8] + m[9] * 255;
                    data[i + 2] = r * m[10] + g * m[11] + b * m[12] + a2 * m[13] + m[14] * 255;
                    data[i + 3] = r * m[15] + g * m[16] + b * m[17] + a2 * m[18] + m[19] * 255;
                  }
                }
              },
              getUniformLocations: function(gl, program) {
                return {
                  uColorMatrix: gl.getUniformLocation(program, "uColorMatrix"),
                  uConstants: gl.getUniformLocation(program, "uConstants")
                };
              },
              sendUniformData: function(gl, uniformLocations) {
                var m = this.matrix, matrix2 = [
                  m[0],
                  m[1],
                  m[2],
                  m[3],
                  m[5],
                  m[6],
                  m[7],
                  m[8],
                  m[10],
                  m[11],
                  m[12],
                  m[13],
                  m[15],
                  m[16],
                  m[17],
                  m[18]
                ], constants = [m[4], m[9], m[14], m[19]];
                gl.uniformMatrix4fv(uniformLocations.uColorMatrix, false, matrix2);
                gl.uniform4fv(uniformLocations.uConstants, constants);
              }
            });
            fabric2.Image.filters.ColorMatrix.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
            filters.Brightness = createClass(filters.BaseFilter, {
              type: "Brightness",
              fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uBrightness;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor.rgb += uBrightness;\ngl_FragColor = color;\n}",
              brightness: 0,
              mainParameter: "brightness",
              applyTo2d: function(options) {
                if (this.brightness === 0) {
                  return;
                }
                var imageData = options.imageData, data = imageData.data, i, len = data.length, brightness = Math.round(this.brightness * 255);
                for (i = 0; i < len; i += 4) {
                  data[i] = data[i] + brightness;
                  data[i + 1] = data[i + 1] + brightness;
                  data[i + 2] = data[i + 2] + brightness;
                }
              },
              getUniformLocations: function(gl, program) {
                return {
                  uBrightness: gl.getUniformLocation(program, "uBrightness")
                };
              },
              sendUniformData: function(gl, uniformLocations) {
                gl.uniform1f(uniformLocations.uBrightness, this.brightness);
              }
            });
            fabric2.Image.filters.Brightness.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), extend2 = fabric2.util.object.extend, filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
            filters.Convolute = createClass(filters.BaseFilter, {
              type: "Convolute",
              opaque: false,
              matrix: [0, 0, 0, 0, 1, 0, 0, 0, 0],
              fragmentSource: {
                Convolute_3_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[9];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 3.0; h+=1.0) {\nfor (float w = 0.0; w < 3.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 1), uStepH * (h - 1));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 3.0 + w)];\n}\n}\ngl_FragColor = color;\n}",
                Convolute_3_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[9];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 3.0; h+=1.0) {\nfor (float w = 0.0; w < 3.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 1.0), uStepH * (h - 1.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 3.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}",
                Convolute_5_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[25];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 5.0; h+=1.0) {\nfor (float w = 0.0; w < 5.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 5.0 + w)];\n}\n}\ngl_FragColor = color;\n}",
                Convolute_5_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[25];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 5.0; h+=1.0) {\nfor (float w = 0.0; w < 5.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 2.0), uStepH * (h - 2.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 5.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}",
                Convolute_7_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[49];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 7.0; h+=1.0) {\nfor (float w = 0.0; w < 7.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 7.0 + w)];\n}\n}\ngl_FragColor = color;\n}",
                Convolute_7_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[49];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 7.0; h+=1.0) {\nfor (float w = 0.0; w < 7.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 3.0), uStepH * (h - 3.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 7.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}",
                Convolute_9_1: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[81];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 0);\nfor (float h = 0.0; h < 9.0; h+=1.0) {\nfor (float w = 0.0; w < 9.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\ncolor += texture2D(uTexture, vTexCoord + matrixPos) * uMatrix[int(h * 9.0 + w)];\n}\n}\ngl_FragColor = color;\n}",
                Convolute_9_0: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uMatrix[81];\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = vec4(0, 0, 0, 1);\nfor (float h = 0.0; h < 9.0; h+=1.0) {\nfor (float w = 0.0; w < 9.0; w+=1.0) {\nvec2 matrixPos = vec2(uStepW * (w - 4.0), uStepH * (h - 4.0));\ncolor.rgb += texture2D(uTexture, vTexCoord + matrixPos).rgb * uMatrix[int(h * 9.0 + w)];\n}\n}\nfloat alpha = texture2D(uTexture, vTexCoord).a;\ngl_FragColor = color;\ngl_FragColor.a = alpha;\n}"
              },
              retrieveShader: function(options) {
                var size = Math.sqrt(this.matrix.length);
                var cacheKey = this.type + "_" + size + "_" + (this.opaque ? 1 : 0);
                var shaderSource = this.fragmentSource[cacheKey];
                if (!options.programCache.hasOwnProperty(cacheKey)) {
                  options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
                }
                return options.programCache[cacheKey];
              },
              applyTo2d: function(options) {
                var imageData = options.imageData, data = imageData.data, weights = this.matrix, side = Math.round(Math.sqrt(weights.length)), halfSide = Math.floor(side / 2), sw = imageData.width, sh = imageData.height, output = options.ctx.createImageData(sw, sh), dst = output.data, alphaFac = this.opaque ? 1 : 0, r, g, b, a2, dstOff, scx, scy, srcOff, wt, x, y, cx, cy;
                for (y = 0; y < sh; y++) {
                  for (x = 0; x < sw; x++) {
                    dstOff = (y * sw + x) * 4;
                    r = 0;
                    g = 0;
                    b = 0;
                    a2 = 0;
                    for (cy = 0; cy < side; cy++) {
                      for (cx = 0; cx < side; cx++) {
                        scy = y + cy - halfSide;
                        scx = x + cx - halfSide;
                        if (scy < 0 || scy >= sh || scx < 0 || scx >= sw) {
                          continue;
                        }
                        srcOff = (scy * sw + scx) * 4;
                        wt = weights[cy * side + cx];
                        r += data[srcOff] * wt;
                        g += data[srcOff + 1] * wt;
                        b += data[srcOff + 2] * wt;
                        if (!alphaFac) {
                          a2 += data[srcOff + 3] * wt;
                        }
                      }
                    }
                    dst[dstOff] = r;
                    dst[dstOff + 1] = g;
                    dst[dstOff + 2] = b;
                    if (!alphaFac) {
                      dst[dstOff + 3] = a2;
                    } else {
                      dst[dstOff + 3] = data[dstOff + 3];
                    }
                  }
                }
                options.imageData = output;
              },
              getUniformLocations: function(gl, program) {
                return {
                  uMatrix: gl.getUniformLocation(program, "uMatrix"),
                  uOpaque: gl.getUniformLocation(program, "uOpaque"),
                  uHalfSize: gl.getUniformLocation(program, "uHalfSize"),
                  uSize: gl.getUniformLocation(program, "uSize")
                };
              },
              sendUniformData: function(gl, uniformLocations) {
                gl.uniform1fv(uniformLocations.uMatrix, this.matrix);
              },
              toObject: function() {
                return extend2(this.callSuper("toObject"), {
                  opaque: this.opaque,
                  matrix: this.matrix
                });
              }
            });
            fabric2.Image.filters.Convolute.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
            filters.Grayscale = createClass(filters.BaseFilter, {
              type: "Grayscale",
              fragmentSource: {
                average: "precision highp float;\nuniform sampler2D uTexture;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat average = (color.r + color.b + color.g) / 3.0;\ngl_FragColor = vec4(average, average, average, color.a);\n}",
                lightness: "precision highp float;\nuniform sampler2D uTexture;\nuniform int uMode;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 col = texture2D(uTexture, vTexCoord);\nfloat average = (max(max(col.r, col.g),col.b) + min(min(col.r, col.g),col.b)) / 2.0;\ngl_FragColor = vec4(average, average, average, col.a);\n}",
                luminosity: "precision highp float;\nuniform sampler2D uTexture;\nuniform int uMode;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 col = texture2D(uTexture, vTexCoord);\nfloat average = 0.21 * col.r + 0.72 * col.g + 0.07 * col.b;\ngl_FragColor = vec4(average, average, average, col.a);\n}"
              },
              mode: "average",
              mainParameter: "mode",
              applyTo2d: function(options) {
                var imageData = options.imageData, data = imageData.data, i, len = data.length, value, mode = this.mode;
                for (i = 0; i < len; i += 4) {
                  if (mode === "average") {
                    value = (data[i] + data[i + 1] + data[i + 2]) / 3;
                  } else if (mode === "lightness") {
                    value = (Math.min(data[i], data[i + 1], data[i + 2]) + Math.max(data[i], data[i + 1], data[i + 2])) / 2;
                  } else if (mode === "luminosity") {
                    value = 0.21 * data[i] + 0.72 * data[i + 1] + 0.07 * data[i + 2];
                  }
                  data[i] = value;
                  data[i + 1] = value;
                  data[i + 2] = value;
                }
              },
              retrieveShader: function(options) {
                var cacheKey = this.type + "_" + this.mode;
                if (!options.programCache.hasOwnProperty(cacheKey)) {
                  var shaderSource = this.fragmentSource[this.mode];
                  options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
                }
                return options.programCache[cacheKey];
              },
              getUniformLocations: function(gl, program) {
                return {
                  uMode: gl.getUniformLocation(program, "uMode")
                };
              },
              sendUniformData: function(gl, uniformLocations) {
                var mode = 1;
                gl.uniform1i(uniformLocations.uMode, mode);
              },
              isNeutralState: function() {
                return false;
              }
            });
            fabric2.Image.filters.Grayscale.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
            filters.Invert = createClass(filters.BaseFilter, {
              type: "Invert",
              fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform int uInvert;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nif (uInvert == 1) {\ngl_FragColor = vec4(1.0 - color.r,1.0 -color.g,1.0 -color.b,color.a);\n} else {\ngl_FragColor = color;\n}\n}",
              invert: true,
              mainParameter: "invert",
              applyTo2d: function(options) {
                var imageData = options.imageData, data = imageData.data, i, len = data.length;
                for (i = 0; i < len; i += 4) {
                  data[i] = 255 - data[i];
                  data[i + 1] = 255 - data[i + 1];
                  data[i + 2] = 255 - data[i + 2];
                }
              },
              isNeutralState: function() {
                return !this.invert;
              },
              getUniformLocations: function(gl, program) {
                return {
                  uInvert: gl.getUniformLocation(program, "uInvert")
                };
              },
              sendUniformData: function(gl, uniformLocations) {
                gl.uniform1i(uniformLocations.uInvert, this.invert);
              }
            });
            fabric2.Image.filters.Invert.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), extend2 = fabric2.util.object.extend, filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
            filters.Noise = createClass(filters.BaseFilter, {
              type: "Noise",
              fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uStepH;\nuniform float uNoise;\nuniform float uSeed;\nvarying vec2 vTexCoord;\nfloat rand(vec2 co, float seed, float vScale) {\nreturn fract(sin(dot(co.xy * vScale ,vec2(12.9898 , 78.233))) * 43758.5453 * (seed + 0.01) / 2.0);\n}\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ncolor.rgb += (0.5 - rand(vTexCoord, uSeed, 0.1 / uStepH)) * uNoise;\ngl_FragColor = color;\n}",
              mainParameter: "noise",
              noise: 0,
              applyTo2d: function(options) {
                if (this.noise === 0) {
                  return;
                }
                var imageData = options.imageData, data = imageData.data, i, len = data.length, noise = this.noise, rand;
                for (i = 0, len = data.length; i < len; i += 4) {
                  rand = (0.5 - Math.random()) * noise;
                  data[i] += rand;
                  data[i + 1] += rand;
                  data[i + 2] += rand;
                }
              },
              getUniformLocations: function(gl, program) {
                return {
                  uNoise: gl.getUniformLocation(program, "uNoise"),
                  uSeed: gl.getUniformLocation(program, "uSeed")
                };
              },
              sendUniformData: function(gl, uniformLocations) {
                gl.uniform1f(uniformLocations.uNoise, this.noise / 255);
                gl.uniform1f(uniformLocations.uSeed, Math.random());
              },
              toObject: function() {
                return extend2(this.callSuper("toObject"), {
                  noise: this.noise
                });
              }
            });
            fabric2.Image.filters.Noise.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
            filters.Pixelate = createClass(filters.BaseFilter, {
              type: "Pixelate",
              blocksize: 4,
              mainParameter: "blocksize",
              fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uBlocksize;\nuniform float uStepW;\nuniform float uStepH;\nvarying vec2 vTexCoord;\nvoid main() {\nfloat blockW = uBlocksize * uStepW;\nfloat blockH = uBlocksize * uStepW;\nint posX = int(vTexCoord.x / blockW);\nint posY = int(vTexCoord.y / blockH);\nfloat fposX = float(posX);\nfloat fposY = float(posY);\nvec2 squareCoords = vec2(fposX * blockW, fposY * blockH);\nvec4 color = texture2D(uTexture, squareCoords);\ngl_FragColor = color;\n}",
              applyTo2d: function(options) {
                var imageData = options.imageData, data = imageData.data, iLen = imageData.height, jLen = imageData.width, index2, i, j2, r, g, b, a2, _i, _j, _iLen, _jLen;
                for (i = 0; i < iLen; i += this.blocksize) {
                  for (j2 = 0; j2 < jLen; j2 += this.blocksize) {
                    index2 = i * 4 * jLen + j2 * 4;
                    r = data[index2];
                    g = data[index2 + 1];
                    b = data[index2 + 2];
                    a2 = data[index2 + 3];
                    _iLen = Math.min(i + this.blocksize, iLen);
                    _jLen = Math.min(j2 + this.blocksize, jLen);
                    for (_i = i; _i < _iLen; _i++) {
                      for (_j = j2; _j < _jLen; _j++) {
                        index2 = _i * 4 * jLen + _j * 4;
                        data[index2] = r;
                        data[index2 + 1] = g;
                        data[index2 + 2] = b;
                        data[index2 + 3] = a2;
                      }
                    }
                  }
                }
              },
              isNeutralState: function() {
                return this.blocksize === 1;
              },
              getUniformLocations: function(gl, program) {
                return {
                  uBlocksize: gl.getUniformLocation(program, "uBlocksize"),
                  uStepW: gl.getUniformLocation(program, "uStepW"),
                  uStepH: gl.getUniformLocation(program, "uStepH")
                };
              },
              sendUniformData: function(gl, uniformLocations) {
                gl.uniform1f(uniformLocations.uBlocksize, this.blocksize);
              }
            });
            fabric2.Image.filters.Pixelate.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), extend2 = fabric2.util.object.extend, filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
            filters.RemoveColor = createClass(filters.BaseFilter, {
              type: "RemoveColor",
              color: "#FFFFFF",
              fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec4 uLow;\nuniform vec4 uHigh;\nvarying vec2 vTexCoord;\nvoid main() {\ngl_FragColor = texture2D(uTexture, vTexCoord);\nif(all(greaterThan(gl_FragColor.rgb,uLow.rgb)) && all(greaterThan(uHigh.rgb,gl_FragColor.rgb))) {\ngl_FragColor.a = 0.0;\n}\n}",
              distance: 0.02,
              useAlpha: false,
              applyTo2d: function(options) {
                var imageData = options.imageData, data = imageData.data, i, distance2 = this.distance * 255, r, g, b, source2 = new fabric2.Color(this.color).getSource(), lowC = [
                  source2[0] - distance2,
                  source2[1] - distance2,
                  source2[2] - distance2
                ], highC = [
                  source2[0] + distance2,
                  source2[1] + distance2,
                  source2[2] + distance2
                ];
                for (i = 0; i < data.length; i += 4) {
                  r = data[i];
                  g = data[i + 1];
                  b = data[i + 2];
                  if (r > lowC[0] && g > lowC[1] && b > lowC[2] && r < highC[0] && g < highC[1] && b < highC[2]) {
                    data[i + 3] = 0;
                  }
                }
              },
              getUniformLocations: function(gl, program) {
                return {
                  uLow: gl.getUniformLocation(program, "uLow"),
                  uHigh: gl.getUniformLocation(program, "uHigh")
                };
              },
              sendUniformData: function(gl, uniformLocations) {
                var source2 = new fabric2.Color(this.color).getSource(), distance2 = parseFloat(this.distance), lowC = [
                  0 + source2[0] / 255 - distance2,
                  0 + source2[1] / 255 - distance2,
                  0 + source2[2] / 255 - distance2,
                  1
                ], highC = [
                  source2[0] / 255 + distance2,
                  source2[1] / 255 + distance2,
                  source2[2] / 255 + distance2,
                  1
                ];
                gl.uniform4fv(uniformLocations.uLow, lowC);
                gl.uniform4fv(uniformLocations.uHigh, highC);
              },
              toObject: function() {
                return extend2(this.callSuper("toObject"), {
                  color: this.color,
                  distance: this.distance
                });
              }
            });
            fabric2.Image.filters.RemoveColor.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
            var matrices = {
              Brownie: [
                0.5997,
                0.34553,
                -0.27082,
                0,
                0.186,
                -0.0377,
                0.86095,
                0.15059,
                0,
                -0.1449,
                0.24113,
                -0.07441,
                0.44972,
                0,
                -0.02965,
                0,
                0,
                0,
                1,
                0
              ],
              Vintage: [
                0.62793,
                0.32021,
                -0.03965,
                0,
                0.03784,
                0.02578,
                0.64411,
                0.03259,
                0,
                0.02926,
                0.0466,
                -0.08512,
                0.52416,
                0,
                0.02023,
                0,
                0,
                0,
                1,
                0
              ],
              Kodachrome: [
                1.12855,
                -0.39673,
                -0.03992,
                0,
                0.24991,
                -0.16404,
                1.08352,
                -0.05498,
                0,
                0.09698,
                -0.16786,
                -0.56034,
                1.60148,
                0,
                0.13972,
                0,
                0,
                0,
                1,
                0
              ],
              Technicolor: [
                1.91252,
                -0.85453,
                -0.09155,
                0,
                0.04624,
                -0.30878,
                1.76589,
                -0.10601,
                0,
                -0.27589,
                -0.2311,
                -0.75018,
                1.84759,
                0,
                0.12137,
                0,
                0,
                0,
                1,
                0
              ],
              Polaroid: [
                1.438,
                -0.062,
                -0.062,
                0,
                0,
                -0.122,
                1.378,
                -0.122,
                0,
                0,
                -0.016,
                -0.016,
                1.483,
                0,
                0,
                0,
                0,
                0,
                1,
                0
              ],
              Sepia: [
                0.393,
                0.769,
                0.189,
                0,
                0,
                0.349,
                0.686,
                0.168,
                0,
                0,
                0.272,
                0.534,
                0.131,
                0,
                0,
                0,
                0,
                0,
                1,
                0
              ],
              BlackWhite: [
                1.5,
                1.5,
                1.5,
                0,
                -1,
                1.5,
                1.5,
                1.5,
                0,
                -1,
                1.5,
                1.5,
                1.5,
                0,
                -1,
                0,
                0,
                0,
                1,
                0
              ]
            };
            for (var key in matrices) {
              filters[key] = createClass(filters.ColorMatrix, {
                type: key,
                matrix: matrices[key],
                mainParameter: false,
                colorsOnly: true
              });
              fabric2.Image.filters[key].fromObject = fabric2.Image.filters.BaseFilter.fromObject;
            }
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric, filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
            filters.BlendColor = createClass(filters.BaseFilter, {
              type: "BlendColor",
              color: "#F95C63",
              mode: "multiply",
              alpha: 1,
              fragmentSource: {
                multiply: "gl_FragColor.rgb *= uColor.rgb;\n",
                screen: "gl_FragColor.rgb = 1.0 - (1.0 - gl_FragColor.rgb) * (1.0 - uColor.rgb);\n",
                add: "gl_FragColor.rgb += uColor.rgb;\n",
                diff: "gl_FragColor.rgb = abs(gl_FragColor.rgb - uColor.rgb);\n",
                subtract: "gl_FragColor.rgb -= uColor.rgb;\n",
                lighten: "gl_FragColor.rgb = max(gl_FragColor.rgb, uColor.rgb);\n",
                darken: "gl_FragColor.rgb = min(gl_FragColor.rgb, uColor.rgb);\n",
                exclusion: "gl_FragColor.rgb += uColor.rgb - 2.0 * (uColor.rgb * gl_FragColor.rgb);\n",
                overlay: "if (uColor.r < 0.5) {\ngl_FragColor.r *= 2.0 * uColor.r;\n} else {\ngl_FragColor.r = 1.0 - 2.0 * (1.0 - gl_FragColor.r) * (1.0 - uColor.r);\n}\nif (uColor.g < 0.5) {\ngl_FragColor.g *= 2.0 * uColor.g;\n} else {\ngl_FragColor.g = 1.0 - 2.0 * (1.0 - gl_FragColor.g) * (1.0 - uColor.g);\n}\nif (uColor.b < 0.5) {\ngl_FragColor.b *= 2.0 * uColor.b;\n} else {\ngl_FragColor.b = 1.0 - 2.0 * (1.0 - gl_FragColor.b) * (1.0 - uColor.b);\n}\n",
                tint: "gl_FragColor.rgb *= (1.0 - uColor.a);\ngl_FragColor.rgb += uColor.rgb;\n"
              },
              buildSource: function(mode) {
                return "precision highp float;\nuniform sampler2D uTexture;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\ngl_FragColor = color;\nif (color.a > 0.0) {\n" + this.fragmentSource[mode] + "}\n}";
              },
              retrieveShader: function(options) {
                var cacheKey = this.type + "_" + this.mode, shaderSource;
                if (!options.programCache.hasOwnProperty(cacheKey)) {
                  shaderSource = this.buildSource(this.mode);
                  options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
                }
                return options.programCache[cacheKey];
              },
              applyTo2d: function(options) {
                var imageData = options.imageData, data = imageData.data, iLen = data.length, tr, tg, tb, r, g, b, source2, alpha1 = 1 - this.alpha;
                source2 = new fabric2.Color(this.color).getSource();
                tr = source2[0] * this.alpha;
                tg = source2[1] * this.alpha;
                tb = source2[2] * this.alpha;
                for (var i = 0; i < iLen; i += 4) {
                  r = data[i];
                  g = data[i + 1];
                  b = data[i + 2];
                  switch (this.mode) {
                    case "multiply":
                      data[i] = r * tr / 255;
                      data[i + 1] = g * tg / 255;
                      data[i + 2] = b * tb / 255;
                      break;
                    case "screen":
                      data[i] = 255 - (255 - r) * (255 - tr) / 255;
                      data[i + 1] = 255 - (255 - g) * (255 - tg) / 255;
                      data[i + 2] = 255 - (255 - b) * (255 - tb) / 255;
                      break;
                    case "add":
                      data[i] = r + tr;
                      data[i + 1] = g + tg;
                      data[i + 2] = b + tb;
                      break;
                    case "diff":
                    case "difference":
                      data[i] = Math.abs(r - tr);
                      data[i + 1] = Math.abs(g - tg);
                      data[i + 2] = Math.abs(b - tb);
                      break;
                    case "subtract":
                      data[i] = r - tr;
                      data[i + 1] = g - tg;
                      data[i + 2] = b - tb;
                      break;
                    case "darken":
                      data[i] = Math.min(r, tr);
                      data[i + 1] = Math.min(g, tg);
                      data[i + 2] = Math.min(b, tb);
                      break;
                    case "lighten":
                      data[i] = Math.max(r, tr);
                      data[i + 1] = Math.max(g, tg);
                      data[i + 2] = Math.max(b, tb);
                      break;
                    case "overlay":
                      data[i] = tr < 128 ? 2 * r * tr / 255 : 255 - 2 * (255 - r) * (255 - tr) / 255;
                      data[i + 1] = tg < 128 ? 2 * g * tg / 255 : 255 - 2 * (255 - g) * (255 - tg) / 255;
                      data[i + 2] = tb < 128 ? 2 * b * tb / 255 : 255 - 2 * (255 - b) * (255 - tb) / 255;
                      break;
                    case "exclusion":
                      data[i] = tr + r - 2 * tr * r / 255;
                      data[i + 1] = tg + g - 2 * tg * g / 255;
                      data[i + 2] = tb + b - 2 * tb * b / 255;
                      break;
                    case "tint":
                      data[i] = tr + r * alpha1;
                      data[i + 1] = tg + g * alpha1;
                      data[i + 2] = tb + b * alpha1;
                  }
                }
              },
              getUniformLocations: function(gl, program) {
                return {
                  uColor: gl.getUniformLocation(program, "uColor")
                };
              },
              sendUniformData: function(gl, uniformLocations) {
                var source2 = new fabric2.Color(this.color).getSource();
                source2[0] = this.alpha * source2[0] / 255;
                source2[1] = this.alpha * source2[1] / 255;
                source2[2] = this.alpha * source2[2] / 255;
                source2[3] = this.alpha;
                gl.uniform4fv(uniformLocations.uColor, source2);
              },
              toObject: function() {
                return {
                  type: this.type,
                  color: this.color,
                  mode: this.mode,
                  alpha: this.alpha
                };
              }
            });
            fabric2.Image.filters.BlendColor.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric, filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
            filters.BlendImage = createClass(filters.BaseFilter, {
              type: "BlendImage",
              image: null,
              mode: "multiply",
              alpha: 1,
              vertexSource: "attribute vec2 aPosition;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nuniform mat3 uTransformMatrix;\nvoid main() {\nvTexCoord = aPosition;\nvTexCoord2 = (uTransformMatrix * vec3(aPosition, 1.0)).xy;\ngl_Position = vec4(aPosition * 2.0 - 1.0, 0.0, 1.0);\n}",
              fragmentSource: {
                multiply: "precision highp float;\nuniform sampler2D uTexture;\nuniform sampler2D uImage;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec4 color2 = texture2D(uImage, vTexCoord2);\ncolor.rgba *= color2.rgba;\ngl_FragColor = color;\n}",
                mask: "precision highp float;\nuniform sampler2D uTexture;\nuniform sampler2D uImage;\nuniform vec4 uColor;\nvarying vec2 vTexCoord;\nvarying vec2 vTexCoord2;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec4 color2 = texture2D(uImage, vTexCoord2);\ncolor.a = color2.a;\ngl_FragColor = color;\n}"
              },
              retrieveShader: function(options) {
                var cacheKey = this.type + "_" + this.mode;
                var shaderSource = this.fragmentSource[this.mode];
                if (!options.programCache.hasOwnProperty(cacheKey)) {
                  options.programCache[cacheKey] = this.createProgram(options.context, shaderSource);
                }
                return options.programCache[cacheKey];
              },
              applyToWebGL: function(options) {
                var gl = options.context, texture = this.createTexture(options.filterBackend, this.image);
                this.bindAdditionalTexture(gl, texture, gl.TEXTURE1);
                this.callSuper("applyToWebGL", options);
                this.unbindAdditionalTexture(gl, gl.TEXTURE1);
              },
              createTexture: function(backend, image2) {
                return backend.getCachedTexture(image2.cacheKey, image2._element);
              },
              calculateMatrix: function() {
                var image2 = this.image, width = image2._element.width, height = image2._element.height;
                return [
                  1 / image2.scaleX,
                  0,
                  0,
                  0,
                  1 / image2.scaleY,
                  0,
                  -image2.left / width,
                  -image2.top / height,
                  1
                ];
              },
              applyTo2d: function(options) {
                var imageData = options.imageData, resources = options.filterBackend.resources, data = imageData.data, iLen = data.length, width = imageData.width, height = imageData.height, tr, tg, tb, ta, r, g, b, a2, canvas1, context, image2 = this.image, blendData;
                if (!resources.blendImage) {
                  resources.blendImage = fabric2.util.createCanvasElement();
                }
                canvas1 = resources.blendImage;
                context = canvas1.getContext("2d");
                if (canvas1.width !== width || canvas1.height !== height) {
                  canvas1.width = width;
                  canvas1.height = height;
                } else {
                  context.clearRect(0, 0, width, height);
                }
                context.setTransform(image2.scaleX, 0, 0, image2.scaleY, image2.left, image2.top);
                context.drawImage(image2._element, 0, 0, width, height);
                blendData = context.getImageData(0, 0, width, height).data;
                for (var i = 0; i < iLen; i += 4) {
                  r = data[i];
                  g = data[i + 1];
                  b = data[i + 2];
                  a2 = data[i + 3];
                  tr = blendData[i];
                  tg = blendData[i + 1];
                  tb = blendData[i + 2];
                  ta = blendData[i + 3];
                  switch (this.mode) {
                    case "multiply":
                      data[i] = r * tr / 255;
                      data[i + 1] = g * tg / 255;
                      data[i + 2] = b * tb / 255;
                      data[i + 3] = a2 * ta / 255;
                      break;
                    case "mask":
                      data[i + 3] = ta;
                      break;
                  }
                }
              },
              getUniformLocations: function(gl, program) {
                return {
                  uTransformMatrix: gl.getUniformLocation(program, "uTransformMatrix"),
                  uImage: gl.getUniformLocation(program, "uImage")
                };
              },
              sendUniformData: function(gl, uniformLocations) {
                var matrix2 = this.calculateMatrix();
                gl.uniform1i(uniformLocations.uImage, 1);
                gl.uniformMatrix3fv(uniformLocations.uTransformMatrix, false, matrix2);
              },
              toObject: function() {
                return {
                  type: this.type,
                  image: this.image && this.image.toObject(),
                  mode: this.mode,
                  alpha: this.alpha
                };
              }
            });
            fabric2.Image.filters.BlendImage.fromObject = function(object, callback) {
              fabric2.Image.fromObject(object.image, function(image2) {
                var options = fabric2.util.object.clone(object);
                options.image = image2;
                callback(new fabric2.Image.filters.BlendImage(options));
              });
            };
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), pow = Math.pow, floor = Math.floor, sqrt2 = Math.sqrt, abs2 = Math.abs, round = Math.round, sin = Math.sin, ceil = Math.ceil, filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
            filters.Resize = createClass(filters.BaseFilter, {
              type: "Resize",
              resizeType: "hermite",
              scaleX: 1,
              scaleY: 1,
              lanczosLobes: 3,
              getUniformLocations: function(gl, program) {
                return {
                  uDelta: gl.getUniformLocation(program, "uDelta"),
                  uTaps: gl.getUniformLocation(program, "uTaps")
                };
              },
              sendUniformData: function(gl, uniformLocations) {
                gl.uniform2fv(uniformLocations.uDelta, this.horizontal ? [1 / this.width, 0] : [0, 1 / this.height]);
                gl.uniform1fv(uniformLocations.uTaps, this.taps);
              },
              retrieveShader: function(options) {
                var filterWindow = this.getFilterWindow(), cacheKey = this.type + "_" + filterWindow;
                if (!options.programCache.hasOwnProperty(cacheKey)) {
                  var fragmentShader = this.generateShader(filterWindow);
                  options.programCache[cacheKey] = this.createProgram(options.context, fragmentShader);
                }
                return options.programCache[cacheKey];
              },
              getFilterWindow: function() {
                var scale = this.tempScale;
                return Math.ceil(this.lanczosLobes / scale);
              },
              getTaps: function() {
                var lobeFunction = this.lanczosCreate(this.lanczosLobes), scale = this.tempScale, filterWindow = this.getFilterWindow(), taps = new Array(filterWindow);
                for (var i = 1; i <= filterWindow; i++) {
                  taps[i - 1] = lobeFunction(i * scale);
                }
                return taps;
              },
              generateShader: function(filterWindow) {
                var offsets = new Array(filterWindow), fragmentShader = this.fragmentSourceTOP, filterWindow;
                for (var i = 1; i <= filterWindow; i++) {
                  offsets[i - 1] = i + ".0 * uDelta";
                }
                fragmentShader += "uniform float uTaps[" + filterWindow + "];\n";
                fragmentShader += "void main() {\n";
                fragmentShader += "  vec4 color = texture2D(uTexture, vTexCoord);\n";
                fragmentShader += "  float sum = 1.0;\n";
                offsets.forEach(function(offset, i2) {
                  fragmentShader += "  color += texture2D(uTexture, vTexCoord + " + offset + ") * uTaps[" + i2 + "];\n";
                  fragmentShader += "  color += texture2D(uTexture, vTexCoord - " + offset + ") * uTaps[" + i2 + "];\n";
                  fragmentShader += "  sum += 2.0 * uTaps[" + i2 + "];\n";
                });
                fragmentShader += "  gl_FragColor = color / sum;\n";
                fragmentShader += "}";
                return fragmentShader;
              },
              fragmentSourceTOP: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec2 uDelta;\nvarying vec2 vTexCoord;\n",
              applyTo: function(options) {
                if (options.webgl) {
                  options.passes++;
                  this.width = options.sourceWidth;
                  this.horizontal = true;
                  this.dW = Math.round(this.width * this.scaleX);
                  this.dH = options.sourceHeight;
                  this.tempScale = this.dW / this.width;
                  this.taps = this.getTaps();
                  options.destinationWidth = this.dW;
                  this._setupFrameBuffer(options);
                  this.applyToWebGL(options);
                  this._swapTextures(options);
                  options.sourceWidth = options.destinationWidth;
                  this.height = options.sourceHeight;
                  this.horizontal = false;
                  this.dH = Math.round(this.height * this.scaleY);
                  this.tempScale = this.dH / this.height;
                  this.taps = this.getTaps();
                  options.destinationHeight = this.dH;
                  this._setupFrameBuffer(options);
                  this.applyToWebGL(options);
                  this._swapTextures(options);
                  options.sourceHeight = options.destinationHeight;
                } else {
                  this.applyTo2d(options);
                }
              },
              isNeutralState: function() {
                return this.scaleX === 1 && this.scaleY === 1;
              },
              lanczosCreate: function(lobes) {
                return function(x) {
                  if (x >= lobes || x <= -lobes) {
                    return 0;
                  }
                  if (x < 11920929e-14 && x > -11920929e-14) {
                    return 1;
                  }
                  x *= Math.PI;
                  var xx = x / lobes;
                  return sin(x) / x * sin(xx) / xx;
                };
              },
              applyTo2d: function(options) {
                var imageData = options.imageData, scaleX = this.scaleX, scaleY = this.scaleY;
                this.rcpScaleX = 1 / scaleX;
                this.rcpScaleY = 1 / scaleY;
                var oW = imageData.width, oH = imageData.height, dW = round(oW * scaleX), dH = round(oH * scaleY), newData;
                if (this.resizeType === "sliceHack") {
                  newData = this.sliceByTwo(options, oW, oH, dW, dH);
                } else if (this.resizeType === "hermite") {
                  newData = this.hermiteFastResize(options, oW, oH, dW, dH);
                } else if (this.resizeType === "bilinear") {
                  newData = this.bilinearFiltering(options, oW, oH, dW, dH);
                } else if (this.resizeType === "lanczos") {
                  newData = this.lanczosResize(options, oW, oH, dW, dH);
                }
                options.imageData = newData;
              },
              sliceByTwo: function(options, oW, oH, dW, dH) {
                var imageData = options.imageData, mult = 0.5, doneW = false, doneH = false, stepW = oW * mult, stepH = oH * mult, resources = fabric2.filterBackend.resources, tmpCanvas, ctx, sX = 0, sY = 0, dX = oW, dY = 0;
                if (!resources.sliceByTwo) {
                  resources.sliceByTwo = document.createElement("canvas");
                }
                tmpCanvas = resources.sliceByTwo;
                if (tmpCanvas.width < oW * 1.5 || tmpCanvas.height < oH) {
                  tmpCanvas.width = oW * 1.5;
                  tmpCanvas.height = oH;
                }
                ctx = tmpCanvas.getContext("2d");
                ctx.clearRect(0, 0, oW * 1.5, oH);
                ctx.putImageData(imageData, 0, 0);
                dW = floor(dW);
                dH = floor(dH);
                while (!doneW || !doneH) {
                  oW = stepW;
                  oH = stepH;
                  if (dW < floor(stepW * mult)) {
                    stepW = floor(stepW * mult);
                  } else {
                    stepW = dW;
                    doneW = true;
                  }
                  if (dH < floor(stepH * mult)) {
                    stepH = floor(stepH * mult);
                  } else {
                    stepH = dH;
                    doneH = true;
                  }
                  ctx.drawImage(tmpCanvas, sX, sY, oW, oH, dX, dY, stepW, stepH);
                  sX = dX;
                  sY = dY;
                  dY += stepH;
                }
                return ctx.getImageData(sX, sY, dW, dH);
              },
              lanczosResize: function(options, oW, oH, dW, dH) {
                function process2(u2) {
                  var v, i, weight, idx, a2, red, green, blue, alpha, fX, fY;
                  center.x = (u2 + 0.5) * ratioX;
                  icenter.x = floor(center.x);
                  for (v = 0; v < dH; v++) {
                    center.y = (v + 0.5) * ratioY;
                    icenter.y = floor(center.y);
                    a2 = 0;
                    red = 0;
                    green = 0;
                    blue = 0;
                    alpha = 0;
                    for (i = icenter.x - range2X; i <= icenter.x + range2X; i++) {
                      if (i < 0 || i >= oW) {
                        continue;
                      }
                      fX = floor(1e3 * abs2(i - center.x));
                      if (!cacheLanc[fX]) {
                        cacheLanc[fX] = {};
                      }
                      for (var j2 = icenter.y - range2Y; j2 <= icenter.y + range2Y; j2++) {
                        if (j2 < 0 || j2 >= oH) {
                          continue;
                        }
                        fY = floor(1e3 * abs2(j2 - center.y));
                        if (!cacheLanc[fX][fY]) {
                          cacheLanc[fX][fY] = lanczos(sqrt2(pow(fX * rcpRatioX, 2) + pow(fY * rcpRatioY, 2)) / 1e3);
                        }
                        weight = cacheLanc[fX][fY];
                        if (weight > 0) {
                          idx = (j2 * oW + i) * 4;
                          a2 += weight;
                          red += weight * srcData[idx];
                          green += weight * srcData[idx + 1];
                          blue += weight * srcData[idx + 2];
                          alpha += weight * srcData[idx + 3];
                        }
                      }
                    }
                    idx = (v * dW + u2) * 4;
                    destData[idx] = red / a2;
                    destData[idx + 1] = green / a2;
                    destData[idx + 2] = blue / a2;
                    destData[idx + 3] = alpha / a2;
                  }
                  if (++u2 < dW) {
                    return process2(u2);
                  } else {
                    return destImg;
                  }
                }
                var srcData = options.imageData.data, destImg = options.ctx.createImageData(dW, dH), destData = destImg.data, lanczos = this.lanczosCreate(this.lanczosLobes), ratioX = this.rcpScaleX, ratioY = this.rcpScaleY, rcpRatioX = 2 / this.rcpScaleX, rcpRatioY = 2 / this.rcpScaleY, range2X = ceil(ratioX * this.lanczosLobes / 2), range2Y = ceil(ratioY * this.lanczosLobes / 2), cacheLanc = {}, center = {}, icenter = {};
                return process2(0);
              },
              bilinearFiltering: function(options, oW, oH, dW, dH) {
                var a2, b, c, d, x, y, i, j2, xDiff, yDiff, chnl, color2, offset = 0, origPix, ratioX = this.rcpScaleX, ratioY = this.rcpScaleY, w4 = 4 * (oW - 1), img = options.imageData, pixels = img.data, destImage = options.ctx.createImageData(dW, dH), destPixels = destImage.data;
                for (i = 0; i < dH; i++) {
                  for (j2 = 0; j2 < dW; j2++) {
                    x = floor(ratioX * j2);
                    y = floor(ratioY * i);
                    xDiff = ratioX * j2 - x;
                    yDiff = ratioY * i - y;
                    origPix = 4 * (y * oW + x);
                    for (chnl = 0; chnl < 4; chnl++) {
                      a2 = pixels[origPix + chnl];
                      b = pixels[origPix + 4 + chnl];
                      c = pixels[origPix + w4 + chnl];
                      d = pixels[origPix + w4 + 4 + chnl];
                      color2 = a2 * (1 - xDiff) * (1 - yDiff) + b * xDiff * (1 - yDiff) + c * yDiff * (1 - xDiff) + d * xDiff * yDiff;
                      destPixels[offset++] = color2;
                    }
                  }
                }
                return destImage;
              },
              hermiteFastResize: function(options, oW, oH, dW, dH) {
                var ratioW = this.rcpScaleX, ratioH = this.rcpScaleY, ratioWHalf = ceil(ratioW / 2), ratioHHalf = ceil(ratioH / 2), img = options.imageData, data = img.data, img2 = options.ctx.createImageData(dW, dH), data2 = img2.data;
                for (var j2 = 0; j2 < dH; j2++) {
                  for (var i = 0; i < dW; i++) {
                    var x2 = (i + j2 * dW) * 4, weight = 0, weights = 0, weightsAlpha = 0, gxR = 0, gxG = 0, gxB = 0, gxA = 0, centerY = (j2 + 0.5) * ratioH;
                    for (var yy = floor(j2 * ratioH); yy < (j2 + 1) * ratioH; yy++) {
                      var dy = abs2(centerY - (yy + 0.5)) / ratioHHalf, centerX = (i + 0.5) * ratioW, w0 = dy * dy;
                      for (var xx = floor(i * ratioW); xx < (i + 1) * ratioW; xx++) {
                        var dx = abs2(centerX - (xx + 0.5)) / ratioWHalf, w = sqrt2(w0 + dx * dx);
                        if (w > 1 && w < -1) {
                          continue;
                        }
                        weight = 2 * w * w * w - 3 * w * w + 1;
                        if (weight > 0) {
                          dx = 4 * (xx + yy * oW);
                          gxA += weight * data[dx + 3];
                          weightsAlpha += weight;
                          if (data[dx + 3] < 255) {
                            weight = weight * data[dx + 3] / 250;
                          }
                          gxR += weight * data[dx];
                          gxG += weight * data[dx + 1];
                          gxB += weight * data[dx + 2];
                          weights += weight;
                        }
                      }
                    }
                    data2[x2] = gxR / weights;
                    data2[x2 + 1] = gxG / weights;
                    data2[x2 + 2] = gxB / weights;
                    data2[x2 + 3] = gxA / weightsAlpha;
                  }
                }
                return img2;
              },
              toObject: function() {
                return {
                  type: this.type,
                  scaleX: this.scaleX,
                  scaleY: this.scaleY,
                  resizeType: this.resizeType,
                  lanczosLobes: this.lanczosLobes
                };
              }
            });
            fabric2.Image.filters.Resize.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
            filters.Contrast = createClass(filters.BaseFilter, {
              type: "Contrast",
              fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uContrast;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat contrastF = 1.015 * (uContrast + 1.0) / (1.0 * (1.015 - uContrast));\ncolor.rgb = contrastF * (color.rgb - 0.5) + 0.5;\ngl_FragColor = color;\n}",
              contrast: 0,
              mainParameter: "contrast",
              applyTo2d: function(options) {
                if (this.contrast === 0) {
                  return;
                }
                var imageData = options.imageData, i, len, data = imageData.data, len = data.length, contrast = Math.floor(this.contrast * 255), contrastF = 259 * (contrast + 255) / (255 * (259 - contrast));
                for (i = 0; i < len; i += 4) {
                  data[i] = contrastF * (data[i] - 128) + 128;
                  data[i + 1] = contrastF * (data[i + 1] - 128) + 128;
                  data[i + 2] = contrastF * (data[i + 2] - 128) + 128;
                }
              },
              getUniformLocations: function(gl, program) {
                return {
                  uContrast: gl.getUniformLocation(program, "uContrast")
                };
              },
              sendUniformData: function(gl, uniformLocations) {
                gl.uniform1f(uniformLocations.uContrast, this.contrast);
              }
            });
            fabric2.Image.filters.Contrast.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
            filters.Saturation = createClass(filters.BaseFilter, {
              type: "Saturation",
              fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uSaturation;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat rgMax = max(color.r, color.g);\nfloat rgbMax = max(rgMax, color.b);\ncolor.r += rgbMax != color.r ? (rgbMax - color.r) * uSaturation : 0.00;\ncolor.g += rgbMax != color.g ? (rgbMax - color.g) * uSaturation : 0.00;\ncolor.b += rgbMax != color.b ? (rgbMax - color.b) * uSaturation : 0.00;\ngl_FragColor = color;\n}",
              saturation: 0,
              mainParameter: "saturation",
              applyTo2d: function(options) {
                if (this.saturation === 0) {
                  return;
                }
                var imageData = options.imageData, data = imageData.data, len = data.length, adjust = -this.saturation, i, max2;
                for (i = 0; i < len; i += 4) {
                  max2 = Math.max(data[i], data[i + 1], data[i + 2]);
                  data[i] += max2 !== data[i] ? (max2 - data[i]) * adjust : 0;
                  data[i + 1] += max2 !== data[i + 1] ? (max2 - data[i + 1]) * adjust : 0;
                  data[i + 2] += max2 !== data[i + 2] ? (max2 - data[i + 2]) * adjust : 0;
                }
              },
              getUniformLocations: function(gl, program) {
                return {
                  uSaturation: gl.getUniformLocation(program, "uSaturation")
                };
              },
              sendUniformData: function(gl, uniformLocations) {
                gl.uniform1f(uniformLocations.uSaturation, -this.saturation);
              }
            });
            fabric2.Image.filters.Saturation.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
            filters.Vibrance = createClass(filters.BaseFilter, {
              type: "Vibrance",
              fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform float uVibrance;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nfloat max = max(color.r, max(color.g, color.b));\nfloat avg = (color.r + color.g + color.b) / 3.0;\nfloat amt = (abs(max - avg) * 2.0) * uVibrance;\ncolor.r += max != color.r ? (max - color.r) * amt : 0.00;\ncolor.g += max != color.g ? (max - color.g) * amt : 0.00;\ncolor.b += max != color.b ? (max - color.b) * amt : 0.00;\ngl_FragColor = color;\n}",
              vibrance: 0,
              mainParameter: "vibrance",
              applyTo2d: function(options) {
                if (this.vibrance === 0) {
                  return;
                }
                var imageData = options.imageData, data = imageData.data, len = data.length, adjust = -this.vibrance, i, max2, avg, amt;
                for (i = 0; i < len; i += 4) {
                  max2 = Math.max(data[i], data[i + 1], data[i + 2]);
                  avg = (data[i] + data[i + 1] + data[i + 2]) / 3;
                  amt = Math.abs(max2 - avg) * 2 / 255 * adjust;
                  data[i] += max2 !== data[i] ? (max2 - data[i]) * amt : 0;
                  data[i + 1] += max2 !== data[i + 1] ? (max2 - data[i + 1]) * amt : 0;
                  data[i + 2] += max2 !== data[i + 2] ? (max2 - data[i + 2]) * amt : 0;
                }
              },
              getUniformLocations: function(gl, program) {
                return {
                  uVibrance: gl.getUniformLocation(program, "uVibrance")
                };
              },
              sendUniformData: function(gl, uniformLocations) {
                gl.uniform1f(uniformLocations.uVibrance, -this.vibrance);
              }
            });
            fabric2.Image.filters.Vibrance.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
            filters.Blur = createClass(filters.BaseFilter, {
              type: "Blur",
              fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec2 uDelta;\nvarying vec2 vTexCoord;\nconst float nSamples = 15.0;\nvec3 v3offset = vec3(12.9898, 78.233, 151.7182);\nfloat random(vec3 scale) {\nreturn fract(sin(dot(gl_FragCoord.xyz, scale)) * 43758.5453);\n}\nvoid main() {\nvec4 color = vec4(0.0);\nfloat total = 0.0;\nfloat offset = random(v3offset);\nfor (float t = -nSamples; t <= nSamples; t++) {\nfloat percent = (t + offset - 0.5) / nSamples;\nfloat weight = 1.0 - abs(percent);\ncolor += texture2D(uTexture, vTexCoord + uDelta * percent) * weight;\ntotal += weight;\n}\ngl_FragColor = color / total;\n}",
              blur: 0,
              mainParameter: "blur",
              applyTo: function(options) {
                if (options.webgl) {
                  this.aspectRatio = options.sourceWidth / options.sourceHeight;
                  options.passes++;
                  this._setupFrameBuffer(options);
                  this.horizontal = true;
                  this.applyToWebGL(options);
                  this._swapTextures(options);
                  this._setupFrameBuffer(options);
                  this.horizontal = false;
                  this.applyToWebGL(options);
                  this._swapTextures(options);
                } else {
                  this.applyTo2d(options);
                }
              },
              applyTo2d: function(options) {
                options.imageData = this.simpleBlur(options);
              },
              simpleBlur: function(options) {
                var resources = options.filterBackend.resources, canvas1, canvas2, width = options.imageData.width, height = options.imageData.height;
                if (!resources.blurLayer1) {
                  resources.blurLayer1 = fabric2.util.createCanvasElement();
                  resources.blurLayer2 = fabric2.util.createCanvasElement();
                }
                canvas1 = resources.blurLayer1;
                canvas2 = resources.blurLayer2;
                if (canvas1.width !== width || canvas1.height !== height) {
                  canvas2.width = canvas1.width = width;
                  canvas2.height = canvas1.height = height;
                }
                var ctx1 = canvas1.getContext("2d"), ctx2 = canvas2.getContext("2d"), nSamples = 15, random, percent, j2, i, blur = this.blur * 0.06 * 0.5;
                ctx1.putImageData(options.imageData, 0, 0);
                ctx2.clearRect(0, 0, width, height);
                for (i = -nSamples; i <= nSamples; i++) {
                  random = (Math.random() - 0.5) / 4;
                  percent = i / nSamples;
                  j2 = blur * percent * width + random;
                  ctx2.globalAlpha = 1 - Math.abs(percent);
                  ctx2.drawImage(canvas1, j2, random);
                  ctx1.drawImage(canvas2, 0, 0);
                  ctx2.globalAlpha = 1;
                  ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
                }
                for (i = -nSamples; i <= nSamples; i++) {
                  random = (Math.random() - 0.5) / 4;
                  percent = i / nSamples;
                  j2 = blur * percent * height + random;
                  ctx2.globalAlpha = 1 - Math.abs(percent);
                  ctx2.drawImage(canvas1, random, j2);
                  ctx1.drawImage(canvas2, 0, 0);
                  ctx2.globalAlpha = 1;
                  ctx2.clearRect(0, 0, canvas2.width, canvas2.height);
                }
                options.ctx.drawImage(canvas1, 0, 0);
                var newImageData = options.ctx.getImageData(0, 0, canvas1.width, canvas1.height);
                ctx1.globalAlpha = 1;
                ctx1.clearRect(0, 0, canvas1.width, canvas1.height);
                return newImageData;
              },
              getUniformLocations: function(gl, program) {
                return {
                  delta: gl.getUniformLocation(program, "uDelta")
                };
              },
              sendUniformData: function(gl, uniformLocations) {
                var delta = this.chooseRightDelta();
                gl.uniform2fv(uniformLocations.delta, delta);
              },
              chooseRightDelta: function() {
                var blurScale = 1, delta = [0, 0], blur;
                if (this.horizontal) {
                  if (this.aspectRatio > 1) {
                    blurScale = 1 / this.aspectRatio;
                  }
                } else {
                  if (this.aspectRatio < 1) {
                    blurScale = this.aspectRatio;
                  }
                }
                blur = blurScale * this.blur * 0.12;
                if (this.horizontal) {
                  delta[0] = blur;
                } else {
                  delta[1] = blur;
                }
                return delta;
              }
            });
            filters.Blur.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
            filters.Gamma = createClass(filters.BaseFilter, {
              type: "Gamma",
              fragmentSource: "precision highp float;\nuniform sampler2D uTexture;\nuniform vec3 uGamma;\nvarying vec2 vTexCoord;\nvoid main() {\nvec4 color = texture2D(uTexture, vTexCoord);\nvec3 correction = (1.0 / uGamma);\ncolor.r = pow(color.r, correction.r);\ncolor.g = pow(color.g, correction.g);\ncolor.b = pow(color.b, correction.b);\ngl_FragColor = color;\ngl_FragColor.rgb *= color.a;\n}",
              gamma: [1, 1, 1],
              mainParameter: "gamma",
              initialize: function(options) {
                this.gamma = [1, 1, 1];
                filters.BaseFilter.prototype.initialize.call(this, options);
              },
              applyTo2d: function(options) {
                var imageData = options.imageData, data = imageData.data, gamma = this.gamma, len = data.length, rInv = 1 / gamma[0], gInv = 1 / gamma[1], bInv = 1 / gamma[2], i;
                if (!this.rVals) {
                  this.rVals = new Uint8Array(256);
                  this.gVals = new Uint8Array(256);
                  this.bVals = new Uint8Array(256);
                }
                for (i = 0, len = 256; i < len; i++) {
                  this.rVals[i] = Math.pow(i / 255, rInv) * 255;
                  this.gVals[i] = Math.pow(i / 255, gInv) * 255;
                  this.bVals[i] = Math.pow(i / 255, bInv) * 255;
                }
                for (i = 0, len = data.length; i < len; i += 4) {
                  data[i] = this.rVals[data[i]];
                  data[i + 1] = this.gVals[data[i + 1]];
                  data[i + 2] = this.bVals[data[i + 2]];
                }
              },
              getUniformLocations: function(gl, program) {
                return {
                  uGamma: gl.getUniformLocation(program, "uGamma")
                };
              },
              sendUniformData: function(gl, uniformLocations) {
                gl.uniform3fv(uniformLocations.uGamma, this.gamma);
              }
            });
            fabric2.Image.filters.Gamma.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
            filters.Composed = createClass(filters.BaseFilter, {
              type: "Composed",
              subFilters: [],
              initialize: function(options) {
                this.callSuper("initialize", options);
                this.subFilters = this.subFilters.slice(0);
              },
              applyTo: function(options) {
                options.passes += this.subFilters.length - 1;
                this.subFilters.forEach(function(filter) {
                  filter.applyTo(options);
                });
              },
              toObject: function() {
                return fabric2.util.object.extend(this.callSuper("toObject"), {
                  subFilters: this.subFilters.map(function(filter) {
                    return filter.toObject();
                  })
                });
              },
              isNeutralState: function() {
                return !this.subFilters.some(function(filter) {
                  return !filter.isNeutralState();
                });
              }
            });
            fabric2.Image.filters.Composed.fromObject = function(object, callback) {
              var filters2 = object.subFilters || [], subFilters = filters2.map(function(filter) {
                return new fabric2.Image.filters[filter.type](filter);
              }), instance = new fabric2.Image.filters.Composed({ subFilters });
              callback && callback(instance);
              return instance;
            };
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), filters = fabric2.Image.filters, createClass = fabric2.util.createClass;
            filters.HueRotation = createClass(filters.ColorMatrix, {
              type: "HueRotation",
              rotation: 0,
              mainParameter: "rotation",
              calculateMatrix: function() {
                var rad = this.rotation * Math.PI, cos = fabric2.util.cos(rad), sin = fabric2.util.sin(rad), aThird = 1 / 3, aThirdSqtSin = Math.sqrt(aThird) * sin, OneMinusCos = 1 - cos;
                this.matrix = [
                  1,
                  0,
                  0,
                  0,
                  0,
                  0,
                  1,
                  0,
                  0,
                  0,
                  0,
                  0,
                  1,
                  0,
                  0,
                  0,
                  0,
                  0,
                  1,
                  0
                ];
                this.matrix[0] = cos + OneMinusCos / 3;
                this.matrix[1] = aThird * OneMinusCos - aThirdSqtSin;
                this.matrix[2] = aThird * OneMinusCos + aThirdSqtSin;
                this.matrix[5] = aThird * OneMinusCos + aThirdSqtSin;
                this.matrix[6] = cos + aThird * OneMinusCos;
                this.matrix[7] = aThird * OneMinusCos - aThirdSqtSin;
                this.matrix[10] = aThird * OneMinusCos - aThirdSqtSin;
                this.matrix[11] = aThird * OneMinusCos + aThirdSqtSin;
                this.matrix[12] = cos + aThird * OneMinusCos;
              },
              isNeutralState: function(options) {
                this.calculateMatrix();
                return filters.BaseFilter.prototype.isNeutralState.call(this, options);
              },
              applyTo: function(options) {
                this.calculateMatrix();
                filters.BaseFilter.prototype.applyTo.call(this, options);
              }
            });
            fabric2.Image.filters.HueRotation.fromObject = fabric2.Image.filters.BaseFilter.fromObject;
          })(exports2);
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {}), clone2 = fabric2.util.object.clone;
            if (fabric2.Text) {
              fabric2.warn("fabric.Text is already defined");
              return;
            }
            var additionalProps = "fontFamily fontWeight fontSize text underline overline linethrough textAlign fontStyle lineHeight textBackgroundColor charSpacing styles direction path pathStartOffset pathSide".split(" ");
            fabric2.Text = fabric2.util.createClass(fabric2.Object, {
              _dimensionAffectingProps: [
                "fontSize",
                "fontWeight",
                "fontFamily",
                "fontStyle",
                "lineHeight",
                "text",
                "charSpacing",
                "textAlign",
                "styles",
                "path",
                "pathStartOffset",
                "pathSide"
              ],
              _reNewline: /\r?\n/,
              _reSpacesAndTabs: /[ \t\r]/g,
              _reSpaceAndTab: /[ \t\r]/,
              _reWords: /\S+/g,
              type: "text",
              fontSize: 40,
              fontWeight: "normal",
              fontFamily: "Times New Roman",
              underline: false,
              overline: false,
              linethrough: false,
              textAlign: "left",
              fontStyle: "normal",
              lineHeight: 1.16,
              superscript: {
                size: 0.6,
                baseline: -0.35
              },
              subscript: {
                size: 0.6,
                baseline: 0.11
              },
              textBackgroundColor: "",
              stateProperties: fabric2.Object.prototype.stateProperties.concat(additionalProps),
              cacheProperties: fabric2.Object.prototype.cacheProperties.concat(additionalProps),
              stroke: null,
              shadow: null,
              path: null,
              pathStartOffset: 0,
              pathSide: "left",
              _fontSizeFraction: 0.222,
              offsets: {
                underline: 0.1,
                linethrough: -0.315,
                overline: -0.88
              },
              _fontSizeMult: 1.13,
              charSpacing: 0,
              styles: null,
              _measuringContext: null,
              deltaY: 0,
              direction: "ltr",
              _styleProperties: [
                "stroke",
                "strokeWidth",
                "fill",
                "fontFamily",
                "fontSize",
                "fontWeight",
                "fontStyle",
                "underline",
                "overline",
                "linethrough",
                "deltaY",
                "textBackgroundColor"
              ],
              __charBounds: [],
              CACHE_FONT_SIZE: 400,
              MIN_TEXT_WIDTH: 2,
              initialize: function(text, options) {
                this.styles = options ? options.styles || {} : {};
                this.text = text;
                this.__skipDimension = true;
                this.callSuper("initialize", options);
                if (this.path) {
                  this.setPathInfo();
                }
                this.__skipDimension = false;
                this.initDimensions();
                this.setCoords();
                this.setupState({ propertySet: "_dimensionAffectingProps" });
              },
              setPathInfo: function() {
                var path = this.path;
                if (path) {
                  path.segmentsInfo = fabric2.util.getPathSegmentsInfo(path.path);
                }
              },
              getMeasuringContext: function() {
                if (!fabric2._measuringContext) {
                  fabric2._measuringContext = this.canvas && this.canvas.contextCache || fabric2.util.createCanvasElement().getContext("2d");
                }
                return fabric2._measuringContext;
              },
              _splitText: function() {
                var newLines = this._splitTextIntoLines(this.text);
                this.textLines = newLines.lines;
                this._textLines = newLines.graphemeLines;
                this._unwrappedTextLines = newLines._unwrappedLines;
                this._text = newLines.graphemeText;
                return newLines;
              },
              initDimensions: function() {
                if (this.__skipDimension) {
                  return;
                }
                this._splitText();
                this._clearCache();
                if (this.path) {
                  this.width = this.path.width;
                  this.height = this.path.height;
                } else {
                  this.width = this.calcTextWidth() || this.cursorWidth || this.MIN_TEXT_WIDTH;
                  this.height = this.calcTextHeight();
                }
                if (this.textAlign.indexOf("justify") !== -1) {
                  this.enlargeSpaces();
                }
                this.saveState({ propertySet: "_dimensionAffectingProps" });
              },
              enlargeSpaces: function() {
                var diffSpace, currentLineWidth, numberOfSpaces, accumulatedSpace, line, charBound, spaces;
                for (var i = 0, len = this._textLines.length; i < len; i++) {
                  if (this.textAlign !== "justify" && (i === len - 1 || this.isEndOfWrapping(i))) {
                    continue;
                  }
                  accumulatedSpace = 0;
                  line = this._textLines[i];
                  currentLineWidth = this.getLineWidth(i);
                  if (currentLineWidth < this.width && (spaces = this.textLines[i].match(this._reSpacesAndTabs))) {
                    numberOfSpaces = spaces.length;
                    diffSpace = (this.width - currentLineWidth) / numberOfSpaces;
                    for (var j2 = 0, jlen = line.length; j2 <= jlen; j2++) {
                      charBound = this.__charBounds[i][j2];
                      if (this._reSpaceAndTab.test(line[j2])) {
                        charBound.width += diffSpace;
                        charBound.kernedWidth += diffSpace;
                        charBound.left += accumulatedSpace;
                        accumulatedSpace += diffSpace;
                      } else {
                        charBound.left += accumulatedSpace;
                      }
                    }
                  }
                }
              },
              isEndOfWrapping: function(lineIndex) {
                return lineIndex === this._textLines.length - 1;
              },
              missingNewlineOffset: function() {
                return 1;
              },
              toString: function() {
                return "#<fabric.Text (" + this.complexity() + '): { "text": "' + this.text + '", "fontFamily": "' + this.fontFamily + '" }>';
              },
              _getCacheCanvasDimensions: function() {
                var dims = this.callSuper("_getCacheCanvasDimensions");
                var fontSize2 = this.fontSize;
                dims.width += fontSize2 * dims.zoomX;
                dims.height += fontSize2 * dims.zoomY;
                return dims;
              },
              _render: function(ctx) {
                var path = this.path;
                path && !path.isNotVisible() && path._render(ctx);
                this._setTextStyles(ctx);
                this._renderTextLinesBackground(ctx);
                this._renderTextDecoration(ctx, "underline");
                this._renderText(ctx);
                this._renderTextDecoration(ctx, "overline");
                this._renderTextDecoration(ctx, "linethrough");
              },
              _renderText: function(ctx) {
                if (this.paintFirst === "stroke") {
                  this._renderTextStroke(ctx);
                  this._renderTextFill(ctx);
                } else {
                  this._renderTextFill(ctx);
                  this._renderTextStroke(ctx);
                }
              },
              _setTextStyles: function(ctx, charStyle, forMeasuring) {
                ctx.textBaseline = "alphabetic";
                ctx.font = this._getFontDeclaration(charStyle, forMeasuring);
              },
              calcTextWidth: function() {
                var maxWidth = this.getLineWidth(0);
                for (var i = 1, len = this._textLines.length; i < len; i++) {
                  var currentLineWidth = this.getLineWidth(i);
                  if (currentLineWidth > maxWidth) {
                    maxWidth = currentLineWidth;
                  }
                }
                return maxWidth;
              },
              _renderTextLine: function(method, ctx, line, left, top, lineIndex) {
                this._renderChars(method, ctx, line, left, top, lineIndex);
              },
              _renderTextLinesBackground: function(ctx) {
                if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor")) {
                  return;
                }
                var heightOfLine, lineLeftOffset, originalFill = ctx.fillStyle, line, lastColor, leftOffset = this._getLeftOffset(), lineTopOffset = this._getTopOffset(), boxStart = 0, boxWidth = 0, charBox, currentColor, path = this.path, drawStart;
                for (var i = 0, len = this._textLines.length; i < len; i++) {
                  heightOfLine = this.getHeightOfLine(i);
                  if (!this.textBackgroundColor && !this.styleHas("textBackgroundColor", i)) {
                    lineTopOffset += heightOfLine;
                    continue;
                  }
                  line = this._textLines[i];
                  lineLeftOffset = this._getLineLeftOffset(i);
                  boxWidth = 0;
                  boxStart = 0;
                  lastColor = this.getValueOfPropertyAt(i, 0, "textBackgroundColor");
                  for (var j2 = 0, jlen = line.length; j2 < jlen; j2++) {
                    charBox = this.__charBounds[i][j2];
                    currentColor = this.getValueOfPropertyAt(i, j2, "textBackgroundColor");
                    if (path) {
                      ctx.save();
                      ctx.translate(charBox.renderLeft, charBox.renderTop);
                      ctx.rotate(charBox.angle);
                      ctx.fillStyle = currentColor;
                      currentColor && ctx.fillRect(
                        -charBox.width / 2,
                        -heightOfLine / this.lineHeight * (1 - this._fontSizeFraction),
                        charBox.width,
                        heightOfLine / this.lineHeight
                      );
                      ctx.restore();
                    } else if (currentColor !== lastColor) {
                      drawStart = leftOffset + lineLeftOffset + boxStart;
                      if (this.direction === "rtl") {
                        drawStart = this.width - drawStart - boxWidth;
                      }
                      ctx.fillStyle = lastColor;
                      lastColor && ctx.fillRect(
                        drawStart,
                        lineTopOffset,
                        boxWidth,
                        heightOfLine / this.lineHeight
                      );
                      boxStart = charBox.left;
                      boxWidth = charBox.width;
                      lastColor = currentColor;
                    } else {
                      boxWidth += charBox.kernedWidth;
                    }
                  }
                  if (currentColor && !path) {
                    drawStart = leftOffset + lineLeftOffset + boxStart;
                    if (this.direction === "rtl") {
                      drawStart = this.width - drawStart - boxWidth;
                    }
                    ctx.fillStyle = currentColor;
                    ctx.fillRect(
                      drawStart,
                      lineTopOffset,
                      boxWidth,
                      heightOfLine / this.lineHeight
                    );
                  }
                  lineTopOffset += heightOfLine;
                }
                ctx.fillStyle = originalFill;
                this._removeShadow(ctx);
              },
              getFontCache: function(decl) {
                var fontFamily2 = decl.fontFamily.toLowerCase();
                if (!fabric2.charWidthsCache[fontFamily2]) {
                  fabric2.charWidthsCache[fontFamily2] = {};
                }
                var cache = fabric2.charWidthsCache[fontFamily2], cacheProp = decl.fontStyle.toLowerCase() + "_" + (decl.fontWeight + "").toLowerCase();
                if (!cache[cacheProp]) {
                  cache[cacheProp] = {};
                }
                return cache[cacheProp];
              },
              _measureChar: function(_char, charStyle, previousChar, prevCharStyle) {
                var fontCache = this.getFontCache(charStyle), fontDeclaration = this._getFontDeclaration(charStyle), previousFontDeclaration = this._getFontDeclaration(prevCharStyle), couple = previousChar + _char, stylesAreEqual = fontDeclaration === previousFontDeclaration, width, coupleWidth, previousWidth, fontMultiplier = charStyle.fontSize / this.CACHE_FONT_SIZE, kernedWidth;
                if (previousChar && fontCache[previousChar] !== void 0) {
                  previousWidth = fontCache[previousChar];
                }
                if (fontCache[_char] !== void 0) {
                  kernedWidth = width = fontCache[_char];
                }
                if (stylesAreEqual && fontCache[couple] !== void 0) {
                  coupleWidth = fontCache[couple];
                  kernedWidth = coupleWidth - previousWidth;
                }
                if (width === void 0 || previousWidth === void 0 || coupleWidth === void 0) {
                  var ctx = this.getMeasuringContext();
                  this._setTextStyles(ctx, charStyle, true);
                }
                if (width === void 0) {
                  kernedWidth = width = ctx.measureText(_char).width;
                  fontCache[_char] = width;
                }
                if (previousWidth === void 0 && stylesAreEqual && previousChar) {
                  previousWidth = ctx.measureText(previousChar).width;
                  fontCache[previousChar] = previousWidth;
                }
                if (stylesAreEqual && coupleWidth === void 0) {
                  coupleWidth = ctx.measureText(couple).width;
                  fontCache[couple] = coupleWidth;
                  kernedWidth = coupleWidth - previousWidth;
                }
                return { width: width * fontMultiplier, kernedWidth: kernedWidth * fontMultiplier };
              },
              getHeightOfChar: function(line, _char) {
                return this.getValueOfPropertyAt(line, _char, "fontSize");
              },
              measureLine: function(lineIndex) {
                var lineInfo = this._measureLine(lineIndex);
                if (this.charSpacing !== 0) {
                  lineInfo.width -= this._getWidthOfCharSpacing();
                }
                if (lineInfo.width < 0) {
                  lineInfo.width = 0;
                }
                return lineInfo;
              },
              _measureLine: function(lineIndex) {
                var width = 0, i, grapheme, line = this._textLines[lineIndex], prevGrapheme, graphemeInfo, numOfSpaces = 0, lineBounds = new Array(line.length), positionInPath = 0, startingPoint, totalPathLength, path = this.path, reverse = this.pathSide === "right";
                this.__charBounds[lineIndex] = lineBounds;
                for (i = 0; i < line.length; i++) {
                  grapheme = line[i];
                  graphemeInfo = this._getGraphemeBox(grapheme, lineIndex, i, prevGrapheme);
                  lineBounds[i] = graphemeInfo;
                  width += graphemeInfo.kernedWidth;
                  prevGrapheme = grapheme;
                }
                lineBounds[i] = {
                  left: graphemeInfo ? graphemeInfo.left + graphemeInfo.width : 0,
                  width: 0,
                  kernedWidth: 0,
                  height: this.fontSize
                };
                if (path) {
                  totalPathLength = path.segmentsInfo[path.segmentsInfo.length - 1].length;
                  startingPoint = fabric2.util.getPointOnPath(path.path, 0, path.segmentsInfo);
                  startingPoint.x += path.pathOffset.x;
                  startingPoint.y += path.pathOffset.y;
                  switch (this.textAlign) {
                    case "left":
                      positionInPath = reverse ? totalPathLength - width : 0;
                      break;
                    case "center":
                      positionInPath = (totalPathLength - width) / 2;
                      break;
                    case "right":
                      positionInPath = reverse ? 0 : totalPathLength - width;
                      break;
                  }
                  positionInPath += this.pathStartOffset * (reverse ? -1 : 1);
                  for (i = reverse ? line.length - 1 : 0; reverse ? i >= 0 : i < line.length; reverse ? i-- : i++) {
                    graphemeInfo = lineBounds[i];
                    if (positionInPath > totalPathLength) {
                      positionInPath %= totalPathLength;
                    } else if (positionInPath < 0) {
                      positionInPath += totalPathLength;
                    }
                    this._setGraphemeOnPath(positionInPath, graphemeInfo, startingPoint);
                    positionInPath += graphemeInfo.kernedWidth;
                  }
                }
                return { width, numOfSpaces };
              },
              _setGraphemeOnPath: function(positionInPath, graphemeInfo, startingPoint) {
                var centerPosition = positionInPath + graphemeInfo.kernedWidth / 2, path = this.path;
                var info = fabric2.util.getPointOnPath(path.path, centerPosition, path.segmentsInfo);
                graphemeInfo.renderLeft = info.x - startingPoint.x;
                graphemeInfo.renderTop = info.y - startingPoint.y;
                graphemeInfo.angle = info.angle + (this.pathSide === "right" ? Math.PI : 0);
              },
              _getGraphemeBox: function(grapheme, lineIndex, charIndex, prevGrapheme, skipLeft) {
                var style = this.getCompleteStyleDeclaration(lineIndex, charIndex), prevStyle = prevGrapheme ? this.getCompleteStyleDeclaration(lineIndex, charIndex - 1) : {}, info = this._measureChar(grapheme, style, prevGrapheme, prevStyle), kernedWidth = info.kernedWidth, width = info.width, charSpacing;
                if (this.charSpacing !== 0) {
                  charSpacing = this._getWidthOfCharSpacing();
                  width += charSpacing;
                  kernedWidth += charSpacing;
                }
                var box = {
                  width,
                  left: 0,
                  height: style.fontSize,
                  kernedWidth,
                  deltaY: style.deltaY
                };
                if (charIndex > 0 && !skipLeft) {
                  var previousBox = this.__charBounds[lineIndex][charIndex - 1];
                  box.left = previousBox.left + previousBox.width + info.kernedWidth - info.width;
                }
                return box;
              },
              getHeightOfLine: function(lineIndex) {
                if (this.__lineHeights[lineIndex]) {
                  return this.__lineHeights[lineIndex];
                }
                var line = this._textLines[lineIndex], maxHeight = this.getHeightOfChar(lineIndex, 0);
                for (var i = 1, len = line.length; i < len; i++) {
                  maxHeight = Math.max(this.getHeightOfChar(lineIndex, i), maxHeight);
                }
                return this.__lineHeights[lineIndex] = maxHeight * this.lineHeight * this._fontSizeMult;
              },
              calcTextHeight: function() {
                var lineHeight2, height = 0;
                for (var i = 0, len = this._textLines.length; i < len; i++) {
                  lineHeight2 = this.getHeightOfLine(i);
                  height += i === len - 1 ? lineHeight2 / this.lineHeight : lineHeight2;
                }
                return height;
              },
              _getLeftOffset: function() {
                return this.direction === "ltr" ? -this.width / 2 : this.width / 2;
              },
              _getTopOffset: function() {
                return -this.height / 2;
              },
              _renderTextCommon: function(ctx, method) {
                ctx.save();
                var lineHeights = 0, left = this._getLeftOffset(), top = this._getTopOffset();
                for (var i = 0, len = this._textLines.length; i < len; i++) {
                  var heightOfLine = this.getHeightOfLine(i), maxHeight = heightOfLine / this.lineHeight, leftOffset = this._getLineLeftOffset(i);
                  this._renderTextLine(
                    method,
                    ctx,
                    this._textLines[i],
                    left + leftOffset,
                    top + lineHeights + maxHeight,
                    i
                  );
                  lineHeights += heightOfLine;
                }
                ctx.restore();
              },
              _renderTextFill: function(ctx) {
                if (!this.fill && !this.styleHas("fill")) {
                  return;
                }
                this._renderTextCommon(ctx, "fillText");
              },
              _renderTextStroke: function(ctx) {
                if ((!this.stroke || this.strokeWidth === 0) && this.isEmptyStyles()) {
                  return;
                }
                if (this.shadow && !this.shadow.affectStroke) {
                  this._removeShadow(ctx);
                }
                ctx.save();
                this._setLineDash(ctx, this.strokeDashArray);
                ctx.beginPath();
                this._renderTextCommon(ctx, "strokeText");
                ctx.closePath();
                ctx.restore();
              },
              _renderChars: function(method, ctx, line, left, top, lineIndex) {
                var lineHeight2 = this.getHeightOfLine(lineIndex), isJustify = this.textAlign.indexOf("justify") !== -1, actualStyle, nextStyle, charsToRender = "", charBox, boxWidth = 0, timeToRender, path = this.path, shortCut = !isJustify && this.charSpacing === 0 && this.isEmptyStyles(lineIndex) && !path, isLtr = this.direction === "ltr", sign2 = this.direction === "ltr" ? 1 : -1, drawingLeft;
                ctx.save();
                top -= lineHeight2 * this._fontSizeFraction / this.lineHeight;
                if (shortCut) {
                  ctx.canvas.setAttribute("dir", isLtr ? "ltr" : "rtl");
                  ctx.direction = isLtr ? "ltr" : "rtl";
                  ctx.textAlign = isLtr ? "left" : "right";
                  this._renderChar(method, ctx, lineIndex, 0, line.join(""), left, top, lineHeight2);
                  ctx.restore();
                  return;
                }
                for (var i = 0, len = line.length - 1; i <= len; i++) {
                  timeToRender = i === len || this.charSpacing || path;
                  charsToRender += line[i];
                  charBox = this.__charBounds[lineIndex][i];
                  if (boxWidth === 0) {
                    left += sign2 * (charBox.kernedWidth - charBox.width);
                    boxWidth += charBox.width;
                  } else {
                    boxWidth += charBox.kernedWidth;
                  }
                  if (isJustify && !timeToRender) {
                    if (this._reSpaceAndTab.test(line[i])) {
                      timeToRender = true;
                    }
                  }
                  if (!timeToRender) {
                    actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);
                    nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);
                    timeToRender = this._hasStyleChanged(actualStyle, nextStyle);
                  }
                  if (timeToRender) {
                    if (path) {
                      ctx.save();
                      ctx.translate(charBox.renderLeft, charBox.renderTop);
                      ctx.rotate(charBox.angle);
                      this._renderChar(method, ctx, lineIndex, i, charsToRender, -boxWidth / 2, 0, lineHeight2);
                      ctx.restore();
                    } else {
                      drawingLeft = left;
                      ctx.canvas.setAttribute("dir", isLtr ? "ltr" : "rtl");
                      ctx.direction = isLtr ? "ltr" : "rtl";
                      ctx.textAlign = isLtr ? "left" : "right";
                      this._renderChar(method, ctx, lineIndex, i, charsToRender, drawingLeft, top, lineHeight2);
                    }
                    charsToRender = "";
                    actualStyle = nextStyle;
                    left += sign2 * boxWidth;
                    boxWidth = 0;
                  }
                }
                ctx.restore();
              },
              _applyPatternGradientTransformText: function(filler) {
                var pCanvas = fabric2.util.createCanvasElement(), pCtx, width = this.width + this.strokeWidth, height = this.height + this.strokeWidth;
                pCanvas.width = width;
                pCanvas.height = height;
                pCtx = pCanvas.getContext("2d");
                pCtx.beginPath();
                pCtx.moveTo(0, 0);
                pCtx.lineTo(width, 0);
                pCtx.lineTo(width, height);
                pCtx.lineTo(0, height);
                pCtx.closePath();
                pCtx.translate(width / 2, height / 2);
                pCtx.fillStyle = filler.toLive(pCtx);
                this._applyPatternGradientTransform(pCtx, filler);
                pCtx.fill();
                return pCtx.createPattern(pCanvas, "no-repeat");
              },
              handleFiller: function(ctx, property, filler) {
                var offsetX, offsetY;
                if (filler.toLive) {
                  if (filler.gradientUnits === "percentage" || filler.gradientTransform || filler.patternTransform) {
                    offsetX = -this.width / 2;
                    offsetY = -this.height / 2;
                    ctx.translate(offsetX, offsetY);
                    ctx[property] = this._applyPatternGradientTransformText(filler);
                    return { offsetX, offsetY };
                  } else {
                    ctx[property] = filler.toLive(ctx, this);
                    return this._applyPatternGradientTransform(ctx, filler);
                  }
                } else {
                  ctx[property] = filler;
                }
                return { offsetX: 0, offsetY: 0 };
              },
              _setStrokeStyles: function(ctx, decl) {
                ctx.lineWidth = decl.strokeWidth;
                ctx.lineCap = this.strokeLineCap;
                ctx.lineDashOffset = this.strokeDashOffset;
                ctx.lineJoin = this.strokeLineJoin;
                ctx.miterLimit = this.strokeMiterLimit;
                return this.handleFiller(ctx, "strokeStyle", decl.stroke);
              },
              _setFillStyles: function(ctx, decl) {
                return this.handleFiller(ctx, "fillStyle", decl.fill);
              },
              _renderChar: function(method, ctx, lineIndex, charIndex, _char, left, top) {
                var decl = this._getStyleDeclaration(lineIndex, charIndex), fullDecl = this.getCompleteStyleDeclaration(lineIndex, charIndex), shouldFill = method === "fillText" && fullDecl.fill, shouldStroke = method === "strokeText" && fullDecl.stroke && fullDecl.strokeWidth, fillOffsets, strokeOffsets;
                if (!shouldStroke && !shouldFill) {
                  return;
                }
                ctx.save();
                shouldFill && (fillOffsets = this._setFillStyles(ctx, fullDecl));
                shouldStroke && (strokeOffsets = this._setStrokeStyles(ctx, fullDecl));
                ctx.font = this._getFontDeclaration(fullDecl);
                if (decl && decl.textBackgroundColor) {
                  this._removeShadow(ctx);
                }
                if (decl && decl.deltaY) {
                  top += decl.deltaY;
                }
                shouldFill && ctx.fillText(_char, left - fillOffsets.offsetX, top - fillOffsets.offsetY);
                shouldStroke && ctx.strokeText(_char, left - strokeOffsets.offsetX, top - strokeOffsets.offsetY);
                ctx.restore();
              },
              setSuperscript: function(start, end) {
                return this._setScript(start, end, this.superscript);
              },
              setSubscript: function(start, end) {
                return this._setScript(start, end, this.subscript);
              },
              _setScript: function(start, end, schema) {
                var loc = this.get2DCursorLocation(start, true), fontSize2 = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, "fontSize"), dy = this.getValueOfPropertyAt(loc.lineIndex, loc.charIndex, "deltaY"), style = { fontSize: fontSize2 * schema.size, deltaY: dy + fontSize2 * schema.baseline };
                this.setSelectionStyles(style, start, end);
                return this;
              },
              _hasStyleChanged: function(prevStyle, thisStyle) {
                return prevStyle.fill !== thisStyle.fill || prevStyle.stroke !== thisStyle.stroke || prevStyle.strokeWidth !== thisStyle.strokeWidth || prevStyle.fontSize !== thisStyle.fontSize || prevStyle.fontFamily !== thisStyle.fontFamily || prevStyle.fontWeight !== thisStyle.fontWeight || prevStyle.fontStyle !== thisStyle.fontStyle || prevStyle.deltaY !== thisStyle.deltaY;
              },
              _hasStyleChangedForSvg: function(prevStyle, thisStyle) {
                return this._hasStyleChanged(prevStyle, thisStyle) || prevStyle.overline !== thisStyle.overline || prevStyle.underline !== thisStyle.underline || prevStyle.linethrough !== thisStyle.linethrough;
              },
              _getLineLeftOffset: function(lineIndex) {
                var lineWidth = this.getLineWidth(lineIndex), lineDiff = this.width - lineWidth, textAlign2 = this.textAlign, direction2 = this.direction, isEndOfWrapping, leftOffset = 0, isEndOfWrapping = this.isEndOfWrapping(lineIndex);
                if (textAlign2 === "justify" || textAlign2 === "justify-center" && !isEndOfWrapping || textAlign2 === "justify-right" && !isEndOfWrapping || textAlign2 === "justify-left" && !isEndOfWrapping) {
                  return 0;
                }
                if (textAlign2 === "center") {
                  leftOffset = lineDiff / 2;
                }
                if (textAlign2 === "right") {
                  leftOffset = lineDiff;
                }
                if (textAlign2 === "justify-center") {
                  leftOffset = lineDiff / 2;
                }
                if (textAlign2 === "justify-right") {
                  leftOffset = lineDiff;
                }
                if (direction2 === "rtl") {
                  leftOffset -= lineDiff;
                }
                return leftOffset;
              },
              _clearCache: function() {
                this.__lineWidths = [];
                this.__lineHeights = [];
                this.__charBounds = [];
              },
              _shouldClearDimensionCache: function() {
                var shouldClear = this._forceClearCache;
                shouldClear || (shouldClear = this.hasStateChanged("_dimensionAffectingProps"));
                if (shouldClear) {
                  this.dirty = true;
                  this._forceClearCache = false;
                }
                return shouldClear;
              },
              getLineWidth: function(lineIndex) {
                if (this.__lineWidths[lineIndex]) {
                  return this.__lineWidths[lineIndex];
                }
                var width, line = this._textLines[lineIndex], lineInfo;
                if (line === "") {
                  width = 0;
                } else {
                  lineInfo = this.measureLine(lineIndex);
                  width = lineInfo.width;
                }
                this.__lineWidths[lineIndex] = width;
                return width;
              },
              _getWidthOfCharSpacing: function() {
                if (this.charSpacing !== 0) {
                  return this.fontSize * this.charSpacing / 1e3;
                }
                return 0;
              },
              getValueOfPropertyAt: function(lineIndex, charIndex, property) {
                var charStyle = this._getStyleDeclaration(lineIndex, charIndex);
                if (charStyle && typeof charStyle[property] !== "undefined") {
                  return charStyle[property];
                }
                return this[property];
              },
              _renderTextDecoration: function(ctx, type) {
                if (!this[type] && !this.styleHas(type)) {
                  return;
                }
                var heightOfLine, size, _size, lineLeftOffset, dy, _dy, line, lastDecoration, leftOffset = this._getLeftOffset(), topOffset = this._getTopOffset(), top, boxStart, boxWidth, charBox, currentDecoration, maxHeight, currentFill, lastFill, path = this.path, charSpacing = this._getWidthOfCharSpacing(), offsetY = this.offsets[type];
                for (var i = 0, len = this._textLines.length; i < len; i++) {
                  heightOfLine = this.getHeightOfLine(i);
                  if (!this[type] && !this.styleHas(type, i)) {
                    topOffset += heightOfLine;
                    continue;
                  }
                  line = this._textLines[i];
                  maxHeight = heightOfLine / this.lineHeight;
                  lineLeftOffset = this._getLineLeftOffset(i);
                  boxStart = 0;
                  boxWidth = 0;
                  lastDecoration = this.getValueOfPropertyAt(i, 0, type);
                  lastFill = this.getValueOfPropertyAt(i, 0, "fill");
                  top = topOffset + maxHeight * (1 - this._fontSizeFraction);
                  size = this.getHeightOfChar(i, 0);
                  dy = this.getValueOfPropertyAt(i, 0, "deltaY");
                  for (var j2 = 0, jlen = line.length; j2 < jlen; j2++) {
                    charBox = this.__charBounds[i][j2];
                    currentDecoration = this.getValueOfPropertyAt(i, j2, type);
                    currentFill = this.getValueOfPropertyAt(i, j2, "fill");
                    _size = this.getHeightOfChar(i, j2);
                    _dy = this.getValueOfPropertyAt(i, j2, "deltaY");
                    if (path && currentDecoration && currentFill) {
                      ctx.save();
                      ctx.fillStyle = lastFill;
                      ctx.translate(charBox.renderLeft, charBox.renderTop);
                      ctx.rotate(charBox.angle);
                      ctx.fillRect(
                        -charBox.kernedWidth / 2,
                        offsetY * _size + _dy,
                        charBox.kernedWidth,
                        this.fontSize / 15
                      );
                      ctx.restore();
                    } else if ((currentDecoration !== lastDecoration || currentFill !== lastFill || _size !== size || _dy !== dy) && boxWidth > 0) {
                      var drawStart = leftOffset + lineLeftOffset + boxStart;
                      if (this.direction === "rtl") {
                        drawStart = this.width - drawStart - boxWidth;
                      }
                      if (lastDecoration && lastFill) {
                        ctx.fillStyle = lastFill;
                        ctx.fillRect(
                          drawStart,
                          top + offsetY * size + dy,
                          boxWidth,
                          this.fontSize / 15
                        );
                      }
                      boxStart = charBox.left;
                      boxWidth = charBox.width;
                      lastDecoration = currentDecoration;
                      lastFill = currentFill;
                      size = _size;
                      dy = _dy;
                    } else {
                      boxWidth += charBox.kernedWidth;
                    }
                  }
                  var drawStart = leftOffset + lineLeftOffset + boxStart;
                  if (this.direction === "rtl") {
                    drawStart = this.width - drawStart - boxWidth;
                  }
                  ctx.fillStyle = currentFill;
                  currentDecoration && currentFill && ctx.fillRect(
                    drawStart,
                    top + offsetY * size + dy,
                    boxWidth - charSpacing,
                    this.fontSize / 15
                  );
                  topOffset += heightOfLine;
                }
                this._removeShadow(ctx);
              },
              _getFontDeclaration: function(styleObject, forMeasuring) {
                var style = styleObject || this, family = this.fontFamily, fontIsGeneric = fabric2.Text.genericFonts.indexOf(family.toLowerCase()) > -1;
                var fontFamily2 = family === void 0 || family.indexOf("'") > -1 || family.indexOf(",") > -1 || family.indexOf('"') > -1 || fontIsGeneric ? style.fontFamily : '"' + style.fontFamily + '"';
                return [
                  fabric2.isLikelyNode ? style.fontWeight : style.fontStyle,
                  fabric2.isLikelyNode ? style.fontStyle : style.fontWeight,
                  forMeasuring ? this.CACHE_FONT_SIZE + "px" : style.fontSize + "px",
                  fontFamily2
                ].join(" ");
              },
              render: function(ctx) {
                if (!this.visible) {
                  return;
                }
                if (this.canvas && this.canvas.skipOffscreen && !this.group && !this.isOnScreen()) {
                  return;
                }
                if (this._shouldClearDimensionCache()) {
                  this.initDimensions();
                }
                this.callSuper("render", ctx);
              },
              _splitTextIntoLines: function(text) {
                var lines = text.split(this._reNewline), newLines = new Array(lines.length), newLine = ["\n"], newText = [];
                for (var i = 0; i < lines.length; i++) {
                  newLines[i] = fabric2.util.string.graphemeSplit(lines[i]);
                  newText = newText.concat(newLines[i], newLine);
                }
                newText.pop();
                return { _unwrappedLines: newLines, lines, graphemeText: newText, graphemeLines: newLines };
              },
              toObject: function(propertiesToInclude) {
                var allProperties = additionalProps.concat(propertiesToInclude);
                var obj = this.callSuper("toObject", allProperties);
                obj.styles = clone2(this.styles, true);
                if (obj.path) {
                  obj.path = this.path.toObject();
                }
                return obj;
              },
              set: function(key, value) {
                this.callSuper("set", key, value);
                var needsDims = false;
                var isAddingPath = false;
                if (typeof key === "object") {
                  for (var _key in key) {
                    if (_key === "path") {
                      this.setPathInfo();
                    }
                    needsDims = needsDims || this._dimensionAffectingProps.indexOf(_key) !== -1;
                    isAddingPath = isAddingPath || _key === "path";
                  }
                } else {
                  needsDims = this._dimensionAffectingProps.indexOf(key) !== -1;
                  isAddingPath = key === "path";
                }
                if (isAddingPath) {
                  this.setPathInfo();
                }
                if (needsDims) {
                  this.initDimensions();
                  this.setCoords();
                }
                return this;
              },
              complexity: function() {
                return 1;
              }
            });
            fabric2.Text.ATTRIBUTE_NAMES = fabric2.SHARED_ATTRIBUTES.concat(
              "x y dx dy font-family font-style font-weight font-size letter-spacing text-decoration text-anchor".split(" ")
            );
            fabric2.Text.DEFAULT_SVG_FONT_SIZE = 16;
            fabric2.Text.fromElement = function(element, callback, options) {
              if (!element) {
                return callback(null);
              }
              var parsedAttributes = fabric2.parseAttributes(element, fabric2.Text.ATTRIBUTE_NAMES), parsedAnchor = parsedAttributes.textAnchor || "left";
              options = fabric2.util.object.extend(options ? clone2(options) : {}, parsedAttributes);
              options.top = options.top || 0;
              options.left = options.left || 0;
              if (parsedAttributes.textDecoration) {
                var textDecoration = parsedAttributes.textDecoration;
                if (textDecoration.indexOf("underline") !== -1) {
                  options.underline = true;
                }
                if (textDecoration.indexOf("overline") !== -1) {
                  options.overline = true;
                }
                if (textDecoration.indexOf("line-through") !== -1) {
                  options.linethrough = true;
                }
                delete options.textDecoration;
              }
              if ("dx" in parsedAttributes) {
                options.left += parsedAttributes.dx;
              }
              if ("dy" in parsedAttributes) {
                options.top += parsedAttributes.dy;
              }
              if (!("fontSize" in options)) {
                options.fontSize = fabric2.Text.DEFAULT_SVG_FONT_SIZE;
              }
              var textContent = "";
              if (!("textContent" in element)) {
                if ("firstChild" in element && element.firstChild !== null) {
                  if ("data" in element.firstChild && element.firstChild.data !== null) {
                    textContent = element.firstChild.data;
                  }
                }
              } else {
                textContent = element.textContent;
              }
              textContent = textContent.replace(/^\s+|\s+$|\n+/g, "").replace(/\s+/g, " ");
              var originalStrokeWidth = options.strokeWidth;
              options.strokeWidth = 0;
              var text = new fabric2.Text(textContent, options), textHeightScaleFactor = text.getScaledHeight() / text.height, lineHeightDiff = (text.height + text.strokeWidth) * text.lineHeight - text.height, scaledDiff = lineHeightDiff * textHeightScaleFactor, textHeight = text.getScaledHeight() + scaledDiff, offX = 0;
              if (parsedAnchor === "center") {
                offX = text.getScaledWidth() / 2;
              }
              if (parsedAnchor === "right") {
                offX = text.getScaledWidth();
              }
              text.set({
                left: text.left - offX,
                top: text.top - (textHeight - text.fontSize * (0.07 + text._fontSizeFraction)) / text.lineHeight,
                strokeWidth: typeof originalStrokeWidth !== "undefined" ? originalStrokeWidth : 1
              });
              callback(text);
            };
            fabric2.Text.fromObject = function(object, callback) {
              var objectCopy = clone2(object), path = object.path;
              delete objectCopy.path;
              return fabric2.Object._fromObject("Text", objectCopy, function(textInstance) {
                if (path) {
                  fabric2.Object._fromObject("Path", path, function(pathInstance) {
                    textInstance.set("path", pathInstance);
                    callback(textInstance);
                  }, "path");
                } else {
                  callback(textInstance);
                }
              }, "text");
            };
            fabric2.Text.genericFonts = ["sans-serif", "serif", "cursive", "fantasy", "monospace"];
            fabric2.util.createAccessors && fabric2.util.createAccessors(fabric2.Text);
          })(exports2);
          (function() {
            fabric.util.object.extend(fabric.Text.prototype, {
              isEmptyStyles: function(lineIndex) {
                if (!this.styles) {
                  return true;
                }
                if (typeof lineIndex !== "undefined" && !this.styles[lineIndex]) {
                  return true;
                }
                var obj = typeof lineIndex === "undefined" ? this.styles : { line: this.styles[lineIndex] };
                for (var p1 in obj) {
                  for (var p2 in obj[p1]) {
                    for (var p3 in obj[p1][p2]) {
                      return false;
                    }
                  }
                }
                return true;
              },
              styleHas: function(property, lineIndex) {
                if (!this.styles || !property || property === "") {
                  return false;
                }
                if (typeof lineIndex !== "undefined" && !this.styles[lineIndex]) {
                  return false;
                }
                var obj = typeof lineIndex === "undefined" ? this.styles : { 0: this.styles[lineIndex] };
                for (var p1 in obj) {
                  for (var p2 in obj[p1]) {
                    if (typeof obj[p1][p2][property] !== "undefined") {
                      return true;
                    }
                  }
                }
                return false;
              },
              cleanStyle: function(property) {
                if (!this.styles || !property || property === "") {
                  return false;
                }
                var obj = this.styles, stylesCount = 0, letterCount, stylePropertyValue, allStyleObjectPropertiesMatch = true, graphemeCount = 0, styleObject;
                for (var p1 in obj) {
                  letterCount = 0;
                  for (var p2 in obj[p1]) {
                    var styleObject = obj[p1][p2], stylePropertyHasBeenSet = styleObject.hasOwnProperty(property);
                    stylesCount++;
                    if (stylePropertyHasBeenSet) {
                      if (!stylePropertyValue) {
                        stylePropertyValue = styleObject[property];
                      } else if (styleObject[property] !== stylePropertyValue) {
                        allStyleObjectPropertiesMatch = false;
                      }
                      if (styleObject[property] === this[property]) {
                        delete styleObject[property];
                      }
                    } else {
                      allStyleObjectPropertiesMatch = false;
                    }
                    if (Object.keys(styleObject).length !== 0) {
                      letterCount++;
                    } else {
                      delete obj[p1][p2];
                    }
                  }
                  if (letterCount === 0) {
                    delete obj[p1];
                  }
                }
                for (var i = 0; i < this._textLines.length; i++) {
                  graphemeCount += this._textLines[i].length;
                }
                if (allStyleObjectPropertiesMatch && stylesCount === graphemeCount) {
                  this[property] = stylePropertyValue;
                  this.removeStyle(property);
                }
              },
              removeStyle: function(property) {
                if (!this.styles || !property || property === "") {
                  return;
                }
                var obj = this.styles, line, lineNum, charNum;
                for (lineNum in obj) {
                  line = obj[lineNum];
                  for (charNum in line) {
                    delete line[charNum][property];
                    if (Object.keys(line[charNum]).length === 0) {
                      delete line[charNum];
                    }
                  }
                  if (Object.keys(line).length === 0) {
                    delete obj[lineNum];
                  }
                }
              },
              _extendStyles: function(index2, styles) {
                var loc = this.get2DCursorLocation(index2);
                if (!this._getLineStyle(loc.lineIndex)) {
                  this._setLineStyle(loc.lineIndex);
                }
                if (!this._getStyleDeclaration(loc.lineIndex, loc.charIndex)) {
                  this._setStyleDeclaration(loc.lineIndex, loc.charIndex, {});
                }
                fabric.util.object.extend(this._getStyleDeclaration(loc.lineIndex, loc.charIndex), styles);
              },
              get2DCursorLocation: function(selectionStart, skipWrapping) {
                if (typeof selectionStart === "undefined") {
                  selectionStart = this.selectionStart;
                }
                var lines = skipWrapping ? this._unwrappedTextLines : this._textLines, len = lines.length;
                for (var i = 0; i < len; i++) {
                  if (selectionStart <= lines[i].length) {
                    return {
                      lineIndex: i,
                      charIndex: selectionStart
                    };
                  }
                  selectionStart -= lines[i].length + this.missingNewlineOffset(i);
                }
                return {
                  lineIndex: i - 1,
                  charIndex: lines[i - 1].length < selectionStart ? lines[i - 1].length : selectionStart
                };
              },
              getSelectionStyles: function(startIndex, endIndex, complete) {
                if (typeof startIndex === "undefined") {
                  startIndex = this.selectionStart || 0;
                }
                if (typeof endIndex === "undefined") {
                  endIndex = this.selectionEnd || startIndex;
                }
                var styles = [];
                for (var i = startIndex; i < endIndex; i++) {
                  styles.push(this.getStyleAtPosition(i, complete));
                }
                return styles;
              },
              getStyleAtPosition: function(position2, complete) {
                var loc = this.get2DCursorLocation(position2), style = complete ? this.getCompleteStyleDeclaration(loc.lineIndex, loc.charIndex) : this._getStyleDeclaration(loc.lineIndex, loc.charIndex);
                return style || {};
              },
              setSelectionStyles: function(styles, startIndex, endIndex) {
                if (typeof startIndex === "undefined") {
                  startIndex = this.selectionStart || 0;
                }
                if (typeof endIndex === "undefined") {
                  endIndex = this.selectionEnd || startIndex;
                }
                for (var i = startIndex; i < endIndex; i++) {
                  this._extendStyles(i, styles);
                }
                this._forceClearCache = true;
                return this;
              },
              _getStyleDeclaration: function(lineIndex, charIndex) {
                var lineStyle = this.styles && this.styles[lineIndex];
                if (!lineStyle) {
                  return null;
                }
                return lineStyle[charIndex];
              },
              getCompleteStyleDeclaration: function(lineIndex, charIndex) {
                var style = this._getStyleDeclaration(lineIndex, charIndex) || {}, styleObject = {}, prop;
                for (var i = 0; i < this._styleProperties.length; i++) {
                  prop = this._styleProperties[i];
                  styleObject[prop] = typeof style[prop] === "undefined" ? this[prop] : style[prop];
                }
                return styleObject;
              },
              _setStyleDeclaration: function(lineIndex, charIndex, style) {
                this.styles[lineIndex][charIndex] = style;
              },
              _deleteStyleDeclaration: function(lineIndex, charIndex) {
                delete this.styles[lineIndex][charIndex];
              },
              _getLineStyle: function(lineIndex) {
                return !!this.styles[lineIndex];
              },
              _setLineStyle: function(lineIndex) {
                this.styles[lineIndex] = {};
              },
              _deleteLineStyle: function(lineIndex) {
                delete this.styles[lineIndex];
              }
            });
          })();
          (function() {
            function parseDecoration(object) {
              if (object.textDecoration) {
                object.textDecoration.indexOf("underline") > -1 && (object.underline = true);
                object.textDecoration.indexOf("line-through") > -1 && (object.linethrough = true);
                object.textDecoration.indexOf("overline") > -1 && (object.overline = true);
                delete object.textDecoration;
              }
            }
            fabric.IText = fabric.util.createClass(fabric.Text, fabric.Observable, {
              type: "i-text",
              selectionStart: 0,
              selectionEnd: 0,
              selectionColor: "rgba(17,119,255,0.3)",
              isEditing: false,
              editable: true,
              editingBorderColor: "rgba(102,153,255,0.25)",
              cursorWidth: 2,
              cursorColor: "",
              cursorDelay: 1e3,
              cursorDuration: 600,
              caching: true,
              hiddenTextareaContainer: null,
              _reSpace: /\s|\n/,
              _currentCursorOpacity: 0,
              _selectionDirection: null,
              _abortCursorAnimation: false,
              __widthOfSpace: [],
              inCompositionMode: false,
              initialize: function(text, options) {
                this.callSuper("initialize", text, options);
                this.initBehavior();
              },
              setSelectionStart: function(index2) {
                index2 = Math.max(index2, 0);
                this._updateAndFire("selectionStart", index2);
              },
              setSelectionEnd: function(index2) {
                index2 = Math.min(index2, this.text.length);
                this._updateAndFire("selectionEnd", index2);
              },
              _updateAndFire: function(property, index2) {
                if (this[property] !== index2) {
                  this._fireSelectionChanged();
                  this[property] = index2;
                }
                this._updateTextarea();
              },
              _fireSelectionChanged: function() {
                this.fire("selection:changed");
                this.canvas && this.canvas.fire("text:selection:changed", { target: this });
              },
              initDimensions: function() {
                this.isEditing && this.initDelayedCursor();
                this.clearContextTop();
                this.callSuper("initDimensions");
              },
              render: function(ctx) {
                this.clearContextTop();
                this.callSuper("render", ctx);
                this.cursorOffsetCache = {};
                this.renderCursorOrSelection();
              },
              _render: function(ctx) {
                this.callSuper("_render", ctx);
              },
              clearContextTop: function(skipRestore) {
                if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {
                  return;
                }
                var ctx = this.canvas.contextTop, v = this.canvas.viewportTransform;
                ctx.save();
                ctx.transform(v[0], v[1], v[2], v[3], v[4], v[5]);
                this.transform(ctx);
                this._clearTextArea(ctx);
                skipRestore || ctx.restore();
              },
              renderCursorOrSelection: function() {
                if (!this.isEditing || !this.canvas || !this.canvas.contextTop) {
                  return;
                }
                var boundaries = this._getCursorBoundaries(), ctx = this.canvas.contextTop;
                this.clearContextTop(true);
                if (this.selectionStart === this.selectionEnd) {
                  this.renderCursor(boundaries, ctx);
                } else {
                  this.renderSelection(boundaries, ctx);
                }
                ctx.restore();
              },
              _clearTextArea: function(ctx) {
                var width = this.width + 4, height = this.height + 4;
                ctx.clearRect(-width / 2, -height / 2, width, height);
              },
              _getCursorBoundaries: function(position2) {
                if (typeof position2 === "undefined") {
                  position2 = this.selectionStart;
                }
                var left = this._getLeftOffset(), top = this._getTopOffset(), offsets = this._getCursorBoundariesOffsets(position2);
                return {
                  left,
                  top,
                  leftOffset: offsets.left,
                  topOffset: offsets.top
                };
              },
              _getCursorBoundariesOffsets: function(position2) {
                if (this.cursorOffsetCache && "top" in this.cursorOffsetCache) {
                  return this.cursorOffsetCache;
                }
                var lineLeftOffset, lineIndex, charIndex, topOffset = 0, leftOffset = 0, boundaries, cursorPosition = this.get2DCursorLocation(position2);
                charIndex = cursorPosition.charIndex;
                lineIndex = cursorPosition.lineIndex;
                for (var i = 0; i < lineIndex; i++) {
                  topOffset += this.getHeightOfLine(i);
                }
                lineLeftOffset = this._getLineLeftOffset(lineIndex);
                var bound = this.__charBounds[lineIndex][charIndex];
                bound && (leftOffset = bound.left);
                if (this.charSpacing !== 0 && charIndex === this._textLines[lineIndex].length) {
                  leftOffset -= this._getWidthOfCharSpacing();
                }
                boundaries = {
                  top: topOffset,
                  left: lineLeftOffset + (leftOffset > 0 ? leftOffset : 0)
                };
                if (this.direction === "rtl") {
                  boundaries.left *= -1;
                }
                this.cursorOffsetCache = boundaries;
                return this.cursorOffsetCache;
              },
              renderCursor: function(boundaries, ctx) {
                var cursorLocation = this.get2DCursorLocation(), lineIndex = cursorLocation.lineIndex, charIndex = cursorLocation.charIndex > 0 ? cursorLocation.charIndex - 1 : 0, charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, "fontSize"), multiplier = this.scaleX * this.canvas.getZoom(), cursorWidth = this.cursorWidth / multiplier, topOffset = boundaries.topOffset, dy = this.getValueOfPropertyAt(lineIndex, charIndex, "deltaY");
                topOffset += (1 - this._fontSizeFraction) * this.getHeightOfLine(lineIndex) / this.lineHeight - charHeight * (1 - this._fontSizeFraction);
                if (this.inCompositionMode) {
                  this.renderSelection(boundaries, ctx);
                }
                ctx.fillStyle = this.cursorColor || this.getValueOfPropertyAt(lineIndex, charIndex, "fill");
                ctx.globalAlpha = this.__isMousedown ? 1 : this._currentCursorOpacity;
                ctx.fillRect(
                  boundaries.left + boundaries.leftOffset - cursorWidth / 2,
                  topOffset + boundaries.top + dy,
                  cursorWidth,
                  charHeight
                );
              },
              renderSelection: function(boundaries, ctx) {
                var selectionStart = this.inCompositionMode ? this.hiddenTextarea.selectionStart : this.selectionStart, selectionEnd = this.inCompositionMode ? this.hiddenTextarea.selectionEnd : this.selectionEnd, isJustify = this.textAlign.indexOf("justify") !== -1, start = this.get2DCursorLocation(selectionStart), end = this.get2DCursorLocation(selectionEnd), startLine = start.lineIndex, endLine = end.lineIndex, startChar = start.charIndex < 0 ? 0 : start.charIndex, endChar = end.charIndex < 0 ? 0 : end.charIndex;
                for (var i = startLine; i <= endLine; i++) {
                  var lineOffset = this._getLineLeftOffset(i) || 0, lineHeight2 = this.getHeightOfLine(i), realLineHeight = 0, boxStart = 0, boxEnd = 0;
                  if (i === startLine) {
                    boxStart = this.__charBounds[startLine][startChar].left;
                  }
                  if (i >= startLine && i < endLine) {
                    boxEnd = isJustify && !this.isEndOfWrapping(i) ? this.width : this.getLineWidth(i) || 5;
                  } else if (i === endLine) {
                    if (endChar === 0) {
                      boxEnd = this.__charBounds[endLine][endChar].left;
                    } else {
                      var charSpacing = this._getWidthOfCharSpacing();
                      boxEnd = this.__charBounds[endLine][endChar - 1].left + this.__charBounds[endLine][endChar - 1].width - charSpacing;
                    }
                  }
                  realLineHeight = lineHeight2;
                  if (this.lineHeight < 1 || i === endLine && this.lineHeight > 1) {
                    lineHeight2 /= this.lineHeight;
                  }
                  var drawStart = boundaries.left + lineOffset + boxStart, drawWidth = boxEnd - boxStart, drawHeight = lineHeight2, extraTop = 0;
                  if (this.inCompositionMode) {
                    ctx.fillStyle = this.compositionColor || "black";
                    drawHeight = 1;
                    extraTop = lineHeight2;
                  } else {
                    ctx.fillStyle = this.selectionColor;
                  }
                  if (this.direction === "rtl") {
                    drawStart = this.width - drawStart - drawWidth;
                  }
                  ctx.fillRect(
                    drawStart,
                    boundaries.top + boundaries.topOffset + extraTop,
                    drawWidth,
                    drawHeight
                  );
                  boundaries.topOffset += realLineHeight;
                }
              },
              getCurrentCharFontSize: function() {
                var cp = this._getCurrentCharIndex();
                return this.getValueOfPropertyAt(cp.l, cp.c, "fontSize");
              },
              getCurrentCharColor: function() {
                var cp = this._getCurrentCharIndex();
                return this.getValueOfPropertyAt(cp.l, cp.c, "fill");
              },
              _getCurrentCharIndex: function() {
                var cursorPosition = this.get2DCursorLocation(this.selectionStart, true), charIndex = cursorPosition.charIndex > 0 ? cursorPosition.charIndex - 1 : 0;
                return { l: cursorPosition.lineIndex, c: charIndex };
              }
            });
            fabric.IText.fromObject = function(object, callback) {
              parseDecoration(object);
              if (object.styles) {
                for (var i in object.styles) {
                  for (var j2 in object.styles[i]) {
                    parseDecoration(object.styles[i][j2]);
                  }
                }
              }
              fabric.Object._fromObject("IText", object, callback, "text");
            };
          })();
          (function() {
            var clone2 = fabric.util.object.clone;
            fabric.util.object.extend(fabric.IText.prototype, {
              initBehavior: function() {
                this.initAddedHandler();
                this.initRemovedHandler();
                this.initCursorSelectionHandlers();
                this.initDoubleClickSimulation();
                this.mouseMoveHandler = this.mouseMoveHandler.bind(this);
              },
              onDeselect: function() {
                this.isEditing && this.exitEditing();
                this.selected = false;
              },
              initAddedHandler: function() {
                var _this = this;
                this.on("added", function() {
                  var canvas = _this.canvas;
                  if (canvas) {
                    if (!canvas._hasITextHandlers) {
                      canvas._hasITextHandlers = true;
                      _this._initCanvasHandlers(canvas);
                    }
                    canvas._iTextInstances = canvas._iTextInstances || [];
                    canvas._iTextInstances.push(_this);
                  }
                });
              },
              initRemovedHandler: function() {
                var _this = this;
                this.on("removed", function() {
                  var canvas = _this.canvas;
                  if (canvas) {
                    canvas._iTextInstances = canvas._iTextInstances || [];
                    fabric.util.removeFromArray(canvas._iTextInstances, _this);
                    if (canvas._iTextInstances.length === 0) {
                      canvas._hasITextHandlers = false;
                      _this._removeCanvasHandlers(canvas);
                    }
                  }
                });
              },
              _initCanvasHandlers: function(canvas) {
                canvas._mouseUpITextHandler = function() {
                  if (canvas._iTextInstances) {
                    canvas._iTextInstances.forEach(function(obj) {
                      obj.__isMousedown = false;
                    });
                  }
                };
                canvas.on("mouse:up", canvas._mouseUpITextHandler);
              },
              _removeCanvasHandlers: function(canvas) {
                canvas.off("mouse:up", canvas._mouseUpITextHandler);
              },
              _tick: function() {
                this._currentTickState = this._animateCursor(this, 1, this.cursorDuration, "_onTickComplete");
              },
              _animateCursor: function(obj, targetOpacity, duration2, completeMethod) {
                var tickState;
                tickState = {
                  isAborted: false,
                  abort: function() {
                    this.isAborted = true;
                  }
                };
                obj.animate("_currentCursorOpacity", targetOpacity, {
                  duration: duration2,
                  onComplete: function() {
                    if (!tickState.isAborted) {
                      obj[completeMethod]();
                    }
                  },
                  onChange: function() {
                    if (obj.canvas && obj.selectionStart === obj.selectionEnd) {
                      obj.renderCursorOrSelection();
                    }
                  },
                  abort: function() {
                    return tickState.isAborted;
                  }
                });
                return tickState;
              },
              _onTickComplete: function() {
                var _this = this;
                if (this._cursorTimeout1) {
                  clearTimeout(this._cursorTimeout1);
                }
                this._cursorTimeout1 = setTimeout(function() {
                  _this._currentTickCompleteState = _this._animateCursor(_this, 0, this.cursorDuration / 2, "_tick");
                }, 100);
              },
              initDelayedCursor: function(restart) {
                var _this = this, delay = restart ? 0 : this.cursorDelay;
                this.abortCursorAnimation();
                this._currentCursorOpacity = 1;
                this._cursorTimeout2 = setTimeout(function() {
                  _this._tick();
                }, delay);
              },
              abortCursorAnimation: function() {
                var shouldClear = this._currentTickState || this._currentTickCompleteState, canvas = this.canvas;
                this._currentTickState && this._currentTickState.abort();
                this._currentTickCompleteState && this._currentTickCompleteState.abort();
                clearTimeout(this._cursorTimeout1);
                clearTimeout(this._cursorTimeout2);
                this._currentCursorOpacity = 0;
                if (shouldClear && canvas) {
                  canvas.clearContext(canvas.contextTop || canvas.contextContainer);
                }
              },
              selectAll: function() {
                this.selectionStart = 0;
                this.selectionEnd = this._text.length;
                this._fireSelectionChanged();
                this._updateTextarea();
                return this;
              },
              getSelectedText: function() {
                return this._text.slice(this.selectionStart, this.selectionEnd).join("");
              },
              findWordBoundaryLeft: function(startFrom) {
                var offset = 0, index2 = startFrom - 1;
                if (this._reSpace.test(this._text[index2])) {
                  while (this._reSpace.test(this._text[index2])) {
                    offset++;
                    index2--;
                  }
                }
                while (/\S/.test(this._text[index2]) && index2 > -1) {
                  offset++;
                  index2--;
                }
                return startFrom - offset;
              },
              findWordBoundaryRight: function(startFrom) {
                var offset = 0, index2 = startFrom;
                if (this._reSpace.test(this._text[index2])) {
                  while (this._reSpace.test(this._text[index2])) {
                    offset++;
                    index2++;
                  }
                }
                while (/\S/.test(this._text[index2]) && index2 < this._text.length) {
                  offset++;
                  index2++;
                }
                return startFrom + offset;
              },
              findLineBoundaryLeft: function(startFrom) {
                var offset = 0, index2 = startFrom - 1;
                while (!/\n/.test(this._text[index2]) && index2 > -1) {
                  offset++;
                  index2--;
                }
                return startFrom - offset;
              },
              findLineBoundaryRight: function(startFrom) {
                var offset = 0, index2 = startFrom;
                while (!/\n/.test(this._text[index2]) && index2 < this._text.length) {
                  offset++;
                  index2++;
                }
                return startFrom + offset;
              },
              searchWordBoundary: function(selectionStart, direction2) {
                var text = this._text, index2 = this._reSpace.test(text[selectionStart]) ? selectionStart - 1 : selectionStart, _char = text[index2], reNonWord = fabric.reNonWord;
                while (!reNonWord.test(_char) && index2 > 0 && index2 < text.length) {
                  index2 += direction2;
                  _char = text[index2];
                }
                if (reNonWord.test(_char)) {
                  index2 += direction2 === 1 ? 0 : 1;
                }
                return index2;
              },
              selectWord: function(selectionStart) {
                selectionStart = selectionStart || this.selectionStart;
                var newSelectionStart = this.searchWordBoundary(selectionStart, -1), newSelectionEnd = this.searchWordBoundary(selectionStart, 1);
                this.selectionStart = newSelectionStart;
                this.selectionEnd = newSelectionEnd;
                this._fireSelectionChanged();
                this._updateTextarea();
                this.renderCursorOrSelection();
              },
              selectLine: function(selectionStart) {
                selectionStart = selectionStart || this.selectionStart;
                var newSelectionStart = this.findLineBoundaryLeft(selectionStart), newSelectionEnd = this.findLineBoundaryRight(selectionStart);
                this.selectionStart = newSelectionStart;
                this.selectionEnd = newSelectionEnd;
                this._fireSelectionChanged();
                this._updateTextarea();
                return this;
              },
              enterEditing: function(e2) {
                if (this.isEditing || !this.editable) {
                  return;
                }
                if (this.canvas) {
                  this.canvas.calcOffset();
                  this.exitEditingOnOthers(this.canvas);
                }
                this.isEditing = true;
                this.initHiddenTextarea(e2);
                this.hiddenTextarea.focus();
                this.hiddenTextarea.value = this.text;
                this._updateTextarea();
                this._saveEditingProps();
                this._setEditingProps();
                this._textBeforeEdit = this.text;
                this._tick();
                this.fire("editing:entered");
                this._fireSelectionChanged();
                if (!this.canvas) {
                  return this;
                }
                this.canvas.fire("text:editing:entered", { target: this });
                this.initMouseMoveHandler();
                this.canvas.requestRenderAll();
                return this;
              },
              exitEditingOnOthers: function(canvas) {
                if (canvas._iTextInstances) {
                  canvas._iTextInstances.forEach(function(obj) {
                    obj.selected = false;
                    if (obj.isEditing) {
                      obj.exitEditing();
                    }
                  });
                }
              },
              initMouseMoveHandler: function() {
                this.canvas.on("mouse:move", this.mouseMoveHandler);
              },
              mouseMoveHandler: function(options) {
                if (!this.__isMousedown || !this.isEditing) {
                  return;
                }
                var newSelectionStart = this.getSelectionStartFromPointer(options.e), currentStart = this.selectionStart, currentEnd = this.selectionEnd;
                if ((newSelectionStart !== this.__selectionStartOnMouseDown || currentStart === currentEnd) && (currentStart === newSelectionStart || currentEnd === newSelectionStart)) {
                  return;
                }
                if (newSelectionStart > this.__selectionStartOnMouseDown) {
                  this.selectionStart = this.__selectionStartOnMouseDown;
                  this.selectionEnd = newSelectionStart;
                } else {
                  this.selectionStart = newSelectionStart;
                  this.selectionEnd = this.__selectionStartOnMouseDown;
                }
                if (this.selectionStart !== currentStart || this.selectionEnd !== currentEnd) {
                  this.restartCursorIfNeeded();
                  this._fireSelectionChanged();
                  this._updateTextarea();
                  this.renderCursorOrSelection();
                }
              },
              _setEditingProps: function() {
                this.hoverCursor = "text";
                if (this.canvas) {
                  this.canvas.defaultCursor = this.canvas.moveCursor = "text";
                }
                this.borderColor = this.editingBorderColor;
                this.hasControls = this.selectable = false;
                this.lockMovementX = this.lockMovementY = true;
              },
              fromStringToGraphemeSelection: function(start, end, text) {
                var smallerTextStart = text.slice(0, start), graphemeStart = fabric.util.string.graphemeSplit(smallerTextStart).length;
                if (start === end) {
                  return { selectionStart: graphemeStart, selectionEnd: graphemeStart };
                }
                var smallerTextEnd = text.slice(start, end), graphemeEnd = fabric.util.string.graphemeSplit(smallerTextEnd).length;
                return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };
              },
              fromGraphemeToStringSelection: function(start, end, _text) {
                var smallerTextStart = _text.slice(0, start), graphemeStart = smallerTextStart.join("").length;
                if (start === end) {
                  return { selectionStart: graphemeStart, selectionEnd: graphemeStart };
                }
                var smallerTextEnd = _text.slice(start, end), graphemeEnd = smallerTextEnd.join("").length;
                return { selectionStart: graphemeStart, selectionEnd: graphemeStart + graphemeEnd };
              },
              _updateTextarea: function() {
                this.cursorOffsetCache = {};
                if (!this.hiddenTextarea) {
                  return;
                }
                if (!this.inCompositionMode) {
                  var newSelection = this.fromGraphemeToStringSelection(this.selectionStart, this.selectionEnd, this._text);
                  this.hiddenTextarea.selectionStart = newSelection.selectionStart;
                  this.hiddenTextarea.selectionEnd = newSelection.selectionEnd;
                }
                this.updateTextareaPosition();
              },
              updateFromTextArea: function() {
                if (!this.hiddenTextarea) {
                  return;
                }
                this.cursorOffsetCache = {};
                this.text = this.hiddenTextarea.value;
                if (this._shouldClearDimensionCache()) {
                  this.initDimensions();
                  this.setCoords();
                }
                var newSelection = this.fromStringToGraphemeSelection(
                  this.hiddenTextarea.selectionStart,
                  this.hiddenTextarea.selectionEnd,
                  this.hiddenTextarea.value
                );
                this.selectionEnd = this.selectionStart = newSelection.selectionEnd;
                if (!this.inCompositionMode) {
                  this.selectionStart = newSelection.selectionStart;
                }
                this.updateTextareaPosition();
              },
              updateTextareaPosition: function() {
                if (this.selectionStart === this.selectionEnd) {
                  var style = this._calcTextareaPosition();
                  this.hiddenTextarea.style.left = style.left;
                  this.hiddenTextarea.style.top = style.top;
                }
              },
              _calcTextareaPosition: function() {
                if (!this.canvas) {
                  return { x: 1, y: 1 };
                }
                var desiredPosition = this.inCompositionMode ? this.compositionStart : this.selectionStart, boundaries = this._getCursorBoundaries(desiredPosition), cursorLocation = this.get2DCursorLocation(desiredPosition), lineIndex = cursorLocation.lineIndex, charIndex = cursorLocation.charIndex, charHeight = this.getValueOfPropertyAt(lineIndex, charIndex, "fontSize") * this.lineHeight, leftOffset = boundaries.leftOffset, m = this.calcTransformMatrix(), p = {
                  x: boundaries.left + leftOffset,
                  y: boundaries.top + boundaries.topOffset + charHeight
                }, retinaScaling = this.canvas.getRetinaScaling(), upperCanvas = this.canvas.upperCanvasEl, upperCanvasWidth = upperCanvas.width / retinaScaling, upperCanvasHeight = upperCanvas.height / retinaScaling, maxWidth = upperCanvasWidth - charHeight, maxHeight = upperCanvasHeight - charHeight, scaleX = upperCanvas.clientWidth / upperCanvasWidth, scaleY = upperCanvas.clientHeight / upperCanvasHeight;
                p = fabric.util.transformPoint(p, m);
                p = fabric.util.transformPoint(p, this.canvas.viewportTransform);
                p.x *= scaleX;
                p.y *= scaleY;
                if (p.x < 0) {
                  p.x = 0;
                }
                if (p.x > maxWidth) {
                  p.x = maxWidth;
                }
                if (p.y < 0) {
                  p.y = 0;
                }
                if (p.y > maxHeight) {
                  p.y = maxHeight;
                }
                p.x += this.canvas._offset.left;
                p.y += this.canvas._offset.top;
                return { left: p.x + "px", top: p.y + "px", fontSize: charHeight + "px", charHeight };
              },
              _saveEditingProps: function() {
                this._savedProps = {
                  hasControls: this.hasControls,
                  borderColor: this.borderColor,
                  lockMovementX: this.lockMovementX,
                  lockMovementY: this.lockMovementY,
                  hoverCursor: this.hoverCursor,
                  selectable: this.selectable,
                  defaultCursor: this.canvas && this.canvas.defaultCursor,
                  moveCursor: this.canvas && this.canvas.moveCursor
                };
              },
              _restoreEditingProps: function() {
                if (!this._savedProps) {
                  return;
                }
                this.hoverCursor = this._savedProps.hoverCursor;
                this.hasControls = this._savedProps.hasControls;
                this.borderColor = this._savedProps.borderColor;
                this.selectable = this._savedProps.selectable;
                this.lockMovementX = this._savedProps.lockMovementX;
                this.lockMovementY = this._savedProps.lockMovementY;
                if (this.canvas) {
                  this.canvas.defaultCursor = this._savedProps.defaultCursor;
                  this.canvas.moveCursor = this._savedProps.moveCursor;
                }
              },
              exitEditing: function() {
                var isTextChanged = this._textBeforeEdit !== this.text;
                var hiddenTextarea = this.hiddenTextarea;
                this.selected = false;
                this.isEditing = false;
                this.selectionEnd = this.selectionStart;
                if (hiddenTextarea) {
                  hiddenTextarea.blur && hiddenTextarea.blur();
                  hiddenTextarea.parentNode && hiddenTextarea.parentNode.removeChild(hiddenTextarea);
                }
                this.hiddenTextarea = null;
                this.abortCursorAnimation();
                this._restoreEditingProps();
                this._currentCursorOpacity = 0;
                if (this._shouldClearDimensionCache()) {
                  this.initDimensions();
                  this.setCoords();
                }
                this.fire("editing:exited");
                isTextChanged && this.fire("modified");
                if (this.canvas) {
                  this.canvas.off("mouse:move", this.mouseMoveHandler);
                  this.canvas.fire("text:editing:exited", { target: this });
                  isTextChanged && this.canvas.fire("object:modified", { target: this });
                }
                return this;
              },
              _removeExtraneousStyles: function() {
                for (var prop in this.styles) {
                  if (!this._textLines[prop]) {
                    delete this.styles[prop];
                  }
                }
              },
              removeStyleFromTo: function(start, end) {
                var cursorStart = this.get2DCursorLocation(start, true), cursorEnd = this.get2DCursorLocation(end, true), lineStart = cursorStart.lineIndex, charStart = cursorStart.charIndex, lineEnd = cursorEnd.lineIndex, charEnd = cursorEnd.charIndex, i, styleObj;
                if (lineStart !== lineEnd) {
                  if (this.styles[lineStart]) {
                    for (i = charStart; i < this._unwrappedTextLines[lineStart].length; i++) {
                      delete this.styles[lineStart][i];
                    }
                  }
                  if (this.styles[lineEnd]) {
                    for (i = charEnd; i < this._unwrappedTextLines[lineEnd].length; i++) {
                      styleObj = this.styles[lineEnd][i];
                      if (styleObj) {
                        this.styles[lineStart] || (this.styles[lineStart] = {});
                        this.styles[lineStart][charStart + i - charEnd] = styleObj;
                      }
                    }
                  }
                  for (i = lineStart + 1; i <= lineEnd; i++) {
                    delete this.styles[i];
                  }
                  this.shiftLineStyles(lineEnd, lineStart - lineEnd);
                } else {
                  if (this.styles[lineStart]) {
                    styleObj = this.styles[lineStart];
                    var diff2 = charEnd - charStart, numericChar, _char;
                    for (i = charStart; i < charEnd; i++) {
                      delete styleObj[i];
                    }
                    for (_char in this.styles[lineStart]) {
                      numericChar = parseInt(_char, 10);
                      if (numericChar >= charEnd) {
                        styleObj[numericChar - diff2] = styleObj[_char];
                        delete styleObj[_char];
                      }
                    }
                  }
                }
              },
              shiftLineStyles: function(lineIndex, offset) {
                var clonedStyles = clone2(this.styles);
                for (var line in this.styles) {
                  var numericLine = parseInt(line, 10);
                  if (numericLine > lineIndex) {
                    this.styles[numericLine + offset] = clonedStyles[numericLine];
                    if (!clonedStyles[numericLine - offset]) {
                      delete this.styles[numericLine];
                    }
                  }
                }
              },
              restartCursorIfNeeded: function() {
                if (!this._currentTickState || this._currentTickState.isAborted || !this._currentTickCompleteState || this._currentTickCompleteState.isAborted) {
                  this.initDelayedCursor();
                }
              },
              insertNewlineStyleObject: function(lineIndex, charIndex, qty, copiedStyle) {
                var currentCharStyle, newLineStyles = {}, somethingAdded = false, isEndOfLine = this._unwrappedTextLines[lineIndex].length === charIndex;
                qty || (qty = 1);
                this.shiftLineStyles(lineIndex, qty);
                if (this.styles[lineIndex]) {
                  currentCharStyle = this.styles[lineIndex][charIndex === 0 ? charIndex : charIndex - 1];
                }
                for (var index2 in this.styles[lineIndex]) {
                  var numIndex = parseInt(index2, 10);
                  if (numIndex >= charIndex) {
                    somethingAdded = true;
                    newLineStyles[numIndex - charIndex] = this.styles[lineIndex][index2];
                    if (!(isEndOfLine && charIndex === 0)) {
                      delete this.styles[lineIndex][index2];
                    }
                  }
                }
                var styleCarriedOver = false;
                if (somethingAdded && !isEndOfLine) {
                  this.styles[lineIndex + qty] = newLineStyles;
                  styleCarriedOver = true;
                }
                if (styleCarriedOver) {
                  qty--;
                }
                while (qty > 0) {
                  if (copiedStyle && copiedStyle[qty - 1]) {
                    this.styles[lineIndex + qty] = { 0: clone2(copiedStyle[qty - 1]) };
                  } else if (currentCharStyle) {
                    this.styles[lineIndex + qty] = { 0: clone2(currentCharStyle) };
                  } else {
                    delete this.styles[lineIndex + qty];
                  }
                  qty--;
                }
                this._forceClearCache = true;
              },
              insertCharStyleObject: function(lineIndex, charIndex, quantity, copiedStyle) {
                if (!this.styles) {
                  this.styles = {};
                }
                var currentLineStyles = this.styles[lineIndex], currentLineStylesCloned = currentLineStyles ? clone2(currentLineStyles) : {};
                quantity || (quantity = 1);
                for (var index2 in currentLineStylesCloned) {
                  var numericIndex = parseInt(index2, 10);
                  if (numericIndex >= charIndex) {
                    currentLineStyles[numericIndex + quantity] = currentLineStylesCloned[numericIndex];
                    if (!currentLineStylesCloned[numericIndex - quantity]) {
                      delete currentLineStyles[numericIndex];
                    }
                  }
                }
                this._forceClearCache = true;
                if (copiedStyle) {
                  while (quantity--) {
                    if (!Object.keys(copiedStyle[quantity]).length) {
                      continue;
                    }
                    if (!this.styles[lineIndex]) {
                      this.styles[lineIndex] = {};
                    }
                    this.styles[lineIndex][charIndex + quantity] = clone2(copiedStyle[quantity]);
                  }
                  return;
                }
                if (!currentLineStyles) {
                  return;
                }
                var newStyle = currentLineStyles[charIndex ? charIndex - 1 : 1];
                while (newStyle && quantity--) {
                  this.styles[lineIndex][charIndex + quantity] = clone2(newStyle);
                }
              },
              insertNewStyleBlock: function(insertedText, start, copiedStyle) {
                var cursorLoc = this.get2DCursorLocation(start, true), addedLines = [0], linesLength = 0;
                for (var i = 0; i < insertedText.length; i++) {
                  if (insertedText[i] === "\n") {
                    linesLength++;
                    addedLines[linesLength] = 0;
                  } else {
                    addedLines[linesLength]++;
                  }
                }
                if (addedLines[0] > 0) {
                  this.insertCharStyleObject(cursorLoc.lineIndex, cursorLoc.charIndex, addedLines[0], copiedStyle);
                  copiedStyle = copiedStyle && copiedStyle.slice(addedLines[0] + 1);
                }
                linesLength && this.insertNewlineStyleObject(
                  cursorLoc.lineIndex,
                  cursorLoc.charIndex + addedLines[0],
                  linesLength
                );
                for (var i = 1; i < linesLength; i++) {
                  if (addedLines[i] > 0) {
                    this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);
                  } else if (copiedStyle) {
                    this.styles[cursorLoc.lineIndex + i][0] = copiedStyle[0];
                  }
                  copiedStyle = copiedStyle && copiedStyle.slice(addedLines[i] + 1);
                }
                if (addedLines[i] > 0) {
                  this.insertCharStyleObject(cursorLoc.lineIndex + i, 0, addedLines[i], copiedStyle);
                }
              },
              setSelectionStartEndWithShift: function(start, end, newSelection) {
                if (newSelection <= start) {
                  if (end === start) {
                    this._selectionDirection = "left";
                  } else if (this._selectionDirection === "right") {
                    this._selectionDirection = "left";
                    this.selectionEnd = start;
                  }
                  this.selectionStart = newSelection;
                } else if (newSelection > start && newSelection < end) {
                  if (this._selectionDirection === "right") {
                    this.selectionEnd = newSelection;
                  } else {
                    this.selectionStart = newSelection;
                  }
                } else {
                  if (end === start) {
                    this._selectionDirection = "right";
                  } else if (this._selectionDirection === "left") {
                    this._selectionDirection = "right";
                    this.selectionStart = end;
                  }
                  this.selectionEnd = newSelection;
                }
              },
              setSelectionInBoundaries: function() {
                var length = this.text.length;
                if (this.selectionStart > length) {
                  this.selectionStart = length;
                } else if (this.selectionStart < 0) {
                  this.selectionStart = 0;
                }
                if (this.selectionEnd > length) {
                  this.selectionEnd = length;
                } else if (this.selectionEnd < 0) {
                  this.selectionEnd = 0;
                }
              }
            });
          })();
          fabric.util.object.extend(fabric.IText.prototype, {
            initDoubleClickSimulation: function() {
              this.__lastClickTime = +new Date();
              this.__lastLastClickTime = +new Date();
              this.__lastPointer = {};
              this.on("mousedown", this.onMouseDown);
            },
            onMouseDown: function(options) {
              if (!this.canvas) {
                return;
              }
              this.__newClickTime = +new Date();
              var newPointer = options.pointer;
              if (this.isTripleClick(newPointer)) {
                this.fire("tripleclick", options);
                this._stopEvent(options.e);
              }
              this.__lastLastClickTime = this.__lastClickTime;
              this.__lastClickTime = this.__newClickTime;
              this.__lastPointer = newPointer;
              this.__lastIsEditing = this.isEditing;
              this.__lastSelected = this.selected;
            },
            isTripleClick: function(newPointer) {
              return this.__newClickTime - this.__lastClickTime < 500 && this.__lastClickTime - this.__lastLastClickTime < 500 && this.__lastPointer.x === newPointer.x && this.__lastPointer.y === newPointer.y;
            },
            _stopEvent: function(e2) {
              e2.preventDefault && e2.preventDefault();
              e2.stopPropagation && e2.stopPropagation();
            },
            initCursorSelectionHandlers: function() {
              this.initMousedownHandler();
              this.initMouseupHandler();
              this.initClicks();
            },
            doubleClickHandler: function(options) {
              if (!this.isEditing) {
                return;
              }
              this.selectWord(this.getSelectionStartFromPointer(options.e));
            },
            tripleClickHandler: function(options) {
              if (!this.isEditing) {
                return;
              }
              this.selectLine(this.getSelectionStartFromPointer(options.e));
            },
            initClicks: function() {
              this.on("mousedblclick", this.doubleClickHandler);
              this.on("tripleclick", this.tripleClickHandler);
            },
            _mouseDownHandler: function(options) {
              if (!this.canvas || !this.editable || options.e.button && options.e.button !== 1) {
                return;
              }
              this.__isMousedown = true;
              if (this.selected) {
                this.inCompositionMode = false;
                this.setCursorByClick(options.e);
              }
              if (this.isEditing) {
                this.__selectionStartOnMouseDown = this.selectionStart;
                if (this.selectionStart === this.selectionEnd) {
                  this.abortCursorAnimation();
                }
                this.renderCursorOrSelection();
              }
            },
            _mouseDownHandlerBefore: function(options) {
              if (!this.canvas || !this.editable || options.e.button && options.e.button !== 1) {
                return;
              }
              this.selected = this === this.canvas._activeObject;
            },
            initMousedownHandler: function() {
              this.on("mousedown", this._mouseDownHandler);
              this.on("mousedown:before", this._mouseDownHandlerBefore);
            },
            initMouseupHandler: function() {
              this.on("mouseup", this.mouseUpHandler);
            },
            mouseUpHandler: function(options) {
              this.__isMousedown = false;
              if (!this.editable || this.group || options.transform && options.transform.actionPerformed || options.e.button && options.e.button !== 1) {
                return;
              }
              if (this.canvas) {
                var currentActive = this.canvas._activeObject;
                if (currentActive && currentActive !== this) {
                  return;
                }
              }
              if (this.__lastSelected && !this.__corner) {
                this.selected = false;
                this.__lastSelected = false;
                this.enterEditing(options.e);
                if (this.selectionStart === this.selectionEnd) {
                  this.initDelayedCursor(true);
                } else {
                  this.renderCursorOrSelection();
                }
              } else {
                this.selected = true;
              }
            },
            setCursorByClick: function(e2) {
              var newSelection = this.getSelectionStartFromPointer(e2), start = this.selectionStart, end = this.selectionEnd;
              if (e2.shiftKey) {
                this.setSelectionStartEndWithShift(start, end, newSelection);
              } else {
                this.selectionStart = newSelection;
                this.selectionEnd = newSelection;
              }
              if (this.isEditing) {
                this._fireSelectionChanged();
                this._updateTextarea();
              }
            },
            getSelectionStartFromPointer: function(e2) {
              var mouseOffset = this.getLocalPointer(e2), prevWidth = 0, width = 0, height = 0, charIndex = 0, lineIndex = 0, lineLeftOffset, line;
              for (var i = 0, len = this._textLines.length; i < len; i++) {
                if (height <= mouseOffset.y) {
                  height += this.getHeightOfLine(i) * this.scaleY;
                  lineIndex = i;
                  if (i > 0) {
                    charIndex += this._textLines[i - 1].length + this.missingNewlineOffset(i - 1);
                  }
                } else {
                  break;
                }
              }
              lineLeftOffset = this._getLineLeftOffset(lineIndex);
              width = lineLeftOffset * this.scaleX;
              line = this._textLines[lineIndex];
              if (this.direction === "rtl") {
                mouseOffset.x = this.width * this.scaleX - mouseOffset.x + width;
              }
              for (var j2 = 0, jlen = line.length; j2 < jlen; j2++) {
                prevWidth = width;
                width += this.__charBounds[lineIndex][j2].kernedWidth * this.scaleX;
                if (width <= mouseOffset.x) {
                  charIndex++;
                } else {
                  break;
                }
              }
              return this._getNewSelectionStartFromOffset(mouseOffset, prevWidth, width, charIndex, jlen);
            },
            _getNewSelectionStartFromOffset: function(mouseOffset, prevWidth, width, index2, jlen) {
              var distanceBtwLastCharAndCursor = mouseOffset.x - prevWidth, distanceBtwNextCharAndCursor = width - mouseOffset.x, offset = distanceBtwNextCharAndCursor > distanceBtwLastCharAndCursor || distanceBtwNextCharAndCursor < 0 ? 0 : 1, newSelectionStart = index2 + offset;
              if (this.flipX) {
                newSelectionStart = jlen - newSelectionStart;
              }
              if (newSelectionStart > this._text.length) {
                newSelectionStart = this._text.length;
              }
              return newSelectionStart;
            }
          });
          fabric.util.object.extend(fabric.IText.prototype, {
            initHiddenTextarea: function() {
              this.hiddenTextarea = fabric.document.createElement("textarea");
              this.hiddenTextarea.setAttribute("autocapitalize", "off");
              this.hiddenTextarea.setAttribute("autocorrect", "off");
              this.hiddenTextarea.setAttribute("autocomplete", "off");
              this.hiddenTextarea.setAttribute("spellcheck", "false");
              this.hiddenTextarea.setAttribute("data-fabric-hiddentextarea", "");
              this.hiddenTextarea.setAttribute("wrap", "off");
              var style = this._calcTextareaPosition();
              this.hiddenTextarea.style.cssText = "position: absolute; top: " + style.top + "; left: " + style.left + "; z-index: -999; opacity: 0; width: 1px; height: 1px; font-size: 1px; padding\uFF70top: " + style.fontSize + ";";
              if (this.hiddenTextareaContainer) {
                this.hiddenTextareaContainer.appendChild(this.hiddenTextarea);
              } else {
                fabric.document.body.appendChild(this.hiddenTextarea);
              }
              fabric.util.addListener(this.hiddenTextarea, "keydown", this.onKeyDown.bind(this));
              fabric.util.addListener(this.hiddenTextarea, "keyup", this.onKeyUp.bind(this));
              fabric.util.addListener(this.hiddenTextarea, "input", this.onInput.bind(this));
              fabric.util.addListener(this.hiddenTextarea, "copy", this.copy.bind(this));
              fabric.util.addListener(this.hiddenTextarea, "cut", this.copy.bind(this));
              fabric.util.addListener(this.hiddenTextarea, "paste", this.paste.bind(this));
              fabric.util.addListener(this.hiddenTextarea, "compositionstart", this.onCompositionStart.bind(this));
              fabric.util.addListener(this.hiddenTextarea, "compositionupdate", this.onCompositionUpdate.bind(this));
              fabric.util.addListener(this.hiddenTextarea, "compositionend", this.onCompositionEnd.bind(this));
              if (!this._clickHandlerInitialized && this.canvas) {
                fabric.util.addListener(this.canvas.upperCanvasEl, "click", this.onClick.bind(this));
                this._clickHandlerInitialized = true;
              }
            },
            keysMap: {
              9: "exitEditing",
              27: "exitEditing",
              33: "moveCursorUp",
              34: "moveCursorDown",
              35: "moveCursorRight",
              36: "moveCursorLeft",
              37: "moveCursorLeft",
              38: "moveCursorUp",
              39: "moveCursorRight",
              40: "moveCursorDown"
            },
            keysMapRtl: {
              9: "exitEditing",
              27: "exitEditing",
              33: "moveCursorUp",
              34: "moveCursorDown",
              35: "moveCursorLeft",
              36: "moveCursorRight",
              37: "moveCursorRight",
              38: "moveCursorUp",
              39: "moveCursorLeft",
              40: "moveCursorDown"
            },
            ctrlKeysMapUp: {
              67: "copy",
              88: "cut"
            },
            ctrlKeysMapDown: {
              65: "selectAll"
            },
            onClick: function() {
              this.hiddenTextarea && this.hiddenTextarea.focus();
            },
            onKeyDown: function(e2) {
              if (!this.isEditing) {
                return;
              }
              var keyMap = this.direction === "rtl" ? this.keysMapRtl : this.keysMap;
              if (e2.keyCode in keyMap) {
                this[keyMap[e2.keyCode]](e2);
              } else if (e2.keyCode in this.ctrlKeysMapDown && (e2.ctrlKey || e2.metaKey)) {
                this[this.ctrlKeysMapDown[e2.keyCode]](e2);
              } else {
                return;
              }
              e2.stopImmediatePropagation();
              e2.preventDefault();
              if (e2.keyCode >= 33 && e2.keyCode <= 40) {
                this.inCompositionMode = false;
                this.clearContextTop();
                this.renderCursorOrSelection();
              } else {
                this.canvas && this.canvas.requestRenderAll();
              }
            },
            onKeyUp: function(e2) {
              if (!this.isEditing || this._copyDone || this.inCompositionMode) {
                this._copyDone = false;
                return;
              }
              if (e2.keyCode in this.ctrlKeysMapUp && (e2.ctrlKey || e2.metaKey)) {
                this[this.ctrlKeysMapUp[e2.keyCode]](e2);
              } else {
                return;
              }
              e2.stopImmediatePropagation();
              e2.preventDefault();
              this.canvas && this.canvas.requestRenderAll();
            },
            onInput: function(e2) {
              var fromPaste = this.fromPaste;
              this.fromPaste = false;
              e2 && e2.stopPropagation();
              if (!this.isEditing) {
                return;
              }
              var nextText = this._splitTextIntoLines(this.hiddenTextarea.value).graphemeText, charCount = this._text.length, nextCharCount = nextText.length, removedText, insertedText, charDiff = nextCharCount - charCount, selectionStart = this.selectionStart, selectionEnd = this.selectionEnd, selection = selectionStart !== selectionEnd, copiedStyle, removeFrom, removeTo;
              if (this.hiddenTextarea.value === "") {
                this.styles = {};
                this.updateFromTextArea();
                this.fire("changed");
                if (this.canvas) {
                  this.canvas.fire("text:changed", { target: this });
                  this.canvas.requestRenderAll();
                }
                return;
              }
              var textareaSelection = this.fromStringToGraphemeSelection(
                this.hiddenTextarea.selectionStart,
                this.hiddenTextarea.selectionEnd,
                this.hiddenTextarea.value
              );
              var backDelete = selectionStart > textareaSelection.selectionStart;
              if (selection) {
                removedText = this._text.slice(selectionStart, selectionEnd);
                charDiff += selectionEnd - selectionStart;
              } else if (nextCharCount < charCount) {
                if (backDelete) {
                  removedText = this._text.slice(selectionEnd + charDiff, selectionEnd);
                } else {
                  removedText = this._text.slice(selectionStart, selectionStart - charDiff);
                }
              }
              insertedText = nextText.slice(textareaSelection.selectionEnd - charDiff, textareaSelection.selectionEnd);
              if (removedText && removedText.length) {
                if (insertedText.length) {
                  copiedStyle = this.getSelectionStyles(selectionStart, selectionStart + 1, false);
                  copiedStyle = insertedText.map(function() {
                    return copiedStyle[0];
                  });
                }
                if (selection) {
                  removeFrom = selectionStart;
                  removeTo = selectionEnd;
                } else if (backDelete) {
                  removeFrom = selectionEnd - removedText.length;
                  removeTo = selectionEnd;
                } else {
                  removeFrom = selectionEnd;
                  removeTo = selectionEnd + removedText.length;
                }
                this.removeStyleFromTo(removeFrom, removeTo);
              }
              if (insertedText.length) {
                if (fromPaste && insertedText.join("") === fabric.copiedText && !fabric.disableStyleCopyPaste) {
                  copiedStyle = fabric.copiedTextStyle;
                }
                this.insertNewStyleBlock(insertedText, selectionStart, copiedStyle);
              }
              this.updateFromTextArea();
              this.fire("changed");
              if (this.canvas) {
                this.canvas.fire("text:changed", { target: this });
                this.canvas.requestRenderAll();
              }
            },
            onCompositionStart: function() {
              this.inCompositionMode = true;
            },
            onCompositionEnd: function() {
              this.inCompositionMode = false;
            },
            onCompositionUpdate: function(e2) {
              this.compositionStart = e2.target.selectionStart;
              this.compositionEnd = e2.target.selectionEnd;
              this.updateTextareaPosition();
            },
            copy: function() {
              if (this.selectionStart === this.selectionEnd) {
                return;
              }
              fabric.copiedText = this.getSelectedText();
              if (!fabric.disableStyleCopyPaste) {
                fabric.copiedTextStyle = this.getSelectionStyles(this.selectionStart, this.selectionEnd, true);
              } else {
                fabric.copiedTextStyle = null;
              }
              this._copyDone = true;
            },
            paste: function() {
              this.fromPaste = true;
            },
            _getClipboardData: function(e2) {
              return e2 && e2.clipboardData || fabric.window.clipboardData;
            },
            _getWidthBeforeCursor: function(lineIndex, charIndex) {
              var widthBeforeCursor = this._getLineLeftOffset(lineIndex), bound;
              if (charIndex > 0) {
                bound = this.__charBounds[lineIndex][charIndex - 1];
                widthBeforeCursor += bound.left + bound.width;
              }
              return widthBeforeCursor;
            },
            getDownCursorOffset: function(e2, isRight) {
              var selectionProp = this._getSelectionForOffset(e2, isRight), cursorLocation = this.get2DCursorLocation(selectionProp), lineIndex = cursorLocation.lineIndex;
              if (lineIndex === this._textLines.length - 1 || e2.metaKey || e2.keyCode === 34) {
                return this._text.length - selectionProp;
              }
              var charIndex = cursorLocation.charIndex, widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex), indexOnOtherLine = this._getIndexOnLine(lineIndex + 1, widthBeforeCursor), textAfterCursor = this._textLines[lineIndex].slice(charIndex);
              return textAfterCursor.length + indexOnOtherLine + 1 + this.missingNewlineOffset(lineIndex);
            },
            _getSelectionForOffset: function(e2, isRight) {
              if (e2.shiftKey && this.selectionStart !== this.selectionEnd && isRight) {
                return this.selectionEnd;
              } else {
                return this.selectionStart;
              }
            },
            getUpCursorOffset: function(e2, isRight) {
              var selectionProp = this._getSelectionForOffset(e2, isRight), cursorLocation = this.get2DCursorLocation(selectionProp), lineIndex = cursorLocation.lineIndex;
              if (lineIndex === 0 || e2.metaKey || e2.keyCode === 33) {
                return -selectionProp;
              }
              var charIndex = cursorLocation.charIndex, widthBeforeCursor = this._getWidthBeforeCursor(lineIndex, charIndex), indexOnOtherLine = this._getIndexOnLine(lineIndex - 1, widthBeforeCursor), textBeforeCursor = this._textLines[lineIndex].slice(0, charIndex), missingNewlineOffset = this.missingNewlineOffset(lineIndex - 1);
              return -this._textLines[lineIndex - 1].length + indexOnOtherLine - textBeforeCursor.length + (1 - missingNewlineOffset);
            },
            _getIndexOnLine: function(lineIndex, width) {
              var line = this._textLines[lineIndex], lineLeftOffset = this._getLineLeftOffset(lineIndex), widthOfCharsOnLine = lineLeftOffset, indexOnLine = 0, charWidth, foundMatch;
              for (var j2 = 0, jlen = line.length; j2 < jlen; j2++) {
                charWidth = this.__charBounds[lineIndex][j2].width;
                widthOfCharsOnLine += charWidth;
                if (widthOfCharsOnLine > width) {
                  foundMatch = true;
                  var leftEdge = widthOfCharsOnLine - charWidth, rightEdge = widthOfCharsOnLine, offsetFromLeftEdge = Math.abs(leftEdge - width), offsetFromRightEdge = Math.abs(rightEdge - width);
                  indexOnLine = offsetFromRightEdge < offsetFromLeftEdge ? j2 : j2 - 1;
                  break;
                }
              }
              if (!foundMatch) {
                indexOnLine = line.length - 1;
              }
              return indexOnLine;
            },
            moveCursorDown: function(e2) {
              if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
                return;
              }
              this._moveCursorUpOrDown("Down", e2);
            },
            moveCursorUp: function(e2) {
              if (this.selectionStart === 0 && this.selectionEnd === 0) {
                return;
              }
              this._moveCursorUpOrDown("Up", e2);
            },
            _moveCursorUpOrDown: function(direction2, e2) {
              var action = "get" + direction2 + "CursorOffset", offset = this[action](e2, this._selectionDirection === "right");
              if (e2.shiftKey) {
                this.moveCursorWithShift(offset);
              } else {
                this.moveCursorWithoutShift(offset);
              }
              if (offset !== 0) {
                this.setSelectionInBoundaries();
                this.abortCursorAnimation();
                this._currentCursorOpacity = 1;
                this.initDelayedCursor();
                this._fireSelectionChanged();
                this._updateTextarea();
              }
            },
            moveCursorWithShift: function(offset) {
              var newSelection = this._selectionDirection === "left" ? this.selectionStart + offset : this.selectionEnd + offset;
              this.setSelectionStartEndWithShift(this.selectionStart, this.selectionEnd, newSelection);
              return offset !== 0;
            },
            moveCursorWithoutShift: function(offset) {
              if (offset < 0) {
                this.selectionStart += offset;
                this.selectionEnd = this.selectionStart;
              } else {
                this.selectionEnd += offset;
                this.selectionStart = this.selectionEnd;
              }
              return offset !== 0;
            },
            moveCursorLeft: function(e2) {
              if (this.selectionStart === 0 && this.selectionEnd === 0) {
                return;
              }
              this._moveCursorLeftOrRight("Left", e2);
            },
            _move: function(e2, prop, direction2) {
              var newValue;
              if (e2.altKey) {
                newValue = this["findWordBoundary" + direction2](this[prop]);
              } else if (e2.metaKey || e2.keyCode === 35 || e2.keyCode === 36) {
                newValue = this["findLineBoundary" + direction2](this[prop]);
              } else {
                this[prop] += direction2 === "Left" ? -1 : 1;
                return true;
              }
              if (typeof newValue !== void 0 && this[prop] !== newValue) {
                this[prop] = newValue;
                return true;
              }
            },
            _moveLeft: function(e2, prop) {
              return this._move(e2, prop, "Left");
            },
            _moveRight: function(e2, prop) {
              return this._move(e2, prop, "Right");
            },
            moveCursorLeftWithoutShift: function(e2) {
              var change = true;
              this._selectionDirection = "left";
              if (this.selectionEnd === this.selectionStart && this.selectionStart !== 0) {
                change = this._moveLeft(e2, "selectionStart");
              }
              this.selectionEnd = this.selectionStart;
              return change;
            },
            moveCursorLeftWithShift: function(e2) {
              if (this._selectionDirection === "right" && this.selectionStart !== this.selectionEnd) {
                return this._moveLeft(e2, "selectionEnd");
              } else if (this.selectionStart !== 0) {
                this._selectionDirection = "left";
                return this._moveLeft(e2, "selectionStart");
              }
            },
            moveCursorRight: function(e2) {
              if (this.selectionStart >= this._text.length && this.selectionEnd >= this._text.length) {
                return;
              }
              this._moveCursorLeftOrRight("Right", e2);
            },
            _moveCursorLeftOrRight: function(direction2, e2) {
              var actionName = "moveCursor" + direction2 + "With";
              this._currentCursorOpacity = 1;
              if (e2.shiftKey) {
                actionName += "Shift";
              } else {
                actionName += "outShift";
              }
              if (this[actionName](e2)) {
                this.abortCursorAnimation();
                this.initDelayedCursor();
                this._fireSelectionChanged();
                this._updateTextarea();
              }
            },
            moveCursorRightWithShift: function(e2) {
              if (this._selectionDirection === "left" && this.selectionStart !== this.selectionEnd) {
                return this._moveRight(e2, "selectionStart");
              } else if (this.selectionEnd !== this._text.length) {
                this._selectionDirection = "right";
                return this._moveRight(e2, "selectionEnd");
              }
            },
            moveCursorRightWithoutShift: function(e2) {
              var changed = true;
              this._selectionDirection = "right";
              if (this.selectionStart === this.selectionEnd) {
                changed = this._moveRight(e2, "selectionStart");
                this.selectionEnd = this.selectionStart;
              } else {
                this.selectionStart = this.selectionEnd;
              }
              return changed;
            },
            removeChars: function(start, end) {
              if (typeof end === "undefined") {
                end = start + 1;
              }
              this.removeStyleFromTo(start, end);
              this._text.splice(start, end - start);
              this.text = this._text.join("");
              this.set("dirty", true);
              if (this._shouldClearDimensionCache()) {
                this.initDimensions();
                this.setCoords();
              }
              this._removeExtraneousStyles();
            },
            insertChars: function(text, style, start, end) {
              if (typeof end === "undefined") {
                end = start;
              }
              if (end > start) {
                this.removeStyleFromTo(start, end);
              }
              var graphemes = fabric.util.string.graphemeSplit(text);
              this.insertNewStyleBlock(graphemes, start, style);
              this._text = [].concat(this._text.slice(0, start), graphemes, this._text.slice(end));
              this.text = this._text.join("");
              this.set("dirty", true);
              if (this._shouldClearDimensionCache()) {
                this.initDimensions();
                this.setCoords();
              }
              this._removeExtraneousStyles();
            }
          });
          (function() {
            var toFixed2 = fabric.util.toFixed, multipleSpacesRegex = /  +/g;
            fabric.util.object.extend(fabric.Text.prototype, {
              _toSVG: function() {
                var offsets = this._getSVGLeftTopOffsets(), textAndBg = this._getSVGTextAndBg(offsets.textTop, offsets.textLeft);
                return this._wrapSVGTextAndBg(textAndBg);
              },
              toSVG: function(reviver) {
                return this._createBaseSVGMarkup(
                  this._toSVG(),
                  { reviver, noStyle: true, withShadow: true }
                );
              },
              _getSVGLeftTopOffsets: function() {
                return {
                  textLeft: -this.width / 2,
                  textTop: -this.height / 2,
                  lineTop: this.getHeightOfLine(0)
                };
              },
              _wrapSVGTextAndBg: function(textAndBg) {
                var noShadow = true, textDecoration = this.getSvgTextDecoration(this);
                return [
                  textAndBg.textBgRects.join(""),
                  '		<text xml:space="preserve" ',
                  this.fontFamily ? 'font-family="' + this.fontFamily.replace(/"/g, "'") + '" ' : "",
                  this.fontSize ? 'font-size="' + this.fontSize + '" ' : "",
                  this.fontStyle ? 'font-style="' + this.fontStyle + '" ' : "",
                  this.fontWeight ? 'font-weight="' + this.fontWeight + '" ' : "",
                  textDecoration ? 'text-decoration="' + textDecoration + '" ' : "",
                  'style="',
                  this.getSvgStyles(noShadow),
                  '"',
                  this.addPaintOrder(),
                  " >",
                  textAndBg.textSpans.join(""),
                  "</text>\n"
                ];
              },
              _getSVGTextAndBg: function(textTopOffset, textLeftOffset) {
                var textSpans = [], textBgRects = [], height = textTopOffset, lineOffset;
                this._setSVGBg(textBgRects);
                for (var i = 0, len = this._textLines.length; i < len; i++) {
                  lineOffset = this._getLineLeftOffset(i);
                  if (this.textBackgroundColor || this.styleHas("textBackgroundColor", i)) {
                    this._setSVGTextLineBg(textBgRects, i, textLeftOffset + lineOffset, height);
                  }
                  this._setSVGTextLineText(textSpans, i, textLeftOffset + lineOffset, height);
                  height += this.getHeightOfLine(i);
                }
                return {
                  textSpans,
                  textBgRects
                };
              },
              _createTextCharSpan: function(_char, styleDecl, left, top) {
                var shouldUseWhitespace = _char !== _char.trim() || _char.match(multipleSpacesRegex), styleProps = this.getSvgSpanStyles(styleDecl, shouldUseWhitespace), fillStyles = styleProps ? 'style="' + styleProps + '"' : "", dy = styleDecl.deltaY, dySpan = "", NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
                if (dy) {
                  dySpan = ' dy="' + toFixed2(dy, NUM_FRACTION_DIGITS) + '" ';
                }
                return [
                  '<tspan x="',
                  toFixed2(left, NUM_FRACTION_DIGITS),
                  '" y="',
                  toFixed2(top, NUM_FRACTION_DIGITS),
                  '" ',
                  dySpan,
                  fillStyles,
                  ">",
                  fabric.util.string.escapeXml(_char),
                  "</tspan>"
                ].join("");
              },
              _setSVGTextLineText: function(textSpans, lineIndex, textLeftOffset, textTopOffset) {
                var lineHeight2 = this.getHeightOfLine(lineIndex), isJustify = this.textAlign.indexOf("justify") !== -1, actualStyle, nextStyle, charsToRender = "", charBox, style, boxWidth = 0, line = this._textLines[lineIndex], timeToRender;
                textTopOffset += lineHeight2 * (1 - this._fontSizeFraction) / this.lineHeight;
                for (var i = 0, len = line.length - 1; i <= len; i++) {
                  timeToRender = i === len || this.charSpacing;
                  charsToRender += line[i];
                  charBox = this.__charBounds[lineIndex][i];
                  if (boxWidth === 0) {
                    textLeftOffset += charBox.kernedWidth - charBox.width;
                    boxWidth += charBox.width;
                  } else {
                    boxWidth += charBox.kernedWidth;
                  }
                  if (isJustify && !timeToRender) {
                    if (this._reSpaceAndTab.test(line[i])) {
                      timeToRender = true;
                    }
                  }
                  if (!timeToRender) {
                    actualStyle = actualStyle || this.getCompleteStyleDeclaration(lineIndex, i);
                    nextStyle = this.getCompleteStyleDeclaration(lineIndex, i + 1);
                    timeToRender = this._hasStyleChangedForSvg(actualStyle, nextStyle);
                  }
                  if (timeToRender) {
                    style = this._getStyleDeclaration(lineIndex, i) || {};
                    textSpans.push(this._createTextCharSpan(charsToRender, style, textLeftOffset, textTopOffset));
                    charsToRender = "";
                    actualStyle = nextStyle;
                    textLeftOffset += boxWidth;
                    boxWidth = 0;
                  }
                }
              },
              _pushTextBgRect: function(textBgRects, color2, left, top, width, height) {
                var NUM_FRACTION_DIGITS = fabric.Object.NUM_FRACTION_DIGITS;
                textBgRects.push(
                  "		<rect ",
                  this._getFillAttributes(color2),
                  ' x="',
                  toFixed2(left, NUM_FRACTION_DIGITS),
                  '" y="',
                  toFixed2(top, NUM_FRACTION_DIGITS),
                  '" width="',
                  toFixed2(width, NUM_FRACTION_DIGITS),
                  '" height="',
                  toFixed2(height, NUM_FRACTION_DIGITS),
                  '"></rect>\n'
                );
              },
              _setSVGTextLineBg: function(textBgRects, i, leftOffset, textTopOffset) {
                var line = this._textLines[i], heightOfLine = this.getHeightOfLine(i) / this.lineHeight, boxWidth = 0, boxStart = 0, charBox, currentColor, lastColor = this.getValueOfPropertyAt(i, 0, "textBackgroundColor");
                for (var j2 = 0, jlen = line.length; j2 < jlen; j2++) {
                  charBox = this.__charBounds[i][j2];
                  currentColor = this.getValueOfPropertyAt(i, j2, "textBackgroundColor");
                  if (currentColor !== lastColor) {
                    lastColor && this._pushTextBgRect(
                      textBgRects,
                      lastColor,
                      leftOffset + boxStart,
                      textTopOffset,
                      boxWidth,
                      heightOfLine
                    );
                    boxStart = charBox.left;
                    boxWidth = charBox.width;
                    lastColor = currentColor;
                  } else {
                    boxWidth += charBox.kernedWidth;
                  }
                }
                currentColor && this._pushTextBgRect(
                  textBgRects,
                  currentColor,
                  leftOffset + boxStart,
                  textTopOffset,
                  boxWidth,
                  heightOfLine
                );
              },
              _getFillAttributes: function(value) {
                var fillColor = value && typeof value === "string" ? new fabric.Color(value) : "";
                if (!fillColor || !fillColor.getSource() || fillColor.getAlpha() === 1) {
                  return 'fill="' + value + '"';
                }
                return 'opacity="' + fillColor.getAlpha() + '" fill="' + fillColor.setAlpha(1).toRgb() + '"';
              },
              _getSVGLineTopOffset: function(lineIndex) {
                var lineTopOffset = 0, lastHeight = 0;
                for (var j2 = 0; j2 < lineIndex; j2++) {
                  lineTopOffset += this.getHeightOfLine(j2);
                }
                lastHeight = this.getHeightOfLine(j2);
                return {
                  lineTop: lineTopOffset,
                  offset: (this._fontSizeMult - this._fontSizeFraction) * lastHeight / (this.lineHeight * this._fontSizeMult)
                };
              },
              getSvgStyles: function(skipShadow) {
                var svgStyle = fabric.Object.prototype.getSvgStyles.call(this, skipShadow);
                return svgStyle + " white-space: pre;";
              }
            });
          })();
          (function(global2) {
            var fabric2 = global2.fabric || (global2.fabric = {});
            fabric2.Textbox = fabric2.util.createClass(fabric2.IText, fabric2.Observable, {
              type: "textbox",
              minWidth: 20,
              dynamicMinWidth: 2,
              __cachedLines: null,
              lockScalingFlip: true,
              noScaleCache: false,
              _dimensionAffectingProps: fabric2.Text.prototype._dimensionAffectingProps.concat("width"),
              _wordJoiners: /[ \t\r]/,
              splitByGrapheme: false,
              initDimensions: function() {
                if (this.__skipDimension) {
                  return;
                }
                this.isEditing && this.initDelayedCursor();
                this.clearContextTop();
                this._clearCache();
                this.dynamicMinWidth = 0;
                this._styleMap = this._generateStyleMap(this._splitText());
                if (this.dynamicMinWidth > this.width) {
                  this._set("width", this.dynamicMinWidth);
                }
                if (this.textAlign.indexOf("justify") !== -1) {
                  this.enlargeSpaces();
                }
                this.height = this.calcTextHeight();
                this.saveState({ propertySet: "_dimensionAffectingProps" });
              },
              _generateStyleMap: function(textInfo) {
                var realLineCount = 0, realLineCharCount = 0, charCount = 0, map = {};
                for (var i = 0; i < textInfo.graphemeLines.length; i++) {
                  if (textInfo.graphemeText[charCount] === "\n" && i > 0) {
                    realLineCharCount = 0;
                    charCount++;
                    realLineCount++;
                  } else if (!this.splitByGrapheme && this._reSpaceAndTab.test(textInfo.graphemeText[charCount]) && i > 0) {
                    realLineCharCount++;
                    charCount++;
                  }
                  map[i] = { line: realLineCount, offset: realLineCharCount };
                  charCount += textInfo.graphemeLines[i].length;
                  realLineCharCount += textInfo.graphemeLines[i].length;
                }
                return map;
              },
              styleHas: function(property, lineIndex) {
                if (this._styleMap && !this.isWrapping) {
                  var map = this._styleMap[lineIndex];
                  if (map) {
                    lineIndex = map.line;
                  }
                }
                return fabric2.Text.prototype.styleHas.call(this, property, lineIndex);
              },
              isEmptyStyles: function(lineIndex) {
                if (!this.styles) {
                  return true;
                }
                var offset = 0, nextLineIndex = lineIndex + 1, nextOffset, obj, shouldLimit = false, map = this._styleMap[lineIndex], mapNextLine = this._styleMap[lineIndex + 1];
                if (map) {
                  lineIndex = map.line;
                  offset = map.offset;
                }
                if (mapNextLine) {
                  nextLineIndex = mapNextLine.line;
                  shouldLimit = nextLineIndex === lineIndex;
                  nextOffset = mapNextLine.offset;
                }
                obj = typeof lineIndex === "undefined" ? this.styles : { line: this.styles[lineIndex] };
                for (var p1 in obj) {
                  for (var p2 in obj[p1]) {
                    if (p2 >= offset && (!shouldLimit || p2 < nextOffset)) {
                      for (var p3 in obj[p1][p2]) {
                        return false;
                      }
                    }
                  }
                }
                return true;
              },
              _getStyleDeclaration: function(lineIndex, charIndex) {
                if (this._styleMap && !this.isWrapping) {
                  var map = this._styleMap[lineIndex];
                  if (!map) {
                    return null;
                  }
                  lineIndex = map.line;
                  charIndex = map.offset + charIndex;
                }
                return this.callSuper("_getStyleDeclaration", lineIndex, charIndex);
              },
              _setStyleDeclaration: function(lineIndex, charIndex, style) {
                var map = this._styleMap[lineIndex];
                lineIndex = map.line;
                charIndex = map.offset + charIndex;
                this.styles[lineIndex][charIndex] = style;
              },
              _deleteStyleDeclaration: function(lineIndex, charIndex) {
                var map = this._styleMap[lineIndex];
                lineIndex = map.line;
                charIndex = map.offset + charIndex;
                delete this.styles[lineIndex][charIndex];
              },
              _getLineStyle: function(lineIndex) {
                var map = this._styleMap[lineIndex];
                return !!this.styles[map.line];
              },
              _setLineStyle: function(lineIndex) {
                var map = this._styleMap[lineIndex];
                this.styles[map.line] = {};
              },
              _wrapText: function(lines, desiredWidth) {
                var wrapped = [], i;
                this.isWrapping = true;
                for (i = 0; i < lines.length; i++) {
                  wrapped = wrapped.concat(this._wrapLine(lines[i], i, desiredWidth));
                }
                this.isWrapping = false;
                return wrapped;
              },
              _measureWord: function(word, lineIndex, charOffset) {
                var width = 0, prevGrapheme, skipLeft = true;
                charOffset = charOffset || 0;
                for (var i = 0, len = word.length; i < len; i++) {
                  var box = this._getGraphemeBox(word[i], lineIndex, i + charOffset, prevGrapheme, skipLeft);
                  width += box.kernedWidth;
                  prevGrapheme = word[i];
                }
                return width;
              },
              _wrapLine: function(_line, lineIndex, desiredWidth, reservedSpace) {
                var lineWidth = 0, splitByGrapheme = this.splitByGrapheme, graphemeLines = [], line = [], words = splitByGrapheme ? fabric2.util.string.graphemeSplit(_line) : _line.split(this._wordJoiners), word = "", offset = 0, infix = splitByGrapheme ? "" : " ", wordWidth = 0, infixWidth = 0, largestWordWidth = 0, lineJustStarted = true, additionalSpace = this._getWidthOfCharSpacing(), reservedSpace = reservedSpace || 0;
                if (words.length === 0) {
                  words.push([]);
                }
                desiredWidth -= reservedSpace;
                for (var i = 0; i < words.length; i++) {
                  word = splitByGrapheme ? words[i] : fabric2.util.string.graphemeSplit(words[i]);
                  wordWidth = this._measureWord(word, lineIndex, offset);
                  offset += word.length;
                  lineWidth += infixWidth + wordWidth - additionalSpace;
                  if (lineWidth > desiredWidth && !lineJustStarted) {
                    graphemeLines.push(line);
                    line = [];
                    lineWidth = wordWidth;
                    lineJustStarted = true;
                  } else {
                    lineWidth += additionalSpace;
                  }
                  if (!lineJustStarted && !splitByGrapheme) {
                    line.push(infix);
                  }
                  line = line.concat(word);
                  infixWidth = splitByGrapheme ? 0 : this._measureWord([infix], lineIndex, offset);
                  offset++;
                  lineJustStarted = false;
                  if (wordWidth > largestWordWidth) {
                    largestWordWidth = wordWidth;
                  }
                }
                i && graphemeLines.push(line);
                if (largestWordWidth + reservedSpace > this.dynamicMinWidth) {
                  this.dynamicMinWidth = largestWordWidth - additionalSpace + reservedSpace;
                }
                return graphemeLines;
              },
              isEndOfWrapping: function(lineIndex) {
                if (!this._styleMap[lineIndex + 1]) {
                  return true;
                }
                if (this._styleMap[lineIndex + 1].line !== this._styleMap[lineIndex].line) {
                  return true;
                }
                return false;
              },
              missingNewlineOffset: function(lineIndex) {
                if (this.splitByGrapheme) {
                  return this.isEndOfWrapping(lineIndex) ? 1 : 0;
                }
                return 1;
              },
              _splitTextIntoLines: function(text) {
                var newText = fabric2.Text.prototype._splitTextIntoLines.call(this, text), graphemeLines = this._wrapText(newText.lines, this.width), lines = new Array(graphemeLines.length);
                for (var i = 0; i < graphemeLines.length; i++) {
                  lines[i] = graphemeLines[i].join("");
                }
                newText.lines = lines;
                newText.graphemeLines = graphemeLines;
                return newText;
              },
              getMinWidth: function() {
                return Math.max(this.minWidth, this.dynamicMinWidth);
              },
              _removeExtraneousStyles: function() {
                var linesToKeep = {};
                for (var prop in this._styleMap) {
                  if (this._textLines[prop]) {
                    linesToKeep[this._styleMap[prop].line] = 1;
                  }
                }
                for (var prop in this.styles) {
                  if (!linesToKeep[prop]) {
                    delete this.styles[prop];
                  }
                }
              },
              toObject: function(propertiesToInclude) {
                return this.callSuper("toObject", ["minWidth", "splitByGrapheme"].concat(propertiesToInclude));
              }
            });
            fabric2.Textbox.fromObject = function(object, callback) {
              return fabric2.Object._fromObject("Textbox", object, callback, "text");
            };
          })(exports2);
          (function() {
            var controlsUtils = fabric.controlsUtils, scaleSkewStyleHandler = controlsUtils.scaleSkewCursorStyleHandler, scaleStyleHandler = controlsUtils.scaleCursorStyleHandler, scalingEqually = controlsUtils.scalingEqually, scalingYOrSkewingX = controlsUtils.scalingYOrSkewingX, scalingXOrSkewingY = controlsUtils.scalingXOrSkewingY, scaleOrSkewActionName = controlsUtils.scaleOrSkewActionName, objectControls = fabric.Object.prototype.controls;
            objectControls.ml = new fabric.Control({
              x: -0.5,
              y: 0,
              cursorStyleHandler: scaleSkewStyleHandler,
              actionHandler: scalingXOrSkewingY,
              getActionName: scaleOrSkewActionName
            });
            objectControls.mr = new fabric.Control({
              x: 0.5,
              y: 0,
              cursorStyleHandler: scaleSkewStyleHandler,
              actionHandler: scalingXOrSkewingY,
              getActionName: scaleOrSkewActionName
            });
            objectControls.mb = new fabric.Control({
              x: 0,
              y: 0.5,
              cursorStyleHandler: scaleSkewStyleHandler,
              actionHandler: scalingYOrSkewingX,
              getActionName: scaleOrSkewActionName
            });
            objectControls.mt = new fabric.Control({
              x: 0,
              y: -0.5,
              cursorStyleHandler: scaleSkewStyleHandler,
              actionHandler: scalingYOrSkewingX,
              getActionName: scaleOrSkewActionName
            });
            objectControls.tl = new fabric.Control({
              x: -0.5,
              y: -0.5,
              cursorStyleHandler: scaleStyleHandler,
              actionHandler: scalingEqually
            });
            objectControls.tr = new fabric.Control({
              x: 0.5,
              y: -0.5,
              cursorStyleHandler: scaleStyleHandler,
              actionHandler: scalingEqually
            });
            objectControls.bl = new fabric.Control({
              x: -0.5,
              y: 0.5,
              cursorStyleHandler: scaleStyleHandler,
              actionHandler: scalingEqually
            });
            objectControls.br = new fabric.Control({
              x: 0.5,
              y: 0.5,
              cursorStyleHandler: scaleStyleHandler,
              actionHandler: scalingEqually
            });
            objectControls.mtr = new fabric.Control({
              x: 0,
              y: -0.5,
              actionHandler: controlsUtils.rotationWithSnapping,
              cursorStyleHandler: controlsUtils.rotationStyleHandler,
              offsetY: -40,
              withConnection: true,
              actionName: "rotate"
            });
            if (fabric.Textbox) {
              var textBoxControls = fabric.Textbox.prototype.controls = {};
              textBoxControls.mtr = objectControls.mtr;
              textBoxControls.tr = objectControls.tr;
              textBoxControls.br = objectControls.br;
              textBoxControls.tl = objectControls.tl;
              textBoxControls.bl = objectControls.bl;
              textBoxControls.mt = objectControls.mt;
              textBoxControls.mb = objectControls.mb;
              textBoxControls.mr = new fabric.Control({
                x: 0.5,
                y: 0,
                actionHandler: controlsUtils.changeWidth,
                cursorStyleHandler: scaleSkewStyleHandler,
                actionName: "resizing"
              });
              textBoxControls.ml = new fabric.Control({
                x: -0.5,
                y: 0,
                actionHandler: controlsUtils.changeWidth,
                cursorStyleHandler: scaleSkewStyleHandler,
                actionName: "resizing"
              });
            }
          })();
        },
        3053: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var isArray2 = __webpack_require__2(602);
          function inArray(searchElement, array, startIndex) {
            var i;
            var length;
            startIndex = startIndex || 0;
            if (!isArray2(array)) {
              return -1;
            }
            if (Array.prototype.indexOf) {
              return Array.prototype.indexOf.call(array, searchElement, startIndex);
            }
            length = array.length;
            for (i = startIndex; startIndex >= 0 && i < length; i += 1) {
              if (array[i] === searchElement) {
                return i;
              }
            }
            return -1;
          }
          module2.exports = inArray;
        },
        8592: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var isArray2 = __webpack_require__2(602);
          var forEachArray = __webpack_require__2(6092);
          var forEachOwnProperties = __webpack_require__2(5573);
          function forEach3(obj, iteratee, context) {
            if (isArray2(obj)) {
              forEachArray(obj, iteratee, context);
            } else {
              forEachOwnProperties(obj, iteratee, context);
            }
          }
          module2.exports = forEach3;
        },
        6092: function(module2) {
          function forEachArray(arr2, iteratee, context) {
            var index2 = 0;
            var len = arr2.length;
            context = context || null;
            for (; index2 < len; index2 += 1) {
              if (iteratee.call(context, arr2[index2], index2, arr2) === false) {
                break;
              }
            }
          }
          module2.exports = forEachArray;
        },
        5573: function(module2) {
          function forEachOwnProperties(obj, iteratee, context) {
            var key;
            context = context || null;
            for (key in obj) {
              if (obj.hasOwnProperty(key)) {
                if (iteratee.call(context, obj[key], key, obj) === false) {
                  break;
                }
              }
            }
          }
          module2.exports = forEachOwnProperties;
        },
        9052: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var extend2 = __webpack_require__2(961);
          var isExisty = __webpack_require__2(9886);
          var isString2 = __webpack_require__2(2560);
          var isObject2 = __webpack_require__2(5393);
          var isArray2 = __webpack_require__2(602);
          var isFunction2 = __webpack_require__2(5183);
          var forEach3 = __webpack_require__2(8592);
          var R_EVENTNAME_SPLIT = /\s+/g;
          function CustomEvents() {
            this.events = null;
            this.contexts = null;
          }
          CustomEvents.mixin = function(func) {
            extend2(func.prototype, CustomEvents.prototype);
          };
          CustomEvents.prototype._getHandlerItem = function(handler, context) {
            var item = { handler };
            if (context) {
              item.context = context;
            }
            return item;
          };
          CustomEvents.prototype._safeEvent = function(eventName) {
            var events2 = this.events;
            var byName;
            if (!events2) {
              events2 = this.events = {};
            }
            if (eventName) {
              byName = events2[eventName];
              if (!byName) {
                byName = [];
                events2[eventName] = byName;
              }
              events2 = byName;
            }
            return events2;
          };
          CustomEvents.prototype._safeContext = function() {
            var context = this.contexts;
            if (!context) {
              context = this.contexts = [];
            }
            return context;
          };
          CustomEvents.prototype._indexOfContext = function(ctx) {
            var context = this._safeContext();
            var index2 = 0;
            while (context[index2]) {
              if (ctx === context[index2][0]) {
                return index2;
              }
              index2 += 1;
            }
            return -1;
          };
          CustomEvents.prototype._memorizeContext = function(ctx) {
            var context, index2;
            if (!isExisty(ctx)) {
              return;
            }
            context = this._safeContext();
            index2 = this._indexOfContext(ctx);
            if (index2 > -1) {
              context[index2][1] += 1;
            } else {
              context.push([ctx, 1]);
            }
          };
          CustomEvents.prototype._forgetContext = function(ctx) {
            var context, contextIndex;
            if (!isExisty(ctx)) {
              return;
            }
            context = this._safeContext();
            contextIndex = this._indexOfContext(ctx);
            if (contextIndex > -1) {
              context[contextIndex][1] -= 1;
              if (context[contextIndex][1] <= 0) {
                context.splice(contextIndex, 1);
              }
            }
          };
          CustomEvents.prototype._bindEvent = function(eventName, handler, context) {
            var events2 = this._safeEvent(eventName);
            this._memorizeContext(context);
            events2.push(this._getHandlerItem(handler, context));
          };
          CustomEvents.prototype.on = function(eventName, handler, context) {
            var self2 = this;
            if (isString2(eventName)) {
              eventName = eventName.split(R_EVENTNAME_SPLIT);
              forEach3(eventName, function(name2) {
                self2._bindEvent(name2, handler, context);
              });
            } else if (isObject2(eventName)) {
              context = handler;
              forEach3(eventName, function(func, name2) {
                self2.on(name2, func, context);
              });
            }
          };
          CustomEvents.prototype.once = function(eventName, handler, context) {
            var self2 = this;
            if (isObject2(eventName)) {
              context = handler;
              forEach3(eventName, function(func, name2) {
                self2.once(name2, func, context);
              });
              return;
            }
            function onceHandler() {
              handler.apply(context, arguments);
              self2.off(eventName, onceHandler, context);
            }
            this.on(eventName, onceHandler, context);
          };
          CustomEvents.prototype._spliceMatches = function(arr2, predicate) {
            var i = 0;
            var len;
            if (!isArray2(arr2)) {
              return;
            }
            for (len = arr2.length; i < len; i += 1) {
              if (predicate(arr2[i]) === true) {
                arr2.splice(i, 1);
                len -= 1;
                i -= 1;
              }
            }
          };
          CustomEvents.prototype._matchHandler = function(handler) {
            var self2 = this;
            return function(item) {
              var needRemove = handler === item.handler;
              if (needRemove) {
                self2._forgetContext(item.context);
              }
              return needRemove;
            };
          };
          CustomEvents.prototype._matchContext = function(context) {
            var self2 = this;
            return function(item) {
              var needRemove = context === item.context;
              if (needRemove) {
                self2._forgetContext(item.context);
              }
              return needRemove;
            };
          };
          CustomEvents.prototype._matchHandlerAndContext = function(handler, context) {
            var self2 = this;
            return function(item) {
              var matchHandler = handler === item.handler;
              var matchContext = context === item.context;
              var needRemove = matchHandler && matchContext;
              if (needRemove) {
                self2._forgetContext(item.context);
              }
              return needRemove;
            };
          };
          CustomEvents.prototype._offByEventName = function(eventName, handler) {
            var self2 = this;
            var andByHandler = isFunction2(handler);
            var matchHandler = self2._matchHandler(handler);
            eventName = eventName.split(R_EVENTNAME_SPLIT);
            forEach3(eventName, function(name2) {
              var handlerItems = self2._safeEvent(name2);
              if (andByHandler) {
                self2._spliceMatches(handlerItems, matchHandler);
              } else {
                forEach3(handlerItems, function(item) {
                  self2._forgetContext(item.context);
                });
                self2.events[name2] = [];
              }
            });
          };
          CustomEvents.prototype._offByHandler = function(handler) {
            var self2 = this;
            var matchHandler = this._matchHandler(handler);
            forEach3(this._safeEvent(), function(handlerItems) {
              self2._spliceMatches(handlerItems, matchHandler);
            });
          };
          CustomEvents.prototype._offByObject = function(obj, handler) {
            var self2 = this;
            var matchFunc;
            if (this._indexOfContext(obj) < 0) {
              forEach3(obj, function(func, name2) {
                self2.off(name2, func);
              });
            } else if (isString2(handler)) {
              matchFunc = this._matchContext(obj);
              self2._spliceMatches(this._safeEvent(handler), matchFunc);
            } else if (isFunction2(handler)) {
              matchFunc = this._matchHandlerAndContext(handler, obj);
              forEach3(this._safeEvent(), function(handlerItems) {
                self2._spliceMatches(handlerItems, matchFunc);
              });
            } else {
              matchFunc = this._matchContext(obj);
              forEach3(this._safeEvent(), function(handlerItems) {
                self2._spliceMatches(handlerItems, matchFunc);
              });
            }
          };
          CustomEvents.prototype.off = function(eventName, handler) {
            if (isString2(eventName)) {
              this._offByEventName(eventName, handler);
            } else if (!arguments.length) {
              this.events = {};
              this.contexts = [];
            } else if (isFunction2(eventName)) {
              this._offByHandler(eventName);
            } else if (isObject2(eventName)) {
              this._offByObject(eventName, handler);
            }
          };
          CustomEvents.prototype.fire = function(eventName) {
            this.invoke.apply(this, arguments);
          };
          CustomEvents.prototype.invoke = function(eventName) {
            var events2, args, index2, item;
            if (!this.hasListener(eventName)) {
              return true;
            }
            events2 = this._safeEvent(eventName);
            args = Array.prototype.slice.call(arguments, 1);
            index2 = 0;
            while (events2[index2]) {
              item = events2[index2];
              if (item.handler.apply(item.context, args) === false) {
                return false;
              }
              index2 += 1;
            }
            return true;
          };
          CustomEvents.prototype.hasListener = function(eventName) {
            return this.getListenerLength(eventName) > 0;
          };
          CustomEvents.prototype.getListenerLength = function(eventName) {
            var events2 = this._safeEvent(eventName);
            return events2.length;
          };
          module2.exports = CustomEvents;
        },
        961: function(module2) {
          function extend2(target, objects) {
            var hasOwnProp = Object.prototype.hasOwnProperty;
            var source2, prop, i, len;
            for (i = 1, len = arguments.length; i < len; i += 1) {
              source2 = arguments[i];
              for (prop in source2) {
                if (hasOwnProp.call(source2, prop)) {
                  target[prop] = source2[prop];
                }
              }
            }
            return target;
          }
          module2.exports = extend2;
        },
        1610: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var isUndefined2 = __webpack_require__2(5695);
          var isNull = __webpack_require__2(3778);
          function pick(obj, paths) {
            var args = arguments;
            var target = args[0];
            var i = 1;
            var length = args.length;
            for (; i < length; i += 1) {
              if (isUndefined2(target) || isNull(target)) {
                return;
              }
              target = target[args[i]];
            }
            return target;
          }
          module2.exports = pick;
        },
        4564: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var forEachOwnProperties = __webpack_require__2(5573);
          function imagePing(url, trackingInfo) {
            var trackingElement = document.createElement("img");
            var queryString = "";
            forEachOwnProperties(trackingInfo, function(value, key) {
              queryString += "&" + key + "=" + value;
            });
            queryString = queryString.substring(1);
            trackingElement.src = url + "?" + queryString;
            trackingElement.style.display = "none";
            document.body.appendChild(trackingElement);
            document.body.removeChild(trackingElement);
            return trackingElement;
          }
          module2.exports = imagePing;
        },
        4729: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var isUndefined2 = __webpack_require__2(5695);
          var imagePing = __webpack_require__2(4564);
          var ms7days = 7 * 24 * 60 * 60 * 1e3;
          function isExpired(date) {
            var now2 = new Date().getTime();
            return now2 - date > ms7days;
          }
          function sendHostname(appName, trackingId) {
            var url = "https://www.google-analytics.com/collect";
            var hostname = location.hostname;
            var hitType = "event";
            var eventCategory = "use";
            var applicationKeyForStorage = "TOAST UI " + appName + " for " + hostname + ": Statistics";
            var date = window.localStorage.getItem(applicationKeyForStorage);
            if (!isUndefined2(window.tui) && window.tui.usageStatistics === false) {
              return;
            }
            if (date && !isExpired(date)) {
              return;
            }
            window.localStorage.setItem(applicationKeyForStorage, new Date().getTime());
            setTimeout(function() {
              if (document.readyState === "interactive" || document.readyState === "complete") {
                imagePing(url, {
                  v: 1,
                  t: hitType,
                  tid: trackingId,
                  cid: hostname,
                  dp: hostname,
                  dh: appName,
                  el: appName,
                  ec: eventCategory
                });
              }
            }, 1e3);
          }
          module2.exports = sendHostname;
        },
        602: function(module2) {
          function isArray2(obj) {
            return obj instanceof Array;
          }
          module2.exports = isArray2;
        },
        9886: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var isUndefined2 = __webpack_require__2(5695);
          var isNull = __webpack_require__2(3778);
          function isExisty(param) {
            return !isUndefined2(param) && !isNull(param);
          }
          module2.exports = isExisty;
        },
        5183: function(module2) {
          function isFunction2(obj) {
            return obj instanceof Function;
          }
          module2.exports = isFunction2;
        },
        3778: function(module2) {
          function isNull(obj) {
            return obj === null;
          }
          module2.exports = isNull;
        },
        5393: function(module2) {
          function isObject2(obj) {
            return obj === Object(obj);
          }
          module2.exports = isObject2;
        },
        2560: function(module2) {
          function isString2(obj) {
            return typeof obj === "string" || obj instanceof String;
          }
          module2.exports = isString2;
        },
        5695: function(module2) {
          function isUndefined2(obj) {
            return obj === void 0;
          }
          module2.exports = isUndefined2;
        },
        4426: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(4486);
        },
        9406: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(4877);
        },
        789: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(7178);
        },
        381: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(5603);
        },
        7636: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(1206);
        },
        1899: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(6174);
        },
        899: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(57);
        },
        8005: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(4741);
        },
        6562: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(8368);
        },
        9131: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(3739);
        },
        4383: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(172);
        },
        6065: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(4963);
        },
        1734: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(7820);
        },
        2461: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(5636);
        },
        5214: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(5059);
        },
        6397: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(3969);
        },
        8189: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(6618);
        },
        9146: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(5279);
        },
        4496: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(9562);
        },
        3972: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(652);
        },
        7172: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(2813);
        },
        1845: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(8664);
        },
        662: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(1457);
        },
        711: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(2937);
        },
        6623: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(9297);
        },
        7077: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(8026);
        },
        9856: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(2044);
        },
        4230: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(2214);
        },
        184: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(9256);
        },
        3742: function(module2, __unused_webpack_exports, __webpack_require__2) {
          module2.exports = __webpack_require__2(5659);
        },
        1801: function(module2) {
          var DIVISOR = {
            rect: 1,
            circle: 2,
            triangle: 1
          };
          var DIMENSION_KEYS = {
            rect: {
              w: "width",
              h: "height"
            },
            circle: {
              w: "rx",
              h: "ry"
            },
            triangle: {
              w: "width",
              h: "height"
            }
          };
          function setStartPoint(shape) {
            var originX = shape.originX, originY = shape.originY;
            var originKey = originX.substring(0, 1) + originY.substring(0, 1);
            shape.startPoint = shape.origins[originKey];
          }
          function getPositionsOfRotatedOrigin(origin, pointer, angle2) {
            var sx = origin.x;
            var sy = origin.y;
            var px = pointer.x;
            var py = pointer.y;
            var r = angle2 * Math.PI / 180;
            var rx = (px - sx) * Math.cos(r) - (py - sy) * Math.sin(r) + sx;
            var ry = (px - sx) * Math.sin(r) + (py - sy) * Math.cos(r) + sy;
            return {
              originX: sx > rx ? "right" : "left",
              originY: sy > ry ? "bottom" : "top"
            };
          }
          function hasCenterOrigin(shape) {
            return shape.originX === "center" && shape.originY === "center";
          }
          function adjustOriginByStartPoint(pointer, shape) {
            var centerPoint = shape.getPointByOrigin("center", "center");
            var angle2 = -shape.angle;
            var originPositions = getPositionsOfRotatedOrigin(centerPoint, pointer, angle2);
            var originX = originPositions.originX, originY = originPositions.originY;
            var origin = shape.getPointByOrigin(originX, originY);
            var left = shape.left - (centerPoint.x - origin.x);
            var top = shape.top - (centerPoint.y - origin.y);
            shape.set({
              originX,
              originY,
              left,
              top
            });
            shape.setCoords();
          }
          function adjustOriginByMovingPointer(pointer, shape) {
            var origin = shape.startPoint;
            var angle2 = -shape.angle;
            var originPositions = getPositionsOfRotatedOrigin(origin, pointer, angle2);
            var originX = originPositions.originX, originY = originPositions.originY;
            shape.setPositionByOrigin(origin, originX, originY);
            shape.setCoords();
          }
          function adjustDimensionOnScaling(shape) {
            var type = shape.type, scaleX = shape.scaleX, scaleY = shape.scaleY;
            var dimensionKeys = DIMENSION_KEYS[type];
            var width = shape[dimensionKeys.w] * scaleX;
            var height = shape[dimensionKeys.h] * scaleY;
            if (shape.isRegular) {
              var maxScale = Math.max(scaleX, scaleY);
              width = shape[dimensionKeys.w] * maxScale;
              height = shape[dimensionKeys.h] * maxScale;
            }
            var options = {
              hasControls: false,
              hasBorders: false,
              scaleX: 1,
              scaleY: 1
            };
            options[dimensionKeys.w] = width;
            options[dimensionKeys.h] = height;
            shape.set(options);
          }
          function adjustDimensionOnMouseMove(pointer, shape) {
            var type = shape.type, strokeWidth = shape.strokeWidth, origin = shape.startPoint;
            var divisor = DIVISOR[type];
            var dimensionKeys = DIMENSION_KEYS[type];
            var isTriangle = !!(shape.type === "triangle");
            var options = {};
            var width = Math.abs(origin.x - pointer.x) / divisor;
            var height = Math.abs(origin.y - pointer.y) / divisor;
            if (width > strokeWidth) {
              width -= strokeWidth / divisor;
            }
            if (height > strokeWidth) {
              height -= strokeWidth / divisor;
            }
            if (shape.isRegular) {
              width = height = Math.max(width, height);
              if (isTriangle) {
                height = Math.sqrt(3) / 2 * width;
              }
            }
            options[dimensionKeys.w] = width;
            options[dimensionKeys.h] = height;
            shape.set(options);
          }
          module2.exports = {
            setOrigins: function setOrigins(shape) {
              var leftTopPoint = shape.getPointByOrigin("left", "top");
              var rightTopPoint = shape.getPointByOrigin("right", "top");
              var rightBottomPoint = shape.getPointByOrigin("right", "bottom");
              var leftBottomPoint = shape.getPointByOrigin("left", "bottom");
              shape.origins = {
                lt: leftTopPoint,
                rt: rightTopPoint,
                rb: rightBottomPoint,
                lb: leftBottomPoint
              };
            },
            resize: function resize(shape, pointer, isScaling) {
              if (hasCenterOrigin(shape)) {
                adjustOriginByStartPoint(pointer, shape);
                setStartPoint(shape);
              }
              if (isScaling) {
                adjustDimensionOnScaling(shape);
              } else {
                adjustDimensionOnMouseMove(pointer, shape);
              }
              adjustOriginByMovingPointer(pointer, shape);
            },
            adjustOriginToCenter: function adjustOriginToCenter(shape) {
              var centerPoint = shape.getPointByOrigin("center", "center");
              var originX = shape.originX, originY = shape.originY;
              var origin = shape.getPointByOrigin(originX, originY);
              var left = shape.left + (centerPoint.x - origin.x);
              var top = shape.top + (centerPoint.y - origin.y);
              shape.set({
                hasControls: true,
                hasBorders: true,
                originX: "center",
                originY: "center",
                left,
                top
              });
              shape.setCoords();
            }
          };
        },
        2221: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(5454);
          __webpack_require__2(9173);
          var path = __webpack_require__2(7545);
          module2.exports = path.Array.from;
        },
        5078: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(8118);
          var path = __webpack_require__2(7545);
          module2.exports = path.Array.isArray;
        },
        6135: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(9106);
          var entryVirtual = __webpack_require__2(5607);
          module2.exports = entryVirtual("Array").concat;
        },
        9510: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(1710);
          var entryVirtual = __webpack_require__2(5607);
          module2.exports = entryVirtual("Array").fill;
        },
        3971: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(3436);
          var entryVirtual = __webpack_require__2(5607);
          module2.exports = entryVirtual("Array").filter;
        },
        98: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(9823);
          var entryVirtual = __webpack_require__2(5607);
          module2.exports = entryVirtual("Array").forEach;
        },
        2089: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(2276);
          var entryVirtual = __webpack_require__2(5607);
          module2.exports = entryVirtual("Array").indexOf;
        },
        6209: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(3838);
          var entryVirtual = __webpack_require__2(5607);
          module2.exports = entryVirtual("Array").map;
        },
        2671: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(5818);
          var entryVirtual = __webpack_require__2(5607);
          module2.exports = entryVirtual("Array").slice;
        },
        1375: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(2178);
          var entryVirtual = __webpack_require__2(5607);
          module2.exports = entryVirtual("Array").splice;
        },
        3528: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(665);
          var entryVirtual = __webpack_require__2(5607);
          module2.exports = entryVirtual("Function").bind;
        },
        5739: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(8939);
          __webpack_require__2(5454);
          var getIteratorMethod = __webpack_require__2(8703);
          module2.exports = getIteratorMethod;
        },
        278: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var bind3 = __webpack_require__2(3528);
          var FunctionPrototype = Function.prototype;
          module2.exports = function(it) {
            var own = it.bind;
            return it === FunctionPrototype || it instanceof Function && own === FunctionPrototype.bind ? bind3 : own;
          };
        },
        1484: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var concat = __webpack_require__2(6135);
          var ArrayPrototype = Array.prototype;
          module2.exports = function(it) {
            var own = it.concat;
            return it === ArrayPrototype || it instanceof Array && own === ArrayPrototype.concat ? concat : own;
          };
        },
        7731: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var fill = __webpack_require__2(9510);
          var ArrayPrototype = Array.prototype;
          module2.exports = function(it) {
            var own = it.fill;
            return it === ArrayPrototype || it instanceof Array && own === ArrayPrototype.fill ? fill : own;
          };
        },
        3669: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var filter = __webpack_require__2(3971);
          var ArrayPrototype = Array.prototype;
          module2.exports = function(it) {
            var own = it.filter;
            return it === ArrayPrototype || it instanceof Array && own === ArrayPrototype.filter ? filter : own;
          };
        },
        2604: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var indexOf = __webpack_require__2(2089);
          var ArrayPrototype = Array.prototype;
          module2.exports = function(it) {
            var own = it.indexOf;
            return it === ArrayPrototype || it instanceof Array && own === ArrayPrototype.indexOf ? indexOf : own;
          };
        },
        263: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var map = __webpack_require__2(6209);
          var ArrayPrototype = Array.prototype;
          module2.exports = function(it) {
            var own = it.map;
            return it === ArrayPrototype || it instanceof Array && own === ArrayPrototype.map ? map : own;
          };
        },
        7663: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var slice = __webpack_require__2(2671);
          var ArrayPrototype = Array.prototype;
          module2.exports = function(it) {
            var own = it.slice;
            return it === ArrayPrototype || it instanceof Array && own === ArrayPrototype.slice ? slice : own;
          };
        },
        5063: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var splice = __webpack_require__2(1375);
          var ArrayPrototype = Array.prototype;
          module2.exports = function(it) {
            var own = it.splice;
            return it === ArrayPrototype || it instanceof Array && own === ArrayPrototype.splice ? splice : own;
          };
        },
        6813: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var trim2 = __webpack_require__2(3842);
          var StringPrototype = String.prototype;
          module2.exports = function(it) {
            var own = it.trim;
            return typeof it === "string" || it === StringPrototype || it instanceof String && own === StringPrototype.trim ? trim2 : own;
          };
        },
        6285: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(2666);
          var path = __webpack_require__2(7545);
          module2.exports = path.Number.parseInt;
        },
        3213: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(3113);
          var path = __webpack_require__2(7545);
          var Object2 = path.Object;
          module2.exports = function create2(P2, D2) {
            return Object2.create(P2, D2);
          };
        },
        3512: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(297);
          var path = __webpack_require__2(7545);
          var Object2 = path.Object;
          var defineProperty = module2.exports = function defineProperty2(it, key, desc) {
            return Object2.defineProperty(it, key, desc);
          };
          if (Object2.defineProperty.sham)
            defineProperty.sham = true;
        },
        8168: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(9234);
          var path = __webpack_require__2(7545);
          module2.exports = path.Object.getPrototypeOf;
        },
        8651: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(2647);
          var path = __webpack_require__2(7545);
          module2.exports = path.Object.keys;
        },
        3083: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(3222);
          var path = __webpack_require__2(7545);
          module2.exports = path.Object.setPrototypeOf;
        },
        2987: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(4859);
          var path = __webpack_require__2(7545);
          module2.exports = path.parseFloat;
        },
        2239: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(5706);
          var path = __webpack_require__2(7545);
          module2.exports = path.parseInt;
        },
        3154: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(4242);
          __webpack_require__2(8939);
          __webpack_require__2(6663);
          __webpack_require__2(9021);
          __webpack_require__2(7884);
          __webpack_require__2(8885);
          __webpack_require__2(1868);
          __webpack_require__2(5454);
          var path = __webpack_require__2(7545);
          module2.exports = path.Promise;
        },
        6577: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(5397);
          var path = __webpack_require__2(7545);
          module2.exports = path.Reflect.construct;
        },
        3842: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(957);
          var entryVirtual = __webpack_require__2(5607);
          module2.exports = entryVirtual("String").trim;
        },
        5008: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(9106);
          __webpack_require__2(6663);
          __webpack_require__2(6187);
          __webpack_require__2(9781);
          __webpack_require__2(492);
          __webpack_require__2(6681);
          __webpack_require__2(9594);
          __webpack_require__2(3665);
          __webpack_require__2(9017);
          __webpack_require__2(1250);
          __webpack_require__2(9786);
          __webpack_require__2(503);
          __webpack_require__2(6565);
          __webpack_require__2(9322);
          __webpack_require__2(3610);
          __webpack_require__2(6886);
          __webpack_require__2(3514);
          __webpack_require__2(8671);
          __webpack_require__2(8556);
          __webpack_require__2(1367);
          var path = __webpack_require__2(7545);
          module2.exports = path.Symbol;
        },
        994: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(8939);
          __webpack_require__2(6663);
          __webpack_require__2(5454);
          __webpack_require__2(3665);
          var WrappedWellKnownSymbolModule = __webpack_require__2(9207);
          module2.exports = WrappedWellKnownSymbolModule.f("iterator");
        },
        2813: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(3822);
          module2.exports = parent;
        },
        8664: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(1434);
          module2.exports = parent;
        },
        1457: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(7710);
          module2.exports = parent;
        },
        2937: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(4741);
          module2.exports = parent;
        },
        9297: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(4963);
          module2.exports = parent;
        },
        8026: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(7820);
          module2.exports = parent;
        },
        2044: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(8980);
          module2.exports = parent;
        },
        2214: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(6672);
          module2.exports = parent;
        },
        9256: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(2285);
          __webpack_require__2(177);
          __webpack_require__2(9031);
          __webpack_require__2(6658);
          __webpack_require__2(1875);
          __webpack_require__2(8658);
          __webpack_require__2(4592);
          __webpack_require__2(6680);
          module2.exports = parent;
        },
        5659: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(8535);
          module2.exports = parent;
        },
        6235: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var isCallable = __webpack_require__2(6447);
          var tryToString = __webpack_require__2(9288);
          module2.exports = function(argument) {
            if (isCallable(argument))
              return argument;
            throw TypeError(tryToString(argument) + " is not a function");
          };
        },
        1404: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var isConstructor = __webpack_require__2(2091);
          var tryToString = __webpack_require__2(9288);
          module2.exports = function(argument) {
            if (isConstructor(argument))
              return argument;
            throw TypeError(tryToString(argument) + " is not a constructor");
          };
        },
        7757: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var isCallable = __webpack_require__2(6447);
          module2.exports = function(argument) {
            if (typeof argument === "object" || isCallable(argument))
              return argument;
            throw TypeError("Can't set " + String(argument) + " as a prototype");
          };
        },
        7423: function(module2) {
          module2.exports = function() {
          };
        },
        6961: function(module2) {
          module2.exports = function(it, Constructor, name2) {
            if (it instanceof Constructor)
              return it;
            throw TypeError("Incorrect " + (name2 ? name2 + " " : "") + "invocation");
          };
        },
        1138: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var isObject2 = __webpack_require__2(5744);
          module2.exports = function(argument) {
            if (isObject2(argument))
              return argument;
            throw TypeError(String(argument) + " is not an object");
          };
        },
        2724: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var toObject2 = __webpack_require__2(1795);
          var toAbsoluteIndex = __webpack_require__2(7739);
          var lengthOfArrayLike = __webpack_require__2(4104);
          module2.exports = function fill(value) {
            var O2 = toObject2(this);
            var length = lengthOfArrayLike(O2);
            var argumentsLength = arguments.length;
            var index2 = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : void 0, length);
            var end = argumentsLength > 2 ? arguments[2] : void 0;
            var endPos = end === void 0 ? length : toAbsoluteIndex(end, length);
            while (endPos > index2)
              O2[index2++] = value;
            return O2;
          };
        },
        7397: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var $forEach = __webpack_require__2(454).forEach;
          var arrayMethodIsStrict = __webpack_require__2(424);
          var STRICT_METHOD = arrayMethodIsStrict("forEach");
          module2.exports = !STRICT_METHOD ? function forEach3(callbackfn) {
            return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
          } : [].forEach;
        },
        841: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var bind3 = __webpack_require__2(8043);
          var toObject2 = __webpack_require__2(1795);
          var callWithSafeIterationClosing = __webpack_require__2(1635);
          var isArrayIteratorMethod = __webpack_require__2(6109);
          var isConstructor = __webpack_require__2(2091);
          var lengthOfArrayLike = __webpack_require__2(4104);
          var createProperty = __webpack_require__2(9361);
          var getIterator = __webpack_require__2(1669);
          var getIteratorMethod = __webpack_require__2(8703);
          module2.exports = function from(arrayLike) {
            var O2 = toObject2(arrayLike);
            var IS_CONSTRUCTOR = isConstructor(this);
            var argumentsLength = arguments.length;
            var mapfn = argumentsLength > 1 ? arguments[1] : void 0;
            var mapping = mapfn !== void 0;
            if (mapping)
              mapfn = bind3(mapfn, argumentsLength > 2 ? arguments[2] : void 0, 2);
            var iteratorMethod = getIteratorMethod(O2);
            var index2 = 0;
            var length, result, step, iterator, next, value;
            if (iteratorMethod && !(this == Array && isArrayIteratorMethod(iteratorMethod))) {
              iterator = getIterator(O2, iteratorMethod);
              next = iterator.next;
              result = IS_CONSTRUCTOR ? new this() : [];
              for (; !(step = next.call(iterator)).done; index2++) {
                value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index2], true) : step.value;
                createProperty(result, index2, value);
              }
            } else {
              length = lengthOfArrayLike(O2);
              result = IS_CONSTRUCTOR ? new this(length) : Array(length);
              for (; length > index2; index2++) {
                value = mapping ? mapfn(O2[index2], index2) : O2[index2];
                createProperty(result, index2, value);
              }
            }
            result.length = index2;
            return result;
          };
        },
        8180: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var toIndexedObject = __webpack_require__2(101);
          var toAbsoluteIndex = __webpack_require__2(7739);
          var lengthOfArrayLike = __webpack_require__2(4104);
          var createMethod = function(IS_INCLUDES) {
            return function($this, el, fromIndex) {
              var O2 = toIndexedObject($this);
              var length = lengthOfArrayLike(O2);
              var index2 = toAbsoluteIndex(fromIndex, length);
              var value;
              if (IS_INCLUDES && el != el)
                while (length > index2) {
                  value = O2[index2++];
                  if (value != value)
                    return true;
                }
              else
                for (; length > index2; index2++) {
                  if ((IS_INCLUDES || index2 in O2) && O2[index2] === el)
                    return IS_INCLUDES || index2 || 0;
                }
              return !IS_INCLUDES && -1;
            };
          };
          module2.exports = {
            includes: createMethod(true),
            indexOf: createMethod(false)
          };
        },
        454: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var bind3 = __webpack_require__2(8043);
          var IndexedObject = __webpack_require__2(2202);
          var toObject2 = __webpack_require__2(1795);
          var lengthOfArrayLike = __webpack_require__2(4104);
          var arraySpeciesCreate = __webpack_require__2(1321);
          var push = [].push;
          var createMethod = function(TYPE) {
            var IS_MAP = TYPE == 1;
            var IS_FILTER = TYPE == 2;
            var IS_SOME = TYPE == 3;
            var IS_EVERY = TYPE == 4;
            var IS_FIND_INDEX = TYPE == 6;
            var IS_FILTER_REJECT = TYPE == 7;
            var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
            return function($this, callbackfn, that, specificCreate) {
              var O2 = toObject2($this);
              var self2 = IndexedObject(O2);
              var boundFunction = bind3(callbackfn, that, 3);
              var length = lengthOfArrayLike(self2);
              var index2 = 0;
              var create2 = specificCreate || arraySpeciesCreate;
              var target = IS_MAP ? create2($this, length) : IS_FILTER || IS_FILTER_REJECT ? create2($this, 0) : void 0;
              var value, result;
              for (; length > index2; index2++)
                if (NO_HOLES || index2 in self2) {
                  value = self2[index2];
                  result = boundFunction(value, index2, O2);
                  if (TYPE) {
                    if (IS_MAP)
                      target[index2] = result;
                    else if (result)
                      switch (TYPE) {
                        case 3:
                          return true;
                        case 5:
                          return value;
                        case 6:
                          return index2;
                        case 2:
                          push.call(target, value);
                      }
                    else
                      switch (TYPE) {
                        case 4:
                          return false;
                        case 7:
                          push.call(target, value);
                      }
                  }
                }
              return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
            };
          };
          module2.exports = {
            forEach: createMethod(0),
            map: createMethod(1),
            filter: createMethod(2),
            some: createMethod(3),
            every: createMethod(4),
            find: createMethod(5),
            findIndex: createMethod(6),
            filterReject: createMethod(7)
          };
        },
        242: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var fails = __webpack_require__2(6192);
          var wellKnownSymbol = __webpack_require__2(8182);
          var V8_VERSION = __webpack_require__2(4218);
          var SPECIES = wellKnownSymbol("species");
          module2.exports = function(METHOD_NAME) {
            return V8_VERSION >= 51 || !fails(function() {
              var array = [];
              var constructor = array.constructor = {};
              constructor[SPECIES] = function() {
                return { foo: 1 };
              };
              return array[METHOD_NAME](Boolean).foo !== 1;
            });
          };
        },
        424: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var fails = __webpack_require__2(6192);
          module2.exports = function(METHOD_NAME, argument) {
            var method = [][METHOD_NAME];
            return !!method && fails(function() {
              method.call(null, argument || function() {
                throw 1;
              }, 1);
            });
          };
        },
        3712: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var isArray2 = __webpack_require__2(4770);
          var isConstructor = __webpack_require__2(2091);
          var isObject2 = __webpack_require__2(5744);
          var wellKnownSymbol = __webpack_require__2(8182);
          var SPECIES = wellKnownSymbol("species");
          module2.exports = function(originalArray) {
            var C;
            if (isArray2(originalArray)) {
              C = originalArray.constructor;
              if (isConstructor(C) && (C === Array || isArray2(C.prototype)))
                C = void 0;
              else if (isObject2(C)) {
                C = C[SPECIES];
                if (C === null)
                  C = void 0;
              }
            }
            return C === void 0 ? Array : C;
          };
        },
        1321: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var arraySpeciesConstructor = __webpack_require__2(3712);
          module2.exports = function(originalArray, length) {
            return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
          };
        },
        1635: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var anObject = __webpack_require__2(1138);
          var iteratorClose = __webpack_require__2(6639);
          module2.exports = function(iterator, fn2, value, ENTRIES) {
            try {
              return ENTRIES ? fn2(anObject(value)[0], value[1]) : fn2(value);
            } catch (error) {
              iteratorClose(iterator, "throw", error);
            }
          };
        },
        9770: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var wellKnownSymbol = __webpack_require__2(8182);
          var ITERATOR = wellKnownSymbol("iterator");
          var SAFE_CLOSING = false;
          try {
            var called = 0;
            var iteratorWithReturn = {
              next: function() {
                return { done: !!called++ };
              },
              "return": function() {
                SAFE_CLOSING = true;
              }
            };
            iteratorWithReturn[ITERATOR] = function() {
              return this;
            };
            Array.from(iteratorWithReturn, function() {
              throw 2;
            });
          } catch (error) {
          }
          module2.exports = function(exec, SKIP_CLOSING) {
            if (!SKIP_CLOSING && !SAFE_CLOSING)
              return false;
            var ITERATION_SUPPORT = false;
            try {
              var object = {};
              object[ITERATOR] = function() {
                return {
                  next: function() {
                    return { done: ITERATION_SUPPORT = true };
                  }
                };
              };
              exec(object);
            } catch (error) {
            }
            return ITERATION_SUPPORT;
          };
        },
        9272: function(module2) {
          var toString3 = {}.toString;
          module2.exports = function(it) {
            return toString3.call(it).slice(8, -1);
          };
        },
        4696: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var TO_STRING_TAG_SUPPORT = __webpack_require__2(3471);
          var isCallable = __webpack_require__2(6447);
          var classofRaw = __webpack_require__2(9272);
          var wellKnownSymbol = __webpack_require__2(8182);
          var TO_STRING_TAG = wellKnownSymbol("toStringTag");
          var CORRECT_ARGUMENTS = classofRaw(function() {
            return arguments;
          }()) == "Arguments";
          var tryGet = function(it, key) {
            try {
              return it[key];
            } catch (error) {
            }
          };
          module2.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
            var O2, tag, result;
            return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O2 = Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O2) : (result = classofRaw(O2)) == "Object" && isCallable(O2.callee) ? "Arguments" : result;
          };
        },
        4635: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var fails = __webpack_require__2(6192);
          module2.exports = !fails(function() {
            function F2() {
            }
            F2.prototype.constructor = null;
            return Object.getPrototypeOf(new F2()) !== F2.prototype;
          });
        },
        5148: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var IteratorPrototype = __webpack_require__2(4413).IteratorPrototype;
          var create2 = __webpack_require__2(2853);
          var createPropertyDescriptor = __webpack_require__2(774);
          var setToStringTag = __webpack_require__2(1284);
          var Iterators = __webpack_require__2(7771);
          var returnThis = function() {
            return this;
          };
          module2.exports = function(IteratorConstructor, NAME2, next) {
            var TO_STRING_TAG = NAME2 + " Iterator";
            IteratorConstructor.prototype = create2(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
            setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
            Iterators[TO_STRING_TAG] = returnThis;
            return IteratorConstructor;
          };
        },
        8711: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var DESCRIPTORS = __webpack_require__2(69);
          var definePropertyModule = __webpack_require__2(2760);
          var createPropertyDescriptor = __webpack_require__2(774);
          module2.exports = DESCRIPTORS ? function(object, key, value) {
            return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
          } : function(object, key, value) {
            object[key] = value;
            return object;
          };
        },
        774: function(module2) {
          module2.exports = function(bitmap, value) {
            return {
              enumerable: !(bitmap & 1),
              configurable: !(bitmap & 2),
              writable: !(bitmap & 4),
              value
            };
          };
        },
        9361: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var toPropertyKey = __webpack_require__2(77);
          var definePropertyModule = __webpack_require__2(2760);
          var createPropertyDescriptor = __webpack_require__2(774);
          module2.exports = function(object, key, value) {
            var propertyKey = toPropertyKey(key);
            if (propertyKey in object)
              definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
            else
              object[propertyKey] = value;
          };
        },
        7218: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var IS_PURE = __webpack_require__2(5546);
          var FunctionName = __webpack_require__2(2282);
          var isCallable = __webpack_require__2(6447);
          var createIteratorConstructor = __webpack_require__2(5148);
          var getPrototypeOf = __webpack_require__2(9341);
          var setPrototypeOf = __webpack_require__2(4469);
          var setToStringTag = __webpack_require__2(1284);
          var createNonEnumerableProperty = __webpack_require__2(8711);
          var redefine = __webpack_require__2(9482);
          var wellKnownSymbol = __webpack_require__2(8182);
          var Iterators = __webpack_require__2(7771);
          var IteratorsCore = __webpack_require__2(4413);
          var PROPER_FUNCTION_NAME = FunctionName.PROPER;
          var CONFIGURABLE_FUNCTION_NAME = FunctionName.CONFIGURABLE;
          var IteratorPrototype = IteratorsCore.IteratorPrototype;
          var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
          var ITERATOR = wellKnownSymbol("iterator");
          var KEYS = "keys";
          var VALUES = "values";
          var ENTRIES = "entries";
          var returnThis = function() {
            return this;
          };
          module2.exports = function(Iterable, NAME2, IteratorConstructor, next, DEFAULT2, IS_SET, FORCED) {
            createIteratorConstructor(IteratorConstructor, NAME2, next);
            var getIterationMethod = function(KIND) {
              if (KIND === DEFAULT2 && defaultIterator)
                return defaultIterator;
              if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype)
                return IterablePrototype[KIND];
              switch (KIND) {
                case KEYS:
                  return function keys2() {
                    return new IteratorConstructor(this, KIND);
                  };
                case VALUES:
                  return function values() {
                    return new IteratorConstructor(this, KIND);
                  };
                case ENTRIES:
                  return function entries() {
                    return new IteratorConstructor(this, KIND);
                  };
              }
              return function() {
                return new IteratorConstructor(this);
              };
            };
            var TO_STRING_TAG = NAME2 + " Iterator";
            var INCORRECT_VALUES_NAME = false;
            var IterablePrototype = Iterable.prototype;
            var nativeIterator = IterablePrototype[ITERATOR] || IterablePrototype["@@iterator"] || DEFAULT2 && IterablePrototype[DEFAULT2];
            var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT2);
            var anyNativeIterator = NAME2 == "Array" ? IterablePrototype.entries || nativeIterator : nativeIterator;
            var CurrentIteratorPrototype, methods, KEY;
            if (anyNativeIterator) {
              CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
              if (CurrentIteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
                if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
                  if (setPrototypeOf) {
                    setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
                  } else if (!isCallable(CurrentIteratorPrototype[ITERATOR])) {
                    redefine(CurrentIteratorPrototype, ITERATOR, returnThis);
                  }
                }
                setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
                if (IS_PURE)
                  Iterators[TO_STRING_TAG] = returnThis;
              }
            }
            if (PROPER_FUNCTION_NAME && DEFAULT2 == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
              if (!IS_PURE && CONFIGURABLE_FUNCTION_NAME) {
                createNonEnumerableProperty(IterablePrototype, "name", VALUES);
              } else {
                INCORRECT_VALUES_NAME = true;
                defaultIterator = function values() {
                  return nativeIterator.call(this);
                };
              }
            }
            if (DEFAULT2) {
              methods = {
                values: getIterationMethod(VALUES),
                keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
                entries: getIterationMethod(ENTRIES)
              };
              if (FORCED)
                for (KEY in methods) {
                  if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                    redefine(IterablePrototype, KEY, methods[KEY]);
                  }
                }
              else
                $2({ target: NAME2, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
            }
            if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
              redefine(IterablePrototype, ITERATOR, defaultIterator, { name: DEFAULT2 });
            }
            Iterators[NAME2] = defaultIterator;
            return methods;
          };
        },
        1488: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var path = __webpack_require__2(7545);
          var hasOwn = __webpack_require__2(4500);
          var wrappedWellKnownSymbolModule = __webpack_require__2(9207);
          var defineProperty = __webpack_require__2(2760).f;
          module2.exports = function(NAME2) {
            var Symbol2 = path.Symbol || (path.Symbol = {});
            if (!hasOwn(Symbol2, NAME2))
              defineProperty(Symbol2, NAME2, {
                value: wrappedWellKnownSymbolModule.f(NAME2)
              });
          };
        },
        69: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var fails = __webpack_require__2(6192);
          module2.exports = !fails(function() {
            return Object.defineProperty({}, 1, { get: function() {
              return 7;
            } })[1] != 7;
          });
        },
        7449: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var global2 = __webpack_require__2(8576);
          var isObject2 = __webpack_require__2(5744);
          var document2 = global2.document;
          var EXISTS = isObject2(document2) && isObject2(document2.createElement);
          module2.exports = function(it) {
            return EXISTS ? document2.createElement(it) : {};
          };
        },
        7365: function(module2) {
          module2.exports = {
            CSSRuleList: 0,
            CSSStyleDeclaration: 0,
            CSSValueList: 0,
            ClientRectList: 0,
            DOMRectList: 0,
            DOMStringList: 0,
            DOMTokenList: 1,
            DataTransferItemList: 0,
            FileList: 0,
            HTMLAllCollection: 0,
            HTMLCollection: 0,
            HTMLFormElement: 0,
            HTMLSelectElement: 0,
            MediaList: 0,
            MimeTypeArray: 0,
            NamedNodeMap: 0,
            NodeList: 1,
            PaintRequestList: 0,
            Plugin: 0,
            PluginArray: 0,
            SVGLengthList: 0,
            SVGNumberList: 0,
            SVGPathSegList: 0,
            SVGPointList: 0,
            SVGStringList: 0,
            SVGTransformList: 0,
            SourceBufferList: 0,
            StyleSheetList: 0,
            TextTrackCueList: 0,
            TextTrackList: 0,
            TouchList: 0
          };
        },
        2957: function(module2) {
          module2.exports = typeof window == "object";
        },
        9347: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var userAgent2 = __webpack_require__2(8989);
          var global2 = __webpack_require__2(8576);
          module2.exports = /ipad|iphone|ipod/i.test(userAgent2) && global2.Pebble !== void 0;
        },
        9536: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var userAgent2 = __webpack_require__2(8989);
          module2.exports = /(?:ipad|iphone|ipod).*applewebkit/i.test(userAgent2);
        },
        224: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var classof = __webpack_require__2(9272);
          var global2 = __webpack_require__2(8576);
          module2.exports = classof(global2.process) == "process";
        },
        5914: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var userAgent2 = __webpack_require__2(8989);
          module2.exports = /web0s(?!.*chrome)/i.test(userAgent2);
        },
        8989: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var getBuiltIn = __webpack_require__2(150);
          module2.exports = getBuiltIn("navigator", "userAgent") || "";
        },
        4218: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var global2 = __webpack_require__2(8576);
          var userAgent2 = __webpack_require__2(8989);
          var process2 = global2.process;
          var Deno = global2.Deno;
          var versions = process2 && process2.versions || Deno && Deno.version;
          var v8 = versions && versions.v8;
          var match, version2;
          if (v8) {
            match = v8.split(".");
            version2 = match[0] < 4 ? 1 : match[0] + match[1];
          } else if (userAgent2) {
            match = userAgent2.match(/Edge\/(\d+)/);
            if (!match || match[1] >= 74) {
              match = userAgent2.match(/Chrome\/(\d+)/);
              if (match)
                version2 = match[1];
            }
          }
          module2.exports = version2 && +version2;
        },
        5607: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var path = __webpack_require__2(7545);
          module2.exports = function(CONSTRUCTOR) {
            return path[CONSTRUCTOR + "Prototype"];
          };
        },
        2952: function(module2) {
          module2.exports = [
            "constructor",
            "hasOwnProperty",
            "isPrototypeOf",
            "propertyIsEnumerable",
            "toLocaleString",
            "toString",
            "valueOf"
          ];
        },
        3085: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var global2 = __webpack_require__2(8576);
          var isCallable = __webpack_require__2(6447);
          var getOwnPropertyDescriptor = __webpack_require__2(5141).f;
          var isForced = __webpack_require__2(9245);
          var path = __webpack_require__2(7545);
          var bind3 = __webpack_require__2(8043);
          var createNonEnumerableProperty = __webpack_require__2(8711);
          var hasOwn = __webpack_require__2(4500);
          var wrapConstructor = function(NativeConstructor) {
            var Wrapper = function(a2, b, c) {
              if (this instanceof NativeConstructor) {
                switch (arguments.length) {
                  case 0:
                    return new NativeConstructor();
                  case 1:
                    return new NativeConstructor(a2);
                  case 2:
                    return new NativeConstructor(a2, b);
                }
                return new NativeConstructor(a2, b, c);
              }
              return NativeConstructor.apply(this, arguments);
            };
            Wrapper.prototype = NativeConstructor.prototype;
            return Wrapper;
          };
          module2.exports = function(options, source2) {
            var TARGET = options.target;
            var GLOBAL = options.global;
            var STATIC = options.stat;
            var PROTO = options.proto;
            var nativeSource = GLOBAL ? global2 : STATIC ? global2[TARGET] : (global2[TARGET] || {}).prototype;
            var target = GLOBAL ? path : path[TARGET] || createNonEnumerableProperty(path, TARGET, {})[TARGET];
            var targetPrototype = target.prototype;
            var FORCED, USE_NATIVE, VIRTUAL_PROTOTYPE;
            var key, sourceProperty, targetProperty, nativeProperty, resultProperty, descriptor;
            for (key in source2) {
              FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
              USE_NATIVE = !FORCED && nativeSource && hasOwn(nativeSource, key);
              targetProperty = target[key];
              if (USE_NATIVE)
                if (options.noTargetGet) {
                  descriptor = getOwnPropertyDescriptor(nativeSource, key);
                  nativeProperty = descriptor && descriptor.value;
                } else
                  nativeProperty = nativeSource[key];
              sourceProperty = USE_NATIVE && nativeProperty ? nativeProperty : source2[key];
              if (USE_NATIVE && typeof targetProperty === typeof sourceProperty)
                continue;
              if (options.bind && USE_NATIVE)
                resultProperty = bind3(sourceProperty, global2);
              else if (options.wrap && USE_NATIVE)
                resultProperty = wrapConstructor(sourceProperty);
              else if (PROTO && isCallable(sourceProperty))
                resultProperty = bind3(Function.call, sourceProperty);
              else
                resultProperty = sourceProperty;
              if (options.sham || sourceProperty && sourceProperty.sham || targetProperty && targetProperty.sham) {
                createNonEnumerableProperty(resultProperty, "sham", true);
              }
              createNonEnumerableProperty(target, key, resultProperty);
              if (PROTO) {
                VIRTUAL_PROTOTYPE = TARGET + "Prototype";
                if (!hasOwn(path, VIRTUAL_PROTOTYPE)) {
                  createNonEnumerableProperty(path, VIRTUAL_PROTOTYPE, {});
                }
                createNonEnumerableProperty(path[VIRTUAL_PROTOTYPE], key, sourceProperty);
                if (options.real && targetPrototype && !targetPrototype[key]) {
                  createNonEnumerableProperty(targetPrototype, key, sourceProperty);
                }
              }
            }
          };
        },
        6192: function(module2) {
          module2.exports = function(exec) {
            try {
              return !!exec();
            } catch (error) {
              return true;
            }
          };
        },
        8043: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var aCallable = __webpack_require__2(6235);
          module2.exports = function(fn2, that, length) {
            aCallable(fn2);
            if (that === void 0)
              return fn2;
            switch (length) {
              case 0:
                return function() {
                  return fn2.call(that);
                };
              case 1:
                return function(a2) {
                  return fn2.call(that, a2);
                };
              case 2:
                return function(a2, b) {
                  return fn2.call(that, a2, b);
                };
              case 3:
                return function(a2, b, c) {
                  return fn2.call(that, a2, b, c);
                };
            }
            return function() {
              return fn2.apply(that, arguments);
            };
          };
        },
        6782: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var aCallable = __webpack_require__2(6235);
          var isObject2 = __webpack_require__2(5744);
          var slice = [].slice;
          var factories = {};
          var construct = function(C, argsLength, args) {
            if (!(argsLength in factories)) {
              for (var list = [], i = 0; i < argsLength; i++)
                list[i] = "a[" + i + "]";
              factories[argsLength] = Function("C,a", "return new C(" + list.join(",") + ")");
            }
            return factories[argsLength](C, args);
          };
          module2.exports = Function.bind || function bind3(that) {
            var fn2 = aCallable(this);
            var partArgs = slice.call(arguments, 1);
            var boundFunction = function bound() {
              var args = partArgs.concat(slice.call(arguments));
              return this instanceof boundFunction ? construct(fn2, args.length, args) : fn2.apply(that, args);
            };
            if (isObject2(fn2.prototype))
              boundFunction.prototype = fn2.prototype;
            return boundFunction;
          };
        },
        2282: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var DESCRIPTORS = __webpack_require__2(69);
          var hasOwn = __webpack_require__2(4500);
          var FunctionPrototype = Function.prototype;
          var getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;
          var EXISTS = hasOwn(FunctionPrototype, "name");
          var PROPER = EXISTS && function something() {
          }.name === "something";
          var CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, "name").configurable);
          module2.exports = {
            EXISTS,
            PROPER,
            CONFIGURABLE
          };
        },
        150: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var path = __webpack_require__2(7545);
          var global2 = __webpack_require__2(8576);
          var isCallable = __webpack_require__2(6447);
          var aFunction = function(variable) {
            return isCallable(variable) ? variable : void 0;
          };
          module2.exports = function(namespace, method) {
            return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global2[namespace]) : path[namespace] && path[namespace][method] || global2[namespace] && global2[namespace][method];
          };
        },
        8703: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var classof = __webpack_require__2(4696);
          var getMethod = __webpack_require__2(5037);
          var Iterators = __webpack_require__2(7771);
          var wellKnownSymbol = __webpack_require__2(8182);
          var ITERATOR = wellKnownSymbol("iterator");
          module2.exports = function(it) {
            if (it != void 0)
              return getMethod(it, ITERATOR) || getMethod(it, "@@iterator") || Iterators[classof(it)];
          };
        },
        1669: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var aCallable = __webpack_require__2(6235);
          var anObject = __webpack_require__2(1138);
          var getIteratorMethod = __webpack_require__2(8703);
          module2.exports = function(argument, usingIterator) {
            var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;
            if (aCallable(iteratorMethod))
              return anObject(iteratorMethod.call(argument));
            throw TypeError(String(argument) + " is not iterable");
          };
        },
        5037: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var aCallable = __webpack_require__2(6235);
          module2.exports = function(V2, P2) {
            var func = V2[P2];
            return func == null ? void 0 : aCallable(func);
          };
        },
        8576: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var check = function(it) {
            return it && it.Math == Math && it;
          };
          module2.exports = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof __webpack_require__2.g == "object" && __webpack_require__2.g) || function() {
            return this;
          }() || Function("return this")();
        },
        4500: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var toObject2 = __webpack_require__2(1795);
          var hasOwnProperty = {}.hasOwnProperty;
          module2.exports = Object.hasOwn || function hasOwn(it, key) {
            return hasOwnProperty.call(toObject2(it), key);
          };
        },
        4535: function(module2) {
          module2.exports = {};
        },
        3681: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var global2 = __webpack_require__2(8576);
          module2.exports = function(a2, b) {
            var console2 = global2.console;
            if (console2 && console2.error) {
              arguments.length === 1 ? console2.error(a2) : console2.error(a2, b);
            }
          };
        },
        7403: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var getBuiltIn = __webpack_require__2(150);
          module2.exports = getBuiltIn("document", "documentElement");
        },
        188: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var DESCRIPTORS = __webpack_require__2(69);
          var fails = __webpack_require__2(6192);
          var createElement2 = __webpack_require__2(7449);
          module2.exports = !DESCRIPTORS && !fails(function() {
            return Object.defineProperty(createElement2("div"), "a", {
              get: function() {
                return 7;
              }
            }).a != 7;
          });
        },
        2202: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var fails = __webpack_require__2(6192);
          var classof = __webpack_require__2(9272);
          var split = "".split;
          module2.exports = fails(function() {
            return !Object("z").propertyIsEnumerable(0);
          }) ? function(it) {
            return classof(it) == "String" ? split.call(it, "") : Object(it);
          } : Object;
        },
        9516: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var isCallable = __webpack_require__2(6447);
          var store = __webpack_require__2(6434);
          var functionToString = Function.toString;
          if (!isCallable(store.inspectSource)) {
            store.inspectSource = function(it) {
              return functionToString.call(it);
            };
          }
          module2.exports = store.inspectSource;
        },
        273: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var isObject2 = __webpack_require__2(5744);
          var createNonEnumerableProperty = __webpack_require__2(8711);
          module2.exports = function(O2, options) {
            if (isObject2(options) && "cause" in options) {
              createNonEnumerableProperty(O2, "cause", O2.cause);
            }
          };
        },
        3326: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var NATIVE_WEAK_MAP = __webpack_require__2(8921);
          var global2 = __webpack_require__2(8576);
          var isObject2 = __webpack_require__2(5744);
          var createNonEnumerableProperty = __webpack_require__2(8711);
          var hasOwn = __webpack_require__2(4500);
          var shared = __webpack_require__2(6434);
          var sharedKey = __webpack_require__2(9766);
          var hiddenKeys = __webpack_require__2(4535);
          var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
          var WeakMap2 = global2.WeakMap;
          var set, get, has;
          var enforce = function(it) {
            return has(it) ? get(it) : set(it, {});
          };
          var getterFor = function(TYPE) {
            return function(it) {
              var state;
              if (!isObject2(it) || (state = get(it)).type !== TYPE) {
                throw TypeError("Incompatible receiver, " + TYPE + " required");
              }
              return state;
            };
          };
          if (NATIVE_WEAK_MAP || shared.state) {
            var store = shared.state || (shared.state = new WeakMap2());
            var wmget = store.get;
            var wmhas = store.has;
            var wmset = store.set;
            set = function(it, metadata) {
              if (wmhas.call(store, it))
                throw new TypeError(OBJECT_ALREADY_INITIALIZED);
              metadata.facade = it;
              wmset.call(store, it, metadata);
              return metadata;
            };
            get = function(it) {
              return wmget.call(store, it) || {};
            };
            has = function(it) {
              return wmhas.call(store, it);
            };
          } else {
            var STATE = sharedKey("state");
            hiddenKeys[STATE] = true;
            set = function(it, metadata) {
              if (hasOwn(it, STATE))
                throw new TypeError(OBJECT_ALREADY_INITIALIZED);
              metadata.facade = it;
              createNonEnumerableProperty(it, STATE, metadata);
              return metadata;
            };
            get = function(it) {
              return hasOwn(it, STATE) ? it[STATE] : {};
            };
            has = function(it) {
              return hasOwn(it, STATE);
            };
          }
          module2.exports = {
            set,
            get,
            has,
            enforce,
            getterFor
          };
        },
        6109: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var wellKnownSymbol = __webpack_require__2(8182);
          var Iterators = __webpack_require__2(7771);
          var ITERATOR = wellKnownSymbol("iterator");
          var ArrayPrototype = Array.prototype;
          module2.exports = function(it) {
            return it !== void 0 && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
          };
        },
        4770: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var classof = __webpack_require__2(9272);
          module2.exports = Array.isArray || function isArray2(argument) {
            return classof(argument) == "Array";
          };
        },
        6447: function(module2) {
          module2.exports = function(argument) {
            return typeof argument === "function";
          };
        },
        2091: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var fails = __webpack_require__2(6192);
          var isCallable = __webpack_require__2(6447);
          var classof = __webpack_require__2(4696);
          var getBuiltIn = __webpack_require__2(150);
          var inspectSource = __webpack_require__2(9516);
          var empty = [];
          var construct = getBuiltIn("Reflect", "construct");
          var constructorRegExp = /^\s*(?:class|function)\b/;
          var exec = constructorRegExp.exec;
          var INCORRECT_TO_STRING = !constructorRegExp.exec(function() {
          });
          var isConstructorModern = function(argument) {
            if (!isCallable(argument))
              return false;
            try {
              construct(Object, empty, argument);
              return true;
            } catch (error) {
              return false;
            }
          };
          var isConstructorLegacy = function(argument) {
            if (!isCallable(argument))
              return false;
            switch (classof(argument)) {
              case "AsyncFunction":
              case "GeneratorFunction":
              case "AsyncGeneratorFunction":
                return false;
            }
            return INCORRECT_TO_STRING || !!exec.call(constructorRegExp, inspectSource(argument));
          };
          module2.exports = !construct || fails(function() {
            var called;
            return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
              called = true;
            }) || called;
          }) ? isConstructorLegacy : isConstructorModern;
        },
        9245: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var fails = __webpack_require__2(6192);
          var isCallable = __webpack_require__2(6447);
          var replacement = /#|\.prototype\./;
          var isForced = function(feature, detection) {
            var value = data[normalize2(feature)];
            return value == POLYFILL ? true : value == NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;
          };
          var normalize2 = isForced.normalize = function(string) {
            return String(string).replace(replacement, ".").toLowerCase();
          };
          var data = isForced.data = {};
          var NATIVE = isForced.NATIVE = "N";
          var POLYFILL = isForced.POLYFILL = "P";
          module2.exports = isForced;
        },
        5744: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var isCallable = __webpack_require__2(6447);
          module2.exports = function(it) {
            return typeof it === "object" ? it !== null : isCallable(it);
          };
        },
        5546: function(module2) {
          module2.exports = true;
        },
        3236: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var isCallable = __webpack_require__2(6447);
          var getBuiltIn = __webpack_require__2(150);
          var USE_SYMBOL_AS_UID = __webpack_require__2(615);
          module2.exports = USE_SYMBOL_AS_UID ? function(it) {
            return typeof it == "symbol";
          } : function(it) {
            var $Symbol = getBuiltIn("Symbol");
            return isCallable($Symbol) && Object(it) instanceof $Symbol;
          };
        },
        3442: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var anObject = __webpack_require__2(1138);
          var isArrayIteratorMethod = __webpack_require__2(6109);
          var lengthOfArrayLike = __webpack_require__2(4104);
          var bind3 = __webpack_require__2(8043);
          var getIterator = __webpack_require__2(1669);
          var getIteratorMethod = __webpack_require__2(8703);
          var iteratorClose = __webpack_require__2(6639);
          var Result2 = function(stopped, result) {
            this.stopped = stopped;
            this.result = result;
          };
          module2.exports = function(iterable, unboundFunction, options) {
            var that = options && options.that;
            var AS_ENTRIES = !!(options && options.AS_ENTRIES);
            var IS_ITERATOR = !!(options && options.IS_ITERATOR);
            var INTERRUPTED = !!(options && options.INTERRUPTED);
            var fn2 = bind3(unboundFunction, that, 1 + AS_ENTRIES + INTERRUPTED);
            var iterator, iterFn, index2, length, result, next, step;
            var stop = function(condition) {
              if (iterator)
                iteratorClose(iterator, "normal", condition);
              return new Result2(true, condition);
            };
            var callFn = function(value) {
              if (AS_ENTRIES) {
                anObject(value);
                return INTERRUPTED ? fn2(value[0], value[1], stop) : fn2(value[0], value[1]);
              }
              return INTERRUPTED ? fn2(value, stop) : fn2(value);
            };
            if (IS_ITERATOR) {
              iterator = iterable;
            } else {
              iterFn = getIteratorMethod(iterable);
              if (!iterFn)
                throw TypeError(String(iterable) + " is not iterable");
              if (isArrayIteratorMethod(iterFn)) {
                for (index2 = 0, length = lengthOfArrayLike(iterable); length > index2; index2++) {
                  result = callFn(iterable[index2]);
                  if (result && result instanceof Result2)
                    return result;
                }
                return new Result2(false);
              }
              iterator = getIterator(iterable, iterFn);
            }
            next = iterator.next;
            while (!(step = next.call(iterator)).done) {
              try {
                result = callFn(step.value);
              } catch (error) {
                iteratorClose(iterator, "throw", error);
              }
              if (typeof result == "object" && result && result instanceof Result2)
                return result;
            }
            return new Result2(false);
          };
        },
        6639: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var anObject = __webpack_require__2(1138);
          var getMethod = __webpack_require__2(5037);
          module2.exports = function(iterator, kind, value) {
            var innerResult, innerError;
            anObject(iterator);
            try {
              innerResult = getMethod(iterator, "return");
              if (!innerResult) {
                if (kind === "throw")
                  throw value;
                return value;
              }
              innerResult = innerResult.call(iterator);
            } catch (error) {
              innerError = true;
              innerResult = error;
            }
            if (kind === "throw")
              throw value;
            if (innerError)
              throw innerResult;
            anObject(innerResult);
            return value;
          };
        },
        4413: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var fails = __webpack_require__2(6192);
          var isCallable = __webpack_require__2(6447);
          var create2 = __webpack_require__2(2853);
          var getPrototypeOf = __webpack_require__2(9341);
          var redefine = __webpack_require__2(9482);
          var wellKnownSymbol = __webpack_require__2(8182);
          var IS_PURE = __webpack_require__2(5546);
          var ITERATOR = wellKnownSymbol("iterator");
          var BUGGY_SAFARI_ITERATORS = false;
          var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;
          if ([].keys) {
            arrayIterator = [].keys();
            if (!("next" in arrayIterator))
              BUGGY_SAFARI_ITERATORS = true;
            else {
              PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
              if (PrototypeOfArrayIteratorPrototype !== Object.prototype)
                IteratorPrototype = PrototypeOfArrayIteratorPrototype;
            }
          }
          var NEW_ITERATOR_PROTOTYPE = IteratorPrototype == void 0 || fails(function() {
            var test = {};
            return IteratorPrototype[ITERATOR].call(test) !== test;
          });
          if (NEW_ITERATOR_PROTOTYPE)
            IteratorPrototype = {};
          else if (IS_PURE)
            IteratorPrototype = create2(IteratorPrototype);
          if (!isCallable(IteratorPrototype[ITERATOR])) {
            redefine(IteratorPrototype, ITERATOR, function() {
              return this;
            });
          }
          module2.exports = {
            IteratorPrototype,
            BUGGY_SAFARI_ITERATORS
          };
        },
        7771: function(module2) {
          module2.exports = {};
        },
        4104: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var toLength = __webpack_require__2(8445);
          module2.exports = function(obj) {
            return toLength(obj.length);
          };
        },
        2950: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var global2 = __webpack_require__2(8576);
          var getOwnPropertyDescriptor = __webpack_require__2(5141).f;
          var macrotask = __webpack_require__2(7160).set;
          var IS_IOS = __webpack_require__2(9536);
          var IS_IOS_PEBBLE = __webpack_require__2(9347);
          var IS_WEBOS_WEBKIT = __webpack_require__2(5914);
          var IS_NODE = __webpack_require__2(224);
          var MutationObserver2 = global2.MutationObserver || global2.WebKitMutationObserver;
          var document2 = global2.document;
          var process2 = global2.process;
          var Promise2 = global2.Promise;
          var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global2, "queueMicrotask");
          var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;
          var flush, head, last, notify, toggle, node, promise, then;
          if (!queueMicrotask) {
            flush = function() {
              var parent, fn2;
              if (IS_NODE && (parent = process2.domain))
                parent.exit();
              while (head) {
                fn2 = head.fn;
                head = head.next;
                try {
                  fn2();
                } catch (error) {
                  if (head)
                    notify();
                  else
                    last = void 0;
                  throw error;
                }
              }
              last = void 0;
              if (parent)
                parent.enter();
            };
            if (!IS_IOS && !IS_NODE && !IS_WEBOS_WEBKIT && MutationObserver2 && document2) {
              toggle = true;
              node = document2.createTextNode("");
              new MutationObserver2(flush).observe(node, { characterData: true });
              notify = function() {
                node.data = toggle = !toggle;
              };
            } else if (!IS_IOS_PEBBLE && Promise2 && Promise2.resolve) {
              promise = Promise2.resolve(void 0);
              promise.constructor = Promise2;
              then = promise.then;
              notify = function() {
                then.call(promise, flush);
              };
            } else if (IS_NODE) {
              notify = function() {
                process2.nextTick(flush);
              };
            } else {
              notify = function() {
                macrotask.call(global2, flush);
              };
            }
          }
          module2.exports = queueMicrotask || function(fn2) {
            var task = { fn: fn2, next: void 0 };
            if (last)
              last.next = task;
            if (!head) {
              head = task;
              notify();
            }
            last = task;
          };
        },
        4471: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var global2 = __webpack_require__2(8576);
          module2.exports = global2.Promise;
        },
        3045: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var V8_VERSION = __webpack_require__2(4218);
          var fails = __webpack_require__2(6192);
          module2.exports = !!Object.getOwnPropertySymbols && !fails(function() {
            var symbol = Symbol();
            return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
          });
        },
        4551: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var fails = __webpack_require__2(6192);
          var wellKnownSymbol = __webpack_require__2(8182);
          var IS_PURE = __webpack_require__2(5546);
          var ITERATOR = wellKnownSymbol("iterator");
          module2.exports = !fails(function() {
            var url = new URL("b?a=1&b=2&c=3", "http://a");
            var searchParams = url.searchParams;
            var result = "";
            url.pathname = "c%20d";
            searchParams.forEach(function(value, key) {
              searchParams["delete"]("b");
              result += key + value;
            });
            return IS_PURE && !url.toJSON || !searchParams.sort || url.href !== "http://a/c%20d?a=1&c=3" || searchParams.get("c") !== "3" || String(new URLSearchParams("?a=1")) !== "a=1" || !searchParams[ITERATOR] || new URL("https://a@b").username !== "a" || new URLSearchParams(new URLSearchParams("a=b")).get("a") !== "b" || new URL("http://\u0442\u0435\u0441\u0442").host !== "xn--e1aybc" || new URL("http://a#\u0431").hash !== "#%D0%B1" || result !== "a1c3" || new URL("http://x", void 0).host !== "x";
          });
        },
        8921: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var global2 = __webpack_require__2(8576);
          var isCallable = __webpack_require__2(6447);
          var inspectSource = __webpack_require__2(9516);
          var WeakMap2 = global2.WeakMap;
          module2.exports = isCallable(WeakMap2) && /native code/.test(inspectSource(WeakMap2));
        },
        9438: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var aCallable = __webpack_require__2(6235);
          var PromiseCapability = function(C) {
            var resolve, reject;
            this.promise = new C(function($$resolve, $$reject) {
              if (resolve !== void 0 || reject !== void 0)
                throw TypeError("Bad Promise constructor");
              resolve = $$resolve;
              reject = $$reject;
            });
            this.resolve = aCallable(resolve);
            this.reject = aCallable(reject);
          };
          module2.exports.f = function(C) {
            return new PromiseCapability(C);
          };
        },
        15: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var global2 = __webpack_require__2(8576);
          var fails = __webpack_require__2(6192);
          var toString3 = __webpack_require__2(4845);
          var trim2 = __webpack_require__2(4277).trim;
          var whitespaces = __webpack_require__2(1450);
          var $parseFloat = global2.parseFloat;
          var Symbol2 = global2.Symbol;
          var ITERATOR = Symbol2 && Symbol2.iterator;
          var FORCED = 1 / $parseFloat(whitespaces + "-0") !== -Infinity || ITERATOR && !fails(function() {
            $parseFloat(Object(ITERATOR));
          });
          module2.exports = FORCED ? function parseFloat2(string) {
            var trimmedString = trim2(toString3(string));
            var result = $parseFloat(trimmedString);
            return result === 0 && trimmedString.charAt(0) == "-" ? -0 : result;
          } : $parseFloat;
        },
        2558: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var global2 = __webpack_require__2(8576);
          var fails = __webpack_require__2(6192);
          var toString3 = __webpack_require__2(4845);
          var trim2 = __webpack_require__2(4277).trim;
          var whitespaces = __webpack_require__2(1450);
          var $parseInt = global2.parseInt;
          var Symbol2 = global2.Symbol;
          var ITERATOR = Symbol2 && Symbol2.iterator;
          var hex = /^[+-]?0[Xx]/;
          var FORCED = $parseInt(whitespaces + "08") !== 8 || $parseInt(whitespaces + "0x16") !== 22 || ITERATOR && !fails(function() {
            $parseInt(Object(ITERATOR));
          });
          module2.exports = FORCED ? function parseInt2(string, radix) {
            var S = trim2(toString3(string));
            return $parseInt(S, radix >>> 0 || (hex.test(S) ? 16 : 10));
          } : $parseInt;
        },
        2503: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var DESCRIPTORS = __webpack_require__2(69);
          var fails = __webpack_require__2(6192);
          var objectKeys = __webpack_require__2(7653);
          var getOwnPropertySymbolsModule = __webpack_require__2(4750);
          var propertyIsEnumerableModule = __webpack_require__2(6007);
          var toObject2 = __webpack_require__2(1795);
          var IndexedObject = __webpack_require__2(2202);
          var $assign = Object.assign;
          var defineProperty = Object.defineProperty;
          module2.exports = !$assign || fails(function() {
            if (DESCRIPTORS && $assign({ b: 1 }, $assign(defineProperty({}, "a", {
              enumerable: true,
              get: function() {
                defineProperty(this, "b", {
                  value: 3,
                  enumerable: false
                });
              }
            }), { b: 2 })).b !== 1)
              return true;
            var A2 = {};
            var B3 = {};
            var symbol = Symbol();
            var alphabet = "abcdefghijklmnopqrst";
            A2[symbol] = 7;
            alphabet.split("").forEach(function(chr) {
              B3[chr] = chr;
            });
            return $assign({}, A2)[symbol] != 7 || objectKeys($assign({}, B3)).join("") != alphabet;
          }) ? function assign(target, source2) {
            var T2 = toObject2(target);
            var argumentsLength = arguments.length;
            var index2 = 1;
            var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
            var propertyIsEnumerable = propertyIsEnumerableModule.f;
            while (argumentsLength > index2) {
              var S = IndexedObject(arguments[index2++]);
              var keys2 = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
              var length = keys2.length;
              var j2 = 0;
              var key;
              while (length > j2) {
                key = keys2[j2++];
                if (!DESCRIPTORS || propertyIsEnumerable.call(S, key))
                  T2[key] = S[key];
              }
            }
            return T2;
          } : $assign;
        },
        2853: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var anObject = __webpack_require__2(1138);
          var defineProperties = __webpack_require__2(1187);
          var enumBugKeys = __webpack_require__2(2952);
          var hiddenKeys = __webpack_require__2(4535);
          var html = __webpack_require__2(7403);
          var documentCreateElement = __webpack_require__2(7449);
          var sharedKey = __webpack_require__2(9766);
          var GT = ">";
          var LT = "<";
          var PROTOTYPE = "prototype";
          var SCRIPT = "script";
          var IE_PROTO = sharedKey("IE_PROTO");
          var EmptyConstructor = function() {
          };
          var scriptTag = function(content2) {
            return LT + SCRIPT + GT + content2 + LT + "/" + SCRIPT + GT;
          };
          var NullProtoObjectViaActiveX = function(activeXDocument2) {
            activeXDocument2.write(scriptTag(""));
            activeXDocument2.close();
            var temp = activeXDocument2.parentWindow.Object;
            activeXDocument2 = null;
            return temp;
          };
          var NullProtoObjectViaIFrame = function() {
            var iframe = documentCreateElement("iframe");
            var JS = "java" + SCRIPT + ":";
            var iframeDocument;
            iframe.style.display = "none";
            html.appendChild(iframe);
            iframe.src = String(JS);
            iframeDocument = iframe.contentWindow.document;
            iframeDocument.open();
            iframeDocument.write(scriptTag("document.F=Object"));
            iframeDocument.close();
            return iframeDocument.F;
          };
          var activeXDocument;
          var NullProtoObject = function() {
            try {
              activeXDocument = new ActiveXObject("htmlfile");
            } catch (error) {
            }
            NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
            var length = enumBugKeys.length;
            while (length--)
              delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
            return NullProtoObject();
          };
          hiddenKeys[IE_PROTO] = true;
          module2.exports = Object.create || function create2(O2, Properties2) {
            var result;
            if (O2 !== null) {
              EmptyConstructor[PROTOTYPE] = anObject(O2);
              result = new EmptyConstructor();
              EmptyConstructor[PROTOTYPE] = null;
              result[IE_PROTO] = O2;
            } else
              result = NullProtoObject();
            return Properties2 === void 0 ? result : defineProperties(result, Properties2);
          };
        },
        1187: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var DESCRIPTORS = __webpack_require__2(69);
          var definePropertyModule = __webpack_require__2(2760);
          var anObject = __webpack_require__2(1138);
          var objectKeys = __webpack_require__2(7653);
          module2.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O2, Properties2) {
            anObject(O2);
            var keys2 = objectKeys(Properties2);
            var length = keys2.length;
            var index2 = 0;
            var key;
            while (length > index2)
              definePropertyModule.f(O2, key = keys2[index2++], Properties2[key]);
            return O2;
          };
        },
        2760: function(__unused_webpack_module, exports2, __webpack_require__2) {
          var DESCRIPTORS = __webpack_require__2(69);
          var IE8_DOM_DEFINE = __webpack_require__2(188);
          var anObject = __webpack_require__2(1138);
          var toPropertyKey = __webpack_require__2(77);
          var $defineProperty = Object.defineProperty;
          exports2.f = DESCRIPTORS ? $defineProperty : function defineProperty(O2, P2, Attributes) {
            anObject(O2);
            P2 = toPropertyKey(P2);
            anObject(Attributes);
            if (IE8_DOM_DEFINE)
              try {
                return $defineProperty(O2, P2, Attributes);
              } catch (error) {
              }
            if ("get" in Attributes || "set" in Attributes)
              throw TypeError("Accessors not supported");
            if ("value" in Attributes)
              O2[P2] = Attributes.value;
            return O2;
          };
        },
        5141: function(__unused_webpack_module, exports2, __webpack_require__2) {
          var DESCRIPTORS = __webpack_require__2(69);
          var propertyIsEnumerableModule = __webpack_require__2(6007);
          var createPropertyDescriptor = __webpack_require__2(774);
          var toIndexedObject = __webpack_require__2(101);
          var toPropertyKey = __webpack_require__2(77);
          var hasOwn = __webpack_require__2(4500);
          var IE8_DOM_DEFINE = __webpack_require__2(188);
          var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          exports2.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O2, P2) {
            O2 = toIndexedObject(O2);
            P2 = toPropertyKey(P2);
            if (IE8_DOM_DEFINE)
              try {
                return $getOwnPropertyDescriptor(O2, P2);
              } catch (error) {
              }
            if (hasOwn(O2, P2))
              return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O2, P2), O2[P2]);
          };
        },
        4052: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var toIndexedObject = __webpack_require__2(101);
          var $getOwnPropertyNames = __webpack_require__2(2092).f;
          var toString3 = {}.toString;
          var windowNames = typeof window == "object" && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];
          var getWindowNames = function(it) {
            try {
              return $getOwnPropertyNames(it);
            } catch (error) {
              return windowNames.slice();
            }
          };
          module2.exports.f = function getOwnPropertyNames(it) {
            return windowNames && toString3.call(it) == "[object Window]" ? getWindowNames(it) : $getOwnPropertyNames(toIndexedObject(it));
          };
        },
        2092: function(__unused_webpack_module, exports2, __webpack_require__2) {
          var internalObjectKeys = __webpack_require__2(7934);
          var enumBugKeys = __webpack_require__2(2952);
          var hiddenKeys = enumBugKeys.concat("length", "prototype");
          exports2.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O2) {
            return internalObjectKeys(O2, hiddenKeys);
          };
        },
        4750: function(__unused_webpack_module, exports2) {
          exports2.f = Object.getOwnPropertySymbols;
        },
        9341: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var hasOwn = __webpack_require__2(4500);
          var isCallable = __webpack_require__2(6447);
          var toObject2 = __webpack_require__2(1795);
          var sharedKey = __webpack_require__2(9766);
          var CORRECT_PROTOTYPE_GETTER = __webpack_require__2(4635);
          var IE_PROTO = sharedKey("IE_PROTO");
          var ObjectPrototype = Object.prototype;
          module2.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O2) {
            var object = toObject2(O2);
            if (hasOwn(object, IE_PROTO))
              return object[IE_PROTO];
            var constructor = object.constructor;
            if (isCallable(constructor) && object instanceof constructor) {
              return constructor.prototype;
            }
            return object instanceof Object ? ObjectPrototype : null;
          };
        },
        7934: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var hasOwn = __webpack_require__2(4500);
          var toIndexedObject = __webpack_require__2(101);
          var indexOf = __webpack_require__2(8180).indexOf;
          var hiddenKeys = __webpack_require__2(4535);
          module2.exports = function(object, names) {
            var O2 = toIndexedObject(object);
            var i = 0;
            var result = [];
            var key;
            for (key in O2)
              !hasOwn(hiddenKeys, key) && hasOwn(O2, key) && result.push(key);
            while (names.length > i)
              if (hasOwn(O2, key = names[i++])) {
                ~indexOf(result, key) || result.push(key);
              }
            return result;
          };
        },
        7653: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var internalObjectKeys = __webpack_require__2(7934);
          var enumBugKeys = __webpack_require__2(2952);
          module2.exports = Object.keys || function keys2(O2) {
            return internalObjectKeys(O2, enumBugKeys);
          };
        },
        6007: function(__unused_webpack_module, exports2) {
          var $propertyIsEnumerable = {}.propertyIsEnumerable;
          var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
          var NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);
          exports2.f = NASHORN_BUG ? function propertyIsEnumerable(V2) {
            var descriptor = getOwnPropertyDescriptor(this, V2);
            return !!descriptor && descriptor.enumerable;
          } : $propertyIsEnumerable;
        },
        4469: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var anObject = __webpack_require__2(1138);
          var aPossiblePrototype = __webpack_require__2(7757);
          module2.exports = Object.setPrototypeOf || ("__proto__" in {} ? function() {
            var CORRECT_SETTER = false;
            var test = {};
            var setter;
            try {
              setter = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__").set;
              setter.call(test, []);
              CORRECT_SETTER = test instanceof Array;
            } catch (error) {
            }
            return function setPrototypeOf(O2, proto) {
              anObject(O2);
              aPossiblePrototype(proto);
              if (CORRECT_SETTER)
                setter.call(O2, proto);
              else
                O2.__proto__ = proto;
              return O2;
            };
          }() : void 0);
        },
        158: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var TO_STRING_TAG_SUPPORT = __webpack_require__2(3471);
          var classof = __webpack_require__2(4696);
          module2.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString3() {
            return "[object " + classof(this) + "]";
          };
        },
        380: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var isCallable = __webpack_require__2(6447);
          var isObject2 = __webpack_require__2(5744);
          module2.exports = function(input, pref) {
            var fn2, val;
            if (pref === "string" && isCallable(fn2 = input.toString) && !isObject2(val = fn2.call(input)))
              return val;
            if (isCallable(fn2 = input.valueOf) && !isObject2(val = fn2.call(input)))
              return val;
            if (pref !== "string" && isCallable(fn2 = input.toString) && !isObject2(val = fn2.call(input)))
              return val;
            throw TypeError("Can't convert object to primitive value");
          };
        },
        7545: function(module2) {
          module2.exports = {};
        },
        892: function(module2) {
          module2.exports = function(exec) {
            try {
              return { error: false, value: exec() };
            } catch (error) {
              return { error: true, value: error };
            }
          };
        },
        9126: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var anObject = __webpack_require__2(1138);
          var isObject2 = __webpack_require__2(5744);
          var newPromiseCapability = __webpack_require__2(9438);
          module2.exports = function(C, x) {
            anObject(C);
            if (isObject2(x) && x.constructor === C)
              return x;
            var promiseCapability = newPromiseCapability.f(C);
            var resolve = promiseCapability.resolve;
            resolve(x);
            return promiseCapability.promise;
          };
        },
        533: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var redefine = __webpack_require__2(9482);
          module2.exports = function(target, src, options) {
            for (var key in src) {
              if (options && options.unsafe && target[key])
                target[key] = src[key];
              else
                redefine(target, key, src[key], options);
            }
            return target;
          };
        },
        9482: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var createNonEnumerableProperty = __webpack_require__2(8711);
          module2.exports = function(target, key, value, options) {
            if (options && options.enumerable)
              target[key] = value;
            else
              createNonEnumerableProperty(target, key, value);
          };
        },
        3209: function(module2) {
          module2.exports = function(it) {
            if (it == void 0)
              throw TypeError("Can't call method on " + it);
            return it;
          };
        },
        7613: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var global2 = __webpack_require__2(8576);
          module2.exports = function(key, value) {
            try {
              Object.defineProperty(global2, key, { value, configurable: true, writable: true });
            } catch (error) {
              global2[key] = value;
            }
            return value;
          };
        },
        3656: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var getBuiltIn = __webpack_require__2(150);
          var definePropertyModule = __webpack_require__2(2760);
          var wellKnownSymbol = __webpack_require__2(8182);
          var DESCRIPTORS = __webpack_require__2(69);
          var SPECIES = wellKnownSymbol("species");
          module2.exports = function(CONSTRUCTOR_NAME) {
            var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
            var defineProperty = definePropertyModule.f;
            if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
              defineProperty(Constructor, SPECIES, {
                configurable: true,
                get: function() {
                  return this;
                }
              });
            }
          };
        },
        1284: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var TO_STRING_TAG_SUPPORT = __webpack_require__2(3471);
          var defineProperty = __webpack_require__2(2760).f;
          var createNonEnumerableProperty = __webpack_require__2(8711);
          var hasOwn = __webpack_require__2(4500);
          var toString3 = __webpack_require__2(158);
          var wellKnownSymbol = __webpack_require__2(8182);
          var TO_STRING_TAG = wellKnownSymbol("toStringTag");
          module2.exports = function(it, TAG, STATIC, SET_METHOD) {
            if (it) {
              var target = STATIC ? it : it.prototype;
              if (!hasOwn(target, TO_STRING_TAG)) {
                defineProperty(target, TO_STRING_TAG, { configurable: true, value: TAG });
              }
              if (SET_METHOD && !TO_STRING_TAG_SUPPORT) {
                createNonEnumerableProperty(target, "toString", toString3);
              }
            }
          };
        },
        9766: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var shared = __webpack_require__2(8717);
          var uid = __webpack_require__2(2759);
          var keys2 = shared("keys");
          module2.exports = function(key) {
            return keys2[key] || (keys2[key] = uid(key));
          };
        },
        6434: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var global2 = __webpack_require__2(8576);
          var setGlobal = __webpack_require__2(7613);
          var SHARED = "__core-js_shared__";
          var store = global2[SHARED] || setGlobal(SHARED, {});
          module2.exports = store;
        },
        8717: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var IS_PURE = __webpack_require__2(5546);
          var store = __webpack_require__2(6434);
          (module2.exports = function(key, value) {
            return store[key] || (store[key] = value !== void 0 ? value : {});
          })("versions", []).push({
            version: "3.18.2",
            mode: IS_PURE ? "pure" : "global",
            copyright: "\xA9 2021 Denis Pushkarev (zloirock.ru)"
          });
        },
        4743: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var anObject = __webpack_require__2(1138);
          var aConstructor = __webpack_require__2(1404);
          var wellKnownSymbol = __webpack_require__2(8182);
          var SPECIES = wellKnownSymbol("species");
          module2.exports = function(O2, defaultConstructor) {
            var C = anObject(O2).constructor;
            var S;
            return C === void 0 || (S = anObject(C)[SPECIES]) == void 0 ? defaultConstructor : aConstructor(S);
          };
        },
        863: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var toIntegerOrInfinity = __webpack_require__2(1941);
          var toString3 = __webpack_require__2(4845);
          var requireObjectCoercible = __webpack_require__2(3209);
          var createMethod = function(CONVERT_TO_STRING) {
            return function($this, pos) {
              var S = toString3(requireObjectCoercible($this));
              var position2 = toIntegerOrInfinity(pos);
              var size = S.length;
              var first, second;
              if (position2 < 0 || position2 >= size)
                return CONVERT_TO_STRING ? "" : void 0;
              first = S.charCodeAt(position2);
              return first < 55296 || first > 56319 || position2 + 1 === size || (second = S.charCodeAt(position2 + 1)) < 56320 || second > 57343 ? CONVERT_TO_STRING ? S.charAt(position2) : first : CONVERT_TO_STRING ? S.slice(position2, position2 + 2) : (first - 55296 << 10) + (second - 56320) + 65536;
            };
          };
          module2.exports = {
            codeAt: createMethod(false),
            charAt: createMethod(true)
          };
        },
        7977: function(module2) {
          var maxInt = 2147483647;
          var base2 = 36;
          var tMin = 1;
          var tMax = 26;
          var skew = 38;
          var damp = 700;
          var initialBias = 72;
          var initialN = 128;
          var delimiter = "-";
          var regexNonASCII = /[^\0-\u007E]/;
          var regexSeparators = /[.\u3002\uFF0E\uFF61]/g;
          var OVERFLOW_ERROR = "Overflow: input needs wider integers to process";
          var baseMinusTMin = base2 - tMin;
          var floor = Math.floor;
          var stringFromCharCode = String.fromCharCode;
          var ucs2decode = function(string) {
            var output = [];
            var counter = 0;
            var length = string.length;
            while (counter < length) {
              var value = string.charCodeAt(counter++);
              if (value >= 55296 && value <= 56319 && counter < length) {
                var extra = string.charCodeAt(counter++);
                if ((extra & 64512) == 56320) {
                  output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                } else {
                  output.push(value);
                  counter--;
                }
              } else {
                output.push(value);
              }
            }
            return output;
          };
          var digitToBasic = function(digit) {
            return digit + 22 + 75 * (digit < 26);
          };
          var adapt = function(delta, numPoints, firstTime) {
            var k = 0;
            delta = firstTime ? floor(delta / damp) : delta >> 1;
            delta += floor(delta / numPoints);
            for (; delta > baseMinusTMin * tMax >> 1; k += base2) {
              delta = floor(delta / baseMinusTMin);
            }
            return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
          };
          var encode2 = function(input) {
            var output = [];
            input = ucs2decode(input);
            var inputLength = input.length;
            var n = initialN;
            var delta = 0;
            var bias = initialBias;
            var i, currentValue;
            for (i = 0; i < input.length; i++) {
              currentValue = input[i];
              if (currentValue < 128) {
                output.push(stringFromCharCode(currentValue));
              }
            }
            var basicLength = output.length;
            var handledCPCount = basicLength;
            if (basicLength) {
              output.push(delimiter);
            }
            while (handledCPCount < inputLength) {
              var m = maxInt;
              for (i = 0; i < input.length; i++) {
                currentValue = input[i];
                if (currentValue >= n && currentValue < m) {
                  m = currentValue;
                }
              }
              var handledCPCountPlusOne = handledCPCount + 1;
              if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                throw RangeError(OVERFLOW_ERROR);
              }
              delta += (m - n) * handledCPCountPlusOne;
              n = m;
              for (i = 0; i < input.length; i++) {
                currentValue = input[i];
                if (currentValue < n && ++delta > maxInt) {
                  throw RangeError(OVERFLOW_ERROR);
                }
                if (currentValue == n) {
                  var q2 = delta;
                  for (var k = base2; ; k += base2) {
                    var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                    if (q2 < t)
                      break;
                    var qMinusT = q2 - t;
                    var baseMinusT = base2 - t;
                    output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT)));
                    q2 = floor(qMinusT / baseMinusT);
                  }
                  output.push(stringFromCharCode(digitToBasic(q2)));
                  bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                  delta = 0;
                  ++handledCPCount;
                }
              }
              ++delta;
              ++n;
            }
            return output.join("");
          };
          module2.exports = function(input) {
            var encoded = [];
            var labels = input.toLowerCase().replace(regexSeparators, ".").split(".");
            var i, label;
            for (i = 0; i < labels.length; i++) {
              label = labels[i];
              encoded.push(regexNonASCII.test(label) ? "xn--" + encode2(label) : label);
            }
            return encoded.join(".");
          };
        },
        6815: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var PROPER_FUNCTION_NAME = __webpack_require__2(2282).PROPER;
          var fails = __webpack_require__2(6192);
          var whitespaces = __webpack_require__2(1450);
          var non = "\u200B\x85\u180E";
          module2.exports = function(METHOD_NAME) {
            return fails(function() {
              return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() !== non || PROPER_FUNCTION_NAME && whitespaces[METHOD_NAME].name !== METHOD_NAME;
            });
          };
        },
        4277: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var requireObjectCoercible = __webpack_require__2(3209);
          var toString3 = __webpack_require__2(4845);
          var whitespaces = __webpack_require__2(1450);
          var whitespace = "[" + whitespaces + "]";
          var ltrim = RegExp("^" + whitespace + whitespace + "*");
          var rtrim = RegExp(whitespace + whitespace + "*$");
          var createMethod = function(TYPE) {
            return function($this) {
              var string = toString3(requireObjectCoercible($this));
              if (TYPE & 1)
                string = string.replace(ltrim, "");
              if (TYPE & 2)
                string = string.replace(rtrim, "");
              return string;
            };
          };
          module2.exports = {
            start: createMethod(1),
            end: createMethod(2),
            trim: createMethod(3)
          };
        },
        7160: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var global2 = __webpack_require__2(8576);
          var isCallable = __webpack_require__2(6447);
          var fails = __webpack_require__2(6192);
          var bind3 = __webpack_require__2(8043);
          var html = __webpack_require__2(7403);
          var createElement2 = __webpack_require__2(7449);
          var IS_IOS = __webpack_require__2(9536);
          var IS_NODE = __webpack_require__2(224);
          var set = global2.setImmediate;
          var clear = global2.clearImmediate;
          var process2 = global2.process;
          var MessageChannel = global2.MessageChannel;
          var Dispatch = global2.Dispatch;
          var counter = 0;
          var queue = {};
          var ONREADYSTATECHANGE = "onreadystatechange";
          var location2, defer, channel, port;
          try {
            location2 = global2.location;
          } catch (error) {
          }
          var run = function(id) {
            if (queue.hasOwnProperty(id)) {
              var fn2 = queue[id];
              delete queue[id];
              fn2();
            }
          };
          var runner = function(id) {
            return function() {
              run(id);
            };
          };
          var listener = function(event) {
            run(event.data);
          };
          var post = function(id) {
            global2.postMessage(String(id), location2.protocol + "//" + location2.host);
          };
          if (!set || !clear) {
            set = function setImmediate(fn2) {
              var args = [];
              var argumentsLength = arguments.length;
              var i = 1;
              while (argumentsLength > i)
                args.push(arguments[i++]);
              queue[++counter] = function() {
                (isCallable(fn2) ? fn2 : Function(fn2)).apply(void 0, args);
              };
              defer(counter);
              return counter;
            };
            clear = function clearImmediate(id) {
              delete queue[id];
            };
            if (IS_NODE) {
              defer = function(id) {
                process2.nextTick(runner(id));
              };
            } else if (Dispatch && Dispatch.now) {
              defer = function(id) {
                Dispatch.now(runner(id));
              };
            } else if (MessageChannel && !IS_IOS) {
              channel = new MessageChannel();
              port = channel.port2;
              channel.port1.onmessage = listener;
              defer = bind3(port.postMessage, port, 1);
            } else if (global2.addEventListener && isCallable(global2.postMessage) && !global2.importScripts && location2 && location2.protocol !== "file:" && !fails(post)) {
              defer = post;
              global2.addEventListener("message", listener, false);
            } else if (ONREADYSTATECHANGE in createElement2("script")) {
              defer = function(id) {
                html.appendChild(createElement2("script"))[ONREADYSTATECHANGE] = function() {
                  html.removeChild(this);
                  run(id);
                };
              };
            } else {
              defer = function(id) {
                setTimeout(runner(id), 0);
              };
            }
          }
          module2.exports = {
            set,
            clear
          };
        },
        7739: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var toIntegerOrInfinity = __webpack_require__2(1941);
          var max2 = Math.max;
          var min = Math.min;
          module2.exports = function(index2, length) {
            var integer = toIntegerOrInfinity(index2);
            return integer < 0 ? max2(integer + length, 0) : min(integer, length);
          };
        },
        101: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var IndexedObject = __webpack_require__2(2202);
          var requireObjectCoercible = __webpack_require__2(3209);
          module2.exports = function(it) {
            return IndexedObject(requireObjectCoercible(it));
          };
        },
        1941: function(module2) {
          var ceil = Math.ceil;
          var floor = Math.floor;
          module2.exports = function(argument) {
            var number = +argument;
            return number !== number || number === 0 ? 0 : (number > 0 ? floor : ceil)(number);
          };
        },
        8445: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var toIntegerOrInfinity = __webpack_require__2(1941);
          var min = Math.min;
          module2.exports = function(argument) {
            return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
          };
        },
        1795: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var requireObjectCoercible = __webpack_require__2(3209);
          module2.exports = function(argument) {
            return Object(requireObjectCoercible(argument));
          };
        },
        7888: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var isObject2 = __webpack_require__2(5744);
          var isSymbol = __webpack_require__2(3236);
          var getMethod = __webpack_require__2(5037);
          var ordinaryToPrimitive = __webpack_require__2(380);
          var wellKnownSymbol = __webpack_require__2(8182);
          var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
          module2.exports = function(input, pref) {
            if (!isObject2(input) || isSymbol(input))
              return input;
            var exoticToPrim = getMethod(input, TO_PRIMITIVE);
            var result;
            if (exoticToPrim) {
              if (pref === void 0)
                pref = "default";
              result = exoticToPrim.call(input, pref);
              if (!isObject2(result) || isSymbol(result))
                return result;
              throw TypeError("Can't convert object to primitive value");
            }
            if (pref === void 0)
              pref = "number";
            return ordinaryToPrimitive(input, pref);
          };
        },
        77: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var toPrimitive = __webpack_require__2(7888);
          var isSymbol = __webpack_require__2(3236);
          module2.exports = function(argument) {
            var key = toPrimitive(argument, "string");
            return isSymbol(key) ? key : String(key);
          };
        },
        3471: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var wellKnownSymbol = __webpack_require__2(8182);
          var TO_STRING_TAG = wellKnownSymbol("toStringTag");
          var test = {};
          test[TO_STRING_TAG] = "z";
          module2.exports = String(test) === "[object z]";
        },
        4845: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var classof = __webpack_require__2(4696);
          module2.exports = function(argument) {
            if (classof(argument) === "Symbol")
              throw TypeError("Cannot convert a Symbol value to a string");
            return String(argument);
          };
        },
        9288: function(module2) {
          module2.exports = function(argument) {
            try {
              return String(argument);
            } catch (error) {
              return "Object";
            }
          };
        },
        2759: function(module2) {
          var id = 0;
          var postfix = Math.random();
          module2.exports = function(key) {
            return "Symbol(" + String(key === void 0 ? "" : key) + ")_" + (++id + postfix).toString(36);
          };
        },
        615: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var NATIVE_SYMBOL = __webpack_require__2(3045);
          module2.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == "symbol";
        },
        9207: function(__unused_webpack_module, exports2, __webpack_require__2) {
          var wellKnownSymbol = __webpack_require__2(8182);
          exports2.f = wellKnownSymbol;
        },
        8182: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var global2 = __webpack_require__2(8576);
          var shared = __webpack_require__2(8717);
          var hasOwn = __webpack_require__2(4500);
          var uid = __webpack_require__2(2759);
          var NATIVE_SYMBOL = __webpack_require__2(3045);
          var USE_SYMBOL_AS_UID = __webpack_require__2(615);
          var WellKnownSymbolsStore = shared("wks");
          var Symbol2 = global2.Symbol;
          var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol2 : Symbol2 && Symbol2.withoutSetter || uid;
          module2.exports = function(name2) {
            if (!hasOwn(WellKnownSymbolsStore, name2) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name2] == "string")) {
              if (NATIVE_SYMBOL && hasOwn(Symbol2, name2)) {
                WellKnownSymbolsStore[name2] = Symbol2[name2];
              } else {
                WellKnownSymbolsStore[name2] = createWellKnownSymbol("Symbol." + name2);
              }
            }
            return WellKnownSymbolsStore[name2];
          };
        },
        1450: function(module2) {
          module2.exports = "	\n\v\f\r \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";
        },
        4242: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var getPrototypeOf = __webpack_require__2(9341);
          var setPrototypeOf = __webpack_require__2(4469);
          var create2 = __webpack_require__2(2853);
          var createNonEnumerableProperty = __webpack_require__2(8711);
          var createPropertyDescriptor = __webpack_require__2(774);
          var installErrorCause = __webpack_require__2(273);
          var iterate = __webpack_require__2(3442);
          var toString3 = __webpack_require__2(4845);
          var $AggregateError = function AggregateError(errors, message) {
            var that = this;
            var options = arguments.length > 2 ? arguments[2] : void 0;
            if (!(that instanceof $AggregateError))
              return new $AggregateError(errors, message, options);
            if (setPrototypeOf) {
              that = setPrototypeOf(new Error(void 0), getPrototypeOf(that));
            }
            if (message !== void 0)
              createNonEnumerableProperty(that, "message", toString3(message));
            installErrorCause(that, options);
            var errorsArray = [];
            iterate(errors, errorsArray.push, { that: errorsArray });
            createNonEnumerableProperty(that, "errors", errorsArray);
            return that;
          };
          $AggregateError.prototype = create2(Error.prototype, {
            constructor: createPropertyDescriptor(5, $AggregateError),
            message: createPropertyDescriptor(5, ""),
            name: createPropertyDescriptor(5, "AggregateError")
          });
          $2({ global: true }, {
            AggregateError: $AggregateError
          });
        },
        9106: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var fails = __webpack_require__2(6192);
          var isArray2 = __webpack_require__2(4770);
          var isObject2 = __webpack_require__2(5744);
          var toObject2 = __webpack_require__2(1795);
          var lengthOfArrayLike = __webpack_require__2(4104);
          var createProperty = __webpack_require__2(9361);
          var arraySpeciesCreate = __webpack_require__2(1321);
          var arrayMethodHasSpeciesSupport = __webpack_require__2(242);
          var wellKnownSymbol = __webpack_require__2(8182);
          var V8_VERSION = __webpack_require__2(4218);
          var IS_CONCAT_SPREADABLE = wellKnownSymbol("isConcatSpreadable");
          var MAX_SAFE_INTEGER = 9007199254740991;
          var MAXIMUM_ALLOWED_INDEX_EXCEEDED = "Maximum allowed index exceeded";
          var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function() {
            var array = [];
            array[IS_CONCAT_SPREADABLE] = false;
            return array.concat()[0] !== array;
          });
          var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("concat");
          var isConcatSpreadable = function(O2) {
            if (!isObject2(O2))
              return false;
            var spreadable = O2[IS_CONCAT_SPREADABLE];
            return spreadable !== void 0 ? !!spreadable : isArray2(O2);
          };
          var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;
          $2({ target: "Array", proto: true, forced: FORCED }, {
            concat: function concat(arg) {
              var O2 = toObject2(this);
              var A2 = arraySpeciesCreate(O2, 0);
              var n = 0;
              var i, k, length, len, E2;
              for (i = -1, length = arguments.length; i < length; i++) {
                E2 = i === -1 ? O2 : arguments[i];
                if (isConcatSpreadable(E2)) {
                  len = lengthOfArrayLike(E2);
                  if (n + len > MAX_SAFE_INTEGER)
                    throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                  for (k = 0; k < len; k++, n++)
                    if (k in E2)
                      createProperty(A2, n, E2[k]);
                } else {
                  if (n >= MAX_SAFE_INTEGER)
                    throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
                  createProperty(A2, n++, E2);
                }
              }
              A2.length = n;
              return A2;
            }
          });
        },
        1710: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var fill = __webpack_require__2(2724);
          var addToUnscopables = __webpack_require__2(7423);
          $2({ target: "Array", proto: true }, {
            fill
          });
          addToUnscopables("fill");
        },
        3436: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var $filter = __webpack_require__2(454).filter;
          var arrayMethodHasSpeciesSupport = __webpack_require__2(242);
          var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("filter");
          $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
            filter: function filter(callbackfn) {
              return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
            }
          });
        },
        9823: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var forEach3 = __webpack_require__2(7397);
          $2({ target: "Array", proto: true, forced: [].forEach != forEach3 }, {
            forEach: forEach3
          });
        },
        9173: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var from = __webpack_require__2(841);
          var checkCorrectnessOfIteration = __webpack_require__2(9770);
          var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function(iterable) {
            Array.from(iterable);
          });
          $2({ target: "Array", stat: true, forced: INCORRECT_ITERATION }, {
            from
          });
        },
        2276: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var $indexOf = __webpack_require__2(8180).indexOf;
          var arrayMethodIsStrict = __webpack_require__2(424);
          var nativeIndexOf = [].indexOf;
          var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
          var STRICT_METHOD = arrayMethodIsStrict("indexOf");
          $2({ target: "Array", proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD }, {
            indexOf: function indexOf(searchElement) {
              return NEGATIVE_ZERO ? nativeIndexOf.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : void 0);
            }
          });
        },
        8118: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var isArray2 = __webpack_require__2(4770);
          $2({ target: "Array", stat: true }, {
            isArray: isArray2
          });
        },
        8939: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var toIndexedObject = __webpack_require__2(101);
          var addToUnscopables = __webpack_require__2(7423);
          var Iterators = __webpack_require__2(7771);
          var InternalStateModule = __webpack_require__2(3326);
          var defineIterator = __webpack_require__2(7218);
          var ARRAY_ITERATOR = "Array Iterator";
          var setInternalState = InternalStateModule.set;
          var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);
          module2.exports = defineIterator(Array, "Array", function(iterated, kind) {
            setInternalState(this, {
              type: ARRAY_ITERATOR,
              target: toIndexedObject(iterated),
              index: 0,
              kind
            });
          }, function() {
            var state = getInternalState(this);
            var target = state.target;
            var kind = state.kind;
            var index2 = state.index++;
            if (!target || index2 >= target.length) {
              state.target = void 0;
              return { value: void 0, done: true };
            }
            if (kind == "keys")
              return { value: index2, done: false };
            if (kind == "values")
              return { value: target[index2], done: false };
            return { value: [index2, target[index2]], done: false };
          }, "values");
          Iterators.Arguments = Iterators.Array;
          addToUnscopables("keys");
          addToUnscopables("values");
          addToUnscopables("entries");
        },
        3838: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var $map = __webpack_require__2(454).map;
          var arrayMethodHasSpeciesSupport = __webpack_require__2(242);
          var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("map");
          $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
            map: function map(callbackfn) {
              return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
            }
          });
        },
        5818: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var isArray2 = __webpack_require__2(4770);
          var isConstructor = __webpack_require__2(2091);
          var isObject2 = __webpack_require__2(5744);
          var toAbsoluteIndex = __webpack_require__2(7739);
          var lengthOfArrayLike = __webpack_require__2(4104);
          var toIndexedObject = __webpack_require__2(101);
          var createProperty = __webpack_require__2(9361);
          var wellKnownSymbol = __webpack_require__2(8182);
          var arrayMethodHasSpeciesSupport = __webpack_require__2(242);
          var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("slice");
          var SPECIES = wellKnownSymbol("species");
          var nativeSlice = [].slice;
          var max2 = Math.max;
          $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
            slice: function slice(start, end) {
              var O2 = toIndexedObject(this);
              var length = lengthOfArrayLike(O2);
              var k = toAbsoluteIndex(start, length);
              var fin = toAbsoluteIndex(end === void 0 ? length : end, length);
              var Constructor, result, n;
              if (isArray2(O2)) {
                Constructor = O2.constructor;
                if (isConstructor(Constructor) && (Constructor === Array || isArray2(Constructor.prototype))) {
                  Constructor = void 0;
                } else if (isObject2(Constructor)) {
                  Constructor = Constructor[SPECIES];
                  if (Constructor === null)
                    Constructor = void 0;
                }
                if (Constructor === Array || Constructor === void 0) {
                  return nativeSlice.call(O2, k, fin);
                }
              }
              result = new (Constructor === void 0 ? Array : Constructor)(max2(fin - k, 0));
              for (n = 0; k < fin; k++, n++)
                if (k in O2)
                  createProperty(result, n, O2[k]);
              result.length = n;
              return result;
            }
          });
        },
        2178: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var toAbsoluteIndex = __webpack_require__2(7739);
          var toIntegerOrInfinity = __webpack_require__2(1941);
          var lengthOfArrayLike = __webpack_require__2(4104);
          var toObject2 = __webpack_require__2(1795);
          var arraySpeciesCreate = __webpack_require__2(1321);
          var createProperty = __webpack_require__2(9361);
          var arrayMethodHasSpeciesSupport = __webpack_require__2(242);
          var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport("splice");
          var max2 = Math.max;
          var min = Math.min;
          var MAX_SAFE_INTEGER = 9007199254740991;
          var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = "Maximum allowed length exceeded";
          $2({ target: "Array", proto: true, forced: !HAS_SPECIES_SUPPORT }, {
            splice: function splice(start, deleteCount) {
              var O2 = toObject2(this);
              var len = lengthOfArrayLike(O2);
              var actualStart = toAbsoluteIndex(start, len);
              var argumentsLength = arguments.length;
              var insertCount, actualDeleteCount, A2, k, from, to;
              if (argumentsLength === 0) {
                insertCount = actualDeleteCount = 0;
              } else if (argumentsLength === 1) {
                insertCount = 0;
                actualDeleteCount = len - actualStart;
              } else {
                insertCount = argumentsLength - 2;
                actualDeleteCount = min(max2(toIntegerOrInfinity(deleteCount), 0), len - actualStart);
              }
              if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
                throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
              }
              A2 = arraySpeciesCreate(O2, actualDeleteCount);
              for (k = 0; k < actualDeleteCount; k++) {
                from = actualStart + k;
                if (from in O2)
                  createProperty(A2, k, O2[from]);
              }
              A2.length = actualDeleteCount;
              if (insertCount < actualDeleteCount) {
                for (k = actualStart; k < len - actualDeleteCount; k++) {
                  from = k + actualDeleteCount;
                  to = k + insertCount;
                  if (from in O2)
                    O2[to] = O2[from];
                  else
                    delete O2[to];
                }
                for (k = len; k > len - actualDeleteCount + insertCount; k--)
                  delete O2[k - 1];
              } else if (insertCount > actualDeleteCount) {
                for (k = len - actualDeleteCount; k > actualStart; k--) {
                  from = k + actualDeleteCount - 1;
                  to = k + insertCount - 1;
                  if (from in O2)
                    O2[to] = O2[from];
                  else
                    delete O2[to];
                }
              }
              for (k = 0; k < insertCount; k++) {
                O2[k + actualStart] = arguments[k + 2];
              }
              O2.length = len - actualDeleteCount + insertCount;
              return A2;
            }
          });
        },
        665: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var bind3 = __webpack_require__2(6782);
          $2({ target: "Function", proto: true }, {
            bind: bind3
          });
        },
        8671: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var global2 = __webpack_require__2(8576);
          var setToStringTag = __webpack_require__2(1284);
          setToStringTag(global2.JSON, "JSON", true);
        },
        8556: function() {
        },
        2666: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var parseInt2 = __webpack_require__2(2558);
          $2({ target: "Number", stat: true, forced: Number.parseInt != parseInt2 }, {
            parseInt: parseInt2
          });
        },
        3113: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var DESCRIPTORS = __webpack_require__2(69);
          var create2 = __webpack_require__2(2853);
          $2({ target: "Object", stat: true, sham: !DESCRIPTORS }, {
            create: create2
          });
        },
        297: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var DESCRIPTORS = __webpack_require__2(69);
          var objectDefinePropertyModile = __webpack_require__2(2760);
          $2({ target: "Object", stat: true, forced: !DESCRIPTORS, sham: !DESCRIPTORS }, {
            defineProperty: objectDefinePropertyModile.f
          });
        },
        9234: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var fails = __webpack_require__2(6192);
          var toObject2 = __webpack_require__2(1795);
          var nativeGetPrototypeOf = __webpack_require__2(9341);
          var CORRECT_PROTOTYPE_GETTER = __webpack_require__2(4635);
          var FAILS_ON_PRIMITIVES = fails(function() {
            nativeGetPrototypeOf(1);
          });
          $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
            getPrototypeOf: function getPrototypeOf(it) {
              return nativeGetPrototypeOf(toObject2(it));
            }
          });
        },
        2647: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var toObject2 = __webpack_require__2(1795);
          var nativeKeys = __webpack_require__2(7653);
          var fails = __webpack_require__2(6192);
          var FAILS_ON_PRIMITIVES = fails(function() {
            nativeKeys(1);
          });
          $2({ target: "Object", stat: true, forced: FAILS_ON_PRIMITIVES }, {
            keys: function keys2(it) {
              return nativeKeys(toObject2(it));
            }
          });
        },
        3222: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var setPrototypeOf = __webpack_require__2(4469);
          $2({ target: "Object", stat: true }, {
            setPrototypeOf
          });
        },
        6663: function() {
        },
        4859: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var $parseFloat = __webpack_require__2(15);
          $2({ global: true, forced: parseFloat != $parseFloat }, {
            parseFloat: $parseFloat
          });
        },
        5706: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var $parseInt = __webpack_require__2(2558);
          $2({ global: true, forced: parseInt != $parseInt }, {
            parseInt: $parseInt
          });
        },
        7884: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var aCallable = __webpack_require__2(6235);
          var newPromiseCapabilityModule = __webpack_require__2(9438);
          var perform = __webpack_require__2(892);
          var iterate = __webpack_require__2(3442);
          $2({ target: "Promise", stat: true }, {
            allSettled: function allSettled(iterable) {
              var C = this;
              var capability = newPromiseCapabilityModule.f(C);
              var resolve = capability.resolve;
              var reject = capability.reject;
              var result = perform(function() {
                var promiseResolve = aCallable(C.resolve);
                var values = [];
                var counter = 0;
                var remaining = 1;
                iterate(iterable, function(promise) {
                  var index2 = counter++;
                  var alreadyCalled = false;
                  values.push(void 0);
                  remaining++;
                  promiseResolve.call(C, promise).then(function(value) {
                    if (alreadyCalled)
                      return;
                    alreadyCalled = true;
                    values[index2] = { status: "fulfilled", value };
                    --remaining || resolve(values);
                  }, function(error) {
                    if (alreadyCalled)
                      return;
                    alreadyCalled = true;
                    values[index2] = { status: "rejected", reason: error };
                    --remaining || resolve(values);
                  });
                });
                --remaining || resolve(values);
              });
              if (result.error)
                reject(result.value);
              return capability.promise;
            }
          });
        },
        8885: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var aCallable = __webpack_require__2(6235);
          var getBuiltIn = __webpack_require__2(150);
          var newPromiseCapabilityModule = __webpack_require__2(9438);
          var perform = __webpack_require__2(892);
          var iterate = __webpack_require__2(3442);
          var PROMISE_ANY_ERROR = "No one promise resolved";
          $2({ target: "Promise", stat: true }, {
            any: function any(iterable) {
              var C = this;
              var capability = newPromiseCapabilityModule.f(C);
              var resolve = capability.resolve;
              var reject = capability.reject;
              var result = perform(function() {
                var promiseResolve = aCallable(C.resolve);
                var errors = [];
                var counter = 0;
                var remaining = 1;
                var alreadyResolved = false;
                iterate(iterable, function(promise) {
                  var index2 = counter++;
                  var alreadyRejected = false;
                  errors.push(void 0);
                  remaining++;
                  promiseResolve.call(C, promise).then(function(value) {
                    if (alreadyRejected || alreadyResolved)
                      return;
                    alreadyResolved = true;
                    resolve(value);
                  }, function(error) {
                    if (alreadyRejected || alreadyResolved)
                      return;
                    alreadyRejected = true;
                    errors[index2] = error;
                    --remaining || reject(new (getBuiltIn("AggregateError"))(errors, PROMISE_ANY_ERROR));
                  });
                });
                --remaining || reject(new (getBuiltIn("AggregateError"))(errors, PROMISE_ANY_ERROR));
              });
              if (result.error)
                reject(result.value);
              return capability.promise;
            }
          });
        },
        1868: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var IS_PURE = __webpack_require__2(5546);
          var NativePromise = __webpack_require__2(4471);
          var fails = __webpack_require__2(6192);
          var getBuiltIn = __webpack_require__2(150);
          var isCallable = __webpack_require__2(6447);
          var speciesConstructor = __webpack_require__2(4743);
          var promiseResolve = __webpack_require__2(9126);
          var redefine = __webpack_require__2(9482);
          var NON_GENERIC = !!NativePromise && fails(function() {
            NativePromise.prototype["finally"].call({ then: function() {
            } }, function() {
            });
          });
          $2({ target: "Promise", proto: true, real: true, forced: NON_GENERIC }, {
            "finally": function(onFinally) {
              var C = speciesConstructor(this, getBuiltIn("Promise"));
              var isFunction2 = isCallable(onFinally);
              return this.then(
                isFunction2 ? function(x) {
                  return promiseResolve(C, onFinally()).then(function() {
                    return x;
                  });
                } : onFinally,
                isFunction2 ? function(e2) {
                  return promiseResolve(C, onFinally()).then(function() {
                    throw e2;
                  });
                } : onFinally
              );
            }
          });
          if (!IS_PURE && isCallable(NativePromise)) {
            var method = getBuiltIn("Promise").prototype["finally"];
            if (NativePromise.prototype["finally"] !== method) {
              redefine(NativePromise.prototype, "finally", method, { unsafe: true });
            }
          }
        },
        9021: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var IS_PURE = __webpack_require__2(5546);
          var global2 = __webpack_require__2(8576);
          var getBuiltIn = __webpack_require__2(150);
          var NativePromise = __webpack_require__2(4471);
          var redefine = __webpack_require__2(9482);
          var redefineAll = __webpack_require__2(533);
          var setPrototypeOf = __webpack_require__2(4469);
          var setToStringTag = __webpack_require__2(1284);
          var setSpecies = __webpack_require__2(3656);
          var aCallable = __webpack_require__2(6235);
          var isCallable = __webpack_require__2(6447);
          var isObject2 = __webpack_require__2(5744);
          var anInstance = __webpack_require__2(6961);
          var inspectSource = __webpack_require__2(9516);
          var iterate = __webpack_require__2(3442);
          var checkCorrectnessOfIteration = __webpack_require__2(9770);
          var speciesConstructor = __webpack_require__2(4743);
          var task = __webpack_require__2(7160).set;
          var microtask = __webpack_require__2(2950);
          var promiseResolve = __webpack_require__2(9126);
          var hostReportErrors = __webpack_require__2(3681);
          var newPromiseCapabilityModule = __webpack_require__2(9438);
          var perform = __webpack_require__2(892);
          var InternalStateModule = __webpack_require__2(3326);
          var isForced = __webpack_require__2(9245);
          var wellKnownSymbol = __webpack_require__2(8182);
          var IS_BROWSER = __webpack_require__2(2957);
          var IS_NODE = __webpack_require__2(224);
          var V8_VERSION = __webpack_require__2(4218);
          var SPECIES = wellKnownSymbol("species");
          var PROMISE = "Promise";
          var getInternalState = InternalStateModule.get;
          var setInternalState = InternalStateModule.set;
          var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
          var NativePromisePrototype = NativePromise && NativePromise.prototype;
          var PromiseConstructor = NativePromise;
          var PromiseConstructorPrototype = NativePromisePrototype;
          var TypeError2 = global2.TypeError;
          var document2 = global2.document;
          var process2 = global2.process;
          var newPromiseCapability = newPromiseCapabilityModule.f;
          var newGenericPromiseCapability = newPromiseCapability;
          var DISPATCH_EVENT = !!(document2 && document2.createEvent && global2.dispatchEvent);
          var NATIVE_REJECTION_EVENT = isCallable(global2.PromiseRejectionEvent);
          var UNHANDLED_REJECTION = "unhandledrejection";
          var REJECTION_HANDLED = "rejectionhandled";
          var PENDING = 0;
          var FULFILLED = 1;
          var REJECTED = 2;
          var HANDLED = 1;
          var UNHANDLED = 2;
          var SUBCLASSING = false;
          var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;
          var FORCED = isForced(PROMISE, function() {
            var PROMISE_CONSTRUCTOR_SOURCE = inspectSource(PromiseConstructor);
            var GLOBAL_CORE_JS_PROMISE = PROMISE_CONSTRUCTOR_SOURCE !== String(PromiseConstructor);
            if (!GLOBAL_CORE_JS_PROMISE && V8_VERSION === 66)
              return true;
            if (IS_PURE && !PromiseConstructorPrototype["finally"])
              return true;
            if (V8_VERSION >= 51 && /native code/.test(PROMISE_CONSTRUCTOR_SOURCE))
              return false;
            var promise = new PromiseConstructor(function(resolve) {
              resolve(1);
            });
            var FakePromise = function(exec) {
              exec(function() {
              }, function() {
              });
            };
            var constructor = promise.constructor = {};
            constructor[SPECIES] = FakePromise;
            SUBCLASSING = promise.then(function() {
            }) instanceof FakePromise;
            if (!SUBCLASSING)
              return true;
            return !GLOBAL_CORE_JS_PROMISE && IS_BROWSER && !NATIVE_REJECTION_EVENT;
          });
          var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function(iterable) {
            PromiseConstructor.all(iterable)["catch"](function() {
            });
          });
          var isThenable = function(it) {
            var then;
            return isObject2(it) && isCallable(then = it.then) ? then : false;
          };
          var notify = function(state, isReject) {
            if (state.notified)
              return;
            state.notified = true;
            var chain = state.reactions;
            microtask(function() {
              var value = state.value;
              var ok = state.state == FULFILLED;
              var index2 = 0;
              while (chain.length > index2) {
                var reaction = chain[index2++];
                var handler = ok ? reaction.ok : reaction.fail;
                var resolve = reaction.resolve;
                var reject = reaction.reject;
                var domain = reaction.domain;
                var result, then, exited;
                try {
                  if (handler) {
                    if (!ok) {
                      if (state.rejection === UNHANDLED)
                        onHandleUnhandled(state);
                      state.rejection = HANDLED;
                    }
                    if (handler === true)
                      result = value;
                    else {
                      if (domain)
                        domain.enter();
                      result = handler(value);
                      if (domain) {
                        domain.exit();
                        exited = true;
                      }
                    }
                    if (result === reaction.promise) {
                      reject(TypeError2("Promise-chain cycle"));
                    } else if (then = isThenable(result)) {
                      then.call(result, resolve, reject);
                    } else
                      resolve(result);
                  } else
                    reject(value);
                } catch (error) {
                  if (domain && !exited)
                    domain.exit();
                  reject(error);
                }
              }
              state.reactions = [];
              state.notified = false;
              if (isReject && !state.rejection)
                onUnhandled(state);
            });
          };
          var dispatchEvent2 = function(name2, promise, reason) {
            var event, handler;
            if (DISPATCH_EVENT) {
              event = document2.createEvent("Event");
              event.promise = promise;
              event.reason = reason;
              event.initEvent(name2, false, true);
              global2.dispatchEvent(event);
            } else
              event = { promise, reason };
            if (!NATIVE_REJECTION_EVENT && (handler = global2["on" + name2]))
              handler(event);
            else if (name2 === UNHANDLED_REJECTION)
              hostReportErrors("Unhandled promise rejection", reason);
          };
          var onUnhandled = function(state) {
            task.call(global2, function() {
              var promise = state.facade;
              var value = state.value;
              var IS_UNHANDLED = isUnhandled(state);
              var result;
              if (IS_UNHANDLED) {
                result = perform(function() {
                  if (IS_NODE) {
                    process2.emit("unhandledRejection", value, promise);
                  } else
                    dispatchEvent2(UNHANDLED_REJECTION, promise, value);
                });
                state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
                if (result.error)
                  throw result.value;
              }
            });
          };
          var isUnhandled = function(state) {
            return state.rejection !== HANDLED && !state.parent;
          };
          var onHandleUnhandled = function(state) {
            task.call(global2, function() {
              var promise = state.facade;
              if (IS_NODE) {
                process2.emit("rejectionHandled", promise);
              } else
                dispatchEvent2(REJECTION_HANDLED, promise, state.value);
            });
          };
          var bind3 = function(fn2, state, unwrap) {
            return function(value) {
              fn2(state, value, unwrap);
            };
          };
          var internalReject = function(state, value, unwrap) {
            if (state.done)
              return;
            state.done = true;
            if (unwrap)
              state = unwrap;
            state.value = value;
            state.state = REJECTED;
            notify(state, true);
          };
          var internalResolve = function(state, value, unwrap) {
            if (state.done)
              return;
            state.done = true;
            if (unwrap)
              state = unwrap;
            try {
              if (state.facade === value)
                throw TypeError2("Promise can't be resolved itself");
              var then = isThenable(value);
              if (then) {
                microtask(function() {
                  var wrapper = { done: false };
                  try {
                    then.call(
                      value,
                      bind3(internalResolve, wrapper, state),
                      bind3(internalReject, wrapper, state)
                    );
                  } catch (error) {
                    internalReject(wrapper, error, state);
                  }
                });
              } else {
                state.value = value;
                state.state = FULFILLED;
                notify(state, false);
              }
            } catch (error) {
              internalReject({ done: false }, error, state);
            }
          };
          if (FORCED) {
            PromiseConstructor = function Promise2(executor) {
              anInstance(this, PromiseConstructor, PROMISE);
              aCallable(executor);
              Internal.call(this);
              var state = getInternalState(this);
              try {
                executor(bind3(internalResolve, state), bind3(internalReject, state));
              } catch (error) {
                internalReject(state, error);
              }
            };
            PromiseConstructorPrototype = PromiseConstructor.prototype;
            Internal = function Promise2(executor) {
              setInternalState(this, {
                type: PROMISE,
                done: false,
                notified: false,
                parent: false,
                reactions: [],
                rejection: false,
                state: PENDING,
                value: void 0
              });
            };
            Internal.prototype = redefineAll(PromiseConstructorPrototype, {
              then: function then(onFulfilled, onRejected) {
                var state = getInternalPromiseState(this);
                var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
                reaction.ok = isCallable(onFulfilled) ? onFulfilled : true;
                reaction.fail = isCallable(onRejected) && onRejected;
                reaction.domain = IS_NODE ? process2.domain : void 0;
                state.parent = true;
                state.reactions.push(reaction);
                if (state.state != PENDING)
                  notify(state, false);
                return reaction.promise;
              },
              "catch": function(onRejected) {
                return this.then(void 0, onRejected);
              }
            });
            OwnPromiseCapability = function() {
              var promise = new Internal();
              var state = getInternalState(promise);
              this.promise = promise;
              this.resolve = bind3(internalResolve, state);
              this.reject = bind3(internalReject, state);
            };
            newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
              return C === PromiseConstructor || C === PromiseWrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
            };
            if (!IS_PURE && isCallable(NativePromise) && NativePromisePrototype !== Object.prototype) {
              nativeThen = NativePromisePrototype.then;
              if (!SUBCLASSING) {
                redefine(NativePromisePrototype, "then", function then(onFulfilled, onRejected) {
                  var that = this;
                  return new PromiseConstructor(function(resolve, reject) {
                    nativeThen.call(that, resolve, reject);
                  }).then(onFulfilled, onRejected);
                }, { unsafe: true });
                redefine(NativePromisePrototype, "catch", PromiseConstructorPrototype["catch"], { unsafe: true });
              }
              try {
                delete NativePromisePrototype.constructor;
              } catch (error) {
              }
              if (setPrototypeOf) {
                setPrototypeOf(NativePromisePrototype, PromiseConstructorPrototype);
              }
            }
          }
          $2({ global: true, wrap: true, forced: FORCED }, {
            Promise: PromiseConstructor
          });
          setToStringTag(PromiseConstructor, PROMISE, false, true);
          setSpecies(PROMISE);
          PromiseWrapper = getBuiltIn(PROMISE);
          $2({ target: PROMISE, stat: true, forced: FORCED }, {
            reject: function reject(r) {
              var capability = newPromiseCapability(this);
              capability.reject.call(void 0, r);
              return capability.promise;
            }
          });
          $2({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
            resolve: function resolve(x) {
              return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
            }
          });
          $2({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
            all: function all3(iterable) {
              var C = this;
              var capability = newPromiseCapability(C);
              var resolve = capability.resolve;
              var reject = capability.reject;
              var result = perform(function() {
                var $promiseResolve = aCallable(C.resolve);
                var values = [];
                var counter = 0;
                var remaining = 1;
                iterate(iterable, function(promise) {
                  var index2 = counter++;
                  var alreadyCalled = false;
                  values.push(void 0);
                  remaining++;
                  $promiseResolve.call(C, promise).then(function(value) {
                    if (alreadyCalled)
                      return;
                    alreadyCalled = true;
                    values[index2] = value;
                    --remaining || resolve(values);
                  }, reject);
                });
                --remaining || resolve(values);
              });
              if (result.error)
                reject(result.value);
              return capability.promise;
            },
            race: function race(iterable) {
              var C = this;
              var capability = newPromiseCapability(C);
              var reject = capability.reject;
              var result = perform(function() {
                var $promiseResolve = aCallable(C.resolve);
                iterate(iterable, function(promise) {
                  $promiseResolve.call(C, promise).then(capability.resolve, reject);
                });
              });
              if (result.error)
                reject(result.value);
              return capability.promise;
            }
          });
        },
        5397: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var getBuiltIn = __webpack_require__2(150);
          var aConstructor = __webpack_require__2(1404);
          var anObject = __webpack_require__2(1138);
          var isObject2 = __webpack_require__2(5744);
          var create2 = __webpack_require__2(2853);
          var bind3 = __webpack_require__2(6782);
          var fails = __webpack_require__2(6192);
          var nativeConstruct = getBuiltIn("Reflect", "construct");
          var NEW_TARGET_BUG = fails(function() {
            function F2() {
            }
            return !(nativeConstruct(function() {
            }, [], F2) instanceof F2);
          });
          var ARGS_BUG = !fails(function() {
            nativeConstruct(function() {
            });
          });
          var FORCED = NEW_TARGET_BUG || ARGS_BUG;
          $2({ target: "Reflect", stat: true, forced: FORCED, sham: FORCED }, {
            construct: function construct(Target, args) {
              aConstructor(Target);
              anObject(args);
              var newTarget = arguments.length < 3 ? Target : aConstructor(arguments[2]);
              if (ARGS_BUG && !NEW_TARGET_BUG)
                return nativeConstruct(Target, args, newTarget);
              if (Target == newTarget) {
                switch (args.length) {
                  case 0:
                    return new Target();
                  case 1:
                    return new Target(args[0]);
                  case 2:
                    return new Target(args[0], args[1]);
                  case 3:
                    return new Target(args[0], args[1], args[2]);
                  case 4:
                    return new Target(args[0], args[1], args[2], args[3]);
                }
                var $args = [null];
                $args.push.apply($args, args);
                return new (bind3.apply(Target, $args))();
              }
              var proto = newTarget.prototype;
              var instance = create2(isObject2(proto) ? proto : Object.prototype);
              var result = Function.apply.call(Target, instance, args);
              return isObject2(result) ? result : instance;
            }
          });
        },
        1367: function() {
        },
        5454: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var charAt = __webpack_require__2(863).charAt;
          var toString3 = __webpack_require__2(4845);
          var InternalStateModule = __webpack_require__2(3326);
          var defineIterator = __webpack_require__2(7218);
          var STRING_ITERATOR = "String Iterator";
          var setInternalState = InternalStateModule.set;
          var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);
          defineIterator(String, "String", function(iterated) {
            setInternalState(this, {
              type: STRING_ITERATOR,
              string: toString3(iterated),
              index: 0
            });
          }, function next() {
            var state = getInternalState(this);
            var string = state.string;
            var index2 = state.index;
            var point;
            if (index2 >= string.length)
              return { value: void 0, done: true };
            point = charAt(string, index2);
            state.index += point.length;
            return { value: point, done: false };
          });
        },
        957: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var $trim = __webpack_require__2(4277).trim;
          var forcedStringTrimMethod = __webpack_require__2(6815);
          $2({ target: "String", proto: true, forced: forcedStringTrimMethod("trim") }, {
            trim: function trim2() {
              return $trim(this);
            }
          });
        },
        9781: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var defineWellKnownSymbol = __webpack_require__2(1488);
          defineWellKnownSymbol("asyncIterator");
        },
        492: function() {
        },
        6681: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var defineWellKnownSymbol = __webpack_require__2(1488);
          defineWellKnownSymbol("hasInstance");
        },
        9594: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var defineWellKnownSymbol = __webpack_require__2(1488);
          defineWellKnownSymbol("isConcatSpreadable");
        },
        3665: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var defineWellKnownSymbol = __webpack_require__2(1488);
          defineWellKnownSymbol("iterator");
        },
        6187: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var global2 = __webpack_require__2(8576);
          var getBuiltIn = __webpack_require__2(150);
          var IS_PURE = __webpack_require__2(5546);
          var DESCRIPTORS = __webpack_require__2(69);
          var NATIVE_SYMBOL = __webpack_require__2(3045);
          var fails = __webpack_require__2(6192);
          var hasOwn = __webpack_require__2(4500);
          var isArray2 = __webpack_require__2(4770);
          var isCallable = __webpack_require__2(6447);
          var isObject2 = __webpack_require__2(5744);
          var isSymbol = __webpack_require__2(3236);
          var anObject = __webpack_require__2(1138);
          var toObject2 = __webpack_require__2(1795);
          var toIndexedObject = __webpack_require__2(101);
          var toPropertyKey = __webpack_require__2(77);
          var $toString = __webpack_require__2(4845);
          var createPropertyDescriptor = __webpack_require__2(774);
          var nativeObjectCreate = __webpack_require__2(2853);
          var objectKeys = __webpack_require__2(7653);
          var getOwnPropertyNamesModule = __webpack_require__2(2092);
          var getOwnPropertyNamesExternal = __webpack_require__2(4052);
          var getOwnPropertySymbolsModule = __webpack_require__2(4750);
          var getOwnPropertyDescriptorModule = __webpack_require__2(5141);
          var definePropertyModule = __webpack_require__2(2760);
          var propertyIsEnumerableModule = __webpack_require__2(6007);
          var redefine = __webpack_require__2(9482);
          var shared = __webpack_require__2(8717);
          var sharedKey = __webpack_require__2(9766);
          var hiddenKeys = __webpack_require__2(4535);
          var uid = __webpack_require__2(2759);
          var wellKnownSymbol = __webpack_require__2(8182);
          var wrappedWellKnownSymbolModule = __webpack_require__2(9207);
          var defineWellKnownSymbol = __webpack_require__2(1488);
          var setToStringTag = __webpack_require__2(1284);
          var InternalStateModule = __webpack_require__2(3326);
          var $forEach = __webpack_require__2(454).forEach;
          var HIDDEN = sharedKey("hidden");
          var SYMBOL = "Symbol";
          var PROTOTYPE = "prototype";
          var TO_PRIMITIVE = wellKnownSymbol("toPrimitive");
          var setInternalState = InternalStateModule.set;
          var getInternalState = InternalStateModule.getterFor(SYMBOL);
          var ObjectPrototype = Object[PROTOTYPE];
          var $Symbol = global2.Symbol;
          var $stringify = getBuiltIn("JSON", "stringify");
          var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
          var nativeDefineProperty = definePropertyModule.f;
          var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
          var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
          var AllSymbols = shared("symbols");
          var ObjectPrototypeSymbols = shared("op-symbols");
          var StringToSymbolRegistry = shared("string-to-symbol-registry");
          var SymbolToStringRegistry = shared("symbol-to-string-registry");
          var WellKnownSymbolsStore = shared("wks");
          var QObject = global2.QObject;
          var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;
          var setSymbolDescriptor = DESCRIPTORS && fails(function() {
            return nativeObjectCreate(nativeDefineProperty({}, "a", {
              get: function() {
                return nativeDefineProperty(this, "a", { value: 7 }).a;
              }
            })).a != 7;
          }) ? function(O2, P2, Attributes) {
            var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P2);
            if (ObjectPrototypeDescriptor)
              delete ObjectPrototype[P2];
            nativeDefineProperty(O2, P2, Attributes);
            if (ObjectPrototypeDescriptor && O2 !== ObjectPrototype) {
              nativeDefineProperty(ObjectPrototype, P2, ObjectPrototypeDescriptor);
            }
          } : nativeDefineProperty;
          var wrap = function(tag, description2) {
            var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
            setInternalState(symbol, {
              type: SYMBOL,
              tag,
              description: description2
            });
            if (!DESCRIPTORS)
              symbol.description = description2;
            return symbol;
          };
          var $defineProperty = function defineProperty(O2, P2, Attributes) {
            if (O2 === ObjectPrototype)
              $defineProperty(ObjectPrototypeSymbols, P2, Attributes);
            anObject(O2);
            var key = toPropertyKey(P2);
            anObject(Attributes);
            if (hasOwn(AllSymbols, key)) {
              if (!Attributes.enumerable) {
                if (!hasOwn(O2, HIDDEN))
                  nativeDefineProperty(O2, HIDDEN, createPropertyDescriptor(1, {}));
                O2[HIDDEN][key] = true;
              } else {
                if (hasOwn(O2, HIDDEN) && O2[HIDDEN][key])
                  O2[HIDDEN][key] = false;
                Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
              }
              return setSymbolDescriptor(O2, key, Attributes);
            }
            return nativeDefineProperty(O2, key, Attributes);
          };
          var $defineProperties = function defineProperties(O2, Properties2) {
            anObject(O2);
            var properties = toIndexedObject(Properties2);
            var keys2 = objectKeys(properties).concat($getOwnPropertySymbols(properties));
            $forEach(keys2, function(key) {
              if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key))
                $defineProperty(O2, key, properties[key]);
            });
            return O2;
          };
          var $create = function create2(O2, Properties2) {
            return Properties2 === void 0 ? nativeObjectCreate(O2) : $defineProperties(nativeObjectCreate(O2), Properties2);
          };
          var $propertyIsEnumerable = function propertyIsEnumerable(V2) {
            var P2 = toPropertyKey(V2);
            var enumerable = nativePropertyIsEnumerable.call(this, P2);
            if (this === ObjectPrototype && hasOwn(AllSymbols, P2) && !hasOwn(ObjectPrototypeSymbols, P2))
              return false;
            return enumerable || !hasOwn(this, P2) || !hasOwn(AllSymbols, P2) || hasOwn(this, HIDDEN) && this[HIDDEN][P2] ? enumerable : true;
          };
          var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O2, P2) {
            var it = toIndexedObject(O2);
            var key = toPropertyKey(P2);
            if (it === ObjectPrototype && hasOwn(AllSymbols, key) && !hasOwn(ObjectPrototypeSymbols, key))
              return;
            var descriptor = nativeGetOwnPropertyDescriptor(it, key);
            if (descriptor && hasOwn(AllSymbols, key) && !(hasOwn(it, HIDDEN) && it[HIDDEN][key])) {
              descriptor.enumerable = true;
            }
            return descriptor;
          };
          var $getOwnPropertyNames = function getOwnPropertyNames(O2) {
            var names = nativeGetOwnPropertyNames(toIndexedObject(O2));
            var result = [];
            $forEach(names, function(key) {
              if (!hasOwn(AllSymbols, key) && !hasOwn(hiddenKeys, key))
                result.push(key);
            });
            return result;
          };
          var $getOwnPropertySymbols = function getOwnPropertySymbols(O2) {
            var IS_OBJECT_PROTOTYPE = O2 === ObjectPrototype;
            var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O2));
            var result = [];
            $forEach(names, function(key) {
              if (hasOwn(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || hasOwn(ObjectPrototype, key))) {
                result.push(AllSymbols[key]);
              }
            });
            return result;
          };
          if (!NATIVE_SYMBOL) {
            $Symbol = function Symbol2() {
              if (this instanceof $Symbol)
                throw TypeError("Symbol is not a constructor");
              var description2 = !arguments.length || arguments[0] === void 0 ? void 0 : $toString(arguments[0]);
              var tag = uid(description2);
              var setter = function(value) {
                if (this === ObjectPrototype)
                  setter.call(ObjectPrototypeSymbols, value);
                if (hasOwn(this, HIDDEN) && hasOwn(this[HIDDEN], tag))
                  this[HIDDEN][tag] = false;
                setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
              };
              if (DESCRIPTORS && USE_SETTER)
                setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
              return wrap(tag, description2);
            };
            redefine($Symbol[PROTOTYPE], "toString", function toString3() {
              return getInternalState(this).tag;
            });
            redefine($Symbol, "withoutSetter", function(description2) {
              return wrap(uid(description2), description2);
            });
            propertyIsEnumerableModule.f = $propertyIsEnumerable;
            definePropertyModule.f = $defineProperty;
            getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
            getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
            getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;
            wrappedWellKnownSymbolModule.f = function(name2) {
              return wrap(wellKnownSymbol(name2), name2);
            };
            if (DESCRIPTORS) {
              nativeDefineProperty($Symbol[PROTOTYPE], "description", {
                configurable: true,
                get: function description2() {
                  return getInternalState(this).description;
                }
              });
              if (!IS_PURE) {
                redefine(ObjectPrototype, "propertyIsEnumerable", $propertyIsEnumerable, { unsafe: true });
              }
            }
          }
          $2({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
            Symbol: $Symbol
          });
          $forEach(objectKeys(WellKnownSymbolsStore), function(name2) {
            defineWellKnownSymbol(name2);
          });
          $2({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
            "for": function(key) {
              var string = $toString(key);
              if (hasOwn(StringToSymbolRegistry, string))
                return StringToSymbolRegistry[string];
              var symbol = $Symbol(string);
              StringToSymbolRegistry[string] = symbol;
              SymbolToStringRegistry[symbol] = string;
              return symbol;
            },
            keyFor: function keyFor(sym) {
              if (!isSymbol(sym))
                throw TypeError(sym + " is not a symbol");
              if (hasOwn(SymbolToStringRegistry, sym))
                return SymbolToStringRegistry[sym];
            },
            useSetter: function() {
              USE_SETTER = true;
            },
            useSimple: function() {
              USE_SETTER = false;
            }
          });
          $2({ target: "Object", stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
            create: $create,
            defineProperty: $defineProperty,
            defineProperties: $defineProperties,
            getOwnPropertyDescriptor: $getOwnPropertyDescriptor
          });
          $2({ target: "Object", stat: true, forced: !NATIVE_SYMBOL }, {
            getOwnPropertyNames: $getOwnPropertyNames,
            getOwnPropertySymbols: $getOwnPropertySymbols
          });
          $2({ target: "Object", stat: true, forced: fails(function() {
            getOwnPropertySymbolsModule.f(1);
          }) }, {
            getOwnPropertySymbols: function getOwnPropertySymbols(it) {
              return getOwnPropertySymbolsModule.f(toObject2(it));
            }
          });
          if ($stringify) {
            var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function() {
              var symbol = $Symbol();
              return $stringify([symbol]) != "[null]" || $stringify({ a: symbol }) != "{}" || $stringify(Object(symbol)) != "{}";
            });
            $2({ target: "JSON", stat: true, forced: FORCED_JSON_STRINGIFY }, {
              stringify: function stringify(it, replacer, space) {
                var args = [it];
                var index2 = 1;
                var $replacer;
                while (arguments.length > index2)
                  args.push(arguments[index2++]);
                $replacer = replacer;
                if (!isObject2(replacer) && it === void 0 || isSymbol(it))
                  return;
                if (!isArray2(replacer))
                  replacer = function(key, value) {
                    if (isCallable($replacer))
                      value = $replacer.call(this, key, value);
                    if (!isSymbol(value))
                      return value;
                  };
                args[1] = replacer;
                return $stringify.apply(null, args);
              }
            });
          }
          if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
            var valueOf = $Symbol[PROTOTYPE].valueOf;
            redefine($Symbol[PROTOTYPE], TO_PRIMITIVE, function() {
              return valueOf.apply(this, arguments);
            });
          }
          setToStringTag($Symbol, SYMBOL);
          hiddenKeys[HIDDEN] = true;
        },
        1250: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var defineWellKnownSymbol = __webpack_require__2(1488);
          defineWellKnownSymbol("matchAll");
        },
        9017: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var defineWellKnownSymbol = __webpack_require__2(1488);
          defineWellKnownSymbol("match");
        },
        9786: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var defineWellKnownSymbol = __webpack_require__2(1488);
          defineWellKnownSymbol("replace");
        },
        503: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var defineWellKnownSymbol = __webpack_require__2(1488);
          defineWellKnownSymbol("search");
        },
        6565: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var defineWellKnownSymbol = __webpack_require__2(1488);
          defineWellKnownSymbol("species");
        },
        9322: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var defineWellKnownSymbol = __webpack_require__2(1488);
          defineWellKnownSymbol("split");
        },
        3610: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var defineWellKnownSymbol = __webpack_require__2(1488);
          defineWellKnownSymbol("toPrimitive");
        },
        6886: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var defineWellKnownSymbol = __webpack_require__2(1488);
          defineWellKnownSymbol("toStringTag");
        },
        3514: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var defineWellKnownSymbol = __webpack_require__2(1488);
          defineWellKnownSymbol("unscopables");
        },
        177: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var defineWellKnownSymbol = __webpack_require__2(1488);
          defineWellKnownSymbol("asyncDispose");
        },
        9031: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var defineWellKnownSymbol = __webpack_require__2(1488);
          defineWellKnownSymbol("dispose");
        },
        6658: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var defineWellKnownSymbol = __webpack_require__2(1488);
          defineWellKnownSymbol("matcher");
        },
        1875: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var defineWellKnownSymbol = __webpack_require__2(1488);
          defineWellKnownSymbol("metadata");
        },
        8658: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var defineWellKnownSymbol = __webpack_require__2(1488);
          defineWellKnownSymbol("observable");
        },
        4592: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var defineWellKnownSymbol = __webpack_require__2(1488);
          defineWellKnownSymbol("patternMatch");
        },
        6680: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var defineWellKnownSymbol = __webpack_require__2(1488);
          defineWellKnownSymbol("replaceAll");
        },
        162: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(8939);
          var DOMIterables = __webpack_require__2(7365);
          var global2 = __webpack_require__2(8576);
          var classof = __webpack_require__2(4696);
          var createNonEnumerableProperty = __webpack_require__2(8711);
          var Iterators = __webpack_require__2(7771);
          var wellKnownSymbol = __webpack_require__2(8182);
          var TO_STRING_TAG = wellKnownSymbol("toStringTag");
          for (var COLLECTION_NAME in DOMIterables) {
            var Collection = global2[COLLECTION_NAME];
            var CollectionPrototype = Collection && Collection.prototype;
            if (CollectionPrototype && classof(CollectionPrototype) !== TO_STRING_TAG) {
              createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
            }
            Iterators[COLLECTION_NAME] = Iterators.Array;
          }
        },
        2906: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          var $2 = __webpack_require__2(3085);
          var global2 = __webpack_require__2(8576);
          var isCallable = __webpack_require__2(6447);
          var userAgent2 = __webpack_require__2(8989);
          var slice = [].slice;
          var MSIE = /MSIE .\./.test(userAgent2);
          var wrap = function(scheduler) {
            return function(handler, timeout) {
              var boundArgs = arguments.length > 2;
              var args = boundArgs ? slice.call(arguments, 2) : void 0;
              return scheduler(boundArgs ? function() {
                (isCallable(handler) ? handler : Function(handler)).apply(this, args);
              } : handler, timeout);
            };
          };
          $2({ global: true, bind: true, forced: MSIE }, {
            setTimeout: wrap(global2.setTimeout),
            setInterval: wrap(global2.setInterval)
          });
        },
        9336: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(8939);
          var $2 = __webpack_require__2(3085);
          var getBuiltIn = __webpack_require__2(150);
          var USE_NATIVE_URL = __webpack_require__2(4551);
          var redefine = __webpack_require__2(9482);
          var redefineAll = __webpack_require__2(533);
          var setToStringTag = __webpack_require__2(1284);
          var createIteratorConstructor = __webpack_require__2(5148);
          var InternalStateModule = __webpack_require__2(3326);
          var anInstance = __webpack_require__2(6961);
          var isCallable = __webpack_require__2(6447);
          var hasOwn = __webpack_require__2(4500);
          var bind3 = __webpack_require__2(8043);
          var classof = __webpack_require__2(4696);
          var anObject = __webpack_require__2(1138);
          var isObject2 = __webpack_require__2(5744);
          var $toString = __webpack_require__2(4845);
          var create2 = __webpack_require__2(2853);
          var createPropertyDescriptor = __webpack_require__2(774);
          var getIterator = __webpack_require__2(1669);
          var getIteratorMethod = __webpack_require__2(8703);
          var wellKnownSymbol = __webpack_require__2(8182);
          var nativeFetch = getBuiltIn("fetch");
          var NativeRequest = getBuiltIn("Request");
          var RequestPrototype = NativeRequest && NativeRequest.prototype;
          var Headers = getBuiltIn("Headers");
          var ITERATOR = wellKnownSymbol("iterator");
          var URL_SEARCH_PARAMS = "URLSearchParams";
          var URL_SEARCH_PARAMS_ITERATOR = URL_SEARCH_PARAMS + "Iterator";
          var setInternalState = InternalStateModule.set;
          var getInternalParamsState = InternalStateModule.getterFor(URL_SEARCH_PARAMS);
          var getInternalIteratorState = InternalStateModule.getterFor(URL_SEARCH_PARAMS_ITERATOR);
          var plus2 = /\+/g;
          var sequences = Array(4);
          var percentSequence = function(bytes) {
            return sequences[bytes - 1] || (sequences[bytes - 1] = RegExp("((?:%[\\da-f]{2}){" + bytes + "})", "gi"));
          };
          var percentDecode = function(sequence) {
            try {
              return decodeURIComponent(sequence);
            } catch (error) {
              return sequence;
            }
          };
          var deserialize = function(it) {
            var result = it.replace(plus2, " ");
            var bytes = 4;
            try {
              return decodeURIComponent(result);
            } catch (error) {
              while (bytes) {
                result = result.replace(percentSequence(bytes--), percentDecode);
              }
              return result;
            }
          };
          var find2 = /[!'()~]|%20/g;
          var replace = {
            "!": "%21",
            "'": "%27",
            "(": "%28",
            ")": "%29",
            "~": "%7E",
            "%20": "+"
          };
          var replacer = function(match) {
            return replace[match];
          };
          var serialize = function(it) {
            return encodeURIComponent(it).replace(find2, replacer);
          };
          var parseSearchParams = function(result, query) {
            if (query) {
              var attributes = query.split("&");
              var index2 = 0;
              var attribute, entry;
              while (index2 < attributes.length) {
                attribute = attributes[index2++];
                if (attribute.length) {
                  entry = attribute.split("=");
                  result.push({
                    key: deserialize(entry.shift()),
                    value: deserialize(entry.join("="))
                  });
                }
              }
            }
          };
          var updateSearchParams = function(query) {
            this.entries.length = 0;
            parseSearchParams(this.entries, query);
          };
          var validateArgumentsLength = function(passed, required) {
            if (passed < required)
              throw TypeError("Not enough arguments");
          };
          var URLSearchParamsIterator = createIteratorConstructor(function Iterator(params, kind) {
            setInternalState(this, {
              type: URL_SEARCH_PARAMS_ITERATOR,
              iterator: getIterator(getInternalParamsState(params).entries),
              kind
            });
          }, "Iterator", function next() {
            var state = getInternalIteratorState(this);
            var kind = state.kind;
            var step = state.iterator.next();
            var entry = step.value;
            if (!step.done) {
              step.value = kind === "keys" ? entry.key : kind === "values" ? entry.value : [entry.key, entry.value];
            }
            return step;
          });
          var URLSearchParamsConstructor = function URLSearchParams2() {
            anInstance(this, URLSearchParamsConstructor, URL_SEARCH_PARAMS);
            var init2 = arguments.length > 0 ? arguments[0] : void 0;
            var that = this;
            var entries = [];
            var iteratorMethod, iterator, next, step, entryIterator, entryNext, first, second, key;
            setInternalState(that, {
              type: URL_SEARCH_PARAMS,
              entries,
              updateURL: function() {
              },
              updateSearchParams
            });
            if (init2 !== void 0) {
              if (isObject2(init2)) {
                iteratorMethod = getIteratorMethod(init2);
                if (iteratorMethod) {
                  iterator = getIterator(init2, iteratorMethod);
                  next = iterator.next;
                  while (!(step = next.call(iterator)).done) {
                    entryIterator = getIterator(anObject(step.value));
                    entryNext = entryIterator.next;
                    if ((first = entryNext.call(entryIterator)).done || (second = entryNext.call(entryIterator)).done || !entryNext.call(entryIterator).done)
                      throw TypeError("Expected sequence with length 2");
                    entries.push({ key: $toString(first.value), value: $toString(second.value) });
                  }
                } else
                  for (key in init2)
                    if (hasOwn(init2, key))
                      entries.push({ key, value: $toString(init2[key]) });
              } else {
                parseSearchParams(
                  entries,
                  typeof init2 === "string" ? init2.charAt(0) === "?" ? init2.slice(1) : init2 : $toString(init2)
                );
              }
            }
          };
          var URLSearchParamsPrototype = URLSearchParamsConstructor.prototype;
          redefineAll(URLSearchParamsPrototype, {
            append: function append(name2, value) {
              validateArgumentsLength(arguments.length, 2);
              var state = getInternalParamsState(this);
              state.entries.push({ key: $toString(name2), value: $toString(value) });
              state.updateURL();
            },
            "delete": function(name2) {
              validateArgumentsLength(arguments.length, 1);
              var state = getInternalParamsState(this);
              var entries = state.entries;
              var key = $toString(name2);
              var index2 = 0;
              while (index2 < entries.length) {
                if (entries[index2].key === key)
                  entries.splice(index2, 1);
                else
                  index2++;
              }
              state.updateURL();
            },
            get: function get(name2) {
              validateArgumentsLength(arguments.length, 1);
              var entries = getInternalParamsState(this).entries;
              var key = $toString(name2);
              var index2 = 0;
              for (; index2 < entries.length; index2++) {
                if (entries[index2].key === key)
                  return entries[index2].value;
              }
              return null;
            },
            getAll: function getAll(name2) {
              validateArgumentsLength(arguments.length, 1);
              var entries = getInternalParamsState(this).entries;
              var key = $toString(name2);
              var result = [];
              var index2 = 0;
              for (; index2 < entries.length; index2++) {
                if (entries[index2].key === key)
                  result.push(entries[index2].value);
              }
              return result;
            },
            has: function has(name2) {
              validateArgumentsLength(arguments.length, 1);
              var entries = getInternalParamsState(this).entries;
              var key = $toString(name2);
              var index2 = 0;
              while (index2 < entries.length) {
                if (entries[index2++].key === key)
                  return true;
              }
              return false;
            },
            set: function set(name2, value) {
              validateArgumentsLength(arguments.length, 1);
              var state = getInternalParamsState(this);
              var entries = state.entries;
              var found = false;
              var key = $toString(name2);
              var val = $toString(value);
              var index2 = 0;
              var entry;
              for (; index2 < entries.length; index2++) {
                entry = entries[index2];
                if (entry.key === key) {
                  if (found)
                    entries.splice(index2--, 1);
                  else {
                    found = true;
                    entry.value = val;
                  }
                }
              }
              if (!found)
                entries.push({ key, value: val });
              state.updateURL();
            },
            sort: function sort2() {
              var state = getInternalParamsState(this);
              var entries = state.entries;
              var slice = entries.slice();
              var entry, entriesIndex, sliceIndex;
              entries.length = 0;
              for (sliceIndex = 0; sliceIndex < slice.length; sliceIndex++) {
                entry = slice[sliceIndex];
                for (entriesIndex = 0; entriesIndex < sliceIndex; entriesIndex++) {
                  if (entries[entriesIndex].key > entry.key) {
                    entries.splice(entriesIndex, 0, entry);
                    break;
                  }
                }
                if (entriesIndex === sliceIndex)
                  entries.push(entry);
              }
              state.updateURL();
            },
            forEach: function forEach3(callback) {
              var entries = getInternalParamsState(this).entries;
              var boundFunction = bind3(callback, arguments.length > 1 ? arguments[1] : void 0, 3);
              var index2 = 0;
              var entry;
              while (index2 < entries.length) {
                entry = entries[index2++];
                boundFunction(entry.value, entry.key, this);
              }
            },
            keys: function keys2() {
              return new URLSearchParamsIterator(this, "keys");
            },
            values: function values() {
              return new URLSearchParamsIterator(this, "values");
            },
            entries: function entries() {
              return new URLSearchParamsIterator(this, "entries");
            }
          }, { enumerable: true });
          redefine(URLSearchParamsPrototype, ITERATOR, URLSearchParamsPrototype.entries, { name: "entries" });
          redefine(URLSearchParamsPrototype, "toString", function toString3() {
            var entries = getInternalParamsState(this).entries;
            var result = [];
            var index2 = 0;
            var entry;
            while (index2 < entries.length) {
              entry = entries[index2++];
              result.push(serialize(entry.key) + "=" + serialize(entry.value));
            }
            return result.join("&");
          }, { enumerable: true });
          setToStringTag(URLSearchParamsConstructor, URL_SEARCH_PARAMS);
          $2({ global: true, forced: !USE_NATIVE_URL }, {
            URLSearchParams: URLSearchParamsConstructor
          });
          if (!USE_NATIVE_URL && isCallable(Headers)) {
            var wrapRequestOptions = function(init2) {
              if (isObject2(init2)) {
                var body = init2.body;
                var headers;
                if (classof(body) === URL_SEARCH_PARAMS) {
                  headers = init2.headers ? new Headers(init2.headers) : new Headers();
                  if (!headers.has("content-type")) {
                    headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
                  }
                  return create2(init2, {
                    body: createPropertyDescriptor(0, String(body)),
                    headers: createPropertyDescriptor(0, headers)
                  });
                }
              }
              return init2;
            };
            if (isCallable(nativeFetch)) {
              $2({ global: true, enumerable: true, forced: true }, {
                fetch: function fetch2(input) {
                  return nativeFetch(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
                }
              });
            }
            if (isCallable(NativeRequest)) {
              var RequestConstructor = function Request(input) {
                anInstance(this, RequestConstructor, "Request");
                return new NativeRequest(input, arguments.length > 1 ? wrapRequestOptions(arguments[1]) : {});
              };
              RequestPrototype.constructor = RequestConstructor;
              RequestConstructor.prototype = RequestPrototype;
              $2({ global: true, forced: true }, {
                Request: RequestConstructor
              });
            }
          }
          module2.exports = {
            URLSearchParams: URLSearchParamsConstructor,
            getState: getInternalParamsState
          };
        },
        4948: function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(5454);
          var $2 = __webpack_require__2(3085);
          var DESCRIPTORS = __webpack_require__2(69);
          var USE_NATIVE_URL = __webpack_require__2(4551);
          var global2 = __webpack_require__2(8576);
          var defineProperties = __webpack_require__2(1187);
          var redefine = __webpack_require__2(9482);
          var anInstance = __webpack_require__2(6961);
          var hasOwn = __webpack_require__2(4500);
          var assign = __webpack_require__2(2503);
          var arrayFrom = __webpack_require__2(841);
          var codeAt = __webpack_require__2(863).codeAt;
          var toASCII = __webpack_require__2(7977);
          var $toString = __webpack_require__2(4845);
          var setToStringTag = __webpack_require__2(1284);
          var URLSearchParamsModule = __webpack_require__2(9336);
          var InternalStateModule = __webpack_require__2(3326);
          var NativeURL = global2.URL;
          var URLSearchParams2 = URLSearchParamsModule.URLSearchParams;
          var getInternalSearchParamsState = URLSearchParamsModule.getState;
          var setInternalState = InternalStateModule.set;
          var getInternalURLState = InternalStateModule.getterFor("URL");
          var floor = Math.floor;
          var pow = Math.pow;
          var INVALID_AUTHORITY = "Invalid authority";
          var INVALID_SCHEME = "Invalid scheme";
          var INVALID_HOST = "Invalid host";
          var INVALID_PORT = "Invalid port";
          var ALPHA = /[A-Za-z]/;
          var ALPHANUMERIC = /[\d+-.A-Za-z]/;
          var DIGIT = /\d/;
          var HEX_START = /^0x/i;
          var OCT = /^[0-7]+$/;
          var DEC = /^\d+$/;
          var HEX = /^[\dA-Fa-f]+$/;
          var FORBIDDEN_HOST_CODE_POINT = /[\0\t\n\r #%/:<>?@[\\\]^|]/;
          var FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT = /[\0\t\n\r #/:<>?@[\\\]^|]/;
          var LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE = /^[\u0000-\u0020]+|[\u0000-\u0020]+$/g;
          var TAB_AND_NEW_LINE = /[\t\n\r]/g;
          var EOF2;
          var parseHost = function(url, input) {
            var result, codePoints, index2;
            if (input.charAt(0) == "[") {
              if (input.charAt(input.length - 1) != "]")
                return INVALID_HOST;
              result = parseIPv6(input.slice(1, -1));
              if (!result)
                return INVALID_HOST;
              url.host = result;
            } else if (!isSpecial(url)) {
              if (FORBIDDEN_HOST_CODE_POINT_EXCLUDING_PERCENT.test(input))
                return INVALID_HOST;
              result = "";
              codePoints = arrayFrom(input);
              for (index2 = 0; index2 < codePoints.length; index2++) {
                result += percentEncode(codePoints[index2], C0ControlPercentEncodeSet);
              }
              url.host = result;
            } else {
              input = toASCII(input);
              if (FORBIDDEN_HOST_CODE_POINT.test(input))
                return INVALID_HOST;
              result = parseIPv4(input);
              if (result === null)
                return INVALID_HOST;
              url.host = result;
            }
          };
          var parseIPv4 = function(input) {
            var parts = input.split(".");
            var partsLength, numbers, index2, part, radix, number, ipv4;
            if (parts.length && parts[parts.length - 1] == "") {
              parts.pop();
            }
            partsLength = parts.length;
            if (partsLength > 4)
              return input;
            numbers = [];
            for (index2 = 0; index2 < partsLength; index2++) {
              part = parts[index2];
              if (part == "")
                return input;
              radix = 10;
              if (part.length > 1 && part.charAt(0) == "0") {
                radix = HEX_START.test(part) ? 16 : 8;
                part = part.slice(radix == 8 ? 1 : 2);
              }
              if (part === "") {
                number = 0;
              } else {
                if (!(radix == 10 ? DEC : radix == 8 ? OCT : HEX).test(part))
                  return input;
                number = parseInt(part, radix);
              }
              numbers.push(number);
            }
            for (index2 = 0; index2 < partsLength; index2++) {
              number = numbers[index2];
              if (index2 == partsLength - 1) {
                if (number >= pow(256, 5 - partsLength))
                  return null;
              } else if (number > 255)
                return null;
            }
            ipv4 = numbers.pop();
            for (index2 = 0; index2 < numbers.length; index2++) {
              ipv4 += numbers[index2] * pow(256, 3 - index2);
            }
            return ipv4;
          };
          var parseIPv6 = function(input) {
            var address = [0, 0, 0, 0, 0, 0, 0, 0];
            var pieceIndex = 0;
            var compress = null;
            var pointer = 0;
            var value, length, numbersSeen, ipv4Piece, number, swaps, swap2;
            var chr = function() {
              return input.charAt(pointer);
            };
            if (chr() == ":") {
              if (input.charAt(1) != ":")
                return;
              pointer += 2;
              pieceIndex++;
              compress = pieceIndex;
            }
            while (chr()) {
              if (pieceIndex == 8)
                return;
              if (chr() == ":") {
                if (compress !== null)
                  return;
                pointer++;
                pieceIndex++;
                compress = pieceIndex;
                continue;
              }
              value = length = 0;
              while (length < 4 && HEX.test(chr())) {
                value = value * 16 + parseInt(chr(), 16);
                pointer++;
                length++;
              }
              if (chr() == ".") {
                if (length == 0)
                  return;
                pointer -= length;
                if (pieceIndex > 6)
                  return;
                numbersSeen = 0;
                while (chr()) {
                  ipv4Piece = null;
                  if (numbersSeen > 0) {
                    if (chr() == "." && numbersSeen < 4)
                      pointer++;
                    else
                      return;
                  }
                  if (!DIGIT.test(chr()))
                    return;
                  while (DIGIT.test(chr())) {
                    number = parseInt(chr(), 10);
                    if (ipv4Piece === null)
                      ipv4Piece = number;
                    else if (ipv4Piece == 0)
                      return;
                    else
                      ipv4Piece = ipv4Piece * 10 + number;
                    if (ipv4Piece > 255)
                      return;
                    pointer++;
                  }
                  address[pieceIndex] = address[pieceIndex] * 256 + ipv4Piece;
                  numbersSeen++;
                  if (numbersSeen == 2 || numbersSeen == 4)
                    pieceIndex++;
                }
                if (numbersSeen != 4)
                  return;
                break;
              } else if (chr() == ":") {
                pointer++;
                if (!chr())
                  return;
              } else if (chr())
                return;
              address[pieceIndex++] = value;
            }
            if (compress !== null) {
              swaps = pieceIndex - compress;
              pieceIndex = 7;
              while (pieceIndex != 0 && swaps > 0) {
                swap2 = address[pieceIndex];
                address[pieceIndex--] = address[compress + swaps - 1];
                address[compress + --swaps] = swap2;
              }
            } else if (pieceIndex != 8)
              return;
            return address;
          };
          var findLongestZeroSequence = function(ipv6) {
            var maxIndex = null;
            var maxLength = 1;
            var currStart = null;
            var currLength = 0;
            var index2 = 0;
            for (; index2 < 8; index2++) {
              if (ipv6[index2] !== 0) {
                if (currLength > maxLength) {
                  maxIndex = currStart;
                  maxLength = currLength;
                }
                currStart = null;
                currLength = 0;
              } else {
                if (currStart === null)
                  currStart = index2;
                ++currLength;
              }
            }
            if (currLength > maxLength) {
              maxIndex = currStart;
              maxLength = currLength;
            }
            return maxIndex;
          };
          var serializeHost = function(host) {
            var result, index2, compress, ignore0;
            if (typeof host == "number") {
              result = [];
              for (index2 = 0; index2 < 4; index2++) {
                result.unshift(host % 256);
                host = floor(host / 256);
              }
              return result.join(".");
            } else if (typeof host == "object") {
              result = "";
              compress = findLongestZeroSequence(host);
              for (index2 = 0; index2 < 8; index2++) {
                if (ignore0 && host[index2] === 0)
                  continue;
                if (ignore0)
                  ignore0 = false;
                if (compress === index2) {
                  result += index2 ? ":" : "::";
                  ignore0 = true;
                } else {
                  result += host[index2].toString(16);
                  if (index2 < 7)
                    result += ":";
                }
              }
              return "[" + result + "]";
            }
            return host;
          };
          var C0ControlPercentEncodeSet = {};
          var fragmentPercentEncodeSet = assign({}, C0ControlPercentEncodeSet, {
            " ": 1,
            '"': 1,
            "<": 1,
            ">": 1,
            "`": 1
          });
          var pathPercentEncodeSet = assign({}, fragmentPercentEncodeSet, {
            "#": 1,
            "?": 1,
            "{": 1,
            "}": 1
          });
          var userinfoPercentEncodeSet = assign({}, pathPercentEncodeSet, {
            "/": 1,
            ":": 1,
            ";": 1,
            "=": 1,
            "@": 1,
            "[": 1,
            "\\": 1,
            "]": 1,
            "^": 1,
            "|": 1
          });
          var percentEncode = function(chr, set) {
            var code = codeAt(chr, 0);
            return code > 32 && code < 127 && !hasOwn(set, chr) ? chr : encodeURIComponent(chr);
          };
          var specialSchemes = {
            ftp: 21,
            file: null,
            http: 80,
            https: 443,
            ws: 80,
            wss: 443
          };
          var isSpecial = function(url) {
            return hasOwn(specialSchemes, url.scheme);
          };
          var includesCredentials = function(url) {
            return url.username != "" || url.password != "";
          };
          var cannotHaveUsernamePasswordPort = function(url) {
            return !url.host || url.cannotBeABaseURL || url.scheme == "file";
          };
          var isWindowsDriveLetter = function(string, normalized) {
            var second;
            return string.length == 2 && ALPHA.test(string.charAt(0)) && ((second = string.charAt(1)) == ":" || !normalized && second == "|");
          };
          var startsWithWindowsDriveLetter = function(string) {
            var third;
            return string.length > 1 && isWindowsDriveLetter(string.slice(0, 2)) && (string.length == 2 || ((third = string.charAt(2)) === "/" || third === "\\" || third === "?" || third === "#"));
          };
          var shortenURLsPath = function(url) {
            var path = url.path;
            var pathSize = path.length;
            if (pathSize && (url.scheme != "file" || pathSize != 1 || !isWindowsDriveLetter(path[0], true))) {
              path.pop();
            }
          };
          var isSingleDot = function(segment) {
            return segment === "." || segment.toLowerCase() === "%2e";
          };
          var isDoubleDot = function(segment) {
            segment = segment.toLowerCase();
            return segment === ".." || segment === "%2e." || segment === ".%2e" || segment === "%2e%2e";
          };
          var SCHEME_START = {};
          var SCHEME = {};
          var NO_SCHEME = {};
          var SPECIAL_RELATIVE_OR_AUTHORITY = {};
          var PATH_OR_AUTHORITY = {};
          var RELATIVE = {};
          var RELATIVE_SLASH = {};
          var SPECIAL_AUTHORITY_SLASHES = {};
          var SPECIAL_AUTHORITY_IGNORE_SLASHES = {};
          var AUTHORITY = {};
          var HOST = {};
          var HOSTNAME = {};
          var PORT = {};
          var FILE = {};
          var FILE_SLASH = {};
          var FILE_HOST = {};
          var PATH_START = {};
          var PATH = {};
          var CANNOT_BE_A_BASE_URL_PATH = {};
          var QUERY = {};
          var FRAGMENT = {};
          var parseURL = function(url, input, stateOverride, base2) {
            var state = stateOverride || SCHEME_START;
            var pointer = 0;
            var buffer = "";
            var seenAt = false;
            var seenBracket = false;
            var seenPasswordToken = false;
            var codePoints, chr, bufferCodePoints, failure;
            if (!stateOverride) {
              url.scheme = "";
              url.username = "";
              url.password = "";
              url.host = null;
              url.port = null;
              url.path = [];
              url.query = null;
              url.fragment = null;
              url.cannotBeABaseURL = false;
              input = input.replace(LEADING_AND_TRAILING_C0_CONTROL_OR_SPACE, "");
            }
            input = input.replace(TAB_AND_NEW_LINE, "");
            codePoints = arrayFrom(input);
            while (pointer <= codePoints.length) {
              chr = codePoints[pointer];
              switch (state) {
                case SCHEME_START:
                  if (chr && ALPHA.test(chr)) {
                    buffer += chr.toLowerCase();
                    state = SCHEME;
                  } else if (!stateOverride) {
                    state = NO_SCHEME;
                    continue;
                  } else
                    return INVALID_SCHEME;
                  break;
                case SCHEME:
                  if (chr && (ALPHANUMERIC.test(chr) || chr == "+" || chr == "-" || chr == ".")) {
                    buffer += chr.toLowerCase();
                  } else if (chr == ":") {
                    if (stateOverride && (isSpecial(url) != hasOwn(specialSchemes, buffer) || buffer == "file" && (includesCredentials(url) || url.port !== null) || url.scheme == "file" && !url.host))
                      return;
                    url.scheme = buffer;
                    if (stateOverride) {
                      if (isSpecial(url) && specialSchemes[url.scheme] == url.port)
                        url.port = null;
                      return;
                    }
                    buffer = "";
                    if (url.scheme == "file") {
                      state = FILE;
                    } else if (isSpecial(url) && base2 && base2.scheme == url.scheme) {
                      state = SPECIAL_RELATIVE_OR_AUTHORITY;
                    } else if (isSpecial(url)) {
                      state = SPECIAL_AUTHORITY_SLASHES;
                    } else if (codePoints[pointer + 1] == "/") {
                      state = PATH_OR_AUTHORITY;
                      pointer++;
                    } else {
                      url.cannotBeABaseURL = true;
                      url.path.push("");
                      state = CANNOT_BE_A_BASE_URL_PATH;
                    }
                  } else if (!stateOverride) {
                    buffer = "";
                    state = NO_SCHEME;
                    pointer = 0;
                    continue;
                  } else
                    return INVALID_SCHEME;
                  break;
                case NO_SCHEME:
                  if (!base2 || base2.cannotBeABaseURL && chr != "#")
                    return INVALID_SCHEME;
                  if (base2.cannotBeABaseURL && chr == "#") {
                    url.scheme = base2.scheme;
                    url.path = base2.path.slice();
                    url.query = base2.query;
                    url.fragment = "";
                    url.cannotBeABaseURL = true;
                    state = FRAGMENT;
                    break;
                  }
                  state = base2.scheme == "file" ? FILE : RELATIVE;
                  continue;
                case SPECIAL_RELATIVE_OR_AUTHORITY:
                  if (chr == "/" && codePoints[pointer + 1] == "/") {
                    state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                    pointer++;
                  } else {
                    state = RELATIVE;
                    continue;
                  }
                  break;
                case PATH_OR_AUTHORITY:
                  if (chr == "/") {
                    state = AUTHORITY;
                    break;
                  } else {
                    state = PATH;
                    continue;
                  }
                case RELATIVE:
                  url.scheme = base2.scheme;
                  if (chr == EOF2) {
                    url.username = base2.username;
                    url.password = base2.password;
                    url.host = base2.host;
                    url.port = base2.port;
                    url.path = base2.path.slice();
                    url.query = base2.query;
                  } else if (chr == "/" || chr == "\\" && isSpecial(url)) {
                    state = RELATIVE_SLASH;
                  } else if (chr == "?") {
                    url.username = base2.username;
                    url.password = base2.password;
                    url.host = base2.host;
                    url.port = base2.port;
                    url.path = base2.path.slice();
                    url.query = "";
                    state = QUERY;
                  } else if (chr == "#") {
                    url.username = base2.username;
                    url.password = base2.password;
                    url.host = base2.host;
                    url.port = base2.port;
                    url.path = base2.path.slice();
                    url.query = base2.query;
                    url.fragment = "";
                    state = FRAGMENT;
                  } else {
                    url.username = base2.username;
                    url.password = base2.password;
                    url.host = base2.host;
                    url.port = base2.port;
                    url.path = base2.path.slice();
                    url.path.pop();
                    state = PATH;
                    continue;
                  }
                  break;
                case RELATIVE_SLASH:
                  if (isSpecial(url) && (chr == "/" || chr == "\\")) {
                    state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                  } else if (chr == "/") {
                    state = AUTHORITY;
                  } else {
                    url.username = base2.username;
                    url.password = base2.password;
                    url.host = base2.host;
                    url.port = base2.port;
                    state = PATH;
                    continue;
                  }
                  break;
                case SPECIAL_AUTHORITY_SLASHES:
                  state = SPECIAL_AUTHORITY_IGNORE_SLASHES;
                  if (chr != "/" || buffer.charAt(pointer + 1) != "/")
                    continue;
                  pointer++;
                  break;
                case SPECIAL_AUTHORITY_IGNORE_SLASHES:
                  if (chr != "/" && chr != "\\") {
                    state = AUTHORITY;
                    continue;
                  }
                  break;
                case AUTHORITY:
                  if (chr == "@") {
                    if (seenAt)
                      buffer = "%40" + buffer;
                    seenAt = true;
                    bufferCodePoints = arrayFrom(buffer);
                    for (var i = 0; i < bufferCodePoints.length; i++) {
                      var codePoint = bufferCodePoints[i];
                      if (codePoint == ":" && !seenPasswordToken) {
                        seenPasswordToken = true;
                        continue;
                      }
                      var encodedCodePoints = percentEncode(codePoint, userinfoPercentEncodeSet);
                      if (seenPasswordToken)
                        url.password += encodedCodePoints;
                      else
                        url.username += encodedCodePoints;
                    }
                    buffer = "";
                  } else if (chr == EOF2 || chr == "/" || chr == "?" || chr == "#" || chr == "\\" && isSpecial(url)) {
                    if (seenAt && buffer == "")
                      return INVALID_AUTHORITY;
                    pointer -= arrayFrom(buffer).length + 1;
                    buffer = "";
                    state = HOST;
                  } else
                    buffer += chr;
                  break;
                case HOST:
                case HOSTNAME:
                  if (stateOverride && url.scheme == "file") {
                    state = FILE_HOST;
                    continue;
                  } else if (chr == ":" && !seenBracket) {
                    if (buffer == "")
                      return INVALID_HOST;
                    failure = parseHost(url, buffer);
                    if (failure)
                      return failure;
                    buffer = "";
                    state = PORT;
                    if (stateOverride == HOSTNAME)
                      return;
                  } else if (chr == EOF2 || chr == "/" || chr == "?" || chr == "#" || chr == "\\" && isSpecial(url)) {
                    if (isSpecial(url) && buffer == "")
                      return INVALID_HOST;
                    if (stateOverride && buffer == "" && (includesCredentials(url) || url.port !== null))
                      return;
                    failure = parseHost(url, buffer);
                    if (failure)
                      return failure;
                    buffer = "";
                    state = PATH_START;
                    if (stateOverride)
                      return;
                    continue;
                  } else {
                    if (chr == "[")
                      seenBracket = true;
                    else if (chr == "]")
                      seenBracket = false;
                    buffer += chr;
                  }
                  break;
                case PORT:
                  if (DIGIT.test(chr)) {
                    buffer += chr;
                  } else if (chr == EOF2 || chr == "/" || chr == "?" || chr == "#" || chr == "\\" && isSpecial(url) || stateOverride) {
                    if (buffer != "") {
                      var port = parseInt(buffer, 10);
                      if (port > 65535)
                        return INVALID_PORT;
                      url.port = isSpecial(url) && port === specialSchemes[url.scheme] ? null : port;
                      buffer = "";
                    }
                    if (stateOverride)
                      return;
                    state = PATH_START;
                    continue;
                  } else
                    return INVALID_PORT;
                  break;
                case FILE:
                  url.scheme = "file";
                  if (chr == "/" || chr == "\\")
                    state = FILE_SLASH;
                  else if (base2 && base2.scheme == "file") {
                    if (chr == EOF2) {
                      url.host = base2.host;
                      url.path = base2.path.slice();
                      url.query = base2.query;
                    } else if (chr == "?") {
                      url.host = base2.host;
                      url.path = base2.path.slice();
                      url.query = "";
                      state = QUERY;
                    } else if (chr == "#") {
                      url.host = base2.host;
                      url.path = base2.path.slice();
                      url.query = base2.query;
                      url.fragment = "";
                      state = FRAGMENT;
                    } else {
                      if (!startsWithWindowsDriveLetter(codePoints.slice(pointer).join(""))) {
                        url.host = base2.host;
                        url.path = base2.path.slice();
                        shortenURLsPath(url);
                      }
                      state = PATH;
                      continue;
                    }
                  } else {
                    state = PATH;
                    continue;
                  }
                  break;
                case FILE_SLASH:
                  if (chr == "/" || chr == "\\") {
                    state = FILE_HOST;
                    break;
                  }
                  if (base2 && base2.scheme == "file" && !startsWithWindowsDriveLetter(codePoints.slice(pointer).join(""))) {
                    if (isWindowsDriveLetter(base2.path[0], true))
                      url.path.push(base2.path[0]);
                    else
                      url.host = base2.host;
                  }
                  state = PATH;
                  continue;
                case FILE_HOST:
                  if (chr == EOF2 || chr == "/" || chr == "\\" || chr == "?" || chr == "#") {
                    if (!stateOverride && isWindowsDriveLetter(buffer)) {
                      state = PATH;
                    } else if (buffer == "") {
                      url.host = "";
                      if (stateOverride)
                        return;
                      state = PATH_START;
                    } else {
                      failure = parseHost(url, buffer);
                      if (failure)
                        return failure;
                      if (url.host == "localhost")
                        url.host = "";
                      if (stateOverride)
                        return;
                      buffer = "";
                      state = PATH_START;
                    }
                    continue;
                  } else
                    buffer += chr;
                  break;
                case PATH_START:
                  if (isSpecial(url)) {
                    state = PATH;
                    if (chr != "/" && chr != "\\")
                      continue;
                  } else if (!stateOverride && chr == "?") {
                    url.query = "";
                    state = QUERY;
                  } else if (!stateOverride && chr == "#") {
                    url.fragment = "";
                    state = FRAGMENT;
                  } else if (chr != EOF2) {
                    state = PATH;
                    if (chr != "/")
                      continue;
                  }
                  break;
                case PATH:
                  if (chr == EOF2 || chr == "/" || chr == "\\" && isSpecial(url) || !stateOverride && (chr == "?" || chr == "#")) {
                    if (isDoubleDot(buffer)) {
                      shortenURLsPath(url);
                      if (chr != "/" && !(chr == "\\" && isSpecial(url))) {
                        url.path.push("");
                      }
                    } else if (isSingleDot(buffer)) {
                      if (chr != "/" && !(chr == "\\" && isSpecial(url))) {
                        url.path.push("");
                      }
                    } else {
                      if (url.scheme == "file" && !url.path.length && isWindowsDriveLetter(buffer)) {
                        if (url.host)
                          url.host = "";
                        buffer = buffer.charAt(0) + ":";
                      }
                      url.path.push(buffer);
                    }
                    buffer = "";
                    if (url.scheme == "file" && (chr == EOF2 || chr == "?" || chr == "#")) {
                      while (url.path.length > 1 && url.path[0] === "") {
                        url.path.shift();
                      }
                    }
                    if (chr == "?") {
                      url.query = "";
                      state = QUERY;
                    } else if (chr == "#") {
                      url.fragment = "";
                      state = FRAGMENT;
                    }
                  } else {
                    buffer += percentEncode(chr, pathPercentEncodeSet);
                  }
                  break;
                case CANNOT_BE_A_BASE_URL_PATH:
                  if (chr == "?") {
                    url.query = "";
                    state = QUERY;
                  } else if (chr == "#") {
                    url.fragment = "";
                    state = FRAGMENT;
                  } else if (chr != EOF2) {
                    url.path[0] += percentEncode(chr, C0ControlPercentEncodeSet);
                  }
                  break;
                case QUERY:
                  if (!stateOverride && chr == "#") {
                    url.fragment = "";
                    state = FRAGMENT;
                  } else if (chr != EOF2) {
                    if (chr == "'" && isSpecial(url))
                      url.query += "%27";
                    else if (chr == "#")
                      url.query += "%23";
                    else
                      url.query += percentEncode(chr, C0ControlPercentEncodeSet);
                  }
                  break;
                case FRAGMENT:
                  if (chr != EOF2)
                    url.fragment += percentEncode(chr, fragmentPercentEncodeSet);
                  break;
              }
              pointer++;
            }
          };
          var URLConstructor = function URL2(url) {
            var that = anInstance(this, URLConstructor, "URL");
            var base2 = arguments.length > 1 ? arguments[1] : void 0;
            var urlString = $toString(url);
            var state = setInternalState(that, { type: "URL" });
            var baseState, failure;
            if (base2 !== void 0) {
              if (base2 instanceof URLConstructor)
                baseState = getInternalURLState(base2);
              else {
                failure = parseURL(baseState = {}, $toString(base2));
                if (failure)
                  throw TypeError(failure);
              }
            }
            failure = parseURL(state, urlString, null, baseState);
            if (failure)
              throw TypeError(failure);
            var searchParams = state.searchParams = new URLSearchParams2();
            var searchParamsState = getInternalSearchParamsState(searchParams);
            searchParamsState.updateSearchParams(state.query);
            searchParamsState.updateURL = function() {
              state.query = String(searchParams) || null;
            };
            if (!DESCRIPTORS) {
              that.href = serializeURL.call(that);
              that.origin = getOrigin2.call(that);
              that.protocol = getProtocol.call(that);
              that.username = getUsername.call(that);
              that.password = getPassword.call(that);
              that.host = getHost.call(that);
              that.hostname = getHostname.call(that);
              that.port = getPort.call(that);
              that.pathname = getPathname.call(that);
              that.search = getSearch.call(that);
              that.searchParams = getSearchParams.call(that);
              that.hash = getHash2.call(that);
            }
          };
          var URLPrototype = URLConstructor.prototype;
          var serializeURL = function() {
            var url = getInternalURLState(this);
            var scheme = url.scheme;
            var username = url.username;
            var password = url.password;
            var host = url.host;
            var port = url.port;
            var path = url.path;
            var query = url.query;
            var fragment = url.fragment;
            var output = scheme + ":";
            if (host !== null) {
              output += "//";
              if (includesCredentials(url)) {
                output += username + (password ? ":" + password : "") + "@";
              }
              output += serializeHost(host);
              if (port !== null)
                output += ":" + port;
            } else if (scheme == "file")
              output += "//";
            output += url.cannotBeABaseURL ? path[0] : path.length ? "/" + path.join("/") : "";
            if (query !== null)
              output += "?" + query;
            if (fragment !== null)
              output += "#" + fragment;
            return output;
          };
          var getOrigin2 = function() {
            var url = getInternalURLState(this);
            var scheme = url.scheme;
            var port = url.port;
            if (scheme == "blob")
              try {
                return new URLConstructor(scheme.path[0]).origin;
              } catch (error) {
                return "null";
              }
            if (scheme == "file" || !isSpecial(url))
              return "null";
            return scheme + "://" + serializeHost(url.host) + (port !== null ? ":" + port : "");
          };
          var getProtocol = function() {
            return getInternalURLState(this).scheme + ":";
          };
          var getUsername = function() {
            return getInternalURLState(this).username;
          };
          var getPassword = function() {
            return getInternalURLState(this).password;
          };
          var getHost = function() {
            var url = getInternalURLState(this);
            var host = url.host;
            var port = url.port;
            return host === null ? "" : port === null ? serializeHost(host) : serializeHost(host) + ":" + port;
          };
          var getHostname = function() {
            var host = getInternalURLState(this).host;
            return host === null ? "" : serializeHost(host);
          };
          var getPort = function() {
            var port = getInternalURLState(this).port;
            return port === null ? "" : String(port);
          };
          var getPathname = function() {
            var url = getInternalURLState(this);
            var path = url.path;
            return url.cannotBeABaseURL ? path[0] : path.length ? "/" + path.join("/") : "";
          };
          var getSearch = function() {
            var query = getInternalURLState(this).query;
            return query ? "?" + query : "";
          };
          var getSearchParams = function() {
            return getInternalURLState(this).searchParams;
          };
          var getHash2 = function() {
            var fragment = getInternalURLState(this).fragment;
            return fragment ? "#" + fragment : "";
          };
          var accessorDescriptor = function(getter, setter) {
            return { get: getter, set: setter, configurable: true, enumerable: true };
          };
          if (DESCRIPTORS) {
            defineProperties(URLPrototype, {
              href: accessorDescriptor(serializeURL, function(href) {
                var url = getInternalURLState(this);
                var urlString = $toString(href);
                var failure = parseURL(url, urlString);
                if (failure)
                  throw TypeError(failure);
                getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
              }),
              origin: accessorDescriptor(getOrigin2),
              protocol: accessorDescriptor(getProtocol, function(protocol) {
                var url = getInternalURLState(this);
                parseURL(url, $toString(protocol) + ":", SCHEME_START);
              }),
              username: accessorDescriptor(getUsername, function(username) {
                var url = getInternalURLState(this);
                var codePoints = arrayFrom($toString(username));
                if (cannotHaveUsernamePasswordPort(url))
                  return;
                url.username = "";
                for (var i = 0; i < codePoints.length; i++) {
                  url.username += percentEncode(codePoints[i], userinfoPercentEncodeSet);
                }
              }),
              password: accessorDescriptor(getPassword, function(password) {
                var url = getInternalURLState(this);
                var codePoints = arrayFrom($toString(password));
                if (cannotHaveUsernamePasswordPort(url))
                  return;
                url.password = "";
                for (var i = 0; i < codePoints.length; i++) {
                  url.password += percentEncode(codePoints[i], userinfoPercentEncodeSet);
                }
              }),
              host: accessorDescriptor(getHost, function(host) {
                var url = getInternalURLState(this);
                if (url.cannotBeABaseURL)
                  return;
                parseURL(url, $toString(host), HOST);
              }),
              hostname: accessorDescriptor(getHostname, function(hostname) {
                var url = getInternalURLState(this);
                if (url.cannotBeABaseURL)
                  return;
                parseURL(url, $toString(hostname), HOSTNAME);
              }),
              port: accessorDescriptor(getPort, function(port) {
                var url = getInternalURLState(this);
                if (cannotHaveUsernamePasswordPort(url))
                  return;
                port = $toString(port);
                if (port == "")
                  url.port = null;
                else
                  parseURL(url, port, PORT);
              }),
              pathname: accessorDescriptor(getPathname, function(pathname) {
                var url = getInternalURLState(this);
                if (url.cannotBeABaseURL)
                  return;
                url.path = [];
                parseURL(url, $toString(pathname), PATH_START);
              }),
              search: accessorDescriptor(getSearch, function(search) {
                var url = getInternalURLState(this);
                search = $toString(search);
                if (search == "") {
                  url.query = null;
                } else {
                  if ("?" == search.charAt(0))
                    search = search.slice(1);
                  url.query = "";
                  parseURL(url, search, QUERY);
                }
                getInternalSearchParamsState(url.searchParams).updateSearchParams(url.query);
              }),
              searchParams: accessorDescriptor(getSearchParams),
              hash: accessorDescriptor(getHash2, function(hash2) {
                var url = getInternalURLState(this);
                hash2 = $toString(hash2);
                if (hash2 == "") {
                  url.fragment = null;
                  return;
                }
                if ("#" == hash2.charAt(0))
                  hash2 = hash2.slice(1);
                url.fragment = "";
                parseURL(url, hash2, FRAGMENT);
              })
            });
          }
          redefine(URLPrototype, "toJSON", function toJSON() {
            return serializeURL.call(this);
          }, { enumerable: true });
          redefine(URLPrototype, "toString", function toString3() {
            return serializeURL.call(this);
          }, { enumerable: true });
          if (NativeURL) {
            var nativeCreateObjectURL = NativeURL.createObjectURL;
            var nativeRevokeObjectURL = NativeURL.revokeObjectURL;
            if (nativeCreateObjectURL)
              redefine(URLConstructor, "createObjectURL", function createObjectURL(blob) {
                return nativeCreateObjectURL.apply(NativeURL, arguments);
              });
            if (nativeRevokeObjectURL)
              redefine(URLConstructor, "revokeObjectURL", function revokeObjectURL(url) {
                return nativeRevokeObjectURL.apply(NativeURL, arguments);
              });
          }
          setToStringTag(URLConstructor, "URL");
          $2({ global: true, forced: !USE_NATIVE_URL, sham: !DESCRIPTORS }, {
            URL: URLConstructor
          });
        },
        9801: function() {
        },
        3822: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(2221);
          module2.exports = parent;
        },
        1434: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(5078);
          module2.exports = parent;
        },
        6899: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(98);
          module2.exports = parent;
        },
        7710: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(5739);
          __webpack_require__2(162);
          module2.exports = parent;
        },
        4486: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(278);
          module2.exports = parent;
        },
        4877: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(1484);
          module2.exports = parent;
        },
        7178: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(7731);
          module2.exports = parent;
        },
        5603: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(3669);
          module2.exports = parent;
        },
        1206: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(162);
          var forEach3 = __webpack_require__2(6899);
          var classof = __webpack_require__2(4696);
          var ArrayPrototype = Array.prototype;
          var DOMIterables = {
            DOMTokenList: true,
            NodeList: true
          };
          module2.exports = function(it) {
            var own = it.forEach;
            return it === ArrayPrototype || it instanceof Array && own === ArrayPrototype.forEach || DOMIterables.hasOwnProperty(classof(it)) ? forEach3 : own;
          };
        },
        6174: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(2604);
          module2.exports = parent;
        },
        57: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(263);
          module2.exports = parent;
        },
        4741: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(7663);
          module2.exports = parent;
        },
        8368: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(5063);
          module2.exports = parent;
        },
        3739: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(6813);
          module2.exports = parent;
        },
        172: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(6285);
          module2.exports = parent;
        },
        4963: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(3213);
          module2.exports = parent;
        },
        7820: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(3512);
          module2.exports = parent;
        },
        8980: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(8168);
          module2.exports = parent;
        },
        5636: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(8651);
          module2.exports = parent;
        },
        6672: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(3083);
          module2.exports = parent;
        },
        5059: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(2987);
          module2.exports = parent;
        },
        3969: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(2239);
          module2.exports = parent;
        },
        6618: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(3154);
          __webpack_require__2(162);
          module2.exports = parent;
        },
        5279: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(6577);
          module2.exports = parent;
        },
        9562: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(2906);
          var path = __webpack_require__2(7545);
          module2.exports = path.setTimeout;
        },
        2285: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(5008);
          __webpack_require__2(162);
          module2.exports = parent;
        },
        8535: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(994);
          __webpack_require__2(162);
          module2.exports = parent;
        },
        652: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var parent = __webpack_require__2(5668);
          module2.exports = parent;
        },
        5668: function(module2, __unused_webpack_exports, __webpack_require__2) {
          __webpack_require__2(4948);
          __webpack_require__2(9801);
          __webpack_require__2(9336);
          var path = __webpack_require__2(7545);
          module2.exports = path.URL;
        },
        2534: function(module2) {
          module2.exports = "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz4KPCFET0NUWVBFIHN2ZyBQVUJMSUMgIi0vL1czQy8vRFREIFNWRyAxLjEvL0VOIiAiaHR0cDovL3d3dy53My5vcmcvR3JhcGhpY3MvU1ZHLzEuMS9EVEQvc3ZnMTEuZHRkIj4KPHN2ZyBkaXNwbGF5PSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIj4KPGRlZnMgaWQ9InR1aS1pbWFnZS1lZGl0b3Itc3ZnLWRlZmF1bHQtaWNvbnMiPgo8c3ltYm9sIGlkPSJpYy1hcHBseSIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIHN0cm9rZT0ibm9uZSIgZmlsbD0ibm9uZSIvPgogICAgPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSJpbmhlcml0IiBkPSJNNCAxMi4wMTFsNSA1TDIwLjAxMSA2Ii8+Cjwvc3ltYm9sPgo8c3ltYm9sIGlkPSJpYy1jYW5jZWwiIHZpZXdCb3g9IjAgMCAyNCAyNCI+CiAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBmaWxsPSJub25lIiBzdHJva2U9Im5vbmUiLz4KICAgIDxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iaW5oZXJpdCIgZD0iTTYgNmwxMiAxMk0xOCA2TDYgMTgiLz4KPC9zeW1ib2w+CjxzeW1ib2wgaWQ9ImljLWNyb3AiIHZpZXdCb3g9IjAgMCAyNCAyNCI+CiAgICA8cGF0aCBkPSJNMCAwaDI0djI0SDB6IiBzdHJva2U9Im5vbmUiIGZpbGw9Im5vbmUiIC8+CiAgICA8cGF0aCBzdHJva2U9Im5vbmUiIGZpbGw9ImluaGVyaXQiIGQ9Ik00IDBoMXYyMGExIDEgMCAwIDEtMS0xVjB6TTIwIDE3aC0xVjVoMXYxMnptMCAydjVoLTF2LTVoMXoiLz4KICAgIDxwYXRoIHN0cm9rZT0ibm9uZSIgZmlsbD0iaW5oZXJpdCIgZD0iTTUgMTloMTl2MUg1ek00Ljc2MiA0djFIMFY0aDQuNzYyek03IDRoMTJhMSAxIDAgMCAxIDEgMUg3VjR6Ii8+Cjwvc3ltYm9sPgo8IS0tIFRoaXMgaWNvbiBtYWRlIGJ5IFBpeGVsIHBlcmZlY3QgZnJvbSB3d3cuZmxhdGljb24uY29tIC0tPgo8c3ltYm9sIGlkPSJpYy1yZXNpemUiIHZpZXdCb3g9IjAgMCAyNCAyNCI+CiAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgc3Ryb2tlPSJub25lIiBmaWxsPSJub25lIi8+CiAgPHBhdGggc3Ryb2tlPSJub25lIiBmaWxsPSJpbmhlcml0IiBkPSJNIDE4Ljk4ODI4MSAzLjAxMTcxOSBDIDE4LjgwMDc4MSAyLjgyNDIxOSAxOC41IDIuODI0MjE5IDE4LjMxMjUgMy4wMTE3MTkgTCAxMS42MjEwOTQgOS43MDcwMzEgQyAxMS40Mjk2ODggOS44OTQ1MzEgMTEuNDI5Njg4IDEwLjE5NTMxMiAxMS42MjEwOTQgMTAuMzc4OTA2IEMgMTEuNzEwOTM4IDEwLjQ3MjY1NiAxMS44MzU5MzggMTAuNTE5NTMxIDExLjk1NzAzMSAxMC41MTk1MzEgQyAxMi4wNzgxMjUgMTAuNTE5NTMxIDEyLjIwMzEyNSAxMC40NzI2NTYgMTIuMjkyOTY5IDEwLjM3ODkwNiBMIDE4Ljk4ODI4MSAzLjY4NzUgQyAxOS4xNzU3ODEgMy41IDE5LjE3NTc4MSAzLjE5OTIxOSAxOC45ODgyODEgMy4wMTE3MTkgWiBNIDE4Ljk4ODI4MSAzLjAxMTcxOSAiLz4KICA8cGF0aCBzdHJva2U9Im5vbmUiIGZpbGw9ImluaGVyaXQiIGQ9Ik0gMTguNjUyMzQ0IDIuODY3MTg4IEMgMTguMzg2NzE5IDIuODY3MTg4IDE4LjE3MTg3NSAzLjA4MjAzMSAxOC4xNzE4NzUgMy4zNDc2NTYgTCAxOC4xNzE4NzUgOS4wODU5MzggQyAxOC4xNzE4NzUgOS4zNDc2NTYgMTguMzg2NzE5IDkuNTYyNSAxOC42NTIzNDQgOS41NjI1IEMgMTguOTE3OTY5IDkuNTYyNSAxOS4xMzI4MTIgOS4zNDc2NTYgMTkuMTMyODEyIDkuMDg1OTM4IEwgMTkuMTMyODEyIDMuMzQ3NjU2IEMgMTkuMTMyODEyIDMuMDgyMDMxIDE4LjkxNzk2OSAyLjg2NzE4OCAxOC42NTIzNDQgMi44NjcxODggWiBNIDE4LjY1MjM0NCAyLjg2NzE4OCAiLz4KICA8cGF0aCBzdHJva2U9Im5vbmUiIGZpbGw9ImluaGVyaXQiIGQ9Ik0gMTguNjUyMzQ0IDIuODY3MTg4IEwgMTIuOTE0MDYyIDIuODY3MTg4IEMgMTIuNjUyMzQ0IDIuODY3MTg4IDEyLjQzNzUgMy4wODIwMzEgMTIuNDM3NSAzLjM0NzY1NiBDIDEyLjQzNzUgMy42MTMyODEgMTIuNjUyMzQ0IDMuODI4MTI1IDEyLjkxNDA2MiAzLjgyODEyNSBMIDE4LjY1MjM0NCAzLjgyODEyNSBDIDE4LjkxNzk2OSAzLjgyODEyNSAxOS4xMzI4MTIgMy42MTMyODEgMTkuMTMyODEyIDMuMzQ3NjU2IEMgMTkuMTMyODEyIDMuMDgyMDMxIDE4LjkxNzk2OSAyLjg2NzE4OCAxOC42NTIzNDQgMi44NjcxODggWiBNIDE4LjY1MjM0NCAyLjg2NzE4OCAiLz4KICA8cGF0aCBzdHJva2U9Im5vbmUiIGZpbGw9ImluaGVyaXQiIGQ9Ik0gMTAuMzc4OTA2IDExLjYyMTA5NCBDIDEwLjE5NTMxMiAxMS40MzM1OTQgOS44OTA2MjUgMTEuNDMzNTk0IDkuNzAzMTI1IDExLjYyMTA5NCBMIDMuMDA3ODEyIDE4LjMxNjQwNiBDIDIuODIwMzEyIDE4LjUgMi44MjAzMTIgMTguODA0Njg4IDMuMDA3ODEyIDE4Ljk5MjE4OCBDIDMuMTA1NDY5IDE5LjA4NTkzOCAzLjIyNjU2MiAxOS4xMzI4MTIgMy4zNDc2NTYgMTkuMTMyODEyIEMgMy40Njg3NSAxOS4xMzI4MTIgMy41ODk4NDQgMTkuMDg1OTM4IDMuNjgzNTk0IDE4Ljk5MjE4OCBMIDEwLjM3ODkwNiAxMi4yOTY4NzUgQyAxMC41NjY0MDYgMTIuMTA5Mzc1IDEwLjU2NjQwNiAxMS44MDQ2ODggMTAuMzc4OTA2IDExLjYyMTA5NCBaIE0gMTAuMzc4OTA2IDExLjYyMTA5NCAiLz4KICA8cGF0aCBzdHJva2U9Im5vbmUiIGZpbGw9ImluaGVyaXQiIGQ9Ik0gMy4zNDc2NTYgMTIuNDM3NSBDIDMuMDgyMDMxIDEyLjQzNzUgMi44NjcxODggMTIuNjUyMzQ0IDIuODY3MTg4IDEyLjkxNDA2MiBMIDIuODY3MTg4IDE4LjY1MjM0NCBDIDIuODY3MTg4IDE4LjkxNzk2OSAzLjA4MjAzMSAxOS4xMzI4MTIgMy4zNDc2NTYgMTkuMTMyODEyIEMgMy42MTMyODEgMTkuMTMyODEyIDMuODI4MTI1IDE4LjkxNzk2OSAzLjgyODEyNSAxOC42NTIzNDQgTCAzLjgyODEyNSAxMi45MTQwNjIgQyAzLjgyODEyNSAxMi42NTIzNDQgMy42MTMyODEgMTIuNDM3NSAzLjM0NzY1NiAxMi40Mzc1IFogTSAzLjM0NzY1NiAxMi40Mzc1ICIvPgogIDxwYXRoIHN0cm9rZT0ibm9uZSIgZmlsbD0iaW5oZXJpdCIgZD0iTSA5LjA4NTkzOCAxOC4xNzE4NzUgTCAzLjM0NzY1NiAxOC4xNzE4NzUgQyAzLjA4MjAzMSAxOC4xNzE4NzUgMi44NjcxODggMTguMzg2NzE5IDIuODY3MTg4IDE4LjY1MjM0NCBDIDIuODY3MTg4IDE4LjkxNzk2OSAzLjA4MjAzMSAxOS4xMzI4MTIgMy4zNDc2NTYgMTkuMTMyODEyIEwgOS4wODU5MzggMTkuMTMyODEyIEMgOS4zNDc2NTYgMTkuMTMyODEyIDkuNTYyNSAxOC45MTc5NjkgOS41NjI1IDE4LjY1MjM0NCBDIDkuNTYyNSAxOC4zODY3MTkgOS4zNDc2NTYgMTguMTcxODc1IDkuMDg1OTM4IDE4LjE3MTg3NSBaIE0gOS4wODU5MzggMTguMTcxODc1ICIvPgogIDxwYXRoIHN0cm9rZT0ibm9uZSIgZmlsbD0iaW5oZXJpdCIgZD0iTSAyMC41NjI1IDAgTCAxLjQzNzUgMCBDIDAuNjQ0NTMxIDAgMCAwLjY0NDUzMSAwIDEuNDM3NSBMIDAgMjAuNTYyNSBDIDAgMjEuMzU1NDY5IDAuNjQ0NTMxIDIyIDEuNDM3NSAyMiBMIDIwLjU2MjUgMjIgQyAyMS4zNTU0NjkgMjIgMjIgMjEuMzU1NDY5IDIyIDIwLjU2MjUgTCAyMiAxLjQzNzUgQyAyMiAwLjY0NDUzMSAyMS4zNTU0NjkgMCAyMC41NjI1IDAgWiBNIDIxLjA0Mjk2OSAyMC41NjI1IEMgMjEuMDQyOTY5IDIwLjgyODEyNSAyMC44MjgxMjUgMjEuMDQyOTY5IDIwLjU2MjUgMjEuMDQyOTY5IEwgMS40Mzc1IDIxLjA0Mjk2OSBDIDEuMTcxODc1IDIxLjA0Mjk2OSAwLjk1NzAzMSAyMC44MjgxMjUgMC45NTcwMzEgMjAuNTYyNSBMIDAuOTU3MDMxIDEuNDM3NSBDIDAuOTU3MDMxIDEuMTcxODc1IDEuMTcxODc1IDAuOTU3MDMxIDEuNDM3NSAwLjk1NzAzMSBMIDIwLjU2MjUgMC45NTcwMzEgQyAyMC44MjgxMjUgMC45NTcwMzEgMjEuMDQyOTY5IDEuMTcxODc1IDIxLjA0Mjk2OSAxLjQzNzUgWiBNIDIxLjA0Mjk2OSAyMC41NjI1ICIvPgo8L3N5bWJvbD4KPCEtLSAgLS0+CjxzeW1ib2wgaWQ9ImljLWRlbGV0ZS1hbGwiIHZpZXdCb3g9IjAgMCAyNCAyNCI+CiAgICA8cGF0aCBzdHJva2U9Im5vbmUiIGZpbGw9ImluaGVyaXQiIGQ9Ik01IDIzSDNhMSAxIDAgMCAxLTEtMVY2aDF2MTZoMnYxem0xNi0xMGgtMVY2aDF2N3pNOSAxM0g4di0zaDF2M3ptMyAwaC0xdi0zaDF2M3ptMyAwaC0xdi0zaDF2M3pNMTQuNzk0IDMuNzk0TDEzIDJoLTNMOC4yMDYgMy43OTRBLjk2My45NjMgMCAwIDEgOCAyLjVsLjcwMy0xLjA1NUExIDEgMCAwIDEgOS41MzUgMWgzLjkzYTEgMSAwIDAgMSAuODMyLjQ0NUwxNSAyLjVhLjk2NS45NjUgMCAwIDEtLjIwNiAxLjI5NHpNMTQuMTk3IDRIOC44MDNoNS4zOTR6Ii8+CiAgICA8cGF0aCBzdHJva2U9Im5vbmUiIGZpbGw9ImluaGVyaXQiIGQ9Ik0wIDNoMjN2MUgwek0xMS4yODYgMjFIOC43MTRMOCAyM0g3bDEtMi44VjIwaC4wNzFMOS41IDE2aDFsMS40MjkgNEgxMnYuMmwxIDIuOGgtMWwtLjcxNC0yem0tLjM1Ny0xTDEwIDE3LjQgOS4wNzEgMjBoMS44NTh6TTIwIDIyaDN2MWgtNHYtN2gxdjZ6bS01IDBoM3YxaC00di03aDF2NnoiLz4KPC9zeW1ib2w+CjxzeW1ib2wgaWQ9ImljLWRlbGV0ZSIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIHN0cm9rZT0ibm9uZSIgZmlsbD0iaW5oZXJpdCIgZD0iTTMgNnYxNmgxN1Y2aDF2MTZhMSAxIDAgMCAxLTEgMUgzYTEgMSAwIDAgMS0xLTFWNmgxek0xNC43OTQgMy43OTRMMTMgMmgtM0w4LjIwNiAzLjc5NEEuOTYzLjk2MyAwIDAgMSA4IDIuNWwuNzAzLTEuMDU1QTEgMSAwIDAgMSA5LjUzNSAxaDMuOTNhMSAxIDAgMCAxIC44MzIuNDQ1TDE1IDIuNWEuOTY1Ljk2NSAwIDAgMS0uMjA2IDEuMjk0ek0xNC4xOTcgNEg4LjgwM2g1LjM5NHoiLz4KICAgIDxwYXRoIHN0cm9rZT0ibm9uZSIgZmlsbD0iaW5oZXJpdCIgZD0iTTAgM2gyM3YxSDB6TTggMTBoMXY2SDh2LTZ6bTMgMGgxdjZoLTF2LTZ6bTMgMGgxdjZoLTF2LTZ6Ii8+Cjwvc3ltYm9sPgo8c3ltYm9sIGlkPSJpYy1kcmF3LWZyZWUiIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgICA8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9ImluaGVyaXQiIGQ9Ik0yLjUgMjAuOTI5QzIuNTk0IDEwLjk3NiA0LjMyMyA2IDcuNjg2IDZjNS44NzIgMCAyLjUyNCAxOSA3LjY5NyAxOXMxLjg5LTE0LjkyOSA2LjQxNC0xNC45MjkgMS4zNTcgMTAuODU4IDUuMTMgMTAuODU4YzEuODAyIDAgMi42NTctMi4yNjIgMi41NjYtNi43ODYiLz4KPC9zeW1ib2w+CjxzeW1ib2wgaWQ9ImljLWRyYXctbGluZSIgdmlld0JveD0iMCAwIDMyIDMyIj4KICAgIDxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iaW5oZXJpdCIgZD0iTTIgMTUuNWgyOCIvPgo8L3N5bWJvbD4KPHN5bWJvbCBpZD0iaWMtZHJhdyIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iaW5oZXJpdCIgZD0iTTIuNSAyMS41SDVjLjI0NSAwIC40OC0uMDU4LjY5MS0uMTY4bC4xMjQtLjA2NS4xNC4wMWMuNDI5LjAyOC44NS0uMTI3IDEuMTYtLjQzN0wyMi41NSA1LjQwNWEuNS41IDAgMCAwIDAtLjcwN2wtMy4yNDYtMy4yNDVhLjUuNSAwIDAgMC0uNzA3IDBMMy4xNjIgMTYuODg4YTEuNDk1IDEuNDk1IDAgMCAwLS40MzcgMS4xNTVsLjAxLjE0LS4wNjUuMTIzYy0uMTExLjIxMi0uMTcuNDQ4LS4xNy42OTR2Mi41eiIvPgogICAgPHBhdGggc3Ryb2tlPSJub25lIiBmaWxsPSJpbmhlcml0IiBkPSJNMTYuNDE0IDMuNzA3bDMuODkgMy44OS0uNzA4LjcwNi0zLjg4OS0zLjg4OXoiLz4KPC9zeW1ib2w+CjxzeW1ib2wgaWQ9ImljLWZpbHRlciIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiIHN0cm9rZT0ibm9uZSIgLz4KICAgIDxwYXRoIHN0cm9rZT0ibm9uZSIgZmlsbD0iaW5oZXJpdCIgZD0iTTEyIDd2MUgyVjdoMTB6bTYgMGg0djFoLTRWN3pNMTIgMTZ2MWgxMHYtMUgxMnptLTYgMEgydjFoNHYtMXoiLz4KICAgIDxwYXRoIHN0cm9rZT0ibm9uZSIgZmlsbD0iaW5oZXJpdCIgZD0iTTguNSAyMGEzLjUgMy41IDAgMSAxIDAtNyAzLjUgMy41IDAgMCAxIDAgN3ptMC0xYTIuNSAyLjUgMCAxIDAgMC01IDIuNSAyLjUgMCAwIDAgMCA1ek0xNS41IDExYTMuNSAzLjUgMCAxIDEgMC03IDMuNSAzLjUgMCAwIDEgMCA3em0wLTFhMi41IDIuNSAwIDEgMCAwLTUgMi41IDIuNSAwIDAgMCAwIDV6Ii8+Cjwvc3ltYm9sPgo8c3ltYm9sIGlkPSJpYy1mbGlwLXJlc2V0IiB2aWV3Qm94PSIwIDAgMzEgMzIiPgogICAgPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiBkPSJNMzEgMEgwdjMyaDMxeiIvPgogICAgPHBhdGggc3Ryb2tlPSJub25lIiBmaWxsPSJpbmhlcml0IiBkPSJNMjggMTZhOCA4IDAgMCAxLTggOEgzdi0xaDF2LTdIM2E4IDggMCAwIDEgOC04aDE3djFoLTF2N2gxek0xMSA5YTcgNyAwIDAgMC03IDd2N2gxNmE3IDcgMCAwIDAgNy03VjlIMTF6Ii8+CiAgICA8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9ImluaGVyaXQiIHN0cm9rZS1saW5lY2FwPSJzcXVhcmUiIGQ9Ik0yNCA1bDMuNSAzLjVMMjQgMTJNNyAyMGwtMy41IDMuNUw3IDI3Ii8+Cjwvc3ltYm9sPgo8c3ltYm9sIGlkPSJpYy1mbGlwLXgiIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgICA8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9Im5vbmUiIGQ9Ik0zMiAzMkgwVjBoMzJ6Ii8+CiAgICA8cGF0aCBzdHJva2U9Im5vbmUiIGZpbGw9ImluaGVyaXQiIGQ9Ik0xNyAzMmgtMVYwaDF6TTI3LjE2NyAxMWwuNSAzaC0xLjAzbC0uNTQ2LTNoMS4wNzZ6bS0uNS0zaC0xLjEyMkwyNSA1aC01VjRoNS4xNTNhMSAxIDAgMCAxIC45ODYuODM2TDI2LjY2NyA4em0xLjUgOWwuNSAzaC0uOTRsLS41NDUtM2guOTg1em0xIDZsLjYzOSAzLjgzNkExIDEgMCAwIDEgMjguODE5IDI4SDI2di0xaDNsLS43MjYtNGguODk0ek0yMyAyOGgtM3YtMWgzdjF6TTEzIDR2MUg3TDMgMjdoMTB2MUgzLjE4YTEgMSAwIDAgMS0uOTg2LTEuMTY0bDMuNjY2LTIyQTEgMSAwIDAgMSA2Ljg0NyA0SDEzeiIvPgo8L3N5bWJvbD4KPHN5bWJvbCBpZD0iaWMtZmxpcC15IiB2aWV3Qm94PSIwIDAgMzIgMzIiPgogICAgPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiBkPSJNMCAwdjMyaDMyVjB6Ii8+CiAgICA8cGF0aCBzdHJva2U9Im5vbmUiIGZpbGw9ImluaGVyaXQiIGQ9Ik0wIDE2djFoMzJ2LTF6TTExIDI3LjE2N2wzIC41di0xLjAzbC0zLS41NDZ2MS4wNzZ6bS0zLS41di0xLjEyMkw1IDI1di01SDR2NS4xNTNhMSAxIDAgMCAwIC44MzYuOTg2TDggMjYuNjY3em05IDEuNWwzIC41di0uOTRsLTMtLjU0NXYuOTg1em02IDFsMy44MzYuNjM5QTEgMSAwIDAgMCAyOCAyOC44MlYyNmgtMXYzbC00LS43Mjd2Ljg5NHpNMjggMjN2LTNoLTF2M2gxek00IDEzaDFWN2wyMi00djEwaDFWMy4xOGExIDEgMCAwIDAtMS4xNjQtLjk4NmwtMjIgMy42NjdBMSAxIDAgMCAwIDQgNi44NDdWMTN6Ii8+Cjwvc3ltYm9sPgo8c3ltYm9sIGlkPSJpYy1mbGlwIiB2aWV3Qm94PSIwIDAgMjQgMjQiPgogICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiAvPgogICAgPHBhdGggZmlsbD0iaW5oZXJpdCIgc3Ryb2tlPSJub25lIiBkPSJNMTEgMGgxdjI0aC0xek0xOSAyMXYtMWgydi0yaDF2MmExIDEgMCAwIDEtMSAxaC0yem0tMiAwaC0zdi0xaDN2MXptNS01aC0xdi0zaDF2M3ptMC01aC0xVjhoMXYzem0wLTVoLTFWNGgtMlYzaDJhMSAxIDAgMCAxIDEgMXYyem0tNS0zdjFoLTNWM2gzek05IDN2MUgydjE2aDd2MUgyYTEgMSAwIDAgMS0xLTFWNGExIDEgMCAwIDEgMS0xaDd6Ii8+Cjwvc3ltYm9sPgo8c3ltYm9sIGlkPSJpYy1oaXN0b3J5IiB2aWV3Qm94PSIwIDAgMjQgMjQiPgogICAgPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiBkPSJNMCAwSDI0VjI0SDB6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtNzQwIC0xNikgdHJhbnNsYXRlKDU0NyA4KSB0cmFuc2xhdGUoMTkzIDgpIi8+CiAgICA8cGF0aCBmaWxsPSJpbmhlcml0IiBzdHJva2U9Im5vbmUiIGQ9Ik0xMi41IDFDMTguMjk5IDEgMjMgNS43MDEgMjMgMTEuNVMxOC4yOTkgMjIgMTIuNSAyMmMtNS4yOSAwLTkuNjY1LTMuOTExLTEwLjM5NC04Ljk5OWgxLjAxMkMzLjgzOCAxNy41MzQgNy43NjQgMjEgMTIuNSAyMWM1LjI0NyAwIDkuNS00LjI1MyA5LjUtOS41UzE3Ljc0NyAyIDEyLjUgMkM4LjQ5IDIgNS4wNiA0LjQ4NSAzLjY2NiA4SDNoNHYxSDJWNGgxdjMuMDIyQzQuNjggMy40NjIgOC4zMDMgMSAxMi41IDF6bS41IDVsLS4wMDEgNS4yOTEgMi41MzcgMi41MzctLjcwOC43MDhMMTIuMjkyIDEySDEyVjZoMXoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC03NDAgLTE2KSB0cmFuc2xhdGUoNTQ3IDgpIHRyYW5zbGF0ZSgxOTMgOCkiLz4KPC9zeW1ib2w+CjxzeW1ib2wgaWQ9ImljLWhpc3RvcnktY2hlY2siIHZpZXdCb3g9IjAgMCAyNCAyNCI+CiAgICA8ZyBmaWxsPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiID4KICAgICAgICA8cGF0aCBzdHJva2U9IiM1NTU1NTUiIGQ9Ik00LjUgLTFMMS41IDIgNi41IDciIHRyYW5zZm9ybT0idHJhbnNsYXRlKC02MCAtODA0KSB0cmFuc2xhdGUoNjAgODA0KSB0cmFuc2xhdGUoMiAzKSByb3RhdGUoLTkwIDQgMykiIC8+CiAgICA8L2c+Cjwvc3ltYm9sPgo8c3ltYm9sIGlkPSJpYy1oaXN0b3J5LWNyb3AiIHZpZXdCb3g9IjAgMCAyNCAyNCI+CiAgICA8ZyBmaWxsPSJub25lIiBzdHJva2U9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgPgogICAgICAgIDxwYXRoIGQ9Ik0wIDBIMTJWMTJIMHoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC04NCAtODA0KSB0cmFuc2xhdGUoODQgODA0KSIvPgogICAgICAgIDxwYXRoIGZpbGw9IiM0MzQzNDMiIGQ9Ik0yIDBoMXYxMGMtLjU1MiAwLTEtLjQ0OC0xLTFWMHpNMTAgOXYzSDlWOWgxek05IDJoMXY2SDlWMnoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC04NCAtODA0KSB0cmFuc2xhdGUoODQgODA0KSIvPgogICAgICAgIDxwYXRoIGZpbGw9IiM0MzQzNDMiIGQ9Ik0yIDlIMTJWMTBIMnpNOSAyYy41MTMgMCAuOTM2LjM4Ni45OTMuODgzTDEwIDNIM1YyaDZ6TTIgM0gwVjJoMnYxeiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTg0IC04MDQpIHRyYW5zbGF0ZSg4NCA4MDQpIi8+CiAgICA8L2c+Cjwvc3ltYm9sPgo8IS0tIFRoaXMgaWNvbiBtYWRlIGJ5IFBpeGVsIHBlcmZlY3QgZnJvbSB3d3cuZmxhdGljb24uY29tIC0tPgo8c3ltYm9sIGlkPSJpYy1oaXN0b3J5LXJlc2l6ZSIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICA8ZyBmaWxsPSJub25lIiBzdHJva2U9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgPgogICAgPHBhdGggZmlsbD0iIzQzNDM0MyIgZD0iTSA5LjQ5MjE4OCAxLjUwNzgxMiBDIDkuMzk4NDM4IDEuNDE0MDYyIDkuMjUgMS40MTQwNjIgOS4xNTYyNSAxLjUwNzgxMiBMIDUuODEyNSA0Ljg1MTU2MiBDIDUuNzE0ODQ0IDQuOTQ1MzEyIDUuNzE0ODQ0IDUuMDk3NjU2IDUuODEyNSA1LjE4NzUgQyA1Ljg1NTQ2OSA1LjIzNDM3NSA1LjkxNzk2OSA1LjI1NzgxMiA1Ljk3NjU2MiA1LjI1NzgxMiBDIDYuMDM5MDYyIDUuMjU3ODEyIDYuMTAxNTYyIDUuMjM0Mzc1IDYuMTQ4NDM4IDUuMTg3NSBMIDkuNDkyMTg4IDEuODQzNzUgQyA5LjU4NTkzOCAxLjc1IDkuNTg1OTM4IDEuNjAxNTYyIDkuNDkyMTg4IDEuNTA3ODEyIFogTSA5LjQ5MjE4OCAxLjUwNzgxMiAiLz4KICAgIDxwYXRoIGZpbGw9IiM0MzQzNDMiIGQ9Ik0gOS4zMjgxMjUgMS40MzM1OTQgQyA5LjE5NTMxMiAxLjQzMzU5NCA5LjA4NTkzOCAxLjUzOTA2MiA5LjA4NTkzOCAxLjY3MTg3NSBMIDkuMDg1OTM4IDQuNTQyOTY5IEMgOS4wODU5MzggNC42NzE4NzUgOS4xOTUzMTIgNC43ODEyNSA5LjMyODEyNSA0Ljc4MTI1IEMgOS40NjA5MzggNC43ODEyNSA5LjU2NjQwNiA0LjY3MTg3NSA5LjU2NjQwNiA0LjU0Mjk2OSBMIDkuNTY2NDA2IDEuNjcxODc1IEMgOS41NjY0MDYgMS41MzkwNjIgOS40NjA5MzggMS40MzM1OTQgOS4zMjgxMjUgMS40MzM1OTQgWiBNIDkuMzI4MTI1IDEuNDMzNTk0ICIvPgogICAgPHBhdGggZmlsbD0iIzQzNDM0MyIgZD0iTSA5LjMyODEyNSAxLjQzMzU5NCBMIDYuNDU3MDMxIDEuNDMzNTk0IEMgNi4zMjgxMjUgMS40MzM1OTQgNi4yMTg3NSAxLjUzOTA2MiA2LjIxODc1IDEuNjcxODc1IEMgNi4yMTg3NSAxLjgwNDY4OCA2LjMyODEyNSAxLjkxNDA2MiA2LjQ1NzAzMSAxLjkxNDA2MiBMIDkuMzI4MTI1IDEuOTE0MDYyIEMgOS40NjA5MzggMS45MTQwNjIgOS41NjY0MDYgMS44MDQ2ODggOS41NjY0MDYgMS42NzE4NzUgQyA5LjU2NjQwNiAxLjUzOTA2MiA5LjQ2MDkzOCAxLjQzMzU5NCA5LjMyODEyNSAxLjQzMzU5NCBaIE0gOS4zMjgxMjUgMS40MzM1OTQgIi8+CiAgICA8cGF0aCBmaWxsPSIjNDM0MzQzIiBkPSJNIDUuMTg3NSA1LjgxMjUgQyA1LjA5NzY1NiA1LjcxODc1IDQuOTQ1MzEyIDUuNzE4NzUgNC44NTE1NjIgNS44MTI1IEwgMS41MDM5MDYgOS4xNTYyNSBDIDEuNDEwMTU2IDkuMjUgMS40MTAxNTYgOS40MDIzNDQgMS41MDM5MDYgOS40OTYwOTQgQyAxLjU1NDY4OCA5LjU0Mjk2OSAxLjYxMzI4MSA5LjU2NjQwNiAxLjY3MTg3NSA5LjU2NjQwNiBDIDEuNzM0Mzc1IDkuNTY2NDA2IDEuNzk2ODc1IDkuNTQyOTY5IDEuODQzNzUgOS40OTYwOTQgTCA1LjE4NzUgNi4xNDg0MzggQyA1LjI4MTI1IDYuMDU0Njg4IDUuMjgxMjUgNS45MDIzNDQgNS4xODc1IDUuODEyNSBaIE0gNS4xODc1IDUuODEyNSAiLz4KICAgIDxwYXRoIGZpbGw9IiM0MzQzNDMiIGQ9Ik0gMS42NzE4NzUgNi4yMTg3NSBDIDEuNTM5MDYyIDYuMjE4NzUgMS40MzM1OTQgNi4zMjgxMjUgMS40MzM1OTQgNi40NTcwMzEgTCAxLjQzMzU5NCA5LjMyODEyNSBDIDEuNDMzNTk0IDkuNDYwOTM4IDEuNTM5MDYyIDkuNTY2NDA2IDEuNjcxODc1IDkuNTY2NDA2IEMgMS44MDQ2ODggOS41NjY0MDYgMS45MTQwNjIgOS40NjA5MzggMS45MTQwNjIgOS4zMjgxMjUgTCAxLjkxNDA2MiA2LjQ1NzAzMSBDIDEuOTE0MDYyIDYuMzI4MTI1IDEuODA0Njg4IDYuMjE4NzUgMS42NzE4NzUgNi4yMTg3NSBaIE0gMS42NzE4NzUgNi4yMTg3NSAiLz4KICAgIDxwYXRoIGZpbGw9IiM0MzQzNDMiIGQ9Ik0gNC41NDI5NjkgOS4wODU5MzggTCAxLjY3MTg3NSA5LjA4NTkzOCBDIDEuNTM5MDYyIDkuMDg1OTM4IDEuNDMzNTk0IDkuMTk1MzEyIDEuNDMzNTk0IDkuMzI4MTI1IEMgMS40MzM1OTQgOS40NjA5MzggMS41MzkwNjIgOS41NjY0MDYgMS42NzE4NzUgOS41NjY0MDYgTCA0LjU0Mjk2OSA5LjU2NjQwNiBDIDQuNjcxODc1IDkuNTY2NDA2IDQuNzgxMjUgOS40NjA5MzggNC43ODEyNSA5LjMyODEyNSBDIDQuNzgxMjUgOS4xOTUzMTIgNC42NzE4NzUgOS4wODU5MzggNC41NDI5NjkgOS4wODU5MzggWiBNIDQuNTQyOTY5IDkuMDg1OTM4ICIvPgogICAgPHBhdGggZmlsbD0iIzQzNDM0MyIgZD0iTSAxMC4yODEyNSAwIEwgMC43MTg3NSAwIEMgMC4zMjAzMTIgMCAwIDAuMzIwMzEyIDAgMC43MTg3NSBMIDAgMTAuMjgxMjUgQyAwIDEwLjY3OTY4OCAwLjMyMDMxMiAxMSAwLjcxODc1IDExIEwgMTAuMjgxMjUgMTEgQyAxMC42Nzk2ODggMTEgMTEgMTAuNjc5Njg4IDExIDEwLjI4MTI1IEwgMTEgMC43MTg3NSBDIDExIDAuMzIwMzEyIDEwLjY3OTY4OCAwIDEwLjI4MTI1IDAgWiBNIDEwLjUyMzQzOCAxMC4yODEyNSBDIDEwLjUyMzQzOCAxMC40MTQwNjIgMTAuNDE0MDYyIDEwLjUyMzQzOCAxMC4yODEyNSAxMC41MjM0MzggTCAwLjcxODc1IDEwLjUyMzQzOCBDIDAuNTg1OTM4IDEwLjUyMzQzOCAwLjQ3NjU2MiAxMC40MTQwNjIgMC40NzY1NjIgMTAuMjgxMjUgTCAwLjQ3NjU2MiAwLjcxODc1IEMgMC40NzY1NjIgMC41ODU5MzggMC41ODU5MzggMC40NzY1NjIgMC43MTg3NSAwLjQ3NjU2MiBMIDEwLjI4MTI1IDAuNDc2NTYyIEMgMTAuNDE0MDYyIDAuNDc2NTYyIDEwLjUyMzQzOCAwLjU4NTkzOCAxMC41MjM0MzggMC43MTg3NSBaIE0gMTAuNTIzNDM4IDEwLjI4MTI1ICIvPgogIDwvZz4KPC9zeW1ib2w+CjwhLS0gIC0tPgo8c3ltYm9sIGlkPSJpYy1oaXN0b3J5LWRyYXciIHZpZXdCb3g9IjAgMCAyNCAyNCI+CiAgICA8ZyBmaWxsPSJub25lIiBzdHJva2U9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgPgogICAgICAgIDxwYXRoIGQ9Ik0wIDFIMTJWMTNIMHoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNTYgLTgwNCkgdHJhbnNsYXRlKDE1NiA4MDMpIi8+CiAgICAgICAgPHBhdGggc3Ryb2tlPSIjNDM0MzQzIiBkPSJNOS42MjIgMS41ODRsMS44MzUgMS42NTgtOC4zMSA4LjQwN0wuNSAxMi41VjExbDkuMTIyLTkuNDE2eiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTE1NiAtODA0KSB0cmFuc2xhdGUoMTU2IDgwMykiLz4KICAgICAgICA8cGF0aCBmaWxsPSIjNDM0MzQzIiBkPSJNNy42MjggMy43NTNMMTAuMzc4IDMuNzUzIDEwLjM3OCA0LjI1MyA3LjYyOCA0LjI1M3oiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xNTYgLTgwNCkgdHJhbnNsYXRlKDE1NiA4MDMpIHJvdGF0ZSg0NSA5LjAwMyA0LjAwMykiLz4KICAgIDwvZz4KPC9zeW1ib2w+CjxzeW1ib2wgaWQ9ImljLWhpc3RvcnktZmlsdGVyIiB2aWV3Qm94PSIwIDAgMjQgMjQiPgogICAgPGcgZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiID4KICAgICAgICA8cGF0aCBkPSJNMCAwSDEyVjEySDB6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjc2IC04MDQpIHRyYW5zbGF0ZSgyNzYgODA0KSIvPgogICAgICAgIDxwYXRoIGZpbGw9IiM0MzQzNDMiIGQ9Ik0xMiAzdjFIOVYzaDN6TTcgNEgwVjNoN3YxeiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTI3NiAtODA0KSB0cmFuc2xhdGUoMjc2IDgwNCkiLz4KICAgICAgICA8cGF0aCBmaWxsPSIjNDM0MzQzIiBkPSJNMTIgOHYxSDlWOGgzek03IDlIMFY4aDd2MXoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yNzYgLTgwNCkgdHJhbnNsYXRlKDI3NiA4MDQpIG1hdHJpeCgtMSAwIDAgMSAxMiAwKSIvPgogICAgICAgIDxwYXRoIGZpbGw9IiM0MzQzNDMiIGQ9Ik04IDFjMS4xMDUgMCAyIC44OTUgMiAycy0uODk1IDItMiAyLTItLjg5NS0yLTIgLjg5NS0yIDItMnptMCAxYy0uNTUyIDAtMSAuNDQ4LTEgMXMuNDQ4IDEgMSAxIDEtLjQ0OCAxLTEtLjQ0OC0xLTEtMXpNNCA3YzEuMTA1IDAgMiAuODk1IDIgMnMtLjg5NSAyLTIgMi0yLS44OTUtMi0yIC44OTUtMiAyLTJ6bTAgMWMtLjU1MiAwLTEgLjQ0OC0xIDFzLjQ0OCAxIDEgMSAxLS40NDggMS0xLS40NDgtMS0xLTF6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjc2IC04MDQpIHRyYW5zbGF0ZSgyNzYgODA0KSIvPgogICAgPC9nPgo8L3N5bWJvbD4KPHN5bWJvbCBpZD0iaWMtaGlzdG9yeS1mbGlwIiB2aWV3Qm94PSIwIDAgMjQgMjQiPgogICAgPGcgZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiID4KICAgICAgICA8cGF0aCBkPSJNMCAwSDEyVjEySDB6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTA4IC04MDQpIHRyYW5zbGF0ZSgxMDggODA0KSIvPgogICAgICAgIDxwYXRoIGZpbGw9IiM0MzQzNDMiIGQ9Ik02IDBMNyAwIDcgMTIgNiAxMnpNMTEgMTBWOWgxdjEuNWMwIC4yNzYtLjIyNC41LS41LjVIMTB2LTFoMXpNNSAxdjFIMXY4aDR2MUguNWMtLjI3NiAwLS41LS4yMjQtLjUtLjV2LTljMC0uMjc2LjIyNC0uNS41LS41SDV6bTcgNXYyaC0xVjZoMXptMC0zdjJoLTFWM2gxek05IDF2MUg3VjFoMnptMi41IDBjLjI3NiAwIC41LjIyNC41LjVWMmgtMlYxaDEuNXpNOSAxMUg3di0xaDJ2MXoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMDggLTgwNCkgdHJhbnNsYXRlKDEwOCA4MDQpIi8+CiAgICA8L2c+Cjwvc3ltYm9sPgo8c3ltYm9sIGlkPSJpYy1oaXN0b3J5LWljb24iIHZpZXdCb3g9IjAgMCAyNCAyNCI+CiAgICA8ZyBmaWxsPSJub25lIiBzdHJva2U9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgPgogICAgICAgIDxwYXRoIGQ9Ik0wIDBIMTJWMTJIMHoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMDQgLTgwNCkgdHJhbnNsYXRlKDIwNCA4MDQpIi8+CiAgICAgICAgPHBhdGggc3Ryb2tlPSIjNDM0MzQzIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIHN0cm9rZS13aWR0aD0iMS4xIiBkPSJNNiA5LjU2OEwyLjYwMSAxMSAyLjk3NSA3LjQ2NyAwLjUgNC44MiA0LjEzIDQuMDY4IDYgMSA3Ljg3IDQuMDY4IDExLjUgNC44MiA5LjAyNSA3LjQ2NyA5LjM5OSAxMXoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMDQgLTgwNCkgdHJhbnNsYXRlKDIwNCA4MDQpIi8+CiAgICA8L2c+Cjwvc3ltYm9sPgo8c3ltYm9sIGlkPSJpYy1oaXN0b3J5LW1hc2siIHZpZXdCb3g9IjAgMCAyNCAyNCI+CiAgICA8ZyBmaWxsPSJub25lIiBzdHJva2U9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgPgogICAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yNTIgLTgwNCkgdHJhbnNsYXRlKDI1MiA4MDQpIj4KICAgICAgICAgICAgPHBhdGggZD0iTTAgMEgxMlYxMkgweiIvPgogICAgICAgICAgICA8Y2lyY2xlIGN4PSI2IiBjeT0iNiIgcj0iMi41IiBzdHJva2U9IiM0NDQiLz4KICAgICAgICAgICAgPHBhdGggZmlsbD0iIzQzNDM0MyIgZD0iTTExLjUgMGMuMjc2IDAgLjUuMjI0LjUuNXYxMWMwIC4yNzYtLjIyNC41LS41LjVILjVjLS4yNzYgMC0uNS0uMjI0LS41LS41Vi41QzAgLjIyNC4yMjQgMCAuNSAwaDExek0xMSAxSDF2MTBoMTBWMXoiLz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ltYm9sPgo8c3ltYm9sIGlkPSJpYy1oaXN0b3J5LXJvdGF0ZSIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxkZWZzPgogICAgICAgIDxwYXRoIGlkPSJyZm40cnlsZmZhIiBkPSJNNyAxMmMtLjMzNSAwLS42NjMtLjAyNS0uOTgzLS4wNzRDMy4xNzEgMTEuNDkyIDEgOS4yMDUgMSA2LjQ0NGMwLTEuMzYzLjUzNC0yLjYxMyAxLjQxNS0zLjU4Ii8+CiAgICAgICAgPG1hc2sgaWQ9IjZmOWduMmR5c2IiIHdpZHRoPSI2IiBoZWlnaHQ9IjkuMTM2IiB4PSIwIiB5PSIwIiBtYXNrVW5pdHM9Im9iamVjdEJvdW5kaW5nQm94Ij4KICAgICAgICAgICAgPHVzZSB4bGluazpocmVmPSIjcmZuNHJ5bGZmYSIgc3Ryb2tlPSI0MzQzNDMiLz4KICAgICAgICA8L21hc2s+CiAgICA8L2RlZnM+CiAgICA8ZyBmaWxsPSJub25lIiBzdHJva2U9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgPgogICAgICAgIDxnIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xMzIgLTgwNCkgdHJhbnNsYXRlKDEzMiA4MDQpIj4KICAgICAgICAgICAgPHBhdGggZD0iTTAgMC41SDEyVjEyLjVIMHoiLz4KICAgICAgICAgICAgPHBhdGggZmlsbD0iIzQzNDM0MyIgZD0iTTYuNSAxQzkuNTM4IDEgMTIgMy40NjIgMTIgNi41YzAgMi4zNy0xLjUgNC4zOS0zLjYgNS4xNjNsLS40MDctLjkxNkM5Ljc0NCAxMC4xMyAxMSA4LjQ2MiAxMSA2LjUgMTEgNC4wMTUgOC45ODUgMiA2LjUgMmMtLjc3NyAwLTEuNTA5LjE5Ny0yLjE0Ny41NDRMNCAxLjc1bC0uMjA1LS4wNEM0LjU5NCAxLjI1OCA1LjUxNyAxIDYuNSAxeiIvPgogICAgICAgICAgICA8dXNlIHN0cm9rZT0iIzQzNDM0MyIgc3Ryb2tlLWRhc2hhcnJheT0iMiAxLjI1IiBzdHJva2Utd2lkdGg9IjEiIG1hc2s9InVybCgjNmY5Z24yZHlzYikiIHhsaW5rOmhyZWY9IiNyZm40cnlsZmZhIi8+CiAgICAgICAgICAgIDxwYXRoIGZpbGw9IiM0MzQzNDMiIGQ9Ik00LjI3OSAwTDYgMS43NSA0LjI1IDMuNTcxIDMuNTQzIDIuODY0IDQuNTg2IDEuNzUgMy41NzIgMC43MDd6IiB0cmFuc2Zvcm09Im1hdHJpeCgtMSAwIDAgMSA5LjU0MyAwKSIvPgogICAgICAgIDwvZz4KICAgIDwvZz4KPC9zeW1ib2w+CjxzeW1ib2wgaWQ9ImljLWhpc3Rvcnktc2hhcGUiIHZpZXdCb3g9IjAgMCAyNCAyNCI+CiAgICA8ZyBmaWxsPSJub25lIiBzdHJva2U9Im5vbmUiIGZpbGwtcnVsZT0iZXZlbm9kZCIgPgogICAgICAgIDxwYXRoIGQ9Ik0wIDBIMTJWMTJIMHoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xODAgLTgwNCkgdHJhbnNsYXRlKDE4MCA4MDQpIi8+CiAgICAgICAgPHBhdGggZmlsbD0iIzQzNDM0MyIgZD0iTTExLjUgNGMuMjc2IDAgLjUuMjI0LjUuNXY3YzAgLjI3Ni0uMjI0LjUtLjUuNWgtN2MtLjI3NiAwLS41LS4yMjQtLjUtLjVWOC44aDFWMTFoNlY1SDguMzQxbC0uNTY4LTFIMTEuNXoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0xODAgLTgwNCkgdHJhbnNsYXRlKDE4MCA4MDQpIi8+CiAgICAgICAgPHBhdGggc3Ryb2tlPSIjNDM0MzQzIiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGQ9Ik00LjUgMC41TDguNSA3LjYxMSAwLjUgNy42MTF6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMTgwIC04MDQpIHRyYW5zbGF0ZSgxODAgODA0KSIvPgogICAgPC9nPgo8L3N5bWJvbD4KPHN5bWJvbCBpZD0iaWMtaGlzdG9yeS10ZXh0IiB2aWV3Qm94PSIwIDAgMjQgMjQiPgogICAgPGcgZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiID4KICAgICAgICA8cGF0aCBkPSJNMCAwSDEyVjEySDB6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjI4IC04MDQpIHRyYW5zbGF0ZSgyMjggODA0KSIvPgogICAgICAgIDxwYXRoIGZpbGw9IiM0MzQzNDMiIGQ9Ik0yIDFoOGMuNTUyIDAgMSAuNDQ4IDEgMUgxYzAtLjU1Mi40NDgtMSAxLTF6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjI4IC04MDQpIHRyYW5zbGF0ZSgyMjggODA0KSIvPgogICAgICAgIDxwYXRoIGZpbGw9IiM0MzQzNDMiIGQ9Ik0xIDFIMlYzSDF6TTEwIDFIMTFWM0gxMHpNNS41IDFMNi41IDEgNi41IDExIDUuNSAxMXoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yMjggLTgwNCkgdHJhbnNsYXRlKDIyOCA4MDQpIi8+CiAgICAgICAgPHBhdGggZmlsbD0iIzQzNDM0MyIgZD0iTTQgMTBIOFYxMUg0eiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTIyOCAtODA0KSB0cmFuc2xhdGUoMjI4IDgwNCkiLz4KICAgIDwvZz4KPC9zeW1ib2w+CjxzeW1ib2wgaWQ9ImljLWhpc3RvcnktbG9hZCIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxnIGZpbGw9Im5vbmUiIHN0cm9rZT0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8cGF0aCBkPSJNMCAwSDEyVjEySDB6IiB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMzI0IC04MDUpIHRyYW5zbGF0ZSgzMjQgODA1KSIvPgogICAgICAgIDxwYXRoIGZpbGw9IiM0MzQzNDMiIGQ9Ik01IDBjLjU1MiAwIDEgLjQ0OCAxIDF2MWg1LjVjLjI3NiAwIC41LjIyNC41LjV2OGMwIC4yNzYtLjIyNC41LS41LjVILjVjLS4yNzYgMC0uNS0uMjI0LS41LS41VjFjMC0uNTUyLjQ0OC0xIDEtMWg0em0wIDFIMXY5aDEwVjNINVYxeiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMyNCAtODA1KSB0cmFuc2xhdGUoMzI0IDgwNSkiLz4KICAgICAgICA8cGF0aCBmaWxsPSIjNDM0MzQzIiBkPSJNMSAyTDUgMiA1IDMgMSAzeiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMyNCAtODA1KSB0cmFuc2xhdGUoMzI0IDgwNSkiLz4KICAgIDwvZz4KPC9zeW1ib2w+CjxzeW1ib2wgaWQ9ImljLWhpc3RvcnktZGVsZXRlIiB2aWV3Qm94PSIwIDAgMjQgMjQiPgogICAgPGcgZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiBmaWxsLXJ1bGU9ImV2ZW5vZGQiPgogICAgICAgIDxnIGZpbGw9IiM0MzQzNDMiPgogICAgICAgICAgICA8cGF0aCBkPSJNMiA5aDhWMWgxdjguNWMwIC4yNzYtLjIyNC41LS41LjVoLTljLS4yNzYgMC0uNS0uMjI0LS41LS41VjFoMXY4ek0wIDBIMTJWMUgweiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMwMCAtODA0KSB0cmFuc2xhdGUoMzAwIDgwNCkgdHJhbnNsYXRlKDAgMikiLz4KICAgICAgICAgICAgPHBhdGggZD0iTTQgM0g1VjdINHpNNyAzSDhWN0g3eiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTMwMCAtODA0KSB0cmFuc2xhdGUoMzAwIDgwNCkgdHJhbnNsYXRlKDAgMikiLz4KICAgICAgICAgICAgPHBhdGggZD0iTTQgMWg0VjBoMXYxLjVjMCAuMjc2LS4yMjQuNS0uNS41aC01Yy0uMjc2IDAtLjUtLjIyNC0uNS0uNVYwaDF2MXoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0zMDAgLTgwNCkgdHJhbnNsYXRlKDMwMCA4MDQpIG1hdHJpeCgxIDAgMCAtMSAwIDIpIi8+CiAgICAgICAgPC9nPgogICAgPC9nPgo8L3N5bWJvbD4KPHN5bWJvbCBpZD0iaWMtaGlzdG9yeS1ncm91cCIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxnIGZpbGw9Im5vbmUiIHN0cm9rZT0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIj4KICAgICAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMzQ4IC04MDQpIHRyYW5zbGF0ZSgzNDggODA0KSI+CiAgICAgICAgICAgIDxwYXRoIGQ9Ik0wIDBIMTJWMTJIMHoiLz4KICAgICAgICAgICAgPHBhdGggZmlsbD0iIzQzNDM0MyIgZD0iTTEgOXYyaDF2MUguNWMtLjI3NiAwLS41LS4yMjQtLjUtLjVWOWgxem0xMSAxdjEuNWMwIC4yNzYtLjIyNC41LS41LjVIOXYtMWgydi0xaDF6bS00IDF2MUg2di0xaDJ6bS0zIDB2MUgzdi0xaDJ6bTctNHYyaC0xVjdoMXpNMSA2djJIMFY2aDF6bTExLTJ2MmgtMVY0aDF6TTEgM3YySDBWM2gxem0xMC41LTNjLjI3NiAwIC41LjIyNC41LjVWM2gtMVYxaC0xVjBoMS41ek02IDB2MUg0VjBoMnptMyAwdjFIN1YwaDJ6TTAgLjVDMCAuMjI0LjIyNCAwIC41IDBIM3YxSDF2MUgwVi41ek05LjUgNGMuMjc2IDAgLjUuMjI0LjUuNXY1YzAgLjI3Ni0uMjI0LjUtLjUuNWgtNWMtLjI3NiAwLS41LS4yMjQtLjUtLjVWOC4zNTVjLjMxNy4wOTQuNjUyLjE0NSAxIC4xNDVWOWg0VjVoLS41YzAtLjM0OC0uMDUtLjY4My0uMTQ1LTFIOS41eiIvPgogICAgICAgICAgICA8Y2lyY2xlIGN4PSI1IiBjeT0iNSIgcj0iMi41IiBzdHJva2U9IiM0MzQzNDMiLz4KICAgICAgICA8L2c+CiAgICA8L2c+Cjwvc3ltYm9sPgo8c3ltYm9sIGlkPSJpYy1pY29uLWFycm93LTIiIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgICA8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9ImluaGVyaXQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTIxLjc5MyAxOC41SDIuNXYtNWgxOC45MzVsLTcuNi04aDUuODcybDEwLjUgMTAuNS0xMC41IDEwLjVoLTUuOTE0bDgtOHoiLz4KPC9zeW1ib2w+CjxzeW1ib2wgaWQ9ImljLWljb24tYXJyb3ctMyIgdmlld0JveD0iMCAwIDMyIDMyIj4KICAgIDxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iaW5oZXJpdCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBkPSJNMjUuMjg4IDE2LjQyTDE0LjIwOCAyNy41SDYuNzkybDExLjI5MS0xMS4yOTFMNi44MjYgNC41aDcuMzgxbDExLjY2MSAxMS42NjEtLjU4LjI1OHoiLz4KPC9zeW1ib2w+CjxzeW1ib2wgaWQ9ImljLWljb24tYXJyb3ciIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgICA8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9ImluaGVyaXQiIGQ9Ik0yLjUgMTEuNXY5aDE4djUuMjkzTDMwLjI5MyAxNiAyMC41IDYuMjA3VjExLjVoLTE4eiIvPgo8L3N5bWJvbD4KPHN5bWJvbCBpZD0iaWMtaWNvbi1idWJibGUiIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgICA8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9ImluaGVyaXQiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTIyLjIwNyAyNC41TDE2LjUgMzAuMjA3VjI0LjVIOEE2LjUgNi41IDAgMCAxIDEuNSAxOFY5QTYuNSA2LjUgMCAwIDEgOCAyLjVoMTZBNi41IDYuNSAwIDAgMSAzMC41IDl2OWE2LjUgNi41IDAgMCAxLTYuNSA2LjVoLTEuNzkzeiIvPgo8L3N5bWJvbD4KPHN5bWJvbCBpZD0iaWMtaWNvbi1oZWFydCIgdmlld0JveD0iMCAwIDMyIDMyIj4KICAgIDxwYXRoIGZpbGwtcnVsZT0ibm9uemVybyIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJpbmhlcml0IiBkPSJNMTUuOTk2IDMwLjY3NWwxLjk4MS0xLjc5YzcuODk4LTcuMTc3IDEwLjM2NS05LjcxOCAxMi4xMzUtMTMuMDEyLjkyMi0xLjcxNiAxLjM3Ny0zLjM3IDEuMzc3LTUuMDc2IDAtNC42NS0zLjY0Ny04LjI5Ny04LjI5Ny04LjI5Ny0yLjMzIDAtNC44NiAxLjUyNy02LjgxNyAzLjgyNGwtLjM4LjQ0Ny0uMzgxLS40NDdDMTMuNjU4IDQuMDI3IDExLjEyNiAyLjUgOC43OTcgMi41IDQuMTQ3IDIuNS41IDYuMTQ3LjUgMTAuNzk3YzAgMS43MTQuNDYgMy4zNzUgMS4zODkgNS4wOTggMS43NzUgMy4yODggNC4yNiA1Ljg0MyAxMi4xMjMgMTIuOTc0bDEuOTg0IDEuODA2eiIvPgo8L3N5bWJvbD4KPHN5bWJvbCBpZD0iaWMtaWNvbi1sb2FkIiB2aWV3Qm94PSIwIDAgMzIgMzIiPgogICAgPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSJpbmhlcml0IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGQ9Ik0xNy4zMTQgMTguODY3bDEuOTUxLTIuNTMgNCA1LjE4NGgtMTdsNi41LTguODQgNC41NDkgNi4xODZ6Ii8+CiAgICA8cGF0aCBzdHJva2U9Im5vbmUiIGZpbGw9ImluaGVyaXQiIGQ9Ik0xOC4wMSA0YTExLjc5OCAxMS43OTggMCAwIDAgMCAxSDN2MjRoMjRWMTQuOTg2YTguNzM4IDguNzM4IDAgMCAwIDEgMFYyOWExIDEgMCAwIDEtMSAxSDNhMSAxIDAgMCAxLTEtMVY1YTEgMSAwIDAgMSAxLTFoMTUuMDF6Ii8+CiAgICA8cGF0aCBzdHJva2U9Im5vbmUiIGZpbGw9ImluaGVyaXQiIGQ9Ik0yNSAzaDF2OWgtMXoiLz4KICAgIDxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iaW5oZXJpdCIgZD0iTTIyIDZsMy41LTMuNUwyOSA2Ii8+Cjwvc3ltYm9sPgo8c3ltYm9sIGlkPSJpYy1pY29uLWxvY2F0aW9uIiB2aWV3Qm94PSIwIDAgMzIgMzIiPgogICAgPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSJpbmhlcml0IiBkPSJNMTYgMzEuMjhDMjMuNjc1IDIzLjMwMiAyNy41IDE3LjE4MSAyNy41IDEzYzAtNi4zNTEtNS4xNDktMTEuNS0xMS41LTExLjVTNC41IDYuNjQ5IDQuNSAxM2MwIDQuMTgxIDMuODI1IDEwLjMwMiAxMS41IDE4LjI4eiIvPgogICAgPGNpcmNsZSBmaWxsPSJub25lIiBzdHJva2U9ImluaGVyaXQiIGN4PSIxNiIgY3k9IjEzIiByPSI0LjUiLz4KPC9zeW1ib2w+CjxzeW1ib2wgaWQ9ImljLWljb24tcG9seWdvbiIgdmlld0JveD0iMCAwIDMyIDMyIj4KICAgIDxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iaW5oZXJpdCIgZD0iTS41NzYgMTZMOC4yOSAyOS41aDE1LjQyTDMxLjQyNCAxNiAyMy43MSAyLjVIOC4yOUwuNTc2IDE2eiIvPgo8L3N5bWJvbD4KPHN5bWJvbCBpZD0iaWMtaWNvbi1zdGFyLTIiIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgICA8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9ImluaGVyaXQiIGQ9Ik0xOS40NDYgMzEuNTkybDIuMjY1LTMuMjcyIDMuOTQ2LjI1LjYzNi0zLjk0IDMuNjY1LTEuNTA1LTEuMTItMy44MzIgMi42NTUtMi45NjItMi42NTYtMi45NjIgMS4xMi0zLjgzMi0zLjY2NC0xLjUwNS0uNjM2LTMuOTQxLTMuOTQ2LjI1LTIuMjY1LTMuMjcxTDE2IDMuMDI0IDEyLjU1NCAxLjA3IDEwLjI4OSA0LjM0bC0zLjk0Ni0uMjUtLjYzNiAzLjk0MS0zLjY2NSAxLjUwNSAxLjEyIDMuODMyTC41MDggMTYuMzNsMi42NTYgMi45NjItMS4xMiAzLjgzMiAzLjY2NCAxLjUwNC42MzYgMy45NDIgMy45NDYtLjI1IDIuMjY1IDMuMjdMMTYgMjkuNjM4bDMuNDQ2IDEuOTU1eiIvPgo8L3N5bWJvbD4KPHN5bWJvbCBpZD0iaWMtaWNvbi1zdGFyIiB2aWV3Qm94PSIwIDAgMzIgMzIiPgogICAgPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSJpbmhlcml0IiBkPSJNMjUuMjkyIDI5Ljg3OGwtMS43NzUtMTAuMzQ2IDcuNTE3LTcuMzI3LTEwLjM4OC0xLjUxTDE2IDEuMjgybC00LjY0NiA5LjQxMy0xMC4zODggMS41MSA3LjUxNyA3LjMyNy0xLjc3NSAxMC4zNDZMMTYgMjQuOTkzbDkuMjkyIDQuODg1eiIvPgo8L3N5bWJvbD4KPHN5bWJvbCBpZD0iaWMtaWNvbiIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iaW5oZXJpdCIgc3Ryb2tlLWxpbmVjYXA9InJvdW5kIiBzdHJva2UtbGluZWpvaW49InJvdW5kIiBkPSJNMTEuOTIzIDE5LjEzNkw1LjQyNCAyMmwuNzE1LTcuMDY1LTQuNzMxLTUuMjk2IDYuOTQtMS41MDNMMTEuOTIzIDJsMy41NzQgNi4xMzYgNi45NCAxLjUwMy00LjczMSA1LjI5NkwxOC40MiAyMnoiLz4KPC9zeW1ib2w+CjxzeW1ib2wgaWQ9ImljLW1hc2stbG9hZCIgdmlld0JveD0iMCAwIDMyIDMyIj4KICAgIDxwYXRoIHN0cm9rZT0ibm9uZSIgZmlsbD0ibm9uZSIgZD0iTTAgMGgzMnYzMkgweiIvPgogICAgPHBhdGggc3Ryb2tlPSJub25lIiBmaWxsPSJpbmhlcml0IiBkPSJNMTguMDEgNGExMS43OTggMTEuNzk4IDAgMCAwIDAgMUgzdjI0aDI0VjE0Ljk4NmE4LjczOCA4LjczOCAwIDAgMCAxIDBWMjlhMSAxIDAgMCAxLTEgMUgzYTEgMSAwIDAgMS0xLTFWNWExIDEgMCAwIDEgMS0xaDE1LjAxek0xNSAyM2E2IDYgMCAxIDEgMC0xMiA2IDYgMCAwIDEgMCAxMnptMC0xYTUgNSAwIDEgMCAwLTEwIDUgNSAwIDAgMCAwIDEweiIvPgogICAgPHBhdGggc3Ryb2tlPSJub25lIiBmaWxsPSJpbmhlcml0IiBkPSJNMjUgM2gxdjloLTF6Ii8+CiAgICA8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9ImluaGVyaXQiIGQ9Ik0yMiA2bDMuNS0zLjVMMjkgNiIvPgo8L3N5bWJvbD4KPHN5bWJvbCBpZD0iaWMtbWFzayIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxjaXJjbGUgY3g9IjEyIiBjeT0iMTIiIHI9IjQuNSIgc3Ryb2tlPSJpbmhlcml0IiBmaWxsPSJub25lIi8+CiAgICA8cGF0aCBzdHJva2U9Im5vbmUiIGZpbGw9ImluaGVyaXQiIGQ9Ik0yIDFoMjBhMSAxIDAgMCAxIDEgMXYyMGExIDEgMCAwIDEtMSAxSDJhMSAxIDAgMCAxLTEtMVYyYTEgMSAwIDAgMSAxLTF6bTAgMXYyMGgyMFYySDJ6Ii8+Cjwvc3ltYm9sPgo8c3ltYm9sIGlkPSJpYy1yZWRvIiB2aWV3Qm94PSIwIDAgMjQgMjQiPgogICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgb3BhY2l0eT0iLjUiIGZpbGw9Im5vbmUiIHN0cm9rZT0ibm9uZSIgLz4KICAgIDxwYXRoIHN0cm9rZT0ibm9uZSIgZmlsbD0iaW5oZXJpdCIgZD0iTTIxIDZIOWE2IDYgMCAxIDAgMCAxMmgxMnYxSDlBNyA3IDAgMCAxIDkgNWgxMnYxeiIvPgogICAgPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSJpbmhlcml0IiBzdHJva2UtbGluZWNhcD0ic3F1YXJlIiBkPSJNMTkgM2wyLjUgMi41TDE5IDgiLz4KPC9zeW1ib2w+CjxzeW1ib2wgaWQ9ImljLXJlc2V0IiB2aWV3Qm94PSIwIDAgMjQgMjQiPgogICAgPHBhdGggZD0iTTAgMGgyNHYyNEgweiIgb3BhY2l0eT0iLjUiIHN0cm9rZT0ibm9uZSIgZmlsbD0ibm9uZSIvPgogICAgPHBhdGggc3Ryb2tlPSJub25lIiBmaWxsPSJpbmhlcml0IiBkPSJNMiAxM3YtMWE3IDcgMCAwIDEgNy03aDEzdjFoLTF2NWgxdjFhNyA3IDAgMCAxLTcgN0gydi0xaDF2LTVIMnptNy03YTYgNiAwIDAgMC02IDZ2NmgxMmE2IDYgMCAwIDAgNi02VjZIOXoiLz4KICAgIDxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iaW5oZXJpdCIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSIgZD0iTTE5IDNsMi41IDIuNUwxOSA4TTUgMTZsLTIuNSAyLjVMNSAyMSIvPgo8L3N5bWJvbD4KPHN5bWJvbCBpZD0iaWMtcm90YXRlLWNsb2Nrd2lzZSIgdmlld0JveD0iMCAwIDMyIDMyIj4KICAgIDxwYXRoIHN0cm9rZT0ibm9uZSIgZmlsbD0iaW5oZXJpdCIgZD0iTTI5IDE3aC0uOTI0YzAgNi42MjctNS4zNzMgMTItMTIgMTItNi42MjggMC0xMi01LjM3My0xMi0xMkM0LjA3NiAxMC4zOTggOS40MDcgNS4wNDEgMTYgNVY0QzguODIgNCAzIDkuODIgMyAxN3M1LjgyIDEzIDEzIDEzIDEzLTUuODIgMTMtMTN6Ii8+CiAgICA8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9ImluaGVyaXQiIHN0cm9rZS1saW5lY2FwPSJzcXVhcmUiIGQ9Ik0xNiAxLjVsNCAzLTQgMyIvPgogICAgPHBhdGggc3Ryb2tlPSJub25lIiBmaWxsPSJpbmhlcml0IiBmaWxsLXJ1bGU9Im5vbnplcm8iIGQ9Ik0xNiA0aDR2MWgtNHoiLz4KPC9zeW1ib2w+CjxzeW1ib2wgaWQ9ImljLXJvdGF0ZS1jb3VudGVyY2xvY2t3aXNlIiB2aWV3Qm94PSIwIDAgMzIgMzIiPgogICAgPHBhdGggc3Ryb2tlPSJub25lIiBkPSJNMyAxN2guOTI0YzAgNi42MjcgNS4zNzMgMTIgMTIgMTIgNi42MjggMCAxMi01LjM3MyAxMi0xMiAwLTYuNjAyLTUuMzMxLTExLjk2LTExLjkyNC0xMlY0YzcuMTggMCAxMyA1LjgyIDEzIDEzcy01LjgyIDEzLTEzIDEzUzMgMjQuMTggMyAxN3oiLz4KICAgIDxwYXRoIHN0cm9rZT0ibm9uZSIgZmlsbD0iaW5oZXJpdCIgZmlsbC1ydWxlPSJub256ZXJvIiBkPSJNMTIgNGg0djFoLTR6Ii8+CiAgICA8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9ImluaGVyaXQiIHN0cm9rZS1saW5lY2FwPSJzcXVhcmUiIGQ9Ik0xNiAxLjVsLTQgMyA0IDMiLz4KPC9zeW1ib2w+CjxzeW1ib2wgaWQ9ImljLXJvdGF0ZSIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGQ9Ik0wIDBoMjR2MjRIMHoiIGZpbGw9Im5vbmUiIHN0cm9rZT0ibm9uZSIgLz4KICAgIDxwYXRoIGZpbGw9ImluaGVyaXQiIHN0cm9rZT0ibm9uZSIgZD0iTTguMzQ5IDIyLjI1NGExMC4wMDIgMTAuMDAyIDAgMCAxLTIuNzc4LTEuNzE5bC42NS0uNzZhOS4wMDIgOS4wMDIgMCAwIDAgMi40OTUgMS41NDhsLS4zNjcuOTMxem0yLjg3My43MDRsLjA3OC0uOTk3YTkgOSAwIDEgMC0uNTU3LTE3Ljg1MmwtLjE0LS45OUExMC4wNzYgMTAuMDc2IDAgMCAxIDEyLjE0NSAzYzUuNTIzIDAgMTAgNC40NzcgMTAgMTBzLTQuNDc3IDEwLTEwIDEwYy0uMzEyIDAtLjYyLS4wMTQtLjkyNC0uMDQyem0tNy41NTYtNC42NTVhOS45NDIgOS45NDIgMCAwIDEtMS4yNTMtMi45OTZsLjk3My0uMjM0YTguOTQ4IDguOTQ4IDAgMCAwIDEuMTI0IDIuNjkzbC0uODQ0LjUzN3ptLTEuNTAyLTUuOTFBOS45NDkgOS45NDkgMCAwIDEgMi44OCA5LjIzbC45MjUuMzgyYTguOTU0IDguOTU0IDAgMCAwLS42NDQgMi44NDRsLS45OTgtLjA2MnptMi4yMS01LjY4NmMuNjg3LS44NDggMS41MS0xLjU4IDIuNDM2LTIuMTY2bC41MjMuODUyYTkuMDQ4IDkuMDQ4IDAgMCAwLTIuMTg4IDEuOTVsLS43NzEtLjYzNnoiLz4KICAgIDxwYXRoIHN0cm9rZT0iaW5oZXJpdCIgZmlsbD0ibm9uZSIgc3Ryb2tlLWxpbmVjYXA9InNxdWFyZSIgZD0iTTEzIDFsLTIuNSAyLjVMMTMgNiIvPgo8L3N5bWJvbD4KPHN5bWJvbCBpZD0iaWMtc2hhcGUtY2lyY2xlIiB2aWV3Qm94PSIwIDAgMzIgMzIiPgogICAgPGNpcmNsZSBjeD0iMTYiIGN5PSIxNiIgcj0iMTQuNSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJpbmhlcml0Ii8+Cjwvc3ltYm9sPgo8c3ltYm9sIGlkPSJpYy1zaGFwZS1yZWN0YW5nbGUiIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgICA8cmVjdCB3aWR0aD0iMjciIGhlaWdodD0iMjciIHg9IjIuNSIgeT0iMi41IiBmaWxsPSJub25lIiBzdHJva2U9ImluaGVyaXQiIHJ4PSIxIi8+Cjwvc3ltYm9sPgo8c3ltYm9sIGlkPSJpYy1zaGFwZS10cmlhbmdsZSIgdmlld0JveD0iMCAwIDMyIDMyIj4KICAgIDxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZS1saW5lY2FwPSJyb3VuZCIgc3Ryb2tlLWxpbmVqb2luPSJyb3VuZCIgZD0iTTE2IDIuNWwxNS41IDI3SC41eiIvPgo8L3N5bWJvbD4KPHN5bWJvbCBpZD0iaWMtc2hhcGUiIHZpZXdCb3g9IjAgMCAyNCAyNCI+CiAgICA8cGF0aCBzdHJva2U9Im5vbmUiIGZpbGw9ImluaGVyaXQiIGQ9Ik0xNC43MDYgOEgyMWExIDEgMCAwIDEgMSAxdjEyYTEgMSAwIDAgMS0xIDFIOWExIDEgMCAwIDEtMS0xdi00aDF2NGgxMlY5aC01LjcwNmwtLjU4OC0xeiIvPgogICAgPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSJpbmhlcml0IiBzdHJva2UtbGluZWNhcD0icm91bmQiIHN0cm9rZS1saW5lam9pbj0icm91bmQiIGQ9Ik04LjUgMS41bDcuNSAxM0gxeiIvPgo8L3N5bWJvbD4KPHN5bWJvbCBpZD0iaWMtdGV4dC1hbGlnbi1jZW50ZXIiIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgICA8cGF0aCBzdHJva2U9Im5vbmUiIGZpbGw9Im5vbmUiIGQ9Ik0wIDBoMzJ2MzJIMHoiLz4KICAgIDxwYXRoIHN0cm9rZT0ibm9uZSIgZmlsbD0iaW5oZXJpdCIgZD0iTTIgNWgyOHYxSDJ6TTggMTJoMTZ2MUg4ek0yIDE5aDI4djFIMnpNOCAyNmgxNnYxSDh6Ii8+Cjwvc3ltYm9sPgo8c3ltYm9sIGlkPSJpYy10ZXh0LWFsaWduLWxlZnQiIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgICA8cGF0aCBzdHJva2U9Im5vbmUiIGZpbGw9Im5vbmUiIGQ9Ik0wIDBoMzJ2MzJIMHoiLz4KICAgIDxwYXRoIHN0cm9rZT0ibm9uZSIgZmlsbD0iaW5oZXJpdCIgZD0iTTIgNWgyOHYxSDJ6TTIgMTJoMTZ2MUgyek0yIDE5aDI4djFIMnpNMiAyNmgxNnYxSDJ6Ii8+Cjwvc3ltYm9sPgo8c3ltYm9sIGlkPSJpYy10ZXh0LWFsaWduLXJpZ2h0IiB2aWV3Qm94PSIwIDAgMzIgMzIiPgogICAgPHBhdGggc3Ryb2tlPSJub25lIiBmaWxsPSJub25lIiBkPSJNMCAwaDMydjMySDB6Ii8+CiAgICA8cGF0aCBzdHJva2U9Im5vbmUiIGZpbGw9ImluaGVyaXQiIGQ9Ik0yIDVoMjh2MUgyek0xNCAxMmgxNnYxSDE0ek0yIDE5aDI4djFIMnpNMTQgMjZoMTZ2MUgxNHoiLz4KPC9zeW1ib2w+CjxzeW1ib2wgaWQ9ImljLXRleHQtYm9sZCIgdmlld0JveD0iMCAwIDMyIDMyIj4KICAgIDxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0ibm9uZSIgZD0iTTAgMGgzMnYzMkgweiIvPgogICAgPHBhdGggc3Ryb2tlPSJub25lIiBmaWxsPSJpbmhlcml0IiBkPSJNNyAyaDJ2Mkg3ek03IDI4aDJ2Mkg3eiIvPgogICAgPHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSJpbmhlcml0IiBzdHJva2Utd2lkdGg9IjIiIGQ9Ik05IDN2MTJoOWE2IDYgMCAxIDAgMC0xMkg5ek05IDE1djE0aDEwYTcgNyAwIDAgMCAwLTE0SDl6Ii8+Cjwvc3ltYm9sPgo8c3ltYm9sIGlkPSJpYy10ZXh0LWl0YWxpYyIgdmlld0JveD0iMCAwIDMyIDMyIj4KICAgIDxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0ibm9uZSIgZD0iTTAgMGgzMnYzMkgweiIvPgogICAgPHBhdGggc3Ryb2tlPSJub25lIiBmaWxsPSJpbmhlcml0IiBkPSJNMTUgMmg1djFoLTV6TTExIDI5aDV2MWgtNXpNMTcgM2gxbC00IDI2aC0xeiIvPgo8L3N5bWJvbD4KPHN5bWJvbCBpZD0iaWMtdGV4dC11bmRlcmxpbmUiIHZpZXdCb3g9IjAgMCAzMiAzMiI+CiAgICA8cGF0aCBzdHJva2U9Im5vbmUiIGZpbGw9Im5vbmUiIGQ9Ik0wIDBoMzJ2MzJIMHoiLz4KICAgIDxwYXRoIHN0cm9rZT0ibm9uZSIgZmlsbD0iaW5oZXJpdCIgZD0iTTggMnYxNGE4IDggMCAxIDAgMTYgMFYyaDF2MTRhOSA5IDAgMCAxLTE4IDBWMmgxek0zIDI5aDI2djFIM3oiLz4KICAgIDxwYXRoIHN0cm9rZT0ibm9uZSIgZmlsbD0iaW5oZXJpdCIgZD0iTTUgMmg1djFINXpNMjIgMmg1djFoLTV6Ii8+Cjwvc3ltYm9sPgo8c3ltYm9sIGlkPSJpYy10ZXh0IiB2aWV3Qm94PSIwIDAgMjQgMjQiPgogICAgPHBhdGggc3Ryb2tlPSJub25lIiBmaWxsPSJpbmhlcml0IiBkPSJNNCAzaDE1YTEgMSAwIDAgMSAxIDFIM2ExIDEgMCAwIDEgMS0xek0zIDRoMXYxSDN6TTE5IDRoMXYxaC0xeiIvPgogICAgPHBhdGggc3Ryb2tlPSJub25lIiBmaWxsPSJpbmhlcml0IiBkPSJNMTEgM2gxdjE4aC0xeiIvPgogICAgPHBhdGggc3Ryb2tlPSJub25lIiBmaWxsPSJpbmhlcml0IiBkPSJNMTAgMjBoM3YxaC0zeiIvPgo8L3N5bWJvbD4KPHN5bWJvbCBpZD0iaWMtdW5kbyIgdmlld0JveD0iMCAwIDI0IDI0Ij4KICAgIDxwYXRoIGQ9Ik0yNCAwSDB2MjRoMjR6IiBvcGFjaXR5PSIuNSIgZmlsbD0ibm9uZSIgc3Ryb2tlPSJub25lIiAvPgogICAgPHBhdGggc3Ryb2tlPSJub25lIiBmaWxsPSJpbmhlcml0IiBkPSJNMyA2aDEyYTYgNiAwIDEgMSAwIDEySDN2MWgxMmE3IDcgMCAwIDAgMC0xNEgzdjF6Ii8+CiAgICA8cGF0aCBmaWxsPSJub25lIiBzdHJva2U9ImluaGVyaXQiIHN0cm9rZS1saW5lY2FwPSJzcXVhcmUiIGQ9Ik01IDNMMi41IDUuNSA1IDgiLz4KPC9zeW1ib2w+CjxzeW1ib2wgaWQ9ImljLXpvb20taW4iIHZpZXdCb3g9IjAgMCAyNCAyNCI+CiAgICA8ZyB0cmFuc2Zvcm09InRyYW5zbGF0ZSgtMjI5IC0yOTApIHRyYW5zbGF0ZSgyMjkgMjkwKSI+CiAgICAgICAgPGNpcmNsZSBjeD0iMTAuNSIgY3k9IjEwLjUiIHI9IjkiIHN0cm9rZT0iaW5oZXJpdCIgZmlsbD0ibm9uZSIvPgogICAgICAgIDxwYXRoIGZpbGw9ImluaGVyaXQiIGQ9Ik0xOC44MjggMTUuODI4SDE5LjgyOFYyMi44MjhIMTguODI4eiIgdHJhbnNmb3JtPSJyb3RhdGUoLTQ1IDE5LjMyOCAxOS4zMjgpIi8+CiAgICAgICAgPHBhdGggZmlsbD0iaW5oZXJpdCIgZD0iTTcgMTBIMTRWMTFIN3oiLz4KICAgICAgICA8cGF0aCBmaWxsPSJpbmhlcml0IiBkPSJNMTAgN0gxMVYxNEgxMHoiLz4KICAgIDwvZz4KPC9zeW1ib2w+CjxzeW1ib2wgaWQ9ImljLXpvb20tb3V0IiB2aWV3Qm94PSIwIDAgMjQgMjQiPgogICAgPGcgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTI2MyAtMjkwKSB0cmFuc2xhdGUoMjYzIDI5MCkiPgogICAgICAgIDxjaXJjbGUgY3g9IjEwLjUiIGN5PSIxMC41IiByPSI5IiBzdHJva2U9ImluaGVyaXQiIGZpbGw9Im5vbmUiLz4KICAgICAgICA8cGF0aCBmaWxsPSJpbmhlcml0IiBkPSJNMTguODI4IDE1LjgyOEgxOS44MjhWMjIuODI4SDE4LjgyOHoiIHRyYW5zZm9ybT0icm90YXRlKC00NSAxOS4zMjggMTkuMzI4KSIvPgogICAgICAgIDxwYXRoIGZpbGw9ImluaGVyaXQiIGQ9Ik03IDEwSDE0VjExSDd6Ii8+CiAgICA8L2c+Cjwvc3ltYm9sPgo8c3ltYm9sIGlkPSJpYy1oYW5kIiB2aWV3Qm94PSIwIDAgMjQgMjQiPgogICAgPGcgZmlsbD0ibm9uZSIgZmlsbC1ydWxlPSJldmVub2RkIiBzdHJva2UtbGluZWpvaW49InJvdW5kIj4KICAgICAgICA8cGF0aCBmaWxsPSJpbmhlcml0IiBmaWxsLXJ1bGU9Im5vbnplcm8iIGQ9Ik04LjY3MiAzLjM2YzEuMzI4IDAgMi4xMTQuNzggMi4yOSAxLjg2OWwuMDE0LjEwMS4wMjMuMDA2djEuMDQybC0uNjM4LS4xODVjLS4xODctLjA1NS0uMzIzLS4yMTEtLjM1NC0uMzk5TDEwIDUuNzEzYzAtLjgyNS0uNDItMS4zNTMtMS4zMjgtMS4zNTNDNy42OTUgNC4zNiA3IDUuMDQxIDcgNS43MTN2Ny45NDFjMCAuNDM5LS41MjQuNjY1LS44NDMuMzY0bC0xLjg2OC0xLjc2MWMtLjU5NS0uNTI4LTEuMzE2LS42MTctMS45MTgtLjIxNi0uNTIyLjM0OC0uNTYyIDEuMjAzLS4xOCAxLjhMNy43MzggMjJoMTEuMDEzbC4yODUtLjUxOGMxLjI0Ny0yLjMyNiAxLjg5Ny00LjI1OSAxLjk2LTUuNzg1bC4wMDQtLjIzOVY4LjAzNWMwLS42NTYtLjUtMS4xNy0xLTEuMTctLjUwMyAwLTEgLjQ1Ni0xIDEuMTcgMCAuMzMzLS4zMi41NzMtLjY0LjQ4TDE4IDguNDFWNy4zNjhsLjA4Ni4wMjYuMDQyLS4xMzZjLjI3OS0uODA1Ljk3OC0xLjMzMiAxLjczOC0xLjM4OEwyMCA1Ljg2NWMxLjA1NyAwIDIgLjk2NyAyIDIuMTd2Ny40MjNjMCAxLjkyOS0uODQ1IDQuMzUyLTIuNTIxIDcuMjktLjA5LjE1Ni0uMjU1LjI1Mi0uNDM1LjI1Mkg3LjQ3NGMtLjE2NiAwLS4zMjEtLjA4Mi0uNDE0LS4yMTlsLTUuNzA0LTguMzljLS42NTMtMS4wMTktLjU4NC0yLjQ4Ni40Ni0zLjE4MiAxLS42NjYgMi4yMTYtLjUxNiAzLjE0OC4zMUw2IDEyLjQ5NVY1LjcxM2MwLTEuMTggMS4wNTgtMi4yNjMgMi40OS0yLjM0OHoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yOTcgLTI5MCkgdHJhbnNsYXRlKDI5NyAyOTApIi8+CiAgICAgICAgPHBhdGggZmlsbD0iaW5oZXJpdCIgZmlsbC1ydWxlPSJub256ZXJvIiBkPSJNMTIuNSAxLjVjMS4zMjUgMCAyLjQxIDEuMDMyIDIuNDk1IDIuMzM2TDE1IDR2Ny4yMmgtMVY0YzAtLjgyOC0uNjcyLTEuNS0xLjUtMS41LS43OCAwLTEuNDIuNTk1LTEuNDkzIDEuMzU2TDExIDR2Ny4yMmgtMVY0YzAtMS4zOCAxLjEyLTIuNSAyLjUtMi41eiIgdHJhbnNmb3JtPSJ0cmFuc2xhdGUoLTI5NyAtMjkwKSB0cmFuc2xhdGUoMjk3IDI5MCkiLz4KICAgICAgICA8cGF0aCBmaWxsPSJpbmhlcml0IiBmaWxsLXJ1bGU9Im5vbnplcm8iIGQ9Ik0xNi41IDMuNWMxLjMyNSAwIDIuNDEgMS4wMzIgMi40OTUgMi4zMzZMMTkgNnY2LjNoLTFWNmMwLS44MjgtLjY3Mi0xLjUtMS41LTEuNS0uNzggMC0xLjQyLjU5NS0xLjQ5MyAxLjM1NkwxNSA2djIuNDRoLTFWNmMwLTEuMzggMS4xMi0yLjUgMi41LTIuNXoiIHRyYW5zZm9ybT0idHJhbnNsYXRlKC0yOTcgLTI5MCkgdHJhbnNsYXRlKDI5NyAyOTApIi8+CiAgICA8L2c+Cjwvc3ltYm9sPgo8L2RlZnM+Cjwvc3ZnPgo=";
        },
        4858: function(module2) {
          module2.exports = __WEBPACK_EXTERNAL_MODULE__4858__;
        },
        4960: function() {
        },
        6759: function() {
        },
        6272: function() {
        }
      };
      var __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        var cachedModule = __webpack_module_cache__[moduleId];
        if (cachedModule !== void 0) {
          return cachedModule.exports;
        }
        var module2 = __webpack_module_cache__[moduleId] = {
          exports: {}
        };
        __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
        return module2.exports;
      }
      !function() {
        __webpack_require__.n = function(module2) {
          var getter = module2 && module2.__esModule ? function() {
            return module2["default"];
          } : function() {
            return module2;
          };
          __webpack_require__.d(getter, { a: getter });
          return getter;
        };
      }();
      !function() {
        __webpack_require__.d = function(exports2, definition) {
          for (var key in definition) {
            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
              Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
            }
          }
        };
      }();
      !function() {
        __webpack_require__.g = function() {
          if (typeof globalThis === "object")
            return globalThis;
          try {
            return this || new Function("return this")();
          } catch (e2) {
            if (typeof window === "object")
              return window;
          }
        }();
      }();
      !function() {
        __webpack_require__.o = function(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        };
      }();
      var __webpack_exports__ = {};
      !function() {
        __webpack_require__.d(__webpack_exports__, {
          "default": function() {
            return src;
          }
        });
        var trim2 = __webpack_require__(9131);
        var trim_default = /* @__PURE__ */ __webpack_require__.n(trim2);
        var index_of = __webpack_require__(1899);
        var index_of_default = /* @__PURE__ */ __webpack_require__.n(index_of);
        var splice = __webpack_require__(6562);
        var splice_default = /* @__PURE__ */ __webpack_require__.n(splice);
        var define_property = __webpack_require__(1734);
        var define_property_default = /* @__PURE__ */ __webpack_require__.n(define_property);
        var slice = __webpack_require__(8005);
        var slice_default = /* @__PURE__ */ __webpack_require__.n(slice);
        var create2 = __webpack_require__(6065);
        var create_default = /* @__PURE__ */ __webpack_require__.n(create2);
        var set_timeout = __webpack_require__(4496);
        var set_timeout_default = /* @__PURE__ */ __webpack_require__.n(set_timeout);
        if (!Element.prototype.matches) {
          Element.prototype.matches = Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
        }
        if (!Element.prototype.closest) {
          Element.prototype.closest = function(s) {
            var el = this;
            do {
              if (Element.prototype.matches.call(el, s))
                return el;
              el = el.parentElement || el.parentNode;
            } while (el !== null && el.nodeType === 1);
            return null;
          };
        }
        /*! @source http://purl.eligrey.com/github/classList.js/blob/master/classList.js */
        if ("document" in self) {
          if (!("classList" in document.createElement("_")) || document.createElementNS && !("classList" in document.createElementNS("http://www.w3.org/2000/svg", "g"))) {
            (function(view) {
              if (!("Element" in view))
                return;
              var classListProp = "classList", protoProp = "prototype", elemCtrProto = view.Element[protoProp], objCtr = Object, strTrim = trim_default()(String[protoProp]) || function() {
                return this.replace(/^\s+|\s+$/g, "");
              }, arrIndexOf = index_of_default()(Array[protoProp]) || function(item) {
                var i = 0, len = this.length;
                for (; i < len; i++) {
                  if (i in this && this[i] === item) {
                    return i;
                  }
                }
                return -1;
              }, DOMEx = function DOMEx2(type, message) {
                this.name = type;
                this.code = DOMException[type];
                this.message = message;
              }, checkTokenAndGetIndex = function checkTokenAndGetIndex2(classList, token) {
                if (token === "") {
                  throw new DOMEx("SYNTAX_ERR", "The token must not be empty.");
                }
                if (/\s/.test(token)) {
                  throw new DOMEx("INVALID_CHARACTER_ERR", "The token must not contain space characters.");
                }
                return arrIndexOf.call(classList, token);
              }, ClassList = function ClassList2(elem) {
                var trimmedClasses = strTrim.call(elem.getAttribute("class") || ""), classes = trimmedClasses ? trimmedClasses.split(/\s+/) : [], i = 0, len = classes.length;
                for (; i < len; i++) {
                  this.push(classes[i]);
                }
                this._updateClassName = function() {
                  elem.setAttribute("class", this.toString());
                };
              }, classListProto = ClassList[protoProp] = [], classListGetter = function classListGetter2() {
                return new ClassList(this);
              };
              DOMEx[protoProp] = Error[protoProp];
              classListProto.item = function(i) {
                return this[i] || null;
              };
              classListProto.contains = function(token) {
                return ~checkTokenAndGetIndex(this, token + "");
              };
              classListProto.add = function() {
                var tokens = arguments, i = 0, l = tokens.length, token, updated = false;
                do {
                  token = tokens[i] + "";
                  if (!~checkTokenAndGetIndex(this, token)) {
                    this.push(token);
                    updated = true;
                  }
                } while (++i < l);
                if (updated) {
                  this._updateClassName();
                }
              };
              classListProto.remove = function() {
                var tokens = arguments, i = 0, l = tokens.length, token, updated = false, index2;
                do {
                  token = tokens[i] + "";
                  index2 = checkTokenAndGetIndex(this, token);
                  while (~index2) {
                    var _context2;
                    splice_default()(_context2 = this).call(_context2, index2, 1);
                    updated = true;
                    index2 = checkTokenAndGetIndex(this, token);
                  }
                } while (++i < l);
                if (updated) {
                  this._updateClassName();
                }
              };
              classListProto.toggle = function(token, force) {
                var result = this.contains(token), method = result ? force !== true && "remove" : force !== false && "add";
                if (method) {
                  this[method](token);
                }
                if (force === true || force === false) {
                  return force;
                } else {
                  return !result;
                }
              };
              classListProto.replace = function(token, replacement_token) {
                var index2 = checkTokenAndGetIndex(token + "");
                if (~index2) {
                  var _context2;
                  splice_default()(_context2 = this).call(_context2, index2, 1, replacement_token);
                  this._updateClassName();
                }
              };
              classListProto.toString = function() {
                return this.join(" ");
              };
              if (define_property_default()) {
                var classListPropDesc = {
                  get: classListGetter,
                  enumerable: true,
                  configurable: true
                };
                try {
                  define_property_default()(elemCtrProto, classListProp, classListPropDesc);
                } catch (ex) {
                  if (ex.number === void 0 || ex.number === -2146823252) {
                    classListPropDesc.enumerable = false;
                    define_property_default()(elemCtrProto, classListProp, classListPropDesc);
                  }
                }
              } else if (objCtr[protoProp].__defineGetter__) {
                elemCtrProto.__defineGetter__(classListProp, classListGetter);
              }
            })(self);
          }
          (function() {
            var testElement = document.createElement("_");
            testElement.classList.add("c1", "c2");
            if (!testElement.classList.contains("c2")) {
              var createMethod = function createMethod2(method) {
                var original = DOMTokenList.prototype[method];
                DOMTokenList.prototype[method] = function(token) {
                  var i, len = arguments.length;
                  for (i = 0; i < len; i++) {
                    token = arguments[i];
                    original.call(this, token);
                  }
                };
              };
              createMethod("add");
              createMethod("remove");
            }
            testElement.classList.toggle("c3", false);
            if (testElement.classList.contains("c3")) {
              var _toggle = DOMTokenList.prototype.toggle;
              DOMTokenList.prototype.toggle = function(token, force) {
                if (1 in arguments && !this.contains(token) === !force) {
                  return force;
                } else {
                  return _toggle.call(this, token);
                }
              };
            }
            if (!("replace" in document.createElement("_").classList)) {
              DOMTokenList.prototype.replace = function(token, replacement_token) {
                var tokens = this.toString().split(" "), index2 = index_of_default()(tokens).call(tokens, token + "");
                if (~index2) {
                  tokens = slice_default()(tokens).call(tokens, index2);
                  this.remove.apply(this, tokens);
                  this.add(replacement_token);
                  this.add.apply(this, slice_default()(tokens).call(tokens, 1));
                }
              };
            }
            testElement = null;
          })();
        }
        /*!
         * @copyright Copyright (c) 2017 IcoMoon.io
         * @license   Licensed under MIT license
         *            See https://github.com/Keyamoon/svgxuse
         * @version   1.2.6
         */
        (function() {
          if (typeof window !== "undefined" && window.addEventListener) {
            var cache = create_default()(null);
            var checkUseElems;
            var tid;
            var debouncedCheck = function debouncedCheck2() {
              clearTimeout(tid);
              tid = set_timeout_default()(checkUseElems, 100);
            };
            var unobserveChanges = function unobserveChanges2() {
              return;
            };
            var observeChanges = function observeChanges2() {
              var observer;
              window.addEventListener("resize", debouncedCheck, false);
              window.addEventListener("orientationchange", debouncedCheck, false);
              if (window.MutationObserver) {
                observer = new MutationObserver(debouncedCheck);
                observer.observe(document.documentElement, {
                  childList: true,
                  subtree: true,
                  attributes: true
                });
                unobserveChanges = function unobserveChanges2() {
                  try {
                    observer.disconnect();
                    window.removeEventListener("resize", debouncedCheck, false);
                    window.removeEventListener("orientationchange", debouncedCheck, false);
                  } catch (ignore) {
                  }
                };
              } else {
                document.documentElement.addEventListener("DOMSubtreeModified", debouncedCheck, false);
                unobserveChanges = function unobserveChanges2() {
                  document.documentElement.removeEventListener("DOMSubtreeModified", debouncedCheck, false);
                  window.removeEventListener("resize", debouncedCheck, false);
                  window.removeEventListener("orientationchange", debouncedCheck, false);
                };
              }
            };
            var createRequest = function createRequest2(url2) {
              function getOrigin2(loc) {
                var a2;
                if (loc.protocol !== void 0) {
                  a2 = loc;
                } else {
                  a2 = document.createElement("a");
                  a2.href = loc;
                }
                return a2.protocol.replace(/:/g, "") + a2.host;
              }
              var Request;
              var origin;
              var origin2;
              if (window.XMLHttpRequest) {
                Request = new XMLHttpRequest();
                origin = getOrigin2(location);
                origin2 = getOrigin2(url2);
                if (Request.withCredentials === void 0 && origin2 !== "" && origin2 !== origin) {
                  Request = XDomainRequest || void 0;
                } else {
                  Request = XMLHttpRequest;
                }
              }
              return Request;
            };
            var xlinkNS = "http://www.w3.org/1999/xlink";
            checkUseElems = function checkUseElems2() {
              var base2;
              var bcr;
              var hash2;
              var href;
              var i;
              var inProgressCount = 0;
              var isHidden;
              var Request;
              var url2;
              var uses;
              var xhr2;
              function observeIfDone() {
                inProgressCount -= 1;
                if (inProgressCount === 0) {
                  unobserveChanges();
                  observeChanges();
                }
              }
              function attrUpdateFunc(spec) {
                return function() {
                  if (cache[spec.base] !== true) {
                    spec.useEl.setAttributeNS(xlinkNS, "xlink:href", "#" + spec.hash);
                    if (spec.useEl.hasAttribute("href")) {
                      spec.useEl.setAttribute("href", "#" + spec.hash);
                    }
                  }
                };
              }
              function onloadFunc(xhr3) {
                return function() {
                  var body = document.body;
                  var x = document.createElement("x");
                  var svg;
                  xhr3.onload = null;
                  x.innerHTML = xhr3.responseText;
                  svg = x.getElementsByTagName("svg")[0];
                  if (svg) {
                    svg.setAttribute("aria-hidden", "true");
                    svg.style.position = "absolute";
                    svg.style.width = 0;
                    svg.style.height = 0;
                    svg.style.overflow = "hidden";
                    body.insertBefore(svg, body.firstChild);
                  }
                  observeIfDone();
                };
              }
              function onErrorTimeout(xhr3) {
                return function() {
                  xhr3.onerror = null;
                  xhr3.ontimeout = null;
                  observeIfDone();
                };
              }
              unobserveChanges();
              uses = document.getElementsByTagName("use");
              for (i = 0; i < uses.length; i += 1) {
                try {
                  bcr = uses[i].getBoundingClientRect();
                } catch (ignore) {
                  bcr = false;
                }
                href = uses[i].getAttribute("href") || uses[i].getAttributeNS(xlinkNS, "href") || uses[i].getAttribute("xlink:href");
                if (href && href.split) {
                  url2 = href.split("#");
                } else {
                  url2 = ["", ""];
                }
                base2 = url2[0];
                hash2 = url2[1];
                isHidden = bcr && bcr.left === 0 && bcr.right === 0 && bcr.top === 0 && bcr.bottom === 0;
                if (bcr && bcr.width === 0 && bcr.height === 0 && !isHidden) {
                  if (uses[i].hasAttribute("href")) {
                    uses[i].setAttributeNS(xlinkNS, "xlink:href", href);
                  }
                  if (base2.length) {
                    xhr2 = cache[base2];
                    if (xhr2 !== true) {
                      set_timeout_default()(attrUpdateFunc({
                        useEl: uses[i],
                        base: base2,
                        hash: hash2
                      }), 0);
                    }
                    if (xhr2 === void 0) {
                      Request = createRequest(base2);
                      if (Request !== void 0) {
                        xhr2 = new Request();
                        cache[base2] = xhr2;
                        xhr2.onload = onloadFunc(xhr2);
                        xhr2.onerror = onErrorTimeout(xhr2);
                        xhr2.ontimeout = onErrorTimeout(xhr2);
                        xhr2.open("GET", base2);
                        xhr2.send();
                        inProgressCount += 1;
                      }
                    }
                  }
                } else {
                  if (!isHidden) {
                    if (cache[base2] === void 0) {
                      cache[base2] = true;
                    } else if (cache[base2].onload) {
                      cache[base2].abort();
                      delete cache[base2].onload;
                      cache[base2] = true;
                    }
                  } else if (base2.length && cache[base2]) {
                    set_timeout_default()(attrUpdateFunc({
                      useEl: uses[i],
                      base: base2,
                      hash: hash2
                    }), 0);
                  }
                }
              }
              uses = "";
              inProgressCount += 1;
              observeIfDone();
            };
            var _winLoad;
            _winLoad = function winLoad() {
              window.removeEventListener("load", _winLoad, false);
              tid = set_timeout_default()(checkUseElems, 0);
            };
            if (document.readyState !== "complete") {
              window.addEventListener("load", _winLoad, false);
            } else {
              _winLoad();
            }
          }
        })();
        var is_array = __webpack_require__(1845);
        function _arrayLikeToArray(arr2, len) {
          if (len == null || len > arr2.length)
            len = arr2.length;
          for (var i = 0, arr22 = new Array(len); i < len; i++) {
            arr22[i] = arr2[i];
          }
          return arr22;
        }
        function _arrayWithoutHoles(arr2) {
          if (is_array(arr2))
            return _arrayLikeToArray(arr2);
        }
        var symbol = __webpack_require__(184);
        var get_iterator_method = __webpack_require__(662);
        var from = __webpack_require__(7172);
        function _iterableToArray(iter) {
          if (typeof symbol !== "undefined" && get_iterator_method(iter) != null || iter["@@iterator"] != null)
            return from(iter);
        }
        var instance_slice = __webpack_require__(711);
        function _unsupportedIterableToArray(o, minLen) {
          var _context2;
          if (!o)
            return;
          if (typeof o === "string")
            return _arrayLikeToArray(o, minLen);
          var n = instance_slice(_context2 = Object.prototype.toString.call(o)).call(_context2, 8, -1);
          if (n === "Object" && o.constructor)
            n = o.constructor.name;
          if (n === "Map" || n === "Set")
            return from(o);
          if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
            return _arrayLikeToArray(o, minLen);
        }
        function _nonIterableSpread() {
          throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _toConsumableArray(arr2) {
          return _arrayWithoutHoles(arr2) || _iterableToArray(arr2) || _unsupportedIterableToArray(arr2) || _nonIterableSpread();
        }
        var object_define_property = __webpack_require__(7077);
        function _defineProperty2(obj, key, value) {
          if (key in obj) {
            object_define_property(obj, key, {
              value,
              enumerable: true,
              configurable: true,
              writable: true
            });
          } else {
            obj[key] = value;
          }
          return obj;
        }
        function _classCallCheck(instance, Constructor) {
          if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
          }
        }
        function _defineProperties(target, props2) {
          for (var i = 0; i < props2.length; i++) {
            var descriptor = props2[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor)
              descriptor.writable = true;
            object_define_property(target, descriptor.key, descriptor);
          }
        }
        function _createClass(Constructor, protoProps, staticProps) {
          if (protoProps)
            _defineProperties(Constructor.prototype, protoProps);
          if (staticProps)
            _defineProperties(Constructor, staticProps);
          return Constructor;
        }
        var bind3 = __webpack_require__(4426);
        var bind_default = /* @__PURE__ */ __webpack_require__.n(bind3);
        var concat = __webpack_require__(9406);
        var concat_default = /* @__PURE__ */ __webpack_require__.n(concat);
        var core_js_stable_promise = __webpack_require__(8189);
        var promise_default = /* @__PURE__ */ __webpack_require__.n(core_js_stable_promise);
        var url = __webpack_require__(3972);
        var url_default = /* @__PURE__ */ __webpack_require__.n(url);
        var fabric = __webpack_require__(2777);
        var extend2 = __webpack_require__(961);
        var extend_default = /* @__PURE__ */ __webpack_require__.n(extend2);
        var type_isUndefined = __webpack_require__(5695);
        var isUndefined_default = /* @__PURE__ */ __webpack_require__.n(type_isUndefined);
        var collection_forEach = __webpack_require__(8592);
        var forEach_default = /* @__PURE__ */ __webpack_require__.n(collection_forEach);
        var customEvents = __webpack_require__(9052);
        var customEvents_default = /* @__PURE__ */ __webpack_require__.n(customEvents);
        var isString2 = __webpack_require__(2560);
        var isString_default = /* @__PURE__ */ __webpack_require__.n(isString2);
        var keys2 = __webpack_require__(2461);
        var keys_default = /* @__PURE__ */ __webpack_require__.n(keys2);
        function _arrayWithHoles(arr2) {
          if (is_array(arr2))
            return arr2;
        }
        function _iterableToArrayLimit(arr2, i) {
          var _i = arr2 == null ? null : typeof symbol !== "undefined" && get_iterator_method(arr2) || arr2["@@iterator"];
          if (_i == null)
            return;
          var _arr = [];
          var _n = true;
          var _d = false;
          var _s, _e;
          try {
            for (_i = _i.call(arr2); !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);
              if (i && _arr.length === i)
                break;
            }
          } catch (err) {
            _d = true;
            _e = err;
          } finally {
            try {
              if (!_n && _i["return"] != null)
                _i["return"]();
            } finally {
              if (_d)
                throw _e;
            }
          }
          return _arr;
        }
        function _nonIterableRest() {
          throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        function _slicedToArray(arr2, i) {
          return _arrayWithHoles(arr2) || _iterableToArrayLimit(arr2, i) || _unsupportedIterableToArray(arr2, i) || _nonIterableRest();
        }
        var parse_int = __webpack_require__(6397);
        var parse_int_default = /* @__PURE__ */ __webpack_require__.n(parse_int);
        var for_each = __webpack_require__(7636);
        var for_each_default = /* @__PURE__ */ __webpack_require__.n(for_each);
        var instance_fill = __webpack_require__(789);
        var fill_default = /* @__PURE__ */ __webpack_require__.n(instance_fill);
        var sendHostname = __webpack_require__(4729);
        var sendHostname_default = /* @__PURE__ */ __webpack_require__.n(sendHostname);
        var pick = __webpack_require__(1610);
        var pick_default = /* @__PURE__ */ __webpack_require__.n(pick);
        var inArray = __webpack_require__(3053);
        var inArray_default = /* @__PURE__ */ __webpack_require__.n(inArray);
        var _context;
        var ZOOM_HELP_MENUS = ["zoomIn", "zoomOut", "hand"];
        var COMMAND_HELP_MENUS = ["history", "undo", "redo", "reset"];
        var DELETE_HELP_MENUS = ["delete", "deleteAll"];
        var HELP_MENUS = concat_default()(_context = []).call(_context, ZOOM_HELP_MENUS, COMMAND_HELP_MENUS, DELETE_HELP_MENUS);
        var SHAPE_FILL_TYPE = {
          FILTER: "filter",
          COLOR: "color"
        };
        var SHAPE_TYPE = ["rect", "circle", "triangle"];
        var OBJ_TYPE = {
          CROPZONE: "cropzone"
        };
        var filterType = {
          VINTAGE: "vintage",
          SEPIA2: "sepia2",
          REMOVE_COLOR: "removeColor",
          COLOR_FILTER: "colorFilter",
          REMOVE_WHITE: "removeWhite",
          BLEND_COLOR: "blendColor",
          BLEND: "blend"
        };
        var componentNames = keyMirror("IMAGE_LOADER", "CROPPER", "FLIP", "ROTATION", "FREE_DRAWING", "LINE", "TEXT", "ICON", "FILTER", "SHAPE", "ZOOM", "RESIZE");
        var SHAPE_DEFAULT_OPTIONS = {
          lockSkewingX: true,
          lockSkewingY: true,
          bringForward: true,
          isRegular: false
        };
        var CROPZONE_DEFAULT_OPTIONS = {
          hasRotatingPoint: false,
          hasBorders: false,
          lockScalingFlip: true,
          lockRotation: true,
          lockSkewingX: true,
          lockSkewingY: true
        };
        var commandNames = {
          CLEAR_OBJECTS: "clearObjects",
          LOAD_IMAGE: "loadImage",
          FLIP_IMAGE: "flip",
          ROTATE_IMAGE: "rotate",
          ADD_OBJECT: "addObject",
          REMOVE_OBJECT: "removeObject",
          APPLY_FILTER: "applyFilter",
          REMOVE_FILTER: "removeFilter",
          ADD_ICON: "addIcon",
          CHANGE_ICON_COLOR: "changeIconColor",
          ADD_SHAPE: "addShape",
          CHANGE_SHAPE: "changeShape",
          ADD_TEXT: "addText",
          CHANGE_TEXT: "changeText",
          CHANGE_TEXT_STYLE: "changeTextStyle",
          ADD_IMAGE_OBJECT: "addImageObject",
          RESIZE_CANVAS_DIMENSION: "resizeCanvasDimension",
          SET_OBJECT_PROPERTIES: "setObjectProperties",
          SET_OBJECT_POSITION: "setObjectPosition",
          CHANGE_SELECTION: "changeSelection",
          RESIZE_IMAGE: "resize"
        };
        var eventNames = {
          OBJECT_ACTIVATED: "objectActivated",
          OBJECT_MOVED: "objectMoved",
          OBJECT_SCALED: "objectScaled",
          OBJECT_CREATED: "objectCreated",
          OBJECT_ROTATED: "objectRotated",
          OBJECT_ADDED: "objectAdded",
          OBJECT_MODIFIED: "objectModified",
          TEXT_EDITING: "textEditing",
          TEXT_CHANGED: "textChanged",
          ICON_CREATE_RESIZE: "iconCreateResize",
          ICON_CREATE_END: "iconCreateEnd",
          ADD_TEXT: "addText",
          ADD_OBJECT: "addObject",
          ADD_OBJECT_AFTER: "addObjectAfter",
          MOUSE_DOWN: "mousedown",
          MOUSE_UP: "mouseup",
          MOUSE_MOVE: "mousemove",
          REDO_STACK_CHANGED: "redoStackChanged",
          UNDO_STACK_CHANGED: "undoStackChanged",
          SELECTION_CLEARED: "selectionCleared",
          SELECTION_CREATED: "selectionCreated",
          EXECUTE_COMMAND: "executeCommand",
          AFTER_UNDO: "afterUndo",
          AFTER_REDO: "afterRedo",
          ZOOM_CHANGED: "zoomChanged",
          HAND_STARTED: "handStarted",
          HAND_STOPPED: "handStopped",
          KEY_DOWN: "keydown",
          KEY_UP: "keyup",
          INPUT_BOX_EDITING_STARTED: "inputBoxEditingStarted",
          INPUT_BOX_EDITING_STOPPED: "inputBoxEditingStopped",
          FOCUS: "focus",
          BLUR: "blur",
          IMAGE_RESIZED: "imageResized"
        };
        var selectorNames = {
          COLOR_PICKER_INPUT_BOX: ".tui-colorpicker-palette-hex"
        };
        var historyNames = {
          LOAD_IMAGE: "Load",
          LOAD_MASK_IMAGE: "Mask",
          ADD_MASK_IMAGE: "Mask",
          ADD_IMAGE_OBJECT: "Mask",
          CROP: "Crop",
          RESIZE: "Resize",
          APPLY_FILTER: "Filter",
          REMOVE_FILTER: "Filter",
          CHANGE_SHAPE: "Shape",
          CHANGE_ICON_COLOR: "Icon",
          ADD_TEXT: "Text",
          CHANGE_TEXT_STYLE: "Text",
          REMOVE_OBJECT: "Delete",
          CLEAR_OBJECTS: "Delete"
        };
        var drawingModes = keyMirror("NORMAL", "CROPPER", "FREE_DRAWING", "LINE_DRAWING", "TEXT", "SHAPE", "ICON", "ZOOM", "RESIZE");
        var drawingMenuNames = {
          TEXT: "text",
          CROP: "crop",
          RESIZE: "resize",
          SHAPE: "shape",
          ZOOM: "zoom"
        };
        var zoomModes = {
          DEFAULT: "normal",
          ZOOM: "zoom",
          HAND: "hand"
        };
        var keyCodes = {
          Z: 90,
          Y: 89,
          C: 67,
          V: 86,
          SHIFT: 16,
          BACKSPACE: 8,
          DEL: 46,
          ARROW_DOWN: 40,
          ARROW_UP: 38,
          SPACE: 32,
          DIGIT_0: 48,
          DIGIT_9: 57
        };
        var fObjectOptions = {
          SELECTION_STYLE: {
            borderColor: "red",
            cornerColor: "green",
            cornerSize: 10,
            originX: "center",
            originY: "center",
            transparentCorners: false
          }
        };
        var rejectMessages = {
          addedObject: "The object is already added.",
          flip: "The flipX and flipY setting values are not changed.",
          invalidDrawingMode: "This operation is not supported in the drawing mode.",
          invalidParameters: "Invalid parameters.",
          isLock: "The executing command state is locked.",
          loadImage: "The background image is empty.",
          loadingImageFailed: "Invalid image loaded.",
          noActiveObject: "There is no active object.",
          noObject: "The object is not in canvas.",
          redo: "The promise of redo command is reject.",
          rotation: "The current angle is same the old angle.",
          undo: "The promise of undo command is reject.",
          unsupportedOperation: "Unsupported operation.",
          unsupportedType: "Unsupported object type."
        };
        var defaultIconPath = {
          "icon-arrow": "M40 12V0l24 24-24 24V36H0V12h40z",
          "icon-arrow-2": "M49,32 H3 V22 h46 l-18,-18 h12 l23,23 L43,50 h-12 l18,-18  z ",
          "icon-arrow-3": "M43.349998,27 L17.354,53 H1.949999 l25.996,-26 L1.949999,1 h15.404 L43.349998,27  z ",
          "icon-star": "M35,54.557999 l-19.912001,10.468 l3.804,-22.172001 l-16.108,-15.7 l22.26,-3.236 L35,3.746 l9.956,20.172001 l22.26,3.236 l-16.108,15.7 l3.804,22.172001  z ",
          "icon-star-2": "M17,31.212 l-7.194,4.08 l-4.728,-6.83 l-8.234,0.524 l-1.328,-8.226 l-7.644,-3.14 l2.338,-7.992 l-5.54,-6.18 l5.54,-6.176 l-2.338,-7.994 l7.644,-3.138 l1.328,-8.226 l8.234,0.522 l4.728,-6.83 L17,-24.312 l7.194,-4.08 l4.728,6.83 l8.234,-0.522 l1.328,8.226 l7.644,3.14 l-2.338,7.992 l5.54,6.178 l-5.54,6.178 l2.338,7.992 l-7.644,3.14 l-1.328,8.226 l-8.234,-0.524 l-4.728,6.83  z ",
          "icon-polygon": "M3,31 L19,3 h32 l16,28 l-16,28 H19  z ",
          "icon-location": "M24 62C8 45.503 0 32.837 0 24 0 10.745 10.745 0 24 0s24 10.745 24 24c0 8.837-8 21.503-24 38zm0-28c5.523 0 10-4.477 10-10s-4.477-10-10-10-10 4.477-10 10 4.477 10 10 10z",
          "icon-heart": "M49.994999,91.349998 l-6.96,-6.333 C18.324001,62.606995 2.01,47.829002 2.01,29.690998 C2.01,14.912998 13.619999,3.299999 28.401001,3.299999 c8.349,0 16.362,5.859 21.594,12 c5.229,-6.141 13.242001,-12 21.591,-12 c14.778,0 26.390999,11.61 26.390999,26.390999 c0,18.138 -16.314001,32.916 -41.025002,55.374001 l-6.96,6.285  z ",
          "icon-bubble": "M44 48L34 58V48H12C5.373 48 0 42.627 0 36V12C0 5.373 5.373 0 12 0h40c6.627 0 12 5.373 12 12v24c0 6.627-5.373 12-12 12h-8z"
        };
        var defaultRotateRangeValues = {
          realTimeEvent: true,
          min: -360,
          max: 360,
          value: 0
        };
        var defaultDrawRangeValues = {
          min: 5,
          max: 30,
          value: 12
        };
        var defaultShapeStrokeValues = {
          realTimeEvent: true,
          min: 2,
          max: 300,
          value: 3
        };
        var defaultTextRangeValues = {
          realTimeEvent: true,
          min: 10,
          max: 100,
          value: 50
        };
        var defaultFilterRangeValues = {
          tintOpacityRange: {
            realTimeEvent: true,
            min: 0,
            max: 1,
            value: 0.7,
            useDecimal: true
          },
          removewhiteDistanceRange: {
            realTimeEvent: true,
            min: 0,
            max: 1,
            value: 0.2,
            useDecimal: true
          },
          brightnessRange: {
            realTimeEvent: true,
            min: -1,
            max: 1,
            value: 0,
            useDecimal: true
          },
          noiseRange: {
            realTimeEvent: true,
            min: 0,
            max: 1e3,
            value: 100
          },
          pixelateRange: {
            realTimeEvent: true,
            min: 2,
            max: 20,
            value: 4
          },
          colorfilterThresholdRange: {
            realTimeEvent: true,
            min: 0,
            max: 1,
            value: 0.2,
            useDecimal: true
          },
          blurFilterRange: {
            value: 0.1
          }
        };
        var emptyCropRectValues = {
          LEFT: 0,
          TOP: 0,
          WIDTH: 0.5,
          HEIGHT: 0.5
        };
        var defaultResizePixelValues = {
          realTimeEvent: true,
          min: 32,
          max: 4088,
          value: 800
        };
        var FLOATING_POINT_DIGIT = 2;
        var CSS_PREFIX = "tui-image-editor-";
        var min = Math.min, max2 = Math.max;
        var hostnameSent = false;
        var lastId = 0;
        function stamp(obj) {
          if (!obj.__fe_id) {
            lastId += 1;
            obj.__fe_id = lastId;
          }
          return obj.__fe_id;
        }
        function isFunction2(value) {
          return typeof value === "function";
        }
        function clamp(value, minValue, maxValue) {
          if (minValue > maxValue) {
            var _ref = [maxValue, minValue];
            minValue = _ref[0];
            maxValue = _ref[1];
          }
          return max2(minValue, min(value, maxValue));
        }
        function keyMirror() {
          var obj = {};
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          forEach_default()(args, function(key) {
            obj[key] = key;
          });
          return obj;
        }
        function getProperties(obj, keys3) {
          var props2 = {};
          var length = keys3.length;
          var i = 0;
          var key;
          for (i = 0; i < length; i += 1) {
            key = keys3[i];
            props2[key] = obj[key];
          }
          return props2;
        }
        function toInteger(value) {
          return parse_int_default()(value, 10);
        }
        function toCamelCase(targetString) {
          return targetString.replace(/-([a-z])/g, function($0, $1) {
            return $1.toUpperCase();
          });
        }
        function isSupportFileApi() {
          return !!(window.File && window.FileList && window.FileReader);
        }
        function getRgb(color2, alpha) {
          var _context3, _context4, _context5;
          if (color2.length === 4) {
            var _context2;
            color2 = concat_default()(_context2 = "".concat(color2)).call(_context2, slice_default()(color2).call(color2, 1, 4));
          }
          var r = parse_int_default()(slice_default()(color2).call(color2, 1, 3), 16);
          var g = parse_int_default()(slice_default()(color2).call(color2, 3, 5), 16);
          var b = parse_int_default()(slice_default()(color2).call(color2, 5, 7), 16);
          var a2 = alpha || 1;
          return concat_default()(_context3 = concat_default()(_context4 = concat_default()(_context5 = "rgba(".concat(r, ", ")).call(_context5, g, ", ")).call(_context4, b, ", ")).call(_context3, a2, ")");
        }
        function sendHostName() {
          if (hostnameSent) {
            return;
          }
          hostnameSent = true;
          sendHostname_default()("image-editor", "UA-129999381-1");
        }
        function styleLoad(styleBuffer, tagId) {
          var _document$getElements = document.getElementsByTagName("head"), _document$getElements2 = _slicedToArray(_document$getElements, 1), head = _document$getElements2[0];
          var linkElement = document.createElement("link");
          var styleData = encodeURIComponent(styleBuffer);
          if (tagId) {
            linkElement.id = tagId;
          }
          linkElement.setAttribute("rel", "stylesheet");
          linkElement.setAttribute("type", "text/css");
          linkElement.setAttribute("href", "data:text/css;charset=UTF-8,".concat(styleData));
          head.appendChild(linkElement);
        }
        function getSelector(targetElement) {
          return function(str) {
            return targetElement.querySelector(str);
          };
        }
        function base64ToBlob(data) {
          var rImageType = /data:(image\/.+);base64,/;
          var mimeString = "";
          var raw, uInt8Array, i;
          raw = data.replace(rImageType, function(header, imageType) {
            mimeString = imageType;
            return "";
          });
          raw = atob(raw);
          var rawLength = raw.length;
          uInt8Array = new Uint8Array(rawLength);
          for (i = 0; i < rawLength; i += 1) {
            uInt8Array[i] = raw.charCodeAt(i);
          }
          return new Blob([uInt8Array], {
            type: mimeString
          });
        }
        function fixFloatingPoint(value) {
          return Number(value.toFixed(FLOATING_POINT_DIGIT));
        }
        function assignmentForDestroy(targetObject) {
          forEach_default()(targetObject, function(value, key) {
            targetObject[key] = null;
          });
        }
        function cls() {
          var _context7;
          var str = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : "";
          var prefix2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
          if (str.charAt(0) === ".") {
            var _context6;
            return concat_default()(_context6 = ".".concat(CSS_PREFIX).concat(prefix2)).call(_context6, slice_default()(str).call(str, 1));
          }
          return concat_default()(_context7 = "".concat(CSS_PREFIX).concat(prefix2)).call(_context7, str);
        }
        function changeOrigin(fObject, origin) {
          var originX = origin.originX, originY = origin.originY;
          var _fObject$getPointByOr = fObject.getPointByOrigin(originX, originY), left = _fObject$getPointByOr.x, top = _fObject$getPointByOr.y;
          fObject.set({
            left,
            top,
            originX,
            originY
          });
          fObject.setCoords();
        }
        function flipObject(targetObject) {
          var _context8;
          var result = {};
          for_each_default()(_context8 = keys_default()(targetObject)).call(_context8, function(key) {
            result[targetObject[key]] = key;
          });
          return result;
        }
        function setCustomProperty(targetObject, props2) {
          targetObject.customProps = targetObject.customProps || {};
          extend_default()(targetObject.customProps, props2);
        }
        function getCustomProperty(fObject, propNames) {
          var resultObject = {};
          if (isString_default()(propNames)) {
            propNames = [propNames];
          }
          forEach_default()(propNames, function(propName) {
            resultObject[propName] = fObject.customProps[propName];
          });
          return resultObject;
        }
        function capitalizeString(targetString) {
          return targetString.charAt(0).toUpperCase() + slice_default()(targetString).call(targetString, 1);
        }
        function includes(targetArray, compareValue) {
          return index_of_default()(targetArray).call(targetArray, compareValue) >= 0;
        }
        function getFillTypeFromOption() {
          var fillOption = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
          return pick_default()(fillOption, "type") || SHAPE_FILL_TYPE.COLOR;
        }
        function getFillTypeFromObject(shapeObj) {
          var _shapeObj$fill = fill_default()(shapeObj), fill = _shapeObj$fill === void 0 ? {} : _shapeObj$fill;
          if (fill.source) {
            return SHAPE_FILL_TYPE.FILTER;
          }
          return SHAPE_FILL_TYPE.COLOR;
        }
        function isShape(obj) {
          return inArray_default()(obj.get("type"), SHAPE_TYPE) >= 0;
        }
        function getObjectType(type) {
          if (includes(SHAPE_TYPE, type)) {
            return "Shape";
          }
          switch (type) {
            case "i-text":
              return "Text";
            case "path":
            case "line":
              return "Draw";
            case "activeSelection":
              return "Group";
            default:
              return toStartOfCapital(type);
          }
        }
        function getFilterType(type) {
          var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$useAlpha = _ref2.useAlpha, useAlpha = _ref2$useAlpha === void 0 ? true : _ref2$useAlpha, mode = _ref2.mode;
          var VINTAGE = filterType.VINTAGE, REMOVE_COLOR = filterType.REMOVE_COLOR, BLEND_COLOR = filterType.BLEND_COLOR, SEPIA2 = filterType.SEPIA2, COLOR_FILTER = filterType.COLOR_FILTER, REMOVE_WHITE = filterType.REMOVE_WHITE, BLEND = filterType.BLEND;
          var filterName;
          switch (type) {
            case VINTAGE:
              filterName = SEPIA2;
              break;
            case REMOVE_COLOR:
              filterName = useAlpha ? COLOR_FILTER : REMOVE_WHITE;
              break;
            case BLEND_COLOR:
              filterName = mode === "add" ? BLEND : mode;
              break;
            default:
              filterName = type;
          }
          return toStartOfCapital(filterName);
        }
        function isSilentCommand(command2) {
          var LOAD_IMAGE = commandNames.LOAD_IMAGE;
          return typeof command2 === "string" ? LOAD_IMAGE === command2 : LOAD_IMAGE === command2.name;
        }
        function getHistoryTitle(command2) {
          var _context9, _context10;
          var FLIP_IMAGE = commandNames.FLIP_IMAGE, ROTATE_IMAGE = commandNames.ROTATE_IMAGE, ADD_TEXT2 = commandNames.ADD_TEXT, APPLY_FILTER = commandNames.APPLY_FILTER, REMOVE_FILTER = commandNames.REMOVE_FILTER, CHANGE_SHAPE = commandNames.CHANGE_SHAPE, CHANGE_ICON_COLOR = commandNames.CHANGE_ICON_COLOR, CHANGE_TEXT_STYLE = commandNames.CHANGE_TEXT_STYLE, CLEAR_OBJECTS = commandNames.CLEAR_OBJECTS, ADD_IMAGE_OBJECT = commandNames.ADD_IMAGE_OBJECT, REMOVE_OBJECT = commandNames.REMOVE_OBJECT, RESIZE_IMAGE = commandNames.RESIZE_IMAGE;
          var name2 = command2.name, args = command2.args;
          var historyInfo;
          switch (name2) {
            case FLIP_IMAGE:
              historyInfo = {
                name: name2,
                detail: args[1] === "reset" ? args[1] : slice_default()(_context9 = args[1]).call(_context9, 4)
              };
              break;
            case ROTATE_IMAGE:
              historyInfo = {
                name: name2,
                detail: args[2]
              };
              break;
            case APPLY_FILTER:
              historyInfo = {
                name: historyNames.APPLY_FILTER,
                detail: getFilterType(args[1], args[2])
              };
              break;
            case REMOVE_FILTER:
              historyInfo = {
                name: historyNames.REMOVE_FILTER,
                detail: "Remove"
              };
              break;
            case CHANGE_SHAPE:
              historyInfo = {
                name: historyNames.CHANGE_SHAPE,
                detail: "Change"
              };
              break;
            case CHANGE_ICON_COLOR:
              historyInfo = {
                name: historyNames.CHANGE_ICON_COLOR,
                detail: "Change"
              };
              break;
            case CHANGE_TEXT_STYLE:
              historyInfo = {
                name: historyNames.CHANGE_TEXT_STYLE,
                detail: "Change"
              };
              break;
            case REMOVE_OBJECT:
              historyInfo = {
                name: historyNames.REMOVE_OBJECT,
                detail: args[2]
              };
              break;
            case CLEAR_OBJECTS:
              historyInfo = {
                name: historyNames.CLEAR_OBJECTS,
                detail: "All"
              };
              break;
            case ADD_IMAGE_OBJECT:
              historyInfo = {
                name: historyNames.ADD_IMAGE_OBJECT,
                detail: "Add"
              };
              break;
            case ADD_TEXT2:
              historyInfo = {
                name: historyNames.ADD_TEXT
              };
              break;
            case RESIZE_IMAGE:
              historyInfo = {
                name: historyNames.RESIZE,
                detail: concat_default()(_context10 = "".concat(~~args[1].width, "x")).call(_context10, ~~args[1].height)
              };
              break;
            default:
              historyInfo = {
                name: name2
              };
              break;
          }
          if (args[1] === "mask") {
            historyInfo = {
              name: historyNames.LOAD_MASK_IMAGE,
              detail: "Apply"
            };
          }
          return historyInfo;
        }
        function getHelpMenuBarPosition(position2) {
          if (position2 === "top") {
            return "bottom";
          }
          if (position2 === "left") {
            return "right";
          }
          if (position2 === "right") {
            return "left";
          }
          return "top";
        }
        function toStartOfCapital(str) {
          return str.replace(/[a-z]/, function(first) {
            return first.toUpperCase();
          });
        }
        function isEmptyCropzone(cropRect) {
          var left = cropRect.left, top = cropRect.top, width = cropRect.width, height = cropRect.height;
          var LEFT = emptyCropRectValues.LEFT, TOP = emptyCropRectValues.TOP, WIDTH = emptyCropRectValues.WIDTH, HEIGHT = emptyCropRectValues.HEIGHT;
          return left === LEFT && top === TOP && width === WIDTH && height === HEIGHT;
        }
        var types = keyMirror("UN_IMPLEMENTATION", "NO_COMPONENT_NAME");
        var messages = {
          UN_IMPLEMENTATION: "Should implement a method: ",
          NO_COMPONENT_NAME: "Should set a component name"
        };
        var map = {
          UN_IMPLEMENTATION: function UN_IMPLEMENTATION(methodName) {
            return messages.UN_IMPLEMENTATION + methodName;
          },
          NO_COMPONENT_NAME: function NO_COMPONENT_NAME() {
            return messages.NO_COMPONENT_NAME;
          }
        };
        var errorMessage = {
          types: extend_default()({}, types),
          create: function create3(type) {
            type = type.toLowerCase();
            var func = map[type];
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return func.apply(void 0, args);
          }
        };
        var createMessage = errorMessage.create;
        var errorTypes = errorMessage.types;
        var Command = /* @__PURE__ */ function() {
          function Command2(actions2, args) {
            _classCallCheck(this, Command2);
            this.name = actions2.name;
            this.args = args;
            this.execute = actions2.execute;
            this.undo = actions2.undo;
            this.executeCallback = actions2.executeCallback || null;
            this.undoCallback = actions2.undoCallback || null;
            this.undoData = {};
          }
          _createClass(Command2, [{
            key: "execute",
            value: function execute() {
              throw new Error(createMessage(errorTypes.UN_IMPLEMENTATION, "execute"));
            }
          }, {
            key: "undo",
            value: function undo2() {
              throw new Error(createMessage(errorTypes.UN_IMPLEMENTATION, "undo"));
            }
          }, {
            key: "isRedo",
            get: function get() {
              return keys_default()(this.undoData).length > 0;
            }
          }, {
            key: "setUndoData",
            value: function setUndoData(undoData, cachedUndoDataForSilent2, isSilent) {
              if (cachedUndoDataForSilent2) {
                undoData = cachedUndoDataForSilent2;
              }
              if (!isSilent) {
                extend_default()(this.undoData, undoData);
                cachedUndoDataForSilent2 = null;
              } else if (!cachedUndoDataForSilent2) {
                cachedUndoDataForSilent2 = undoData;
              }
              return cachedUndoDataForSilent2;
            }
          }, {
            key: "setExecuteCallback",
            value: function setExecuteCallback(callback) {
              this.executeCallback = callback;
              return this;
            }
          }, {
            key: "setUndoCallback",
            value: function setUndoCallback(callback) {
              this.undoCallback = callback;
              return this;
            }
          }]);
          return Command2;
        }();
        var command = Command;
        var commands = {};
        function command_create(name2) {
          var actions2 = commands[name2];
          if (actions2) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            return new command(actions2, args);
          }
          return null;
        }
        function register(command2) {
          commands[command2.name] = command2;
        }
        var factory_command = {
          create: command_create,
          register
        };
        var Invoker = /* @__PURE__ */ function() {
          function Invoker2() {
            _classCallCheck(this, Invoker2);
            this._undoStack = [];
            this._redoStack = [];
            this._isLocked = false;
            this._isSilent = false;
          }
          _createClass(Invoker2, [{
            key: "_invokeExecution",
            value: function _invokeExecution(command2) {
              var _this = this;
              var isRedo = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              this.lock();
              var args = command2.args;
              if (!args) {
                args = [];
              }
              return command2.execute.apply(command2, _toConsumableArray(args)).then(function(value) {
                if (!_this._isSilent) {
                  _this.pushUndoStack(command2);
                  _this.fire(isRedo ? eventNames.AFTER_REDO : eventNames.EXECUTE_COMMAND, command2);
                }
                _this.unlock();
                if (isFunction2(command2.executeCallback)) {
                  command2.executeCallback(value);
                }
                return value;
              })["catch"](function(message) {
                _this.unlock();
                return promise_default().reject(message);
              });
            }
          }, {
            key: "_invokeUndo",
            value: function _invokeUndo(command2) {
              var _this2 = this;
              this.lock();
              var args = command2.args;
              if (!args) {
                args = [];
              }
              return command2.undo.apply(command2, _toConsumableArray(args)).then(function(value) {
                _this2.pushRedoStack(command2);
                _this2.fire(eventNames.AFTER_UNDO, command2);
                _this2.unlock();
                if (isFunction2(command2.undoCallback)) {
                  command2.undoCallback(value);
                }
                return value;
              })["catch"](function(message) {
                _this2.unlock();
                return promise_default().reject(message);
              });
            }
          }, {
            key: "_fireRedoStackChanged",
            value: function _fireRedoStackChanged() {
              this.fire(eventNames.REDO_STACK_CHANGED, this._redoStack.length);
            }
          }, {
            key: "_fireUndoStackChanged",
            value: function _fireUndoStackChanged() {
              this.fire(eventNames.UNDO_STACK_CHANGED, this._undoStack.length);
            }
          }, {
            key: "lock",
            value: function lock() {
              this._isLocked = true;
            }
          }, {
            key: "unlock",
            value: function unlock() {
              this._isLocked = false;
            }
          }, {
            key: "executeSilent",
            value: function executeSilent() {
              var _this3 = this;
              this._isSilent = true;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return this.execute.apply(this, concat_default()(args).call(args, [this._isSilent])).then(function() {
                _this3._isSilent = false;
              });
            }
          }, {
            key: "execute",
            value: function execute() {
              var _this4 = this;
              if (this._isLocked) {
                return promise_default().reject(rejectMessages.isLock);
              }
              for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                args[_key2] = arguments[_key2];
              }
              var command2 = args[0];
              if (isString_default()(command2)) {
                command2 = factory_command.create.apply(factory_command, args);
              }
              return this._invokeExecution(command2).then(function(value) {
                _this4.clearRedoStack();
                return value;
              });
            }
          }, {
            key: "undo",
            value: function undo2() {
              var command2 = this._undoStack.pop();
              var promise;
              var message = "";
              if (command2 && this._isLocked) {
                this.pushUndoStack(command2, true);
                command2 = null;
              }
              if (command2) {
                if (this.isEmptyUndoStack()) {
                  this._fireUndoStackChanged();
                }
                promise = this._invokeUndo(command2);
              } else {
                message = rejectMessages.undo;
                if (this._isLocked) {
                  var _context2;
                  message = concat_default()(_context2 = "".concat(message, " Because ")).call(_context2, rejectMessages.isLock);
                }
                promise = promise_default().reject(message);
              }
              return promise;
            }
          }, {
            key: "redo",
            value: function redo() {
              var command2 = this._redoStack.pop();
              var promise;
              var message = "";
              if (command2 && this._isLocked) {
                this.pushRedoStack(command2, true);
                command2 = null;
              }
              if (command2) {
                if (this.isEmptyRedoStack()) {
                  this._fireRedoStackChanged();
                }
                promise = this._invokeExecution(command2, true);
              } else {
                message = rejectMessages.redo;
                if (this._isLocked) {
                  var _context2;
                  message = concat_default()(_context2 = "".concat(message, " Because ")).call(_context2, rejectMessages.isLock);
                }
                promise = promise_default().reject(message);
              }
              return promise;
            }
          }, {
            key: "pushUndoStack",
            value: function pushUndoStack(command2, isSilent) {
              this._undoStack.push(command2);
              if (!isSilent) {
                this._fireUndoStackChanged();
              }
            }
          }, {
            key: "pushRedoStack",
            value: function pushRedoStack(command2, isSilent) {
              this._redoStack.push(command2);
              if (!isSilent) {
                this._fireRedoStackChanged();
              }
            }
          }, {
            key: "isEmptyRedoStack",
            value: function isEmptyRedoStack() {
              return this._redoStack.length === 0;
            }
          }, {
            key: "isEmptyUndoStack",
            value: function isEmptyUndoStack() {
              return this._undoStack.length === 0;
            }
          }, {
            key: "clearUndoStack",
            value: function clearUndoStack() {
              if (!this.isEmptyUndoStack()) {
                this._undoStack = [];
                this._fireUndoStackChanged();
              }
            }
          }, {
            key: "clearRedoStack",
            value: function clearRedoStack() {
              if (!this.isEmptyRedoStack()) {
                this._redoStack = [];
                this._fireRedoStackChanged();
              }
            }
          }]);
          return Invoker2;
        }();
        customEvents_default().mixin(Invoker);
        var invoker = Invoker;
        var parse_float = __webpack_require__(5214);
        var parse_float_default = /* @__PURE__ */ __webpack_require__.n(parse_float);
        var mainContainer = function(_ref) {
          var _context2, _context22, _context3, _context4, _context5, _context6, _context7;
          var locale2 = _ref.locale, biImage = _ref.biImage, commonStyle = _ref.commonStyle, headerStyle = _ref.headerStyle, loadButtonStyle = _ref.loadButtonStyle, downloadButtonStyle = _ref.downloadButtonStyle, submenuStyle = _ref.submenuStyle;
          return concat_default()(_context2 = concat_default()(_context22 = concat_default()(_context3 = concat_default()(_context4 = concat_default()(_context5 = concat_default()(_context6 = concat_default()(_context7 = '\n    <div class="tui-image-editor-main-container" style="'.concat(commonStyle, '">\n        <div class="tui-image-editor-header" style="')).call(_context7, headerStyle, '">\n            <div class="tui-image-editor-header-logo">\n                <img src="')).call(_context6, biImage, '" />\n            </div>\n            <div class="tui-image-editor-header-buttons">\n                <div style="')).call(_context5, loadButtonStyle, '">\n                    ')).call(_context4, locale2.localize("Load"), '\n                    <input type="file" class="tui-image-editor-load-btn" />\n                </div>\n                <button class="tui-image-editor-download-btn" style="')).call(_context3, downloadButtonStyle, '">\n                    ')).call(_context22, locale2.localize("Download"), '\n                </button>\n            </div>\n        </div>\n        <div class="tui-image-editor-main">\n            <div class="tui-image-editor-submenu">\n                <div class="tui-image-editor-submenu-style" style="')).call(_context2, submenuStyle, '"></div>\n            </div>\n            <div class="tui-image-editor-wrap">\n                <div class="tui-image-editor-size-wrap">\n                    <div class="tui-image-editor-align-wrap">\n                        <div class="tui-image-editor"></div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n');
        };
        var controls = function(_ref) {
          var _context2, _context22, _context3, _context4, _context5;
          var locale2 = _ref.locale, biImage = _ref.biImage, loadButtonStyle = _ref.loadButtonStyle, downloadButtonStyle = _ref.downloadButtonStyle, menuBarPosition = _ref.menuBarPosition;
          return concat_default()(_context2 = concat_default()(_context22 = concat_default()(_context3 = concat_default()(_context4 = concat_default()(_context5 = '\n    <ul class="tui-image-editor-help-menu '.concat(getHelpMenuBarPosition(menuBarPosition), '"></ul>\n    <div class="tui-image-editor-controls">\n        <div class="tui-image-editor-controls-logo">\n            <img src="')).call(_context5, biImage, '" />\n        </div>\n        <ul class="tui-image-editor-menu"></ul>\n\n        <div class="tui-image-editor-controls-buttons">\n            <div style="')).call(_context4, loadButtonStyle, '">\n                ')).call(_context3, locale2.localize("Load"), '\n                <input type="file" class="tui-image-editor-load-btn" />\n            </div>\n            <button class="tui-image-editor-download-btn" style="')).call(_context22, downloadButtonStyle, '">\n                ')).call(_context2, locale2.localize("Download"), "\n            </button>\n        </div>\n    </div>\n");
        };
        var instance_map = __webpack_require__(899);
        var map_default = /* @__PURE__ */ __webpack_require__.n(instance_map);
        var style = function(_ref) {
          var _context2, _context22, _context3, _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13, _context14, _context15, _context16, _context17, _context18, _context19, _context20, _context21, _context222, _context23, _context24, _context25, _context26, _context27, _context28, _context29;
          var subMenuLabelActive = _ref.subMenuLabelActive, subMenuLabelNormal = _ref.subMenuLabelNormal, subMenuRangeTitle = _ref.subMenuRangeTitle, submenuPartitionVertical = _ref.submenuPartitionVertical, submenuPartitionHorizontal = _ref.submenuPartitionHorizontal, submenuCheckbox = _ref.submenuCheckbox, submenuRangePointer = _ref.submenuRangePointer, submenuRangeValue = _ref.submenuRangeValue, submenuColorpickerTitle = _ref.submenuColorpickerTitle, submenuColorpickerButton = _ref.submenuColorpickerButton, submenuRangeBar = _ref.submenuRangeBar, submenuRangeSubbar = _ref.submenuRangeSubbar, submenuDisabledRangePointer = _ref.submenuDisabledRangePointer, submenuDisabledRangeBar = _ref.submenuDisabledRangeBar, submenuDisabledRangeSubbar = _ref.submenuDisabledRangeSubbar, submenuIconSize = _ref.submenuIconSize, menuIconSize = _ref.menuIconSize, biSize = _ref.biSize, menuIconStyle = _ref.menuIconStyle, submenuIconStyle = _ref.submenuIconStyle;
          return concat_default()(_context2 = concat_default()(_context22 = concat_default()(_context3 = concat_default()(_context4 = concat_default()(_context5 = concat_default()(_context6 = concat_default()(_context7 = concat_default()(_context8 = concat_default()(_context9 = concat_default()(_context10 = concat_default()(_context11 = concat_default()(_context12 = concat_default()(_context13 = concat_default()(_context14 = concat_default()(_context15 = concat_default()(_context16 = concat_default()(_context17 = concat_default()(_context18 = concat_default()(_context19 = concat_default()(_context20 = concat_default()(_context21 = concat_default()(_context222 = concat_default()(_context23 = concat_default()(_context24 = concat_default()(_context25 = concat_default()(_context26 = concat_default()(_context27 = concat_default()(_context28 = concat_default()(_context29 = '\n    .tie-icon-add-button.icon-bubble .tui-image-editor-button[data-icontype="icon-bubble"] label,\n    .tie-icon-add-button.icon-heart .tui-image-editor-button[data-icontype="icon-heart"] label,\n    .tie-icon-add-button.icon-location .tui-image-editor-button[data-icontype="icon-location"] label,\n    .tie-icon-add-button.icon-polygon .tui-image-editor-button[data-icontype="icon-polygon"] label,\n    .tie-icon-add-button.icon-star .tui-image-editor-button[data-icontype="icon-star"] label,\n    .tie-icon-add-button.icon-star-2 .tui-image-editor-button[data-icontype="icon-star-2"] label,\n    .tie-icon-add-button.icon-arrow-3 .tui-image-editor-button[data-icontype="icon-arrow-3"] label,\n    .tie-icon-add-button.icon-arrow-2 .tui-image-editor-button[data-icontype="icon-arrow-2"] label,\n    .tie-icon-add-button.icon-arrow .tui-image-editor-button[data-icontype="icon-arrow"] label,\n    .tie-icon-add-button.icon-bubble .tui-image-editor-button[data-icontype="icon-bubble"] label,\n    .tie-draw-line-select-button.line .tui-image-editor-button.line label,\n    .tie-draw-line-select-button.free .tui-image-editor-button.free label,\n    .tie-flip-button.flipX .tui-image-editor-button.flipX label,\n    .tie-flip-button.flipY .tui-image-editor-button.flipY label,\n    .tie-flip-button.resetFlip .tui-image-editor-button.resetFlip label,\n    .tie-crop-button .tui-image-editor-button.apply.active label,\n    .tie-crop-preset-button .tui-image-editor-button.preset.active label,\n    .tie-resize-button .tui-image-editor-button.apply.active label,\n    .tie-resize-preset-button .tui-image-editor-button.preset.active label,\n    .tie-shape-button.rect .tui-image-editor-button.rect label,\n    .tie-shape-button.circle .tui-image-editor-button.circle label,\n    .tie-shape-button.triangle .tui-image-editor-button.triangle label,\n    .tie-text-effect-button .tui-image-editor-button.active label,\n    .tie-text-align-button.tie-text-align-left .tui-image-editor-button.left label,\n    .tie-text-align-button.tie-text-align-center .tui-image-editor-button.center label,\n    .tie-text-align-button.tie-text-align-right .tui-image-editor-button.right label,\n    .tie-mask-apply.apply.active .tui-image-editor-button.apply label,\n    .tui-image-editor-container .tui-image-editor-submenu .tui-image-editor-button:hover > label,\n    .tui-image-editor-container .tui-image-editor-checkbox label > span {\n        '.concat(subMenuLabelActive, "\n    }\n    .tui-image-editor-container .tui-image-editor-submenu .tui-image-editor-button > label,\n    .tui-image-editor-container .tui-image-editor-range-wrap.tui-image-editor-newline.short label,\n    .tui-image-editor-container .tui-image-editor-range-wrap.tui-image-editor-newline.short label > span {\n        ")).call(_context29, subMenuLabelNormal, "\n    }\n    .tui-image-editor-container .tui-image-editor-range-wrap label > span {\n        ")).call(_context28, subMenuRangeTitle, "\n    }\n    .tui-image-editor-container .tui-image-editor-partition > div {\n        ")).call(_context27, submenuPartitionVertical, "\n    }\n    .tui-image-editor-container.left .tui-image-editor-submenu .tui-image-editor-partition > div,\n    .tui-image-editor-container.right .tui-image-editor-submenu .tui-image-editor-partition > div {\n        ")).call(_context26, submenuPartitionHorizontal, "\n    }\n    .tui-image-editor-container .tui-image-editor-checkbox label > span:before {\n        ")).call(_context25, submenuCheckbox, "\n    }\n    .tui-image-editor-container .tui-image-editor-checkbox label > input:checked + span:before {\n        border: 0;\n    }\n    .tui-image-editor-container .tui-image-editor-virtual-range-pointer {\n        ")).call(_context24, submenuRangePointer, "\n    }\n    .tui-image-editor-container .tui-image-editor-virtual-range-bar {\n        ")).call(_context23, submenuRangeBar, "\n    }\n    .tui-image-editor-container .tui-image-editor-virtual-range-subbar {\n        ")).call(_context222, submenuRangeSubbar, "\n    }\n    .tui-image-editor-container .tui-image-editor-disabled .tui-image-editor-virtual-range-pointer {\n        ")).call(_context21, submenuDisabledRangePointer, "\n    }\n    .tui-image-editor-container .tui-image-editor-disabled .tui-image-editor-virtual-range-subbar {\n        ")).call(_context20, submenuDisabledRangeSubbar, "\n    }\n    .tui-image-editor-container .tui-image-editor-disabled .tui-image-editor-virtual-range-bar {\n        ")).call(_context19, submenuDisabledRangeBar, "\n    }\n    .tui-image-editor-container .tui-image-editor-range-value {\n        ")).call(_context18, submenuRangeValue, "\n    }\n    .tui-image-editor-container .tui-image-editor-submenu .tui-image-editor-button .color-picker-value + label {\n        ")).call(_context17, submenuColorpickerTitle, "\n    }\n    .tui-image-editor-container .tui-image-editor-submenu .tui-image-editor-button .color-picker-value {\n        ")).call(_context16, submenuColorpickerButton, "\n    }\n    .tui-image-editor-container .svg_ic-menu {\n        ")).call(_context15, menuIconSize, "\n    }\n    .tui-image-editor-container .svg_ic-submenu {\n        ")).call(_context14, submenuIconSize, "\n    }\n    .tui-image-editor-container .tui-image-editor-controls-logo > img,\n    .tui-image-editor-container .tui-image-editor-header-logo > img {\n        ")).call(_context13, biSize, "\n    }\n    .tui-image-editor-menu use.normal.use-default,\n    .tui-image-editor-help-menu use.normal.use-default {\n        fill-rule: evenodd;\n        fill: ")).call(_context12, menuIconStyle.normal.color, ";\n        stroke: ")).call(_context11, menuIconStyle.normal.color, ";\n    }\n    .tui-image-editor-menu use.active.use-default,\n    .tui-image-editor-help-menu use.active.use-default {\n        fill-rule: evenodd;\n        fill: ")).call(_context10, menuIconStyle.active.color, ";\n        stroke: ")).call(_context9, menuIconStyle.active.color, ";\n    }\n    .tui-image-editor-menu use.hover.use-default,\n    .tui-image-editor-help-menu use.hover.use-default {\n        fill-rule: evenodd;\n        fill: ")).call(_context8, menuIconStyle.hover.color, ";\n        stroke: ")).call(_context7, menuIconStyle.hover.color, ";\n    }\n    .tui-image-editor-menu use.disabled.use-default,\n    .tui-image-editor-help-menu use.disabled.use-default {\n        fill-rule: evenodd;\n        fill: ")).call(_context6, menuIconStyle.disabled.color, ";\n        stroke: ")).call(_context5, menuIconStyle.disabled.color, ";\n    }\n    .tui-image-editor-submenu use.normal.use-default {\n        fill-rule: evenodd;\n        fill: ")).call(_context4, submenuIconStyle.normal.color, ";\n        stroke: ")).call(_context3, submenuIconStyle.normal.color, ";\n    }\n    .tui-image-editor-submenu use.active.use-default {\n        fill-rule: evenodd;\n        fill: ")).call(_context22, submenuIconStyle.active.color, ";\n        stroke: ")).call(_context2, submenuIconStyle.active.color, ";\n    }\n");
        };
        var standard = {
          "common.bi.image": "https://uicdn.toast.com/toastui/img/tui-image-editor-bi.png",
          "common.bisize.width": "251px",
          "common.bisize.height": "21px",
          "common.backgroundImage": "none",
          "common.backgroundColor": "#1e1e1e",
          "common.border": "0px",
          "header.backgroundImage": "none",
          "header.backgroundColor": "transparent",
          "header.border": "0px",
          "loadButton.backgroundColor": "#fff",
          "loadButton.border": "1px solid #ddd",
          "loadButton.color": "#222",
          "loadButton.fontFamily": "'Noto Sans', sans-serif",
          "loadButton.fontSize": "12px",
          "downloadButton.backgroundColor": "#fdba3b",
          "downloadButton.border": "1px solid #fdba3b",
          "downloadButton.color": "#fff",
          "downloadButton.fontFamily": "'Noto Sans', sans-serif",
          "downloadButton.fontSize": "12px",
          "menu.normalIcon.color": "#8a8a8a",
          "menu.activeIcon.color": "#555555",
          "menu.disabledIcon.color": "#434343",
          "menu.hoverIcon.color": "#e9e9e9",
          "submenu.normalIcon.color": "#8a8a8a",
          "submenu.activeIcon.color": "#e9e9e9",
          "menu.iconSize.width": "24px",
          "menu.iconSize.height": "24px",
          "submenu.iconSize.width": "32px",
          "submenu.iconSize.height": "32px",
          "submenu.backgroundColor": "#1e1e1e",
          "submenu.partition.color": "#3c3c3c",
          "submenu.normalLabel.color": "#8a8a8a",
          "submenu.normalLabel.fontWeight": "lighter",
          "submenu.activeLabel.color": "#fff",
          "submenu.activeLabel.fontWeight": "lighter",
          "checkbox.border": "0px",
          "checkbox.backgroundColor": "#fff",
          "range.pointer.color": "#fff",
          "range.bar.color": "#666",
          "range.subbar.color": "#d1d1d1",
          "range.disabledPointer.color": "#414141",
          "range.disabledBar.color": "#282828",
          "range.disabledSubbar.color": "#414141",
          "range.value.color": "#fff",
          "range.value.fontWeight": "lighter",
          "range.value.fontSize": "11px",
          "range.value.border": "1px solid #353535",
          "range.value.backgroundColor": "#151515",
          "range.title.color": "#fff",
          "range.title.fontWeight": "lighter",
          "colorpicker.button.border": "1px solid #1e1e1e",
          "colorpicker.title.color": "#fff"
        };
        var svg_default = __webpack_require__(2534);
        var Theme = /* @__PURE__ */ function() {
          function Theme2(customTheme) {
            _classCallCheck(this, Theme2);
            this.styles = this._changeToObject(extend_default()({}, standard, customTheme));
            styleLoad(this._styleMaker());
            this._loadDefaultSvgIcon();
          }
          _createClass(Theme2, [{
            key: "getStyle",
            value: function getStyle(type) {
              var result = null;
              var firstProperty = type.replace(/\..+$/, "");
              var option2 = this.styles[type];
              switch (type) {
                case "common.bi":
                  result = this.styles[type].image;
                  break;
                case "menu.icon":
                  result = {
                    active: this.styles["".concat(firstProperty, ".activeIcon")],
                    normal: this.styles["".concat(firstProperty, ".normalIcon")],
                    hover: this.styles["".concat(firstProperty, ".hoverIcon")],
                    disabled: this.styles["".concat(firstProperty, ".disabledIcon")]
                  };
                  break;
                case "submenu.icon":
                  result = {
                    active: this.styles["".concat(firstProperty, ".activeIcon")],
                    normal: this.styles["".concat(firstProperty, ".normalIcon")]
                  };
                  break;
                case "submenu.label":
                  result = {
                    active: this._makeCssText(this.styles["".concat(firstProperty, ".activeLabel")]),
                    normal: this._makeCssText(this.styles["".concat(firstProperty, ".normalLabel")])
                  };
                  break;
                case "submenu.partition":
                  result = {
                    vertical: this._makeCssText(extend_default()({}, option2, {
                      borderLeft: "1px solid ".concat(option2.color)
                    })),
                    horizontal: this._makeCssText(extend_default()({}, option2, {
                      borderBottom: "1px solid ".concat(option2.color)
                    }))
                  };
                  break;
                case "range.disabledPointer":
                case "range.disabledBar":
                case "range.disabledSubbar":
                case "range.pointer":
                case "range.bar":
                case "range.subbar":
                  option2.backgroundColor = option2.color;
                  result = this._makeCssText(option2);
                  break;
                default:
                  result = this._makeCssText(option2);
                  break;
              }
              return result;
            }
          }, {
            key: "_styleMaker",
            value: function _styleMaker() {
              var submenuLabelStyle = this.getStyle("submenu.label");
              var submenuPartitionStyle = this.getStyle("submenu.partition");
              return style({
                subMenuLabelActive: submenuLabelStyle.active,
                subMenuLabelNormal: submenuLabelStyle.normal,
                submenuPartitionVertical: submenuPartitionStyle.vertical,
                submenuPartitionHorizontal: submenuPartitionStyle.horizontal,
                biSize: this.getStyle("common.bisize"),
                subMenuRangeTitle: this.getStyle("range.title"),
                submenuRangePointer: this.getStyle("range.pointer"),
                submenuRangeBar: this.getStyle("range.bar"),
                submenuRangeSubbar: this.getStyle("range.subbar"),
                submenuDisabledRangePointer: this.getStyle("range.disabledPointer"),
                submenuDisabledRangeBar: this.getStyle("range.disabledBar"),
                submenuDisabledRangeSubbar: this.getStyle("range.disabledSubbar"),
                submenuRangeValue: this.getStyle("range.value"),
                submenuColorpickerTitle: this.getStyle("colorpicker.title"),
                submenuColorpickerButton: this.getStyle("colorpicker.button"),
                submenuCheckbox: this.getStyle("checkbox"),
                menuIconSize: this.getStyle("menu.iconSize"),
                submenuIconSize: this.getStyle("submenu.iconSize"),
                menuIconStyle: this.getStyle("menu.icon"),
                submenuIconStyle: this.getStyle("submenu.icon")
              });
            }
          }, {
            key: "_changeToObject",
            value: function _changeToObject(styleOptions) {
              var styleObject = {};
              forEach_default()(styleOptions, function(value, key) {
                var keyExplode = key.match(/^(.+)\.([a-z]+)$/i);
                var _keyExplode = _slicedToArray(keyExplode, 3), property = _keyExplode[1], subProperty = _keyExplode[2];
                if (!styleObject[property]) {
                  styleObject[property] = {};
                }
                styleObject[property][subProperty] = value;
              });
              return styleObject;
            }
          }, {
            key: "_makeCssText",
            value: function _makeCssText(styleObject) {
              var _this = this;
              var converterStack = [];
              forEach_default()(styleObject, function(value, key) {
                var _context2, _context22;
                if (index_of_default()(_context2 = ["backgroundImage"]).call(_context2, key) > -1 && value !== "none") {
                  value = "url(".concat(value, ")");
                }
                converterStack.push(concat_default()(_context22 = "".concat(_this._toUnderScore(key), ": ")).call(_context22, value));
              });
              return converterStack.join(";");
            }
          }, {
            key: "_toUnderScore",
            value: function _toUnderScore(targetString) {
              return targetString.replace(/([A-Z])/g, function($0, $1) {
                return "-".concat($1.toLowerCase());
              });
            }
          }, {
            key: "_loadDefaultSvgIcon",
            value: function _loadDefaultSvgIcon() {
              if (!document.getElementById("tui-image-editor-svg-default-icons")) {
                var parser = new DOMParser();
                var encodedURI = svg_default.replace(/data:image\/svg\+xml;base64,/, "");
                var dom = parser.parseFromString(atob(encodedURI), "text/xml");
                document.body.appendChild(dom.documentElement);
              }
            }
          }, {
            key: "_makeIconClassName",
            value: function _makeIconClassName(iconType, isSubmenu) {
              var iconStyleInfo = isSubmenu ? this.getStyle("submenu.icon") : this.getStyle("menu.icon");
              var _iconStyleInfo$iconTy = iconStyleInfo[iconType], path = _iconStyleInfo$iconTy.path, name2 = _iconStyleInfo$iconTy.name;
              return path && name2 ? iconType : "".concat(iconType, " use-default");
            }
          }, {
            key: "_makeSvgIconPrefix",
            value: function _makeSvgIconPrefix(iconType, isSubmenu) {
              var _context3;
              var iconStyleInfo = isSubmenu ? this.getStyle("submenu.icon") : this.getStyle("menu.icon");
              var _iconStyleInfo$iconTy2 = iconStyleInfo[iconType], path = _iconStyleInfo$iconTy2.path, name2 = _iconStyleInfo$iconTy2.name;
              return path && name2 ? concat_default()(_context3 = "".concat(path, "#")).call(_context3, name2, "-") : "#";
            }
          }, {
            key: "_makeSvgItem",
            value: function _makeSvgItem(useIconTypes, menuName, isSubmenu) {
              var _this2 = this;
              return map_default()(useIconTypes).call(useIconTypes, function(iconType) {
                var _context4, _context5;
                var svgIconPrefix = _this2._makeSvgIconPrefix(iconType, isSubmenu);
                var iconName = _this2._toUnderScore(menuName);
                var svgIconClassName = _this2._makeIconClassName(iconType, isSubmenu);
                return concat_default()(_context4 = concat_default()(_context5 = '<use xlink:href="'.concat(svgIconPrefix, "ic-")).call(_context5, iconName, '" class="')).call(_context4, svgIconClassName, '"/>');
              }).join("");
            }
          }, {
            key: "makeMenSvgIconSet",
            value: function makeMenSvgIconSet(useIconTypes, menuName) {
              var _context6;
              var isSubmenu = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
              return concat_default()(_context6 = '<svg class="svg_ic-'.concat(isSubmenu ? "submenu" : "menu", '">')).call(_context6, this._makeSvgItem(useIconTypes, menuName, isSubmenu), "</svg>");
            }
          }]);
          return Theme2;
        }();
        var theme = Theme;
        var construct = __webpack_require__(9146);
        var construct_default = /* @__PURE__ */ __webpack_require__.n(construct);
        var object_create = __webpack_require__(6623);
        var set_prototype_of = __webpack_require__(4230);
        function _setPrototypeOf(o, p) {
          _setPrototypeOf = set_prototype_of || function _setPrototypeOf2(o2, p2) {
            o2.__proto__ = p2;
            return o2;
          };
          return _setPrototypeOf(o, p);
        }
        function _inherits(subClass, superClass) {
          if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function");
          }
          subClass.prototype = object_create(superClass && superClass.prototype, {
            constructor: {
              value: subClass,
              writable: true,
              configurable: true
            }
          });
          if (superClass)
            _setPrototypeOf(subClass, superClass);
        }
        var iterator = __webpack_require__(3742);
        function _typeof2(obj) {
          "@babel/helpers - typeof";
          if (typeof symbol === "function" && typeof iterator === "symbol") {
            _typeof2 = function _typeof3(obj2) {
              return typeof obj2;
            };
          } else {
            _typeof2 = function _typeof3(obj2) {
              return obj2 && typeof symbol === "function" && obj2.constructor === symbol && obj2 !== symbol.prototype ? "symbol" : typeof obj2;
            };
          }
          return _typeof2(obj);
        }
        function _assertThisInitialized(self2) {
          if (self2 === void 0) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
          }
          return self2;
        }
        function _possibleConstructorReturn(self2, call) {
          if (call && (_typeof2(call) === "object" || typeof call === "function")) {
            return call;
          } else if (call !== void 0) {
            throw new TypeError("Derived constructors may only return object or undefined");
          }
          return _assertThisInitialized(self2);
        }
        var get_prototype_of = __webpack_require__(9856);
        function _getPrototypeOf(o) {
          _getPrototypeOf = set_prototype_of ? get_prototype_of : function _getPrototypeOf2(o2) {
            return o2.__proto__ || get_prototype_of(o2);
          };
          return _getPrototypeOf(o);
        }
        var forEachArray = __webpack_require__(6092);
        var forEachArray_default = /* @__PURE__ */ __webpack_require__.n(forEachArray);
        var external_commonjs_tui_color_picker_commonjs2_tui_color_picker_amd_tui_color_picker_root_tui_colorPicker_ = __webpack_require__(4858);
        var external_commonjs_tui_color_picker_commonjs2_tui_color_picker_amd_tui_color_picker_root_tui_colorPicker_default = /* @__PURE__ */ __webpack_require__.n(external_commonjs_tui_color_picker_commonjs2_tui_color_picker_amd_tui_color_picker_root_tui_colorPicker_);
        var PICKER_COLOR = ["#000000", "#2a2a2a", "#545454", "#7e7e7e", "#a8a8a8", "#d2d2d2", "#ffffff", "", "#ff4040", "#ff6518", "#ffbb3b", "#03bd9e", "#00a9ff", "#515ce6", "#9e5fff", "#ff5583"];
        var Colorpicker = /* @__PURE__ */ function() {
          function Colorpicker2(colorpickerElement, _ref) {
            var _ref$defaultColor = _ref.defaultColor, defaultColor = _ref$defaultColor === void 0 ? "#7e7e7e" : _ref$defaultColor, _ref$toggleDirection = _ref.toggleDirection, toggleDirection = _ref$toggleDirection === void 0 ? "up" : _ref$toggleDirection, usageStatistics = _ref.usageStatistics;
            _classCallCheck(this, Colorpicker2);
            this.colorpickerElement = colorpickerElement;
            this.usageStatistics = usageStatistics;
            this._show = false;
            this._colorpickerElement = colorpickerElement;
            this._toggleDirection = toggleDirection;
            this._makePickerButtonElement(defaultColor);
            this._makePickerLayerElement(colorpickerElement, colorpickerElement.getAttribute("title"));
            this._color = defaultColor;
            this.picker = external_commonjs_tui_color_picker_commonjs2_tui_color_picker_amd_tui_color_picker_root_tui_colorPicker_default().create({
              container: this.pickerElement,
              preset: PICKER_COLOR,
              color: defaultColor,
              usageStatistics: this.usageStatistics
            });
            this._addEvent();
          }
          _createClass(Colorpicker2, [{
            key: "destroy",
            value: function destroy2() {
              var _this = this;
              this._removeEvent();
              this.picker.destroy();
              this.colorpickerElement.innerHTML = "";
              forEach_default()(this, function(value, key) {
                _this[key] = null;
              });
            }
          }, {
            key: "color",
            get: function get() {
              return this._color;
            },
            set: function set(color2) {
              this._color = color2;
              this._changeColorElement(color2);
            }
          }, {
            key: "_changeColorElement",
            value: function _changeColorElement(color2) {
              if (color2) {
                this.colorElement.classList.remove("transparent");
                this.colorElement.style.backgroundColor = color2;
              } else {
                this.colorElement.style.backgroundColor = "#fff";
                this.colorElement.classList.add("transparent");
              }
            }
          }, {
            key: "_makePickerButtonElement",
            value: function _makePickerButtonElement(defaultColor) {
              this.colorpickerElement.classList.add("tui-image-editor-button");
              this.colorElement = document.createElement("div");
              this.colorElement.className = "color-picker-value";
              if (defaultColor) {
                this.colorElement.style.backgroundColor = defaultColor;
              } else {
                this.colorElement.classList.add("transparent");
              }
            }
          }, {
            key: "_makePickerLayerElement",
            value: function _makePickerLayerElement(colorpickerElement, title) {
              var label = document.createElement("label");
              var triangle = document.createElement("div");
              this.pickerControl = document.createElement("div");
              this.pickerControl.className = "color-picker-control";
              this.pickerElement = document.createElement("div");
              this.pickerElement.className = "color-picker";
              label.innerHTML = title;
              triangle.className = "triangle";
              this.pickerControl.appendChild(this.pickerElement);
              this.pickerControl.appendChild(triangle);
              colorpickerElement.appendChild(this.pickerControl);
              colorpickerElement.appendChild(this.colorElement);
              colorpickerElement.appendChild(label);
            }
          }, {
            key: "_addEvent",
            value: function _addEvent() {
              var _this2 = this, _context2;
              this.picker.on("selectColor", function(value) {
                _this2._changeColorElement(value.color);
                _this2._color = value.color;
                _this2.fire("change", value.color);
              });
              this.eventHandler = {
                pickerToggle: bind_default()(_context2 = this._pickerToggleEventHandler).call(_context2, this),
                pickerHide: function pickerHide() {
                  return _this2.hide();
                }
              };
              this.colorpickerElement.addEventListener("click", this.eventHandler.pickerToggle);
              document.body.addEventListener("click", this.eventHandler.pickerHide);
            }
          }, {
            key: "_removeEvent",
            value: function _removeEvent() {
              this.colorpickerElement.removeEventListener("click", this.eventHandler.pickerToggle);
              document.body.removeEventListener("click", this.eventHandler.pickerHide);
              this.picker.off();
            }
          }, {
            key: "_pickerToggleEventHandler",
            value: function _pickerToggleEventHandler(event) {
              var target = event.target;
              var isInPickerControl = target && this._isElementInColorPickerControl(target);
              if (!isInPickerControl || isInPickerControl && this._isPaletteButton(target)) {
                this._show = !this._show;
                this.pickerControl.style.display = this._show ? "block" : "none";
                this._setPickerControlPosition();
                this.fire("changeShow", this);
              }
              event.stopPropagation();
            }
          }, {
            key: "_isPaletteButton",
            value: function _isPaletteButton(target) {
              return target.className === "tui-colorpicker-palette-button";
            }
          }, {
            key: "_isElementInColorPickerControl",
            value: function _isElementInColorPickerControl(element) {
              var parentNode = element;
              while (parentNode !== document.body) {
                if (!parentNode) {
                  break;
                }
                if (parentNode === this.pickerControl) {
                  return true;
                }
                parentNode = parentNode.parentNode;
              }
              return false;
            }
          }, {
            key: "hide",
            value: function hide() {
              this._show = false;
              this.pickerControl.style.display = "none";
            }
          }, {
            key: "_setPickerControlPosition",
            value: function _setPickerControlPosition() {
              var controlStyle = this.pickerControl.style;
              var halfPickerWidth = this._colorpickerElement.clientWidth / 2 + 2;
              var left = this.pickerControl.offsetWidth / 2 - halfPickerWidth;
              var top = (this.pickerControl.offsetHeight + 10) * -1;
              if (this._toggleDirection === "down") {
                top = 30;
              }
              controlStyle.top = "".concat(top, "px");
              controlStyle.left = "-".concat(left, "px");
            }
          }]);
          return Colorpicker2;
        }();
        customEvents_default().mixin(Colorpicker);
        var colorpicker = Colorpicker;
        var INPUT_FILTER_REGEXP = /(-?)([0-9]*)[^0-9]*([0-9]*)/g;
        var Range = /* @__PURE__ */ function() {
          function Range2(rangeElements) {
            var _context2, _context22, _context3, _context4, _context5, _context6, _context7;
            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
            _classCallCheck(this, Range2);
            this._value = options.value || 0;
            this.rangeElement = rangeElements.slider;
            this.rangeInputElement = rangeElements.input;
            this._drawRangeElement();
            this.rangeWidth = this._getRangeWidth();
            this._min = options.min || 0;
            this._max = options.max || 100;
            this._useDecimal = options.useDecimal;
            this._absMax = this._min * -1 + this._max;
            this.realTimeEvent = options.realTimeEvent || false;
            this._userInputTimer = null;
            this.eventHandler = {
              startChangingSlide: bind_default()(_context2 = this._startChangingSlide).call(_context2, this),
              stopChangingSlide: bind_default()(_context22 = this._stopChangingSlide).call(_context22, this),
              changeSlide: bind_default()(_context3 = this._changeSlide).call(_context3, this),
              changeSlideFinally: bind_default()(_context4 = this._changeSlideFinally).call(_context4, this),
              changeInput: bind_default()(_context5 = this._changeInput).call(_context5, this),
              changeInputFinally: bind_default()(_context6 = this._changeValueWithInput).call(_context6, this, true),
              changeInputWithArrow: bind_default()(_context7 = this._changeValueWithInputKeyEvent).call(_context7, this)
            };
            this._addClickEvent();
            this._addDragEvent();
            this._addInputEvent();
            this.value = options.value;
            this.trigger("change");
          }
          _createClass(Range2, [{
            key: "destroy",
            value: function destroy2() {
              var _this = this;
              this._removeClickEvent();
              this._removeDragEvent();
              this._removeInputEvent();
              this.rangeElement.innerHTML = "";
              forEach_default()(this, function(value, key) {
                _this[key] = null;
              });
            }
          }, {
            key: "max",
            get: function get() {
              return this._max;
            },
            set: function set(maxValue) {
              this._max = maxValue;
              this._absMax = this._min * -1 + this._max;
              this.value = this._value;
            }
          }, {
            key: "min",
            get: function get() {
              return this._min;
            },
            set: function set(minValue) {
              this._min = minValue;
              this.max = this._max;
            }
          }, {
            key: "value",
            get: function get() {
              return this._value;
            },
            set: function set(value) {
              value = this._useDecimal ? value : toInteger(value);
              var absValue = value - this._min;
              var leftPosition = absValue * this.rangeWidth / this._absMax;
              if (this.rangeWidth < leftPosition) {
                leftPosition = this.rangeWidth;
              }
              this.pointer.style.left = "".concat(leftPosition, "px");
              this.subbar.style.right = "".concat(this.rangeWidth - leftPosition, "px");
              this._value = value;
              if (this.rangeInputElement) {
                this.rangeInputElement.value = value;
              }
            }
          }, {
            key: "trigger",
            value: function trigger(type) {
              this.fire(type, this._value);
            }
          }, {
            key: "_getRangeWidth",
            value: function _getRangeWidth() {
              var getElementWidth = function getElementWidth2(element) {
                return toInteger(window.getComputedStyle(element, null).width);
              };
              return getElementWidth(this.rangeElement) - getElementWidth(this.pointer);
            }
          }, {
            key: "_drawRangeElement",
            value: function _drawRangeElement() {
              this.rangeElement.classList.add("tui-image-editor-range");
              this.bar = document.createElement("div");
              this.bar.className = "tui-image-editor-virtual-range-bar";
              this.subbar = document.createElement("div");
              this.subbar.className = "tui-image-editor-virtual-range-subbar";
              this.pointer = document.createElement("div");
              this.pointer.className = "tui-image-editor-virtual-range-pointer";
              this.bar.appendChild(this.subbar);
              this.bar.appendChild(this.pointer);
              this.rangeElement.appendChild(this.bar);
            }
          }, {
            key: "_addInputEvent",
            value: function _addInputEvent() {
              if (this.rangeInputElement) {
                this.rangeInputElement.addEventListener("keydown", this.eventHandler.changeInputWithArrow);
                this.rangeInputElement.addEventListener("keydown", this.eventHandler.changeInput);
                this.rangeInputElement.addEventListener("blur", this.eventHandler.changeInputFinally);
              }
            }
          }, {
            key: "_removeInputEvent",
            value: function _removeInputEvent() {
              if (this.rangeInputElement) {
                this.rangeInputElement.removeEventListener("keydown", this.eventHandler.changeInputWithArrow);
                this.rangeInputElement.removeEventListener("keydown", this.eventHandler.changeInput);
                this.rangeInputElement.removeEventListener("blur", this.eventHandler.changeInputFinally);
              }
            }
          }, {
            key: "_changeValueWithInputKeyEvent",
            value: function _changeValueWithInputKeyEvent(event) {
              var _context8;
              var keyCode = event.keyCode, target = event.target;
              if (index_of_default()(_context8 = [keyCodes.ARROW_UP, keyCodes.ARROW_DOWN]).call(_context8, keyCode) < 0) {
                return;
              }
              var value = Number(target.value);
              value = this._valueUpDownForKeyEvent(value, keyCode);
              var unChanged = value < this._min || value > this._max;
              if (!unChanged) {
                var clampValue = clamp(value, this._min, this.max);
                this.value = clampValue;
                this.fire("change", clampValue, false);
              }
            }
          }, {
            key: "_valueUpDownForKeyEvent",
            value: function _valueUpDownForKeyEvent(value, keyCode) {
              var step = this._useDecimal ? 0.1 : 1;
              if (keyCode === keyCodes.ARROW_UP) {
                value += step;
              } else if (keyCode === keyCodes.ARROW_DOWN) {
                value -= step;
              }
              return value;
            }
          }, {
            key: "_changeInput",
            value: function _changeInput(event) {
              var _this2 = this;
              clearTimeout(this._userInputTimer);
              var keyCode = event.keyCode;
              if (keyCode < keyCodes.DIGIT_0 || keyCode > keyCodes.DIGIT_9) {
                event.preventDefault();
                return;
              }
              this._userInputTimer = set_timeout_default()(function() {
                _this2._inputSetValue(event.target.value);
              }, 350);
            }
          }, {
            key: "_inputSetValue",
            value: function _inputSetValue(stringValue) {
              var value = this._useDecimal ? Number(stringValue) : toInteger(stringValue);
              value = clamp(value, this._min, this.max);
              this.value = value;
              this.fire("change", value, true);
            }
          }, {
            key: "_changeValueWithInput",
            value: function _changeValueWithInput(isLast, event) {
              var _context9;
              var keyCode = event.keyCode, target = event.target;
              if (index_of_default()(_context9 = [keyCodes.ARROW_UP, keyCodes.ARROW_DOWN]).call(_context9, keyCode) >= 0) {
                return;
              }
              var stringValue = this._filterForInputText(target.value);
              var waitForChange = !stringValue || isNaN(stringValue);
              target.value = stringValue;
              if (!waitForChange) {
                this._inputSetValue(stringValue);
              }
            }
          }, {
            key: "_addClickEvent",
            value: function _addClickEvent() {
              this.rangeElement.addEventListener("click", this.eventHandler.changeSlideFinally);
            }
          }, {
            key: "_removeClickEvent",
            value: function _removeClickEvent() {
              this.rangeElement.removeEventListener("click", this.eventHandler.changeSlideFinally);
            }
          }, {
            key: "_addDragEvent",
            value: function _addDragEvent() {
              this.pointer.addEventListener("mousedown", this.eventHandler.startChangingSlide);
            }
          }, {
            key: "_removeDragEvent",
            value: function _removeDragEvent() {
              this.pointer.removeEventListener("mousedown", this.eventHandler.startChangingSlide);
            }
          }, {
            key: "_changeSlide",
            value: function _changeSlide(event) {
              var changePosition = event.screenX;
              var diffPosition = changePosition - this.firstPosition;
              var touchPx = this.firstLeft + diffPosition;
              touchPx = touchPx > this.rangeWidth ? this.rangeWidth : touchPx;
              touchPx = touchPx < 0 ? 0 : touchPx;
              this.pointer.style.left = "".concat(touchPx, "px");
              this.subbar.style.right = "".concat(this.rangeWidth - touchPx, "px");
              var ratio = touchPx / this.rangeWidth;
              var resultValue = this._absMax * ratio + this._min;
              var value = this._useDecimal ? resultValue : toInteger(resultValue);
              var isValueChanged = this.value !== value;
              if (isValueChanged) {
                this.value = value;
                if (this.realTimeEvent) {
                  this.fire("change", this._value, false);
                }
              }
            }
          }, {
            key: "_changeSlideFinally",
            value: function _changeSlideFinally(event) {
              event.stopPropagation();
              if (event.target.className !== "tui-image-editor-range") {
                return;
              }
              var touchPx = event.offsetX;
              var ratio = touchPx / this.rangeWidth;
              var value = this._absMax * ratio + this._min;
              this.pointer.style.left = "".concat(ratio * this.rangeWidth, "px");
              this.subbar.style.right = "".concat((1 - ratio) * this.rangeWidth, "px");
              this.value = value;
              this.fire("change", value, true);
            }
          }, {
            key: "_startChangingSlide",
            value: function _startChangingSlide(event) {
              this.firstPosition = event.screenX;
              this.firstLeft = toInteger(this.pointer.style.left) || 0;
              document.addEventListener("mousemove", this.eventHandler.changeSlide);
              document.addEventListener("mouseup", this.eventHandler.stopChangingSlide);
            }
          }, {
            key: "_stopChangingSlide",
            value: function _stopChangingSlide() {
              this.fire("change", this._value, true);
              document.removeEventListener("mousemove", this.eventHandler.changeSlide);
              document.removeEventListener("mouseup", this.eventHandler.stopChangingSlide);
            }
          }, {
            key: "_filterForInputText",
            value: function _filterForInputText(inputValue) {
              return inputValue.replace(INPUT_FILTER_REGEXP, "$1$2$3");
            }
          }]);
          return Range2;
        }();
        customEvents_default().mixin(Range);
        var range = Range;
        var Submenu = /* @__PURE__ */ function() {
          function Submenu2(subMenuElement, _ref) {
            var locale2 = _ref.locale, name2 = _ref.name, makeSvgIcon = _ref.makeSvgIcon, menuBarPosition = _ref.menuBarPosition, templateHtml = _ref.templateHtml, usageStatistics = _ref.usageStatistics;
            _classCallCheck(this, Submenu2);
            this.subMenuElement = subMenuElement;
            this.menuBarPosition = menuBarPosition;
            this.toggleDirection = menuBarPosition === "top" ? "down" : "up";
            this.colorPickerControls = [];
            this.usageStatistics = usageStatistics;
            this.eventHandler = {};
            this._makeSubMenuElement({
              locale: locale2,
              name: name2,
              makeSvgIcon,
              templateHtml
            });
          }
          _createClass(Submenu2, [{
            key: "selector",
            value: function selector(selectName) {
              return this.subMenuElement.querySelector(selectName);
            }
          }, {
            key: "colorPickerChangeShow",
            value: function colorPickerChangeShow(occurredControl) {
              var _context2;
              for_each_default()(_context2 = this.colorPickerControls).call(_context2, function(pickerControl) {
                if (occurredControl !== pickerControl) {
                  pickerControl.hide();
                }
              });
            }
          }, {
            key: "getButtonType",
            value: function getButtonType(button, buttonNames) {
              return button.className.match(RegExp("(".concat(buttonNames.join("|"), ")")))[0];
            }
          }, {
            key: "changeClass",
            value: function changeClass(target, removeClass2, addClass2) {
              target.classList.remove(removeClass2);
              target.classList.add(addClass2);
            }
          }, {
            key: "changeStandbyMode",
            value: function changeStandbyMode() {
            }
          }, {
            key: "changeStartMode",
            value: function changeStartMode() {
            }
          }, {
            key: "_makeSubMenuElement",
            value: function _makeSubMenuElement(_ref2) {
              var locale2 = _ref2.locale, name2 = _ref2.name, iconStyle = _ref2.iconStyle, makeSvgIcon = _ref2.makeSvgIcon, templateHtml = _ref2.templateHtml;
              var iconSubMenu = document.createElement("div");
              iconSubMenu.className = "tui-image-editor-menu-".concat(name2);
              iconSubMenu.innerHTML = templateHtml({
                locale: locale2,
                iconStyle,
                makeSvgIcon
              });
              this.subMenuElement.appendChild(iconSubMenu);
            }
          }, {
            key: "_onStartEditingInputBox",
            value: function _onStartEditingInputBox() {
              this.fire(eventNames.INPUT_BOX_EDITING_STARTED);
            }
          }, {
            key: "_onStopEditingInputBox",
            value: function _onStopEditingInputBox() {
              this.fire(eventNames.INPUT_BOX_EDITING_STOPPED);
            }
          }]);
          return Submenu2;
        }();
        customEvents_default().mixin(Submenu);
        var submenuBase = Submenu;
        var shape = function(_ref) {
          var _context2, _context22, _context3, _context4, _context5, _context6, _context7, _context8;
          var locale2 = _ref.locale, makeSvgIcon = _ref.makeSvgIcon;
          return concat_default()(_context2 = concat_default()(_context22 = concat_default()(_context3 = concat_default()(_context4 = concat_default()(_context5 = concat_default()(_context6 = concat_default()(_context7 = concat_default()(_context8 = '\n    <ul class="tui-image-editor-submenu-item">\n        <li class="tie-shape-button">\n            <div class="tui-image-editor-button rect">\n                <div>\n                    '.concat(makeSvgIcon(["normal", "active"], "shape-rectangle", true), "\n                </div>\n                <label> ")).call(_context8, locale2.localize("Rectangle"), ' </label>\n            </div>\n            <div class="tui-image-editor-button circle">\n                <div>\n                    ')).call(_context7, makeSvgIcon(["normal", "active"], "shape-circle", true), "\n                </div>\n                <label> ")).call(_context6, locale2.localize("Circle"), ' </label>\n            </div>\n            <div class="tui-image-editor-button triangle">\n                <div>\n                    ')).call(_context5, makeSvgIcon(["normal", "active"], "shape-triangle", true), "\n                </div>\n                <label> ")).call(_context4, locale2.localize("Triangle"), ' </label>\n            </div>\n        </li>\n        <li class="tui-image-editor-partition">\n            <div></div>\n        </li>\n        <li class="tie-shape-color-button">\n            <div class="tie-color-fill" title="')).call(_context3, locale2.localize("Fill"), '"></div>\n            <div class="tie-color-stroke" title="')).call(_context22, locale2.localize("Stroke"), '"></div>\n        </li>\n        <li class="tui-image-editor-partition only-left-right">\n            <div></div>\n        </li>\n        <li class="tui-image-editor-newline tui-image-editor-range-wrap">\n            <label class="range">')).call(_context2, locale2.localize("Stroke"), '</label>\n            <div class="tie-stroke-range"></div>\n            <input class="tie-stroke-range-value tui-image-editor-range-value" value="0" />\n        </li>\n    </ul>\n');
        };
        function _createSuper(Derived) {
          var hasNativeReflectConstruct = _isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function _isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var SHAPE_DEFAULT_OPTION = {
          stroke: "#ffbb3b",
          fill: "",
          strokeWidth: 3
        };
        var Shape = /* @__PURE__ */ function(_Submenu) {
          _inherits(Shape2, _Submenu);
          var _super = _createSuper(Shape2);
          function Shape2(subMenuElement, _ref) {
            var _this;
            var locale2 = _ref.locale, makeSvgIcon = _ref.makeSvgIcon, menuBarPosition = _ref.menuBarPosition, usageStatistics = _ref.usageStatistics;
            _classCallCheck(this, Shape2);
            _this = _super.call(this, subMenuElement, {
              locale: locale2,
              name: "shape",
              makeSvgIcon,
              menuBarPosition,
              templateHtml: shape,
              usageStatistics
            });
            _this.type = null;
            _this.options = SHAPE_DEFAULT_OPTION;
            _this._els = {
              shapeSelectButton: _this.selector(".tie-shape-button"),
              shapeColorButton: _this.selector(".tie-shape-color-button"),
              strokeRange: new range({
                slider: _this.selector(".tie-stroke-range"),
                input: _this.selector(".tie-stroke-range-value")
              }, defaultShapeStrokeValues),
              fillColorpicker: new colorpicker(_this.selector(".tie-color-fill"), {
                defaultColor: "",
                toggleDirection: _this.toggleDirection,
                usageStatistics: _this.usageStatistics
              }),
              strokeColorpicker: new colorpicker(_this.selector(".tie-color-stroke"), {
                defaultColor: "#ffbb3b",
                toggleDirection: _this.toggleDirection,
                usageStatistics: _this.usageStatistics
              })
            };
            _this.colorPickerControls.push(_this._els.fillColorpicker);
            _this.colorPickerControls.push(_this._els.strokeColorpicker);
            _this.colorPickerInputBoxes = [];
            _this.colorPickerInputBoxes.push(_this._els.fillColorpicker.colorpickerElement.querySelector(selectorNames.COLOR_PICKER_INPUT_BOX));
            _this.colorPickerInputBoxes.push(_this._els.strokeColorpicker.colorpickerElement.querySelector(selectorNames.COLOR_PICKER_INPUT_BOX));
            return _this;
          }
          _createClass(Shape2, [{
            key: "destroy",
            value: function destroy2() {
              this._removeEvent();
              this._els.strokeRange.destroy();
              this._els.fillColorpicker.destroy();
              this._els.strokeColorpicker.destroy();
              assignmentForDestroy(this);
            }
          }, {
            key: "addEvent",
            value: function addEvent2(actions2) {
              var _context2, _context22, _context3, _context4, _context5, _context6, _this2 = this;
              this.eventHandler.shapeTypeSelected = bind_default()(_context2 = this._changeShapeHandler).call(_context2, this);
              this.actions = actions2;
              this._els.shapeSelectButton.addEventListener("click", this.eventHandler.shapeTypeSelected);
              this._els.strokeRange.on("change", bind_default()(_context22 = this._changeStrokeRangeHandler).call(_context22, this));
              this._els.fillColorpicker.on("change", bind_default()(_context3 = this._changeFillColorHandler).call(_context3, this));
              this._els.strokeColorpicker.on("change", bind_default()(_context4 = this._changeStrokeColorHandler).call(_context4, this));
              this._els.fillColorpicker.on("changeShow", bind_default()(_context5 = this.colorPickerChangeShow).call(_context5, this));
              this._els.strokeColorpicker.on("changeShow", bind_default()(_context6 = this.colorPickerChangeShow).call(_context6, this));
              forEachArray_default()(this.colorPickerInputBoxes, function(inputBox) {
                var _context7, _context8;
                inputBox.addEventListener(eventNames.FOCUS, bind_default()(_context7 = _this2._onStartEditingInputBox).call(_context7, _this2));
                inputBox.addEventListener(eventNames.BLUR, bind_default()(_context8 = _this2._onStopEditingInputBox).call(_context8, _this2));
              }, this);
            }
          }, {
            key: "_removeEvent",
            value: function _removeEvent() {
              var _this3 = this;
              this._els.shapeSelectButton.removeEventListener("click", this.eventHandler.shapeTypeSelected);
              this._els.strokeRange.off();
              this._els.fillColorpicker.off();
              this._els.strokeColorpicker.off();
              forEachArray_default()(this.colorPickerInputBoxes, function(inputBox) {
                var _context9, _context10;
                inputBox.removeEventListener(eventNames.FOCUS, bind_default()(_context9 = _this3._onStartEditingInputBox).call(_context9, _this3));
                inputBox.removeEventListener(eventNames.BLUR, bind_default()(_context10 = _this3._onStopEditingInputBox).call(_context10, _this3));
              }, this);
            }
          }, {
            key: "setShapeStatus",
            value: function setShapeStatus(_ref2) {
              var strokeWidth = _ref2.strokeWidth, strokeColor = _ref2.strokeColor, fillColor = _ref2.fillColor;
              this._els.strokeRange.value = strokeWidth;
              this._els.strokeColorpicker.color = strokeColor;
              this._els.fillColorpicker.color = fillColor;
              this.options.stroke = strokeColor;
              this.options.fill = fillColor;
              this.options.strokeWidth = strokeWidth;
              this.actions.setDrawingShape(this.type, {
                strokeWidth
              });
            }
          }, {
            key: "changeStartMode",
            value: function changeStartMode() {
              this.actions.stopDrawingMode();
            }
          }, {
            key: "changeStandbyMode",
            value: function changeStandbyMode() {
              this.type = null;
              this.actions.changeSelectableAll(true);
              this._els.shapeSelectButton.classList.remove("circle");
              this._els.shapeSelectButton.classList.remove("triangle");
              this._els.shapeSelectButton.classList.remove("rect");
            }
          }, {
            key: "setMaxStrokeValue",
            value: function setMaxStrokeValue(maxValue) {
              var strokeMaxValue = maxValue;
              if (strokeMaxValue <= 0) {
                strokeMaxValue = defaultShapeStrokeValues.max;
              }
              this._els.strokeRange.max = strokeMaxValue;
            }
          }, {
            key: "setStrokeValue",
            value: function setStrokeValue(value) {
              this._els.strokeRange.value = value;
              this._els.strokeRange.trigger("change");
            }
          }, {
            key: "getStrokeValue",
            value: function getStrokeValue() {
              return this._els.strokeRange.value;
            }
          }, {
            key: "_changeShapeHandler",
            value: function _changeShapeHandler(event) {
              var button = event.target.closest(".tui-image-editor-button");
              if (button) {
                this.actions.stopDrawingMode();
                this.actions.discardSelection();
                var shapeType = this.getButtonType(button, ["circle", "triangle", "rect"]);
                if (this.type === shapeType) {
                  this.changeStandbyMode();
                  return;
                }
                this.changeStandbyMode();
                this.type = shapeType;
                event.currentTarget.classList.add(shapeType);
                this.actions.changeSelectableAll(false);
                this.actions.modeChange("shape");
              }
            }
          }, {
            key: "_changeStrokeRangeHandler",
            value: function _changeStrokeRangeHandler(value, isLast) {
              this.options.strokeWidth = toInteger(value);
              this.actions.changeShape({
                strokeWidth: value
              }, !isLast);
              this.actions.setDrawingShape(this.type, this.options);
            }
          }, {
            key: "_changeFillColorHandler",
            value: function _changeFillColorHandler(color2) {
              color2 = color2 || "transparent";
              this.options.fill = color2;
              this.actions.changeShape({
                fill: color2
              });
            }
          }, {
            key: "_changeStrokeColorHandler",
            value: function _changeStrokeColorHandler(color2) {
              color2 = color2 || "transparent";
              this.options.stroke = color2;
              this.actions.changeShape({
                stroke: color2
              });
            }
          }]);
          return Shape2;
        }(submenuBase);
        var ui_shape = Shape;
        var crop = function(_ref) {
          var _context2, _context22, _context3, _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13, _context14, _context15, _context16, _context17;
          var locale2 = _ref.locale, makeSvgIcon = _ref.makeSvgIcon;
          return concat_default()(_context2 = concat_default()(_context22 = concat_default()(_context3 = concat_default()(_context4 = concat_default()(_context5 = concat_default()(_context6 = concat_default()(_context7 = concat_default()(_context8 = concat_default()(_context9 = concat_default()(_context10 = concat_default()(_context11 = concat_default()(_context12 = concat_default()(_context13 = concat_default()(_context14 = concat_default()(_context15 = concat_default()(_context16 = concat_default()(_context17 = '\n    <ul class="tui-image-editor-submenu-item">\n        <li class="tie-crop-preset-button">\n            <div class="tui-image-editor-button preset preset-none active">\n                <div>\n                    '.concat(makeSvgIcon(["normal", "active"], "shape-rectangle", true), "\n                </div>\n                <label> ")).call(_context17, locale2.localize("Custom"), ' </label>\n            </div>\n            <div class="tui-image-editor-button preset preset-square">\n                <div>\n                    ')).call(_context16, makeSvgIcon(["normal", "active"], "crop", true), "\n                </div>\n                <label> ")).call(_context15, locale2.localize("Square"), ' </label>\n            </div>\n            <div class="tui-image-editor-button preset preset-3-2">\n                <div>\n                    ')).call(_context14, makeSvgIcon(["normal", "active"], "crop", true), "\n                </div>\n                <label> ")).call(_context13, locale2.localize("3:2"), ' </label>\n            </div>\n            <div class="tui-image-editor-button preset preset-4-3">\n                <div>\n                    ')).call(_context12, makeSvgIcon(["normal", "active"], "crop", true), "\n                </div>\n                <label> ")).call(_context11, locale2.localize("4:3"), ' </label>\n            </div>\n            <div class="tui-image-editor-button preset preset-5-4">\n                <div>\n                    ')).call(_context10, makeSvgIcon(["normal", "active"], "crop", true), "\n                </div>\n                <label> ")).call(_context9, locale2.localize("5:4"), ' </label>\n            </div>\n            <div class="tui-image-editor-button preset preset-7-5">\n                <div>\n                    ')).call(_context8, makeSvgIcon(["normal", "active"], "crop", true), "\n                </div>\n                <label> ")).call(_context7, locale2.localize("7:5"), ' </label>\n            </div>\n            <div class="tui-image-editor-button preset preset-16-9">\n                <div>\n                    ')).call(_context6, makeSvgIcon(["normal", "active"], "crop", true), "\n                </div>\n                <label> ")).call(_context5, locale2.localize("16:9"), ' </label>\n            </div>\n        </li>\n        <li class="tui-image-editor-partition tui-image-editor-newline">\n        </li>\n        <li class="tui-image-editor-partition only-left-right">\n            <div></div>\n        </li>\n        <li class="tie-crop-button action">\n            <div class="tui-image-editor-button apply">\n                ')).call(_context4, makeSvgIcon(["normal", "active"], "apply"), "\n                <label>\n                    ")).call(_context3, locale2.localize("Apply"), '\n                </label>\n            </div>\n            <div class="tui-image-editor-button cancel">\n                ')).call(_context22, makeSvgIcon(["normal", "active"], "cancel"), "\n                <label>\n                    ")).call(_context2, locale2.localize("Cancel"), "\n                </label>\n            </div>\n        </li>\n    </ul>\n");
        };
        function crop_createSuper(Derived) {
          var hasNativeReflectConstruct = crop_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function crop_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var Crop = /* @__PURE__ */ function(_Submenu) {
          _inherits(Crop2, _Submenu);
          var _super = crop_createSuper(Crop2);
          function Crop2(subMenuElement, _ref) {
            var _this;
            var locale2 = _ref.locale, makeSvgIcon = _ref.makeSvgIcon, menuBarPosition = _ref.menuBarPosition, usageStatistics = _ref.usageStatistics;
            _classCallCheck(this, Crop2);
            _this = _super.call(this, subMenuElement, {
              locale: locale2,
              name: "crop",
              makeSvgIcon,
              menuBarPosition,
              templateHtml: crop,
              usageStatistics
            });
            _this.status = "active";
            _this._els = {
              apply: _this.selector(".tie-crop-button .apply"),
              cancel: _this.selector(".tie-crop-button .cancel"),
              preset: _this.selector(".tie-crop-preset-button")
            };
            _this.defaultPresetButton = _this._els.preset.querySelector(".preset-none");
            return _this;
          }
          _createClass(Crop2, [{
            key: "destroy",
            value: function destroy2() {
              this._removeEvent();
              assignmentForDestroy(this);
            }
          }, {
            key: "addEvent",
            value: function addEvent2(actions2) {
              var _context2, _context22, _context3;
              var apply = bind_default()(_context2 = this._applyEventHandler).call(_context2, this);
              var cancel = bind_default()(_context22 = this._cancelEventHandler).call(_context22, this);
              var cropzonePreset = bind_default()(_context3 = this._cropzonePresetEventHandler).call(_context3, this);
              this.eventHandler = {
                apply,
                cancel,
                cropzonePreset
              };
              this.actions = actions2;
              this._els.apply.addEventListener("click", apply);
              this._els.cancel.addEventListener("click", cancel);
              this._els.preset.addEventListener("click", cropzonePreset);
            }
          }, {
            key: "_removeEvent",
            value: function _removeEvent() {
              this._els.apply.removeEventListener("click", this.eventHandler.apply);
              this._els.cancel.removeEventListener("click", this.eventHandler.cancel);
              this._els.preset.removeEventListener("click", this.eventHandler.cropzonePreset);
            }
          }, {
            key: "_applyEventHandler",
            value: function _applyEventHandler() {
              this.actions.crop();
              this._els.apply.classList.remove("active");
            }
          }, {
            key: "_cancelEventHandler",
            value: function _cancelEventHandler() {
              this.actions.cancel();
              this._els.apply.classList.remove("active");
            }
          }, {
            key: "_cropzonePresetEventHandler",
            value: function _cropzonePresetEventHandler(event) {
              var button = event.target.closest(".tui-image-editor-button.preset");
              if (button) {
                var _button$className$mat = button.className.match(/preset-[^\s]+/), _button$className$mat2 = _slicedToArray(_button$className$mat, 1), presetType = _button$className$mat2[0];
                this._setPresetButtonActive(button);
                this.actions.preset(presetType);
              }
            }
          }, {
            key: "changeStartMode",
            value: function changeStartMode() {
              this.actions.modeChange("crop");
            }
          }, {
            key: "changeStandbyMode",
            value: function changeStandbyMode() {
              this.actions.stopDrawingMode();
              this._setPresetButtonActive();
            }
          }, {
            key: "changeApplyButtonStatus",
            value: function changeApplyButtonStatus(enableStatus) {
              if (enableStatus) {
                this._els.apply.classList.add("active");
              } else {
                this._els.apply.classList.remove("active");
              }
            }
          }, {
            key: "_setPresetButtonActive",
            value: function _setPresetButtonActive() {
              var button = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.defaultPresetButton;
              forEach_default()(this._els.preset.querySelectorAll(".preset"), function(presetButton) {
                presetButton.classList.remove("active");
              });
              if (button) {
                button.classList.add("active");
              }
            }
          }]);
          return Crop2;
        }(submenuBase);
        var ui_crop = Crop;
        var resize = function(_ref) {
          var _context2, _context22, _context3, _context4, _context5, _context6;
          var locale2 = _ref.locale, makeSvgIcon = _ref.makeSvgIcon;
          return concat_default()(_context2 = concat_default()(_context22 = concat_default()(_context3 = concat_default()(_context4 = concat_default()(_context5 = concat_default()(_context6 = '\n    <ul class="tui-image-editor-submenu-item">\n        <li class="tui-image-editor-submenu-align">\n            <div class="tui-image-editor-range-wrap tui-image-editor-newline">\n                <label class="range">'.concat(locale2.localize("Width"), '&nbsp;</label>\n                <div class="tie-width-range"></div>\n                <input class="tie-width-range-value tui-image-editor-range-value" value="0" /> <label>px</label>\n                <div class="tui-image-editor-partition tui-image-editor-newline"></div>\n                <label class="range">')).call(_context6, locale2.localize("Height"), '</label>\n                <div class="tie-height-range"></div>\n                <input class="tie-height-range-value tui-image-editor-range-value" value="0" /> <label>px</label>\n            </div>\n        </li>\n        <li class="tui-image-editor-partition tui-image-editor-newline"></li>\n        <li class="tui-image-editor-partition only-left-right">\n            <div></div>\n        </li>\n        <li class="tui-image-editor-submenu-align">\n            <div class="tui-image-editor-checkbox-wrap">\n                <div class="tui-image-editor-checkbox">\n                    <label>\n                        <input type="checkbox" class="tie-lock-aspect-ratio">\n                        <span>')).call(_context5, locale2.localize("Lock Aspect Ratio"), '</span>\n                    </label>\n                </div>\n            </div>\n        </li>\n        <li class="tui-image-editor-partition tui-image-editor-newline"></li>\n        <li class="tui-image-editor-partition only-left-right">\n            <div></div>\n        </li>\n        <li class="tui-image-editor-partition tui-image-editor-newline"></li>\n        <li class="tie-resize-button action">\n            <div class="tui-image-editor-button apply">\n                ')).call(_context4, makeSvgIcon(["normal", "active"], "apply"), "\n                <label>\n                    ")).call(_context3, locale2.localize("Apply"), '\n                </label>\n            </div>\n            <div class="tui-image-editor-button cancel">\n                ')).call(_context22, makeSvgIcon(["normal", "active"], "cancel"), "\n                <label>\n                    ")).call(_context2, locale2.localize("Cancel"), "\n                </label>\n            </div>\n        </li>\n    </ul>\n");
        };
        function resize_createSuper(Derived) {
          var hasNativeReflectConstruct = resize_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function resize_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var Resize = /* @__PURE__ */ function(_Submenu) {
          _inherits(Resize2, _Submenu);
          var _super = resize_createSuper(Resize2);
          function Resize2(subMenuElement, _ref) {
            var _this;
            var locale2 = _ref.locale, makeSvgIcon = _ref.makeSvgIcon, menuBarPosition = _ref.menuBarPosition, usageStatistics = _ref.usageStatistics;
            _classCallCheck(this, Resize2);
            _this = _super.call(this, subMenuElement, {
              locale: locale2,
              name: "resize",
              makeSvgIcon,
              menuBarPosition,
              templateHtml: resize,
              usageStatistics
            });
            _this.status = "active";
            _this._lockState = false;
            _this._originalDimensions = null;
            _this._els = {
              widthRange: new range({
                slider: _this.selector(".tie-width-range"),
                input: _this.selector(".tie-width-range-value")
              }, defaultResizePixelValues),
              heightRange: new range({
                slider: _this.selector(".tie-height-range"),
                input: _this.selector(".tie-height-range-value")
              }, defaultResizePixelValues),
              lockAspectRatio: _this.selector(".tie-lock-aspect-ratio"),
              apply: _this.selector(".tie-resize-button .apply"),
              cancel: _this.selector(".tie-resize-button .cancel")
            };
            return _this;
          }
          _createClass(Resize2, [{
            key: "changeStartMode",
            value: function changeStartMode() {
              this.actions.modeChange("resize");
              var dimensions = this.actions.getCurrentDimensions();
              this._originalDimensions = dimensions;
              this.setWidthValue(dimensions.width);
              this.setHeightValue(dimensions.height);
            }
          }, {
            key: "changeStandbyMode",
            value: function changeStandbyMode() {
              this.actions.stopDrawingMode();
              this.actions.reset(true);
            }
          }, {
            key: "setLimit",
            value: function setLimit(limits) {
              this._els.widthRange.min = this.calcMinValue(limits.minWidth);
              this._els.heightRange.min = this.calcMinValue(limits.minHeight);
              this._els.widthRange.max = this.calcMaxValue(limits.maxWidth);
              this._els.heightRange.max = this.calcMaxValue(limits.maxHeight);
            }
          }, {
            key: "calcMaxValue",
            value: function calcMaxValue(maxValue) {
              if (maxValue <= 0) {
                maxValue = defaultResizePixelValues.max;
              }
              return maxValue;
            }
          }, {
            key: "calcMinValue",
            value: function calcMinValue(minValue) {
              if (minValue <= 0) {
                minValue = defaultResizePixelValues.min;
              }
              return minValue;
            }
          }, {
            key: "setWidthValue",
            value: function setWidthValue(value) {
              var trigger = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              this._els.widthRange.value = value;
              if (trigger) {
                this._els.widthRange.trigger("change");
              }
            }
          }, {
            key: "setHeightValue",
            value: function setHeightValue(value) {
              var trigger = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
              this._els.heightRange.value = value;
              if (trigger) {
                this._els.heightRange.trigger("change");
              }
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              this._removeEvent();
              assignmentForDestroy(this);
            }
          }, {
            key: "addEvent",
            value: function addEvent2(actions2) {
              var _context2, _context22, _context3, _context4, _context5;
              this._els.widthRange.on("change", bind_default()(_context2 = this._changeWidthRangeHandler).call(_context2, this));
              this._els.heightRange.on("change", bind_default()(_context22 = this._changeHeightRangeHandler).call(_context22, this));
              this._els.lockAspectRatio.addEventListener("change", bind_default()(_context3 = this._changeLockAspectRatio).call(_context3, this));
              var apply = bind_default()(_context4 = this._applyEventHandler).call(_context4, this);
              var cancel = bind_default()(_context5 = this._cancelEventHandler).call(_context5, this);
              this.eventHandler = {
                apply,
                cancel
              };
              this.actions = actions2;
              this._els.apply.addEventListener("click", apply);
              this._els.cancel.addEventListener("click", cancel);
            }
          }, {
            key: "_changeWidthRangeHandler",
            value: function _changeWidthRangeHandler(value) {
              this.actions.preview("width", toInteger(value), this._lockState);
            }
          }, {
            key: "_changeHeightRangeHandler",
            value: function _changeHeightRangeHandler(value) {
              this.actions.preview("height", toInteger(value), this._lockState);
            }
          }, {
            key: "_changeLockAspectRatio",
            value: function _changeLockAspectRatio(event) {
              this._lockState = event.target.checked;
              this.actions.lockAspectRatio(this._lockState, defaultResizePixelValues.min, defaultResizePixelValues.max);
            }
          }, {
            key: "_removeEvent",
            value: function _removeEvent() {
              this._els.apply.removeEventListener("click", this.eventHandler.apply);
              this._els.cancel.removeEventListener("click", this.eventHandler.cancel);
            }
          }, {
            key: "_applyEventHandler",
            value: function _applyEventHandler() {
              this.actions.resize();
              this._els.apply.classList.remove("active");
            }
          }, {
            key: "_cancelEventHandler",
            value: function _cancelEventHandler() {
              this.actions.reset();
              this._els.cancel.classList.remove("active");
            }
          }, {
            key: "changeApplyButtonStatus",
            value: function changeApplyButtonStatus(enableStatus) {
              if (enableStatus) {
                this._els.apply.classList.add("active");
              } else {
                this._els.apply.classList.remove("active");
              }
            }
          }]);
          return Resize2;
        }(submenuBase);
        var ui_resize = Resize;
        var flip = function(_ref) {
          var _context2, _context22, _context3, _context4, _context5;
          var locale2 = _ref.locale, makeSvgIcon = _ref.makeSvgIcon;
          return concat_default()(_context2 = concat_default()(_context22 = concat_default()(_context3 = concat_default()(_context4 = concat_default()(_context5 = '\n    <ul class="tie-flip-button tui-image-editor-submenu-item">\n        <li>\n            <div class="tui-image-editor-button flipX">\n                <div>\n                    '.concat(makeSvgIcon(["normal", "active"], "flip-x", true), "\n                </div>\n                <label>\n                    ")).call(_context5, locale2.localize("Flip X"), '\n                </label>\n            </div>\n            <div class="tui-image-editor-button flipY">\n                <div>\n                    ')).call(_context4, makeSvgIcon(["normal", "active"], "flip-y", true), "\n                </div>\n                <label>\n                    ")).call(_context3, locale2.localize("Flip Y"), '\n                </label>\n            </div>\n        </li>\n        <li class="tui-image-editor-partition">\n            <div></div>\n        </li>\n        <li>\n            <div class="tui-image-editor-button resetFlip">\n                <div>\n                    ')).call(_context22, makeSvgIcon(["normal", "active"], "flip-reset", true), "\n                </div>\n                <label>\n                    ")).call(_context2, locale2.localize("Reset"), "\n                </label>\n            </div>\n        </li>\n    </ul>\n");
        };
        function flip_createSuper(Derived) {
          var hasNativeReflectConstruct = flip_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function flip_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var Flip = /* @__PURE__ */ function(_Submenu) {
          _inherits(Flip2, _Submenu);
          var _super = flip_createSuper(Flip2);
          function Flip2(subMenuElement, _ref) {
            var _this;
            var locale2 = _ref.locale, makeSvgIcon = _ref.makeSvgIcon, menuBarPosition = _ref.menuBarPosition, usageStatistics = _ref.usageStatistics;
            _classCallCheck(this, Flip2);
            _this = _super.call(this, subMenuElement, {
              locale: locale2,
              name: "flip",
              makeSvgIcon,
              menuBarPosition,
              templateHtml: flip,
              usageStatistics
            });
            _this.flipStatus = false;
            _this._els = {
              flipButton: _this.selector(".tie-flip-button")
            };
            return _this;
          }
          _createClass(Flip2, [{
            key: "destroy",
            value: function destroy2() {
              this._removeEvent();
              assignmentForDestroy(this);
            }
          }, {
            key: "addEvent",
            value: function addEvent2(actions2) {
              var _context2;
              this.eventHandler.changeFlip = bind_default()(_context2 = this._changeFlip).call(_context2, this);
              this._actions = actions2;
              this._els.flipButton.addEventListener("click", this.eventHandler.changeFlip);
            }
          }, {
            key: "_removeEvent",
            value: function _removeEvent() {
              this._els.flipButton.removeEventListener("click", this.eventHandler.changeFlip);
            }
          }, {
            key: "_changeFlip",
            value: function _changeFlip(event) {
              var _this2 = this;
              var button = event.target.closest(".tui-image-editor-button");
              if (button) {
                var flipType = this.getButtonType(button, ["flipX", "flipY", "resetFlip"]);
                if (!this.flipStatus && flipType === "resetFlip") {
                  return;
                }
                this._actions.flip(flipType).then(function(flipStatus) {
                  var flipClassList = _this2._els.flipButton.classList;
                  _this2.flipStatus = false;
                  flipClassList.remove("resetFlip");
                  forEach_default()(["flipX", "flipY"], function(type) {
                    flipClassList.remove(type);
                    if (flipStatus[type]) {
                      flipClassList.add(type);
                      flipClassList.add("resetFlip");
                      _this2.flipStatus = true;
                    }
                  });
                });
              }
            }
          }]);
          return Flip2;
        }(submenuBase);
        var ui_flip = Flip;
        var rotate2 = function(_ref) {
          var _context2, _context22;
          var locale2 = _ref.locale, makeSvgIcon = _ref.makeSvgIcon;
          return concat_default()(_context2 = concat_default()(_context22 = '\n    <ul class="tui-image-editor-submenu-item">\n        <li class="tie-rotate-button">\n            <div class="tui-image-editor-button clockwise">\n                <div>\n                    '.concat(makeSvgIcon(["normal", "active"], "rotate-clockwise", true), '\n                </div>\n                <label> 30 </label>\n            </div>\n            <div class="tui-image-editor-button counterclockwise">\n                <div>\n                    ')).call(_context22, makeSvgIcon(["normal", "active"], "rotate-counterclockwise", true), '\n                </div>\n                <label> -30 </label>\n            </div>\n        </li>\n        <li class="tui-image-editor-partition only-left-right">\n            <div></div>\n        </li>\n        <li class="tui-image-editor-newline tui-image-editor-range-wrap">\n            <label class="range">')).call(_context2, locale2.localize("Range"), '</label>\n            <div class="tie-rotate-range"></div>\n            <input class="tie-rotate-range-value tui-image-editor-range-value" value="0" />\n        </li>\n    </ul>\n');
        };
        function rotate_createSuper(Derived) {
          var hasNativeReflectConstruct = rotate_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function rotate_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var CLOCKWISE = 30;
        var COUNTERCLOCKWISE = -30;
        var Rotate = /* @__PURE__ */ function(_Submenu) {
          _inherits(Rotate2, _Submenu);
          var _super = rotate_createSuper(Rotate2);
          function Rotate2(subMenuElement, _ref) {
            var _this;
            var locale2 = _ref.locale, makeSvgIcon = _ref.makeSvgIcon, menuBarPosition = _ref.menuBarPosition, usageStatistics = _ref.usageStatistics;
            _classCallCheck(this, Rotate2);
            _this = _super.call(this, subMenuElement, {
              locale: locale2,
              name: "rotate",
              makeSvgIcon,
              menuBarPosition,
              templateHtml: rotate2,
              usageStatistics
            });
            _this._value = 0;
            _this._els = {
              rotateButton: _this.selector(".tie-rotate-button"),
              rotateRange: new range({
                slider: _this.selector(".tie-rotate-range"),
                input: _this.selector(".tie-rotate-range-value")
              }, defaultRotateRangeValues)
            };
            return _this;
          }
          _createClass(Rotate2, [{
            key: "destroy",
            value: function destroy2() {
              this._removeEvent();
              this._els.rotateRange.destroy();
              assignmentForDestroy(this);
            }
          }, {
            key: "setRangeBarAngle",
            value: function setRangeBarAngle(type, angle2) {
              var resultAngle = angle2;
              if (type === "rotate") {
                resultAngle = parse_int_default()(this._els.rotateRange.value, 10) + angle2;
              }
              this._setRangeBarRatio(resultAngle);
            }
          }, {
            key: "_setRangeBarRatio",
            value: function _setRangeBarRatio(angle2) {
              this._els.rotateRange.value = angle2;
            }
          }, {
            key: "addEvent",
            value: function addEvent2(actions2) {
              var _context2, _context22;
              this.eventHandler.rotationAngleChanged = bind_default()(_context2 = this._changeRotateForButton).call(_context2, this);
              this.actions = actions2;
              this._els.rotateButton.addEventListener("click", this.eventHandler.rotationAngleChanged);
              this._els.rotateRange.on("change", bind_default()(_context22 = this._changeRotateForRange).call(_context22, this));
            }
          }, {
            key: "_removeEvent",
            value: function _removeEvent() {
              this._els.rotateButton.removeEventListener("click", this.eventHandler.rotationAngleChanged);
              this._els.rotateRange.off();
            }
          }, {
            key: "_changeRotateForRange",
            value: function _changeRotateForRange(value, isLast) {
              var angle2 = toInteger(value);
              this.actions.setAngle(angle2, !isLast);
              this._value = angle2;
            }
          }, {
            key: "_changeRotateForButton",
            value: function _changeRotateForButton(event) {
              var button = event.target.closest(".tui-image-editor-button");
              var angle2 = this._els.rotateRange.value;
              if (button) {
                var rotateType = this.getButtonType(button, ["counterclockwise", "clockwise"]);
                var rotateAngle = {
                  clockwise: CLOCKWISE,
                  counterclockwise: COUNTERCLOCKWISE
                }[rotateType];
                var newAngle = parse_int_default()(angle2, 10) + rotateAngle;
                var isRotatable = newAngle >= -360 && newAngle <= 360;
                if (isRotatable) {
                  this.actions.rotate(rotateAngle);
                }
              }
            }
          }]);
          return Rotate2;
        }(submenuBase);
        var ui_rotate = Rotate;
        var submenu_text = function(_ref) {
          var _context2, _context22, _context3, _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13;
          var locale2 = _ref.locale, makeSvgIcon = _ref.makeSvgIcon;
          return concat_default()(_context2 = concat_default()(_context22 = concat_default()(_context3 = concat_default()(_context4 = concat_default()(_context5 = concat_default()(_context6 = concat_default()(_context7 = concat_default()(_context8 = concat_default()(_context9 = concat_default()(_context10 = concat_default()(_context11 = concat_default()(_context12 = concat_default()(_context13 = '\n    <ul class="tui-image-editor-submenu-item">\n        <li class="tie-text-effect-button">\n            <div class="tui-image-editor-button bold">\n                <div>\n                    '.concat(makeSvgIcon(["normal", "active"], "text-bold", true), "\n                </div>\n                <label> ")).call(_context13, locale2.localize("Bold"), ' </label>\n            </div>\n            <div class="tui-image-editor-button italic">\n                <div>\n                    ')).call(_context12, makeSvgIcon(["normal", "active"], "text-italic", true), "\n                </div>\n                <label> ")).call(_context11, locale2.localize("Italic"), ' </label>\n            </div>\n            <div class="tui-image-editor-button underline">\n                <div>\n                    ')).call(_context10, makeSvgIcon(["normal", "active"], "text-underline", true), "\n                </div>\n                <label> ")).call(_context9, locale2.localize("Underline"), ' </label>\n            </div>\n        </li>\n        <li class="tui-image-editor-partition">\n            <div></div>\n        </li>\n        <li class="tie-text-align-button">\n            <div class="tui-image-editor-button left">\n                <div>\n                    ')).call(_context8, makeSvgIcon(["normal", "active"], "text-align-left", true), "\n                </div>\n                <label> ")).call(_context7, locale2.localize("Left"), ' </label>\n            </div>\n            <div class="tui-image-editor-button center">\n                <div>\n                    ')).call(_context6, makeSvgIcon(["normal", "active"], "text-align-center", true), "\n                </div>\n                <label> ")).call(_context5, locale2.localize("Center"), ' </label>\n            </div>\n            <div class="tui-image-editor-button right">\n                <div>\n                    ')).call(_context4, makeSvgIcon(["normal", "active"], "text-align-right", true), "\n                </div>\n                <label> ")).call(_context3, locale2.localize("Right"), ' </label>\n            </div>\n        </li>\n        <li class="tui-image-editor-partition">\n            <div></div>\n        </li>\n        <li>\n            <div class="tie-text-color" title="')).call(_context22, locale2.localize("Color"), '"></div>\n        </li>\n        <li class="tui-image-editor-partition only-left-right">\n            <div></div>\n        </li>\n        <li class="tui-image-editor-newline tui-image-editor-range-wrap">\n            <label class="range">')).call(_context2, locale2.localize("Text size"), '</label>\n            <div class="tie-text-range"></div>\n            <input class="tie-text-range-value tui-image-editor-range-value" value="0" />\n        </li>\n    </ul>\n');
        };
        function text_createSuper(Derived) {
          var hasNativeReflectConstruct = text_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function text_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var Text = /* @__PURE__ */ function(_Submenu) {
          _inherits(Text2, _Submenu);
          var _super = text_createSuper(Text2);
          function Text2(subMenuElement, _ref) {
            var _this;
            var locale2 = _ref.locale, makeSvgIcon = _ref.makeSvgIcon, menuBarPosition = _ref.menuBarPosition, usageStatistics = _ref.usageStatistics;
            _classCallCheck(this, Text2);
            _this = _super.call(this, subMenuElement, {
              locale: locale2,
              name: "text",
              makeSvgIcon,
              menuBarPosition,
              templateHtml: submenu_text,
              usageStatistics
            });
            _this.effect = {
              bold: false,
              italic: false,
              underline: false
            };
            _this.align = "tie-text-align-left";
            _this._els = {
              textEffectButton: _this.selector(".tie-text-effect-button"),
              textAlignButton: _this.selector(".tie-text-align-button"),
              textColorpicker: new colorpicker(_this.selector(".tie-text-color"), {
                defaultColor: "#ffbb3b",
                toggleDirection: _this.toggleDirection,
                usageStatistics: _this.usageStatistics
              }),
              textRange: new range({
                slider: _this.selector(".tie-text-range"),
                input: _this.selector(".tie-text-range-value")
              }, defaultTextRangeValues)
            };
            _this.colorPickerInputBox = _this._els.textColorpicker.colorpickerElement.querySelector(selectorNames.COLOR_PICKER_INPUT_BOX);
            return _this;
          }
          _createClass(Text2, [{
            key: "destroy",
            value: function destroy2() {
              this._removeEvent();
              this._els.textColorpicker.destroy();
              this._els.textRange.destroy();
              assignmentForDestroy(this);
            }
          }, {
            key: "addEvent",
            value: function addEvent2(actions2) {
              var _context2, _context22, _context3, _context4, _context5, _context6;
              var setTextEffect = bind_default()(_context2 = this._setTextEffectHandler).call(_context2, this);
              var setTextAlign = bind_default()(_context22 = this._setTextAlignHandler).call(_context22, this);
              this.eventHandler = {
                setTextEffect,
                setTextAlign
              };
              this.actions = actions2;
              this._els.textEffectButton.addEventListener("click", setTextEffect);
              this._els.textAlignButton.addEventListener("click", setTextAlign);
              this._els.textRange.on("change", bind_default()(_context3 = this._changeTextRnageHandler).call(_context3, this));
              this._els.textColorpicker.on("change", bind_default()(_context4 = this._changeColorHandler).call(_context4, this));
              this.colorPickerInputBox.addEventListener(eventNames.FOCUS, bind_default()(_context5 = this._onStartEditingInputBox).call(_context5, this));
              this.colorPickerInputBox.addEventListener(eventNames.BLUR, bind_default()(_context6 = this._onStopEditingInputBox).call(_context6, this));
            }
          }, {
            key: "_removeEvent",
            value: function _removeEvent() {
              var _context7, _context8;
              var _this$eventHandler = this.eventHandler, setTextEffect = _this$eventHandler.setTextEffect, setTextAlign = _this$eventHandler.setTextAlign;
              this._els.textEffectButton.removeEventListener("click", setTextEffect);
              this._els.textAlignButton.removeEventListener("click", setTextAlign);
              this._els.textRange.off();
              this._els.textColorpicker.off();
              this.colorPickerInputBox.removeEventListener(eventNames.FOCUS, bind_default()(_context7 = this._onStartEditingInputBox).call(_context7, this));
              this.colorPickerInputBox.removeEventListener(eventNames.BLUR, bind_default()(_context8 = this._onStopEditingInputBox).call(_context8, this));
            }
          }, {
            key: "changeStandbyMode",
            value: function changeStandbyMode() {
              this.actions.stopDrawingMode();
            }
          }, {
            key: "changeStartMode",
            value: function changeStartMode() {
              this.actions.modeChange("text");
            }
          }, {
            key: "textColor",
            get: function get() {
              return this._els.textColorpicker.color;
            },
            set: function set(color2) {
              this._els.textColorpicker.color = color2;
            }
          }, {
            key: "fontSize",
            get: function get() {
              return this._els.textRange.value;
            },
            set: function set(value) {
              this._els.textRange.value = value;
            }
          }, {
            key: "fontStyle",
            get: function get() {
              return this.effect.italic ? "italic" : "normal";
            }
          }, {
            key: "fontWeight",
            get: function get() {
              return this.effect.bold ? "bold" : "normal";
            }
          }, {
            key: "underline",
            get: function get() {
              return this.effect.underline;
            }
          }, {
            key: "setTextStyleStateOnAction",
            value: function setTextStyleStateOnAction() {
              var textStyle = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              var fill = fill_default()(textStyle), fontSize2 = textStyle.fontSize, fontStyle2 = textStyle.fontStyle, fontWeight2 = textStyle.fontWeight, textDecoration = textStyle.textDecoration, textAlign2 = textStyle.textAlign;
              this.textColor = fill;
              this.fontSize = fontSize2;
              this.setEffectState("italic", fontStyle2);
              this.setEffectState("bold", fontWeight2);
              this.setEffectState("underline", textDecoration);
              this.setAlignState("tie-text-align-".concat(textAlign2));
            }
          }, {
            key: "setEffectState",
            value: function setEffectState(effectName, value) {
              var effectValue = value === "italic" || value === "bold" || value === "underline";
              var button = this._els.textEffectButton.querySelector(".tui-image-editor-button.".concat(effectName));
              this.effect[effectName] = effectValue;
              button.classList[effectValue ? "add" : "remove"]("active");
            }
          }, {
            key: "setAlignState",
            value: function setAlignState(value) {
              var button = this._els.textAlignButton;
              button.classList.remove(this.align);
              button.classList.add(value);
              this.align = value;
            }
          }, {
            key: "_setTextEffectHandler",
            value: function _setTextEffectHandler(event) {
              var button = event.target.closest(".tui-image-editor-button");
              if (button) {
                var _button$className$mat = button.className.match(/(bold|italic|underline)/), _button$className$mat2 = _slicedToArray(_button$className$mat, 1), styleType = _button$className$mat2[0];
                var styleObj = {
                  bold: {
                    fontWeight: "bold"
                  },
                  italic: {
                    fontStyle: "italic"
                  },
                  underline: {
                    textDecoration: "underline"
                  }
                }[styleType];
                this.effect[styleType] = !this.effect[styleType];
                button.classList.toggle("active");
                this.actions.changeTextStyle(styleObj);
              }
            }
          }, {
            key: "_setTextAlignHandler",
            value: function _setTextAlignHandler(event) {
              var button = event.target.closest(".tui-image-editor-button");
              if (button) {
                var styleType = this.getButtonType(button, ["left", "center", "right"]);
                var styleTypeAlias = "tie-text-align-".concat(styleType);
                event.currentTarget.classList.remove(this.align);
                if (this.align !== styleTypeAlias) {
                  event.currentTarget.classList.add(styleTypeAlias);
                }
                this.actions.changeTextStyle({
                  textAlign: styleType
                });
                this.align = styleTypeAlias;
              }
            }
          }, {
            key: "_changeTextRnageHandler",
            value: function _changeTextRnageHandler(value, isLast) {
              this.actions.changeTextStyle({
                fontSize: value
              }, !isLast);
            }
          }, {
            key: "_changeColorHandler",
            value: function _changeColorHandler(color2) {
              color2 = color2 || "transparent";
              this.actions.changeTextStyle({
                fill: color2
              });
            }
          }]);
          return Text2;
        }(submenuBase);
        var ui_text = Text;
        var mask = function(_ref) {
          var _context2, _context22, _context3;
          var locale2 = _ref.locale, makeSvgIcon = _ref.makeSvgIcon;
          return concat_default()(_context2 = concat_default()(_context22 = concat_default()(_context3 = '\n    <ul class="tui-image-editor-submenu-item">\n        <li>\n            <div class="tui-image-editor-button">\n                <div>\n                    <input type="file" accept="image/*" class="tie-mask-image-file">\n                    '.concat(makeSvgIcon(["normal", "active"], "mask-load", true), "\n                </div>\n                <label> ")).call(_context3, locale2.localize("Load Mask Image"), ' </label>\n            </div>\n        </li>\n        <li class="tui-image-editor-partition only-left-right">\n            <div></div>\n        </li>\n        <li class="tie-mask-apply tui-image-editor-newline apply" style="margin-top: 22px;margin-bottom: 5px">\n            <div class="tui-image-editor-button apply">\n                ')).call(_context22, makeSvgIcon(["normal", "active"], "apply"), "\n                <label>\n                    ")).call(_context2, locale2.localize("Apply"), "\n                </label>\n            </div>\n        </li>\n    </ul>\n");
        };
        function mask_createSuper(Derived) {
          var hasNativeReflectConstruct = mask_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function mask_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var Mask = /* @__PURE__ */ function(_Submenu) {
          _inherits(Mask2, _Submenu);
          var _super = mask_createSuper(Mask2);
          function Mask2(subMenuElement, _ref) {
            var _this;
            var locale2 = _ref.locale, makeSvgIcon = _ref.makeSvgIcon, menuBarPosition = _ref.menuBarPosition, usageStatistics = _ref.usageStatistics;
            _classCallCheck(this, Mask2);
            _this = _super.call(this, subMenuElement, {
              locale: locale2,
              name: "mask",
              makeSvgIcon,
              menuBarPosition,
              templateHtml: mask,
              usageStatistics
            });
            _this._els = {
              applyButton: _this.selector(".tie-mask-apply"),
              maskImageButton: _this.selector(".tie-mask-image-file")
            };
            return _this;
          }
          _createClass(Mask2, [{
            key: "destroy",
            value: function destroy2() {
              this._removeEvent();
              assignmentForDestroy(this);
            }
          }, {
            key: "addEvent",
            value: function addEvent2(actions2) {
              var _context2, _context22;
              var loadMaskFile = bind_default()(_context2 = this._loadMaskFile).call(_context2, this);
              var applyMask = bind_default()(_context22 = this._applyMask).call(_context22, this);
              this.eventHandler = {
                loadMaskFile,
                applyMask
              };
              this.actions = actions2;
              this._els.maskImageButton.addEventListener("change", loadMaskFile);
              this._els.applyButton.addEventListener("click", applyMask);
            }
          }, {
            key: "_removeEvent",
            value: function _removeEvent() {
              this._els.maskImageButton.removeEventListener("change", this.eventHandler.loadMaskFile);
              this._els.applyButton.removeEventListener("click", this.eventHandler.applyMask);
            }
          }, {
            key: "_applyMask",
            value: function _applyMask() {
              this.actions.applyFilter();
              this._els.applyButton.classList.remove("active");
            }
          }, {
            key: "_loadMaskFile",
            value: function _loadMaskFile(event) {
              var imgUrl;
              if (!isSupportFileApi()) {
                alert("This browser does not support file-api");
              }
              var _event$target$files = _slicedToArray(event.target.files, 1), file = _event$target$files[0];
              if (file) {
                imgUrl = url_default().createObjectURL(file);
                this.actions.loadImageFromURL(imgUrl, file);
                this._els.applyButton.classList.add("active");
              }
            }
          }]);
          return Mask2;
        }(submenuBase);
        var ui_mask = Mask;
        var icon = function(_ref) {
          var _context2, _context22, _context3, _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13, _context14, _context15, _context16, _context17, _context18, _context19, _context20;
          var locale2 = _ref.locale, makeSvgIcon = _ref.makeSvgIcon;
          return concat_default()(_context2 = concat_default()(_context22 = concat_default()(_context3 = concat_default()(_context4 = concat_default()(_context5 = concat_default()(_context6 = concat_default()(_context7 = concat_default()(_context8 = concat_default()(_context9 = concat_default()(_context10 = concat_default()(_context11 = concat_default()(_context12 = concat_default()(_context13 = concat_default()(_context14 = concat_default()(_context15 = concat_default()(_context16 = concat_default()(_context17 = concat_default()(_context18 = concat_default()(_context19 = concat_default()(_context20 = '\n    <ul class="tui-image-editor-submenu-item">\n        <li class="tie-icon-add-button">\n            <div class="tui-image-editor-button" data-icontype="icon-arrow">\n                <div>\n                    '.concat(makeSvgIcon(["normal", "active"], "icon-arrow", true), "\n                </div>\n                <label>\n                    ")).call(_context20, locale2.localize("Arrow"), '\n                </label>\n            </div>\n            <div class="tui-image-editor-button" data-icontype="icon-arrow-2">\n                <div>\n                    ')).call(_context19, makeSvgIcon(["normal", "active"], "icon-arrow-2", true), "\n                </div>\n                <label>\n                    ")).call(_context18, locale2.localize("Arrow-2"), '\n                </label>\n            </div>\n            <div class="tui-image-editor-button" data-icontype="icon-arrow-3">\n                <div>\n                    ')).call(_context17, makeSvgIcon(["normal", "active"], "icon-arrow-3", true), "\n                </div>\n                <label>\n                    ")).call(_context16, locale2.localize("Arrow-3"), '\n                </label>\n            </div>\n            <div class="tui-image-editor-button" data-icontype="icon-star">\n                <div>\n                    ')).call(_context15, makeSvgIcon(["normal", "active"], "icon-star", true), "\n                </div>\n                <label>\n                    ")).call(_context14, locale2.localize("Star-1"), '\n                </label>\n            </div>\n            <div class="tui-image-editor-button" data-icontype="icon-star-2">\n                <div>\n                    ')).call(_context13, makeSvgIcon(["normal", "active"], "icon-star-2", true), "\n                </div>\n                <label>\n                    ")).call(_context12, locale2.localize("Star-2"), '\n                </label>\n            </div>\n\n            <div class="tui-image-editor-button" data-icontype="icon-polygon">\n                <div>\n                    ')).call(_context11, makeSvgIcon(["normal", "active"], "icon-polygon", true), "\n                </div>\n                <label>\n                    ")).call(_context10, locale2.localize("Polygon"), '\n                </label>\n            </div>\n\n            <div class="tui-image-editor-button" data-icontype="icon-location">\n                <div>\n                    ')).call(_context9, makeSvgIcon(["normal", "active"], "icon-location", true), "\n                </div>\n                <label>\n                    ")).call(_context8, locale2.localize("Location"), '\n                </label>\n            </div>\n\n            <div class="tui-image-editor-button" data-icontype="icon-heart">\n                <div>\n                    ')).call(_context7, makeSvgIcon(["normal", "active"], "icon-heart", true), "\n                </div>\n                <label>\n                    ")).call(_context6, locale2.localize("Heart"), '\n                </label>\n            </div>\n\n            <div class="tui-image-editor-button" data-icontype="icon-bubble">\n                <div>\n                    ')).call(_context5, makeSvgIcon(["normal", "active"], "icon-bubble", true), "\n                </div>\n                <label>\n                    ")).call(_context4, locale2.localize("Bubble"), '\n                </label>\n            </div>\n        </li>\n        <li class="tui-image-editor-partition">\n            <div></div>\n        </li>\n        <li class="tie-icon-add-button">\n            <div class="tui-image-editor-button" style="margin:0">\n                <div>\n                    <input type="file" accept="image/*" class="tie-icon-image-file">\n                    ')).call(_context3, makeSvgIcon(["normal", "active"], "icon-load", true), "\n                </div>\n                <label>\n                    ")).call(_context22, locale2.localize("Custom icon"), '\n                </label>\n            </div>\n        </li>\n        <li class="tui-image-editor-partition">\n            <div></div>\n        </li>\n        <li>\n            <div class="tie-icon-color" title="')).call(_context2, locale2.localize("Color"), '"></div>\n        </li>\n    </ul>\n');
        };
        function icon_createSuper(Derived) {
          var hasNativeReflectConstruct = icon_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function icon_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var Icon = /* @__PURE__ */ function(_Submenu) {
          _inherits(Icon2, _Submenu);
          var _super = icon_createSuper(Icon2);
          function Icon2(subMenuElement, _ref) {
            var _this;
            var locale2 = _ref.locale, makeSvgIcon = _ref.makeSvgIcon, menuBarPosition = _ref.menuBarPosition, usageStatistics = _ref.usageStatistics;
            _classCallCheck(this, Icon2);
            _this = _super.call(this, subMenuElement, {
              locale: locale2,
              name: "icon",
              makeSvgIcon,
              menuBarPosition,
              templateHtml: icon,
              usageStatistics
            });
            _this.iconType = null;
            _this._iconMap = {};
            _this._els = {
              registerIconButton: _this.selector(".tie-icon-image-file"),
              addIconButton: _this.selector(".tie-icon-add-button"),
              iconColorpicker: new colorpicker(_this.selector(".tie-icon-color"), {
                defaultColor: "#ffbb3b",
                toggleDirection: _this.toggleDirection,
                usageStatistics: _this.usageStatistics
              })
            };
            _this.colorPickerInputBox = _this._els.iconColorpicker.colorpickerElement.querySelector(selectorNames.COLOR_PICKER_INPUT_BOX);
            return _this;
          }
          _createClass(Icon2, [{
            key: "destroy",
            value: function destroy2() {
              this._removeEvent();
              this._els.iconColorpicker.destroy();
              assignmentForDestroy(this);
            }
          }, {
            key: "addEvent",
            value: function addEvent2(actions2) {
              var _context2, _context22, _context3, _context4, _context5;
              var registerIcon = bind_default()(_context2 = this._registerIconHandler).call(_context2, this);
              var addIcon = bind_default()(_context22 = this._addIconHandler).call(_context22, this);
              this.eventHandler = {
                registerIcon,
                addIcon
              };
              this.actions = actions2;
              this._els.iconColorpicker.on("change", bind_default()(_context3 = this._changeColorHandler).call(_context3, this));
              this._els.registerIconButton.addEventListener("change", registerIcon);
              this._els.addIconButton.addEventListener("click", addIcon);
              this.colorPickerInputBox.addEventListener(eventNames.FOCUS, bind_default()(_context4 = this._onStartEditingInputBox).call(_context4, this));
              this.colorPickerInputBox.addEventListener(eventNames.BLUR, bind_default()(_context5 = this._onStopEditingInputBox).call(_context5, this));
            }
          }, {
            key: "_removeEvent",
            value: function _removeEvent() {
              var _context6, _context7;
              this._els.iconColorpicker.off();
              this._els.registerIconButton.removeEventListener("change", this.eventHandler.registerIcon);
              this._els.addIconButton.removeEventListener("click", this.eventHandler.addIcon);
              this.colorPickerInputBox.removeEventListener(eventNames.FOCUS, bind_default()(_context6 = this._onStartEditingInputBox).call(_context6, this));
              this.colorPickerInputBox.removeEventListener(eventNames.BLUR, bind_default()(_context7 = this._onStopEditingInputBox).call(_context7, this));
            }
          }, {
            key: "clearIconType",
            value: function clearIconType() {
              this._els.addIconButton.classList.remove(this.iconType);
              this.iconType = null;
            }
          }, {
            key: "registerDefaultIcon",
            value: function registerDefaultIcon() {
              var _this2 = this;
              forEach_default()(defaultIconPath, function(path, type) {
                _this2.actions.registerDefaultIcons(type, path);
              });
            }
          }, {
            key: "setIconPickerColor",
            value: function setIconPickerColor(iconColor) {
              this._els.iconColorpicker.color = iconColor;
            }
          }, {
            key: "changeStandbyMode",
            value: function changeStandbyMode() {
              this.clearIconType();
              this.actions.cancelAddIcon();
            }
          }, {
            key: "_changeColorHandler",
            value: function _changeColorHandler(color2) {
              color2 = color2 || "transparent";
              this.actions.changeColor(color2);
            }
          }, {
            key: "_addIconHandler",
            value: function _addIconHandler(event) {
              var button = event.target.closest(".tui-image-editor-button");
              if (button) {
                var iconType = button.getAttribute("data-icontype");
                var iconColor = this._els.iconColorpicker.color;
                this.actions.discardSelection();
                this.actions.changeSelectableAll(false);
                this._els.addIconButton.classList.remove(this.iconType);
                this._els.addIconButton.classList.add(iconType);
                if (this.iconType === iconType) {
                  this.changeStandbyMode();
                } else {
                  this.actions.addIcon(iconType, iconColor);
                  this.iconType = iconType;
                }
              }
            }
          }, {
            key: "_registerIconHandler",
            value: function _registerIconHandler(event) {
              var imgUrl;
              if (!isSupportFileApi) {
                alert("This browser does not support file-api");
              }
              var _event$target$files = _slicedToArray(event.target.files, 1), file = _event$target$files[0];
              if (file) {
                imgUrl = url_default().createObjectURL(file);
                this.actions.registerCustomIcon(imgUrl, file);
              }
            }
          }]);
          return Icon2;
        }(submenuBase);
        var ui_icon = Icon;
        var draw = function(_ref) {
          var _context2, _context22, _context3, _context4, _context5;
          var locale2 = _ref.locale, makeSvgIcon = _ref.makeSvgIcon;
          return concat_default()(_context2 = concat_default()(_context22 = concat_default()(_context3 = concat_default()(_context4 = concat_default()(_context5 = '\n    <ul class="tui-image-editor-submenu-item">\n        <li class="tie-draw-line-select-button">\n            <div class="tui-image-editor-button free">\n                <div>\n                    '.concat(makeSvgIcon(["normal", "active"], "draw-free", true), "\n                </div>\n                <label>\n                    ")).call(_context5, locale2.localize("Free"), '\n                </label>\n            </div>\n            <div class="tui-image-editor-button line">\n                <div>\n                    ')).call(_context4, makeSvgIcon(["normal", "active"], "draw-line", true), "\n                </div>\n                <label>\n                    ")).call(_context3, locale2.localize("Straight"), '\n                </label>\n            </div>\n        </li>\n        <li class="tui-image-editor-partition">\n            <div></div>\n        </li>\n        <li>\n            <div class="tie-draw-color" title="')).call(_context22, locale2.localize("Color"), '"></div>\n        </li>\n        <li class="tui-image-editor-partition only-left-right">\n            <div></div>\n        </li>\n        <li class="tui-image-editor-newline tui-image-editor-range-wrap">\n            <label class="range">')).call(_context2, locale2.localize("Range"), '</label>\n            <div class="tie-draw-range"></div>\n            <input class="tie-draw-range-value tui-image-editor-range-value" value="0" />\n        </li>\n    </ul>\n');
        };
        function draw_createSuper(Derived) {
          var hasNativeReflectConstruct = draw_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function draw_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var DRAW_OPACITY = 0.7;
        var Draw = /* @__PURE__ */ function(_Submenu) {
          _inherits(Draw2, _Submenu);
          var _super = draw_createSuper(Draw2);
          function Draw2(subMenuElement, _ref) {
            var _this;
            var locale2 = _ref.locale, makeSvgIcon = _ref.makeSvgIcon, menuBarPosition = _ref.menuBarPosition, usageStatistics = _ref.usageStatistics;
            _classCallCheck(this, Draw2);
            _this = _super.call(this, subMenuElement, {
              locale: locale2,
              name: "draw",
              makeSvgIcon,
              menuBarPosition,
              templateHtml: draw,
              usageStatistics
            });
            _this._els = {
              lineSelectButton: _this.selector(".tie-draw-line-select-button"),
              drawColorPicker: new colorpicker(_this.selector(".tie-draw-color"), {
                defaultColor: "#00a9ff",
                toggleDirection: _this.toggleDirection,
                usageStatistics: _this.usageStatistics
              }),
              drawRange: new range({
                slider: _this.selector(".tie-draw-range"),
                input: _this.selector(".tie-draw-range-value")
              }, defaultDrawRangeValues)
            };
            _this.type = null;
            _this.color = _this._els.drawColorPicker.color;
            _this.width = _this._els.drawRange.value;
            _this.colorPickerInputBox = _this._els.drawColorPicker.colorpickerElement.querySelector(selectorNames.COLOR_PICKER_INPUT_BOX);
            return _this;
          }
          _createClass(Draw2, [{
            key: "destroy",
            value: function destroy2() {
              this._removeEvent();
              this._els.drawColorPicker.destroy();
              this._els.drawRange.destroy();
              assignmentForDestroy(this);
            }
          }, {
            key: "addEvent",
            value: function addEvent2(actions2) {
              var _context2, _context22, _context3, _context4, _context5;
              this.eventHandler.changeDrawType = bind_default()(_context2 = this._changeDrawType).call(_context2, this);
              this.actions = actions2;
              this._els.lineSelectButton.addEventListener("click", this.eventHandler.changeDrawType);
              this._els.drawColorPicker.on("change", bind_default()(_context22 = this._changeDrawColor).call(_context22, this));
              this._els.drawRange.on("change", bind_default()(_context3 = this._changeDrawRange).call(_context3, this));
              this.colorPickerInputBox.addEventListener(eventNames.FOCUS, bind_default()(_context4 = this._onStartEditingInputBox).call(_context4, this));
              this.colorPickerInputBox.addEventListener(eventNames.BLUR, bind_default()(_context5 = this._onStopEditingInputBox).call(_context5, this));
            }
          }, {
            key: "_removeEvent",
            value: function _removeEvent() {
              var _context6, _context7;
              this._els.lineSelectButton.removeEventListener("click", this.eventHandler.changeDrawType);
              this._els.drawColorPicker.off();
              this._els.drawRange.off();
              this.colorPickerInputBox.removeEventListener(eventNames.FOCUS, bind_default()(_context6 = this._onStartEditingInputBox).call(_context6, this));
              this.colorPickerInputBox.removeEventListener(eventNames.BLUR, bind_default()(_context7 = this._onStopEditingInputBox).call(_context7, this));
            }
          }, {
            key: "setDrawMode",
            value: function setDrawMode() {
              this.actions.setDrawMode(this.type, {
                width: this.width,
                color: getRgb(this.color, DRAW_OPACITY)
              });
            }
          }, {
            key: "changeStandbyMode",
            value: function changeStandbyMode() {
              this.type = null;
              this.actions.stopDrawingMode();
              this.actions.changeSelectableAll(true);
              this._els.lineSelectButton.classList.remove("free");
              this._els.lineSelectButton.classList.remove("line");
            }
          }, {
            key: "changeStartMode",
            value: function changeStartMode() {
              this.type = "free";
              this._els.lineSelectButton.classList.add("free");
              this.setDrawMode();
            }
          }, {
            key: "_changeDrawType",
            value: function _changeDrawType(event) {
              var button = event.target.closest(".tui-image-editor-button");
              if (button) {
                var lineType = this.getButtonType(button, ["free", "line"]);
                this.actions.discardSelection();
                if (this.type === lineType) {
                  this.changeStandbyMode();
                  return;
                }
                this.changeStandbyMode();
                this.type = lineType;
                this._els.lineSelectButton.classList.add(lineType);
                this.setDrawMode();
              }
            }
          }, {
            key: "_changeDrawColor",
            value: function _changeDrawColor(color2) {
              this.color = color2 || "transparent";
              if (!this.type) {
                this.changeStartMode();
              } else {
                this.setDrawMode();
              }
            }
          }, {
            key: "_changeDrawRange",
            value: function _changeDrawRange(value) {
              this.width = value;
              if (!this.type) {
                this.changeStartMode();
              } else {
                this.setDrawMode();
              }
            }
          }]);
          return Draw2;
        }(submenuBase);
        var ui_draw = Draw;
        var isExisty = __webpack_require__(9886);
        var isExisty_default = /* @__PURE__ */ __webpack_require__.n(isExisty);
        var filter = function(_ref) {
          var _context2, _context22, _context3, _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13, _context14, _context15, _context16;
          var locale2 = _ref.locale;
          return concat_default()(_context2 = concat_default()(_context22 = concat_default()(_context3 = concat_default()(_context4 = concat_default()(_context5 = concat_default()(_context6 = concat_default()(_context7 = concat_default()(_context8 = concat_default()(_context9 = concat_default()(_context10 = concat_default()(_context11 = concat_default()(_context12 = concat_default()(_context13 = concat_default()(_context14 = concat_default()(_context15 = concat_default()(_context16 = '\n    <ul class="tui-image-editor-submenu-item">\n        <li class="tui-image-editor-submenu-align">\n            <div class="tui-image-editor-checkbox-wrap fixed-width">\n                <div class="tui-image-editor-checkbox">\n                    <label>\n                        <input type="checkbox" class="tie-grayscale">\n                        <span>'.concat(locale2.localize("Grayscale"), '</span>\n                    </label>\n                </div>\n                <div class="tui-image-editor-checkbox">\n                    <label>\n                        <input type="checkbox" class="tie-invert">\n                        <span>')).call(_context16, locale2.localize("Invert"), '</span>\n                    </label>\n                </div>\n                <div class="tui-image-editor-checkbox">\n                    <label>\n                        <input type="checkbox" class="tie-sepia">\n                        <span>')).call(_context15, locale2.localize("Sepia"), '</span>\n                    </label>\n                </div>\n                <div class="tui-image-editor-checkbox">\n                    <label>\n                        <input type="checkbox" class="tie-vintage">\n                        <span>')).call(_context14, locale2.localize("Sepia2"), '</span>\n                    </label>\n                </div>\n                <div class="tui-image-editor-checkbox">\n                    <label>\n                        <input type="checkbox" class="tie-blur">\n                        <span>')).call(_context13, locale2.localize("Blur"), '</span>\n                    </label>\n                </div>\n                <div class="tui-image-editor-checkbox">\n                    <label>\n                        <input type="checkbox" class="tie-sharpen">\n                        <span>')).call(_context12, locale2.localize("Sharpen"), '</span>\n                    </label>\n                </div>\n                <div class="tui-image-editor-checkbox">\n                    <label>\n                        <input type="checkbox" class="tie-emboss">\n                        <span>')).call(_context11, locale2.localize("Emboss"), '</span>\n                    </label>\n                </div>\n            </div>\n        </li>\n        <li class="tui-image-editor-partition">\n            <div></div>\n        </li>\n        <li class="tui-image-editor-submenu-align">\n            <div class="tui-image-editor-checkbox-group tui-image-editor-disabled" style="margin-bottom: 7px;">\n                <div class="tui-image-editor-checkbox-wrap">\n                    <div class="tui-image-editor-checkbox">\n                        <label>\n                            <input type="checkbox" class="tie-remove-white">\n                            <span>')).call(_context10, locale2.localize("Remove White"), '</span>\n                        </label>\n                    </div>\n                </div>\n                <div class="tui-image-editor-newline tui-image-editor-range-wrap short">\n                    <label>')).call(_context9, locale2.localize("Distance"), '</label>\n                    <div class="tie-removewhite-distance-range"></div>\n                </div>\n            </div>\n            <div class="tui-image-editor-checkbox-group tui-image-editor-disabled">\n                <div class="tui-image-editor-checkbox">\n                    <label>\n                        <input type="checkbox" class="tie-brightness">\n                        <span>')).call(_context8, locale2.localize("Brightness"), '</span>\n                    </label>\n                </div>\n                <div class="tui-image-editor-range-wrap short">\n                    <div class="tie-brightness-range"></div>\n                </div>\n            </div>\n            <div class="tui-image-editor-checkbox-group tui-image-editor-disabled">\n                <div class="tui-image-editor-checkbox">\n                    <label>\n                        <input type="checkbox" class="tie-noise">\n                        <span>')).call(_context7, locale2.localize("Noise"), '</span>\n                    </label>\n                </div>\n                <div class="tui-image-editor-range-wrap short">\n                    <div class="tie-noise-range"></div>\n                </div>\n            </div>\n        </li>\n        <li class="tui-image-editor-partition only-left-right">\n            <div></div>\n        </li>\n        <li class="tui-image-editor-submenu-align">\n            <div class="tui-image-editor-checkbox-group tui-image-editor-disabled">\n                <div class="tui-image-editor-checkbox">\n                    <label>\n                        <input type="checkbox" class="tie-pixelate">\n                        <span>')).call(_context6, locale2.localize("Pixelate"), '</span>\n                    </label>\n                </div>\n                <div class="tui-image-editor-range-wrap short">\n                    <div class="tie-pixelate-range"></div>\n                </div>\n            </div>\n            <div class="tui-image-editor-checkbox-group tui-image-editor-disabled">\n                <div class="tui-image-editor-newline tui-image-editor-checkbox-wrap">\n                    <div class="tui-image-editor-checkbox">\n                        <label>\n                            <input type="checkbox" class="tie-color-filter">\n                            <span>')).call(_context5, locale2.localize("Color Filter"), '</span>\n                        </label>\n                    </div>\n                </div>\n                <div class="tui-image-editor-newline tui-image-editor-range-wrap short">\n                    <label>')).call(_context4, locale2.localize("Threshold"), '</label>\n                    <div class="tie-colorfilter-threshold-range"></div>\n                </div>\n            </div>\n        </li>\n        <li class="tui-image-editor-partition">\n            <div></div>\n        </li>\n        <li>\n            <div class="filter-color-item">\n                <div class="tie-filter-tint-color" title="')).call(_context3, locale2.localize("Tint"), '"></div>\n                <div class="tui-image-editor-checkbox">\n                    <label>\n                        <input type="checkbox" class="tie-tint">\n                        <span></span>\n                    </label>\n                </div>\n            </div>\n            <div class="filter-color-item">\n                <div class="tie-filter-multiply-color" title="')).call(_context22, locale2.localize("Multiply"), '"></div>\n                <div class="tui-image-editor-checkbox">\n                    <label>\n                        <input type="checkbox" class="tie-multiply">\n                        <span></span>\n                    </label>\n                </div>\n            </div>\n            <div class="filter-color-item">\n                <div class="tie-filter-blend-color" title="')).call(_context2, locale2.localize("Blend"), '"></div>\n                <div class="tui-image-editor-checkbox">\n                    <label>\n                        <input type="checkbox" class="tie-blend">\n                        <span></span>\n                    </label>\n                </div>\n            </div>\n        </li>\n    </ul>\n');
        };
        function filter_createSuper(Derived) {
          var hasNativeReflectConstruct = filter_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function filter_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var PICKER_CONTROL_HEIGHT = "130px";
        var BLEND_OPTIONS = ["add", "diff", "subtract", "multiply", "screen", "lighten", "darken"];
        var FILTER_OPTIONS = ["grayscale", "invert", "sepia", "vintage", "blur", "sharpen", "emboss", "remove-white", "brightness", "noise", "pixelate", "color-filter", "tint", "multiply", "blend"];
        var filterNameMap = {
          grayscale: "grayscale",
          invert: "invert",
          sepia: "sepia",
          blur: "blur",
          sharpen: "sharpen",
          emboss: "emboss",
          removeWhite: "removeColor",
          brightness: "brightness",
          contrast: "contrast",
          saturation: "saturation",
          vintage: "vintage",
          polaroid: "polaroid",
          noise: "noise",
          pixelate: "pixelate",
          colorFilter: "removeColor",
          tint: "blendColor",
          multiply: "blendColor",
          blend: "blendColor",
          hue: "hue",
          gamma: "gamma"
        };
        var RANGE_INSTANCE_NAMES = ["removewhiteDistanceRange", "colorfilterThresholdRange", "pixelateRange", "noiseRange", "brightnessRange", "tintOpacity"];
        var COLORPICKER_INSTANCE_NAMES = ["filterBlendColor", "filterMultiplyColor", "filterTintColor"];
        var Filter = /* @__PURE__ */ function(_Submenu) {
          _inherits(Filter2, _Submenu);
          var _super = filter_createSuper(Filter2);
          function Filter2(subMenuElement, _ref) {
            var _this;
            var locale2 = _ref.locale, menuBarPosition = _ref.menuBarPosition, usageStatistics = _ref.usageStatistics;
            _classCallCheck(this, Filter2);
            _this = _super.call(this, subMenuElement, {
              locale: locale2,
              name: "filter",
              menuBarPosition,
              templateHtml: filter,
              usageStatistics
            });
            _this.selectBoxShow = false;
            _this.checkedMap = {};
            _this._makeControlElement();
            return _this;
          }
          _createClass(Filter2, [{
            key: "destroy",
            value: function destroy2() {
              this._removeEvent();
              this._destroyToolInstance();
              assignmentForDestroy(this);
            }
          }, {
            key: "_removeEvent",
            value: function _removeEvent() {
              var _this2 = this, _context2;
              forEach_default()(FILTER_OPTIONS, function(filter2) {
                var filterCheckElement = _this2.selector(".tie-".concat(filter2));
                var filterNameCamelCase = toCamelCase(filter2);
                filterCheckElement.removeEventListener("change", _this2.eventHandler[filterNameCamelCase]);
              });
              forEach_default()(concat_default()(_context2 = []).call(_context2, RANGE_INSTANCE_NAMES, COLORPICKER_INSTANCE_NAMES), function(instanceName) {
                _this2._els[instanceName].off();
              });
              this._els.blendType.removeEventListener("change", this.eventHandler.changeBlendFilter);
              this._els.blendType.removeEventListener("click", this.eventHandler.changeBlendFilter);
              forEachArray_default()(this.colorPickerInputBoxes, function(inputBox) {
                var _context22, _context3;
                inputBox.removeEventListener(eventNames.FOCUS, bind_default()(_context22 = _this2._onStartEditingInputBox).call(_context22, _this2));
                inputBox.removeEventListener(eventNames.BLUR, bind_default()(_context3 = _this2._onStopEditingInputBox).call(_context3, _this2));
              }, this);
            }
          }, {
            key: "_destroyToolInstance",
            value: function _destroyToolInstance() {
              var _context4, _this3 = this;
              forEach_default()(concat_default()(_context4 = []).call(_context4, RANGE_INSTANCE_NAMES, COLORPICKER_INSTANCE_NAMES), function(instanceName) {
                _this3._els[instanceName].destroy();
              });
            }
          }, {
            key: "addEvent",
            value: function addEvent2(_ref2) {
              var _this4 = this, _context6, _context7, _context8;
              var applyFilter = _ref2.applyFilter;
              var changeFilterState = function changeFilterState2(filterName) {
                var _context5;
                return bind_default()(_context5 = _this4._changeFilterState).call(_context5, _this4, applyFilter, filterName);
              };
              var changeFilterStateForRange = function changeFilterStateForRange2(filterName) {
                return function(value, isLast) {
                  return _this4._changeFilterState(applyFilter, filterName, isLast);
                };
              };
              this.eventHandler = {
                changeBlendFilter: changeFilterState("blend"),
                blandTypeClick: function blandTypeClick(event) {
                  return event.stopPropagation();
                }
              };
              forEach_default()(FILTER_OPTIONS, function(filter2) {
                var filterCheckElement = _this4.selector(".tie-".concat(filter2));
                var filterNameCamelCase = toCamelCase(filter2);
                _this4.checkedMap[filterNameCamelCase] = filterCheckElement;
                _this4.eventHandler[filterNameCamelCase] = changeFilterState(filterNameCamelCase);
                filterCheckElement.addEventListener("change", _this4.eventHandler[filterNameCamelCase]);
              });
              this._els.removewhiteDistanceRange.on("change", changeFilterStateForRange("removeWhite"));
              this._els.colorfilterThresholdRange.on("change", changeFilterStateForRange("colorFilter"));
              this._els.pixelateRange.on("change", changeFilterStateForRange("pixelate"));
              this._els.noiseRange.on("change", changeFilterStateForRange("noise"));
              this._els.brightnessRange.on("change", changeFilterStateForRange("brightness"));
              this._els.filterBlendColor.on("change", this.eventHandler.changeBlendFilter);
              this._els.filterMultiplyColor.on("change", changeFilterState("multiply"));
              this._els.filterTintColor.on("change", changeFilterState("tint"));
              this._els.tintOpacity.on("change", changeFilterStateForRange("tint"));
              this._els.filterMultiplyColor.on("changeShow", bind_default()(_context6 = this.colorPickerChangeShow).call(_context6, this));
              this._els.filterTintColor.on("changeShow", bind_default()(_context7 = this.colorPickerChangeShow).call(_context7, this));
              this._els.filterBlendColor.on("changeShow", bind_default()(_context8 = this.colorPickerChangeShow).call(_context8, this));
              this._els.blendType.addEventListener("change", this.eventHandler.changeBlendFilter);
              this._els.blendType.addEventListener("click", this.eventHandler.blandTypeClick);
              forEachArray_default()(this.colorPickerInputBoxes, function(inputBox) {
                var _context9, _context10;
                inputBox.addEventListener(eventNames.FOCUS, bind_default()(_context9 = _this4._onStartEditingInputBox).call(_context9, _this4));
                inputBox.addEventListener(eventNames.BLUR, bind_default()(_context10 = _this4._onStopEditingInputBox).call(_context10, _this4));
              }, this);
            }
          }, {
            key: "setFilterState",
            value: function setFilterState(changedFilterInfos) {
              var type = changedFilterInfos.type, options = changedFilterInfos.options, action2 = changedFilterInfos.action;
              var filterName = this._getFilterNameFromOptions(type, options);
              var isRemove = action2 === "remove";
              if (!isRemove) {
                this._setFilterState(filterName, options);
              }
              this.checkedMap[filterName].checked = !isRemove;
            }
          }, {
            key: "initFilterCheckBoxState",
            value: function initFilterCheckBoxState() {
              forEach_default()(this.checkedMap, function(filter2) {
                filter2.checked = false;
              }, this);
            }
          }, {
            key: "_setFilterState",
            value: function _setFilterState(filterName, options) {
              if (filterName === "colorFilter") {
                this._els.colorfilterThresholdRange.value = options.distance;
              } else if (filterName === "removeWhite") {
                this._els.removewhiteDistanceRange.value = options.distance;
              } else if (filterName === "pixelate") {
                this._els.pixelateRange.value = options.blocksize;
              } else if (filterName === "brightness") {
                this._els.brightnessRange.value = options.brightness;
              } else if (filterName === "noise") {
                this._els.noiseRange.value = options.noise;
              } else if (filterName === "tint") {
                this._els.tintOpacity.value = options.alpha;
                this._els.filterTintColor.color = options.color;
              } else if (filterName === "blend") {
                this._els.filterBlendColor.color = options.color;
              } else if (filterName === "multiply") {
                this._els.filterMultiplyColor.color = options.color;
              }
            }
          }, {
            key: "_getFilterNameFromOptions",
            value: function _getFilterNameFromOptions(type, options) {
              var filterName = type;
              if (type === "removeColor") {
                filterName = isExisty_default()(options.useAlpha) ? "removeWhite" : "colorFilter";
              } else if (type === "blendColor") {
                filterName = {
                  add: "blend",
                  multiply: "multiply",
                  tint: "tint"
                }[options.mode];
              }
              return filterName;
            }
          }, {
            key: "_changeFilterState",
            value: function _changeFilterState(applyFilter, filterName) {
              var isLast = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
              var apply = this.checkedMap[filterName].checked;
              var type = filterNameMap[filterName];
              var checkboxGroup = this.checkedMap[filterName].closest(".tui-image-editor-checkbox-group");
              if (checkboxGroup) {
                if (apply) {
                  checkboxGroup.classList.remove("tui-image-editor-disabled");
                } else {
                  checkboxGroup.classList.add("tui-image-editor-disabled");
                }
              }
              applyFilter(apply, type, this._getFilterOption(filterName), !isLast);
            }
          }, {
            key: "_getFilterOption",
            value: function _getFilterOption(type) {
              var option2 = {};
              switch (type) {
                case "removeWhite":
                  option2.color = "#FFFFFF";
                  option2.useAlpha = false;
                  option2.distance = parse_float_default()(this._els.removewhiteDistanceRange.value);
                  break;
                case "colorFilter":
                  option2.color = "#FFFFFF";
                  option2.distance = parse_float_default()(this._els.colorfilterThresholdRange.value);
                  break;
                case "pixelate":
                  option2.blocksize = toInteger(this._els.pixelateRange.value);
                  break;
                case "noise":
                  option2.noise = toInteger(this._els.noiseRange.value);
                  break;
                case "brightness":
                  option2.brightness = parse_float_default()(this._els.brightnessRange.value);
                  break;
                case "blend":
                  option2.mode = "add";
                  option2.color = this._els.filterBlendColor.color;
                  option2.mode = this._els.blendType.value;
                  break;
                case "multiply":
                  option2.mode = "multiply";
                  option2.color = this._els.filterMultiplyColor.color;
                  break;
                case "tint":
                  option2.mode = "tint";
                  option2.color = this._els.filterTintColor.color;
                  option2.alpha = this._els.tintOpacity.value;
                  break;
                case "blur":
                  option2.blur = this._els.blurRange.value;
                  break;
              }
              return option2;
            }
          }, {
            key: "_makeControlElement",
            value: function _makeControlElement() {
              this._els = {
                removewhiteDistanceRange: new range({
                  slider: this.selector(".tie-removewhite-distance-range")
                }, defaultFilterRangeValues.removewhiteDistanceRange),
                brightnessRange: new range({
                  slider: this.selector(".tie-brightness-range")
                }, defaultFilterRangeValues.brightnessRange),
                noiseRange: new range({
                  slider: this.selector(".tie-noise-range")
                }, defaultFilterRangeValues.noiseRange),
                pixelateRange: new range({
                  slider: this.selector(".tie-pixelate-range")
                }, defaultFilterRangeValues.pixelateRange),
                colorfilterThresholdRange: new range({
                  slider: this.selector(".tie-colorfilter-threshold-range")
                }, defaultFilterRangeValues.colorfilterThresholdRange),
                filterTintColor: new colorpicker(this.selector(".tie-filter-tint-color"), {
                  defaultColor: "#03bd9e",
                  toggleDirection: this.toggleDirection,
                  usageStatistics: this.usageStatistics
                }),
                filterMultiplyColor: new colorpicker(this.selector(".tie-filter-multiply-color"), {
                  defaultColor: "#515ce6",
                  toggleDirection: this.toggleDirection,
                  usageStatistics: this.usageStatistics
                }),
                filterBlendColor: new colorpicker(this.selector(".tie-filter-blend-color"), {
                  defaultColor: "#ffbb3b",
                  toggleDirection: this.toggleDirection,
                  usageStatistics: this.usageStatistics
                }),
                blurRange: defaultFilterRangeValues.blurFilterRange
              };
              this._els.tintOpacity = this._pickerWithRange(this._els.filterTintColor.pickerControl);
              this._els.blendType = this._pickerWithSelectbox(this._els.filterBlendColor.pickerControl);
              this.colorPickerControls.push(this._els.filterTintColor);
              this.colorPickerControls.push(this._els.filterMultiplyColor);
              this.colorPickerControls.push(this._els.filterBlendColor);
              this.colorPickerInputBoxes = [];
              this.colorPickerInputBoxes.push(this._els.filterTintColor.colorpickerElement.querySelector(selectorNames.COLOR_PICKER_INPUT_BOX));
              this.colorPickerInputBoxes.push(this._els.filterMultiplyColor.colorpickerElement.querySelector(selectorNames.COLOR_PICKER_INPUT_BOX));
              this.colorPickerInputBoxes.push(this._els.filterBlendColor.colorpickerElement.querySelector(selectorNames.COLOR_PICKER_INPUT_BOX));
            }
          }, {
            key: "_pickerWithRange",
            value: function _pickerWithRange(pickerControl) {
              var rangeWrap = document.createElement("div");
              var rangeLabel = document.createElement("label");
              var slider = document.createElement("div");
              slider.id = "tie-filter-tint-opacity";
              rangeLabel.innerHTML = "Opacity";
              rangeWrap.appendChild(rangeLabel);
              rangeWrap.appendChild(slider);
              pickerControl.appendChild(rangeWrap);
              pickerControl.style.height = PICKER_CONTROL_HEIGHT;
              return new range({
                slider
              }, defaultFilterRangeValues.tintOpacityRange);
            }
          }, {
            key: "_pickerWithSelectbox",
            value: function _pickerWithSelectbox(pickerControl) {
              var selectlistWrap = document.createElement("div");
              var selectlist = document.createElement("select");
              var optionlist = document.createElement("ul");
              selectlistWrap.className = "tui-image-editor-selectlist-wrap";
              optionlist.className = "tui-image-editor-selectlist";
              selectlistWrap.appendChild(selectlist);
              selectlistWrap.appendChild(optionlist);
              this._makeSelectOptionList(selectlist);
              pickerControl.appendChild(selectlistWrap);
              pickerControl.style.height = PICKER_CONTROL_HEIGHT;
              this._drawSelectOptionList(selectlist, optionlist);
              this._pickerWithSelectboxForAddEvent(selectlist, optionlist);
              return selectlist;
            }
          }, {
            key: "_drawSelectOptionList",
            value: function _drawSelectOptionList(selectlist, optionlist) {
              var options = selectlist.querySelectorAll("option");
              forEach_default()(options, function(option2) {
                var optionElement = document.createElement("li");
                optionElement.innerHTML = option2.innerHTML;
                optionElement.setAttribute("data-item", option2.value);
                optionlist.appendChild(optionElement);
              });
            }
          }, {
            key: "_pickerWithSelectboxForAddEvent",
            value: function _pickerWithSelectboxForAddEvent(selectlist, optionlist) {
              var _this5 = this;
              optionlist.addEventListener("click", function(event) {
                var optionValue = event.target.getAttribute("data-item");
                var fireEvent = document.createEvent("HTMLEvents");
                selectlist.querySelector('[value="'.concat(optionValue, '"]')).selected = true;
                fireEvent.initEvent("change", true, true);
                selectlist.dispatchEvent(fireEvent);
                _this5.selectBoxShow = false;
                optionlist.style.display = "none";
              });
              selectlist.addEventListener("mousedown", function(event) {
                event.preventDefault();
                _this5.selectBoxShow = !_this5.selectBoxShow;
                optionlist.style.display = _this5.selectBoxShow ? "block" : "none";
                optionlist.setAttribute("data-selectitem", selectlist.value);
                optionlist.querySelector("[data-item='".concat(selectlist.value, "']")).classList.add("active");
              });
            }
          }, {
            key: "_makeSelectOptionList",
            value: function _makeSelectOptionList(selectlist) {
              forEach_default()(BLEND_OPTIONS, function(option2) {
                var selectOption = document.createElement("option");
                selectOption.setAttribute("value", option2);
                selectOption.innerHTML = option2.replace(/^[a-z]/, function($0) {
                  return $0.toUpperCase();
                });
                selectlist.appendChild(selectOption);
              });
            }
          }]);
          return Filter2;
        }(submenuBase);
        var ui_filter = Filter;
        var number_parse_int = __webpack_require__(4383);
        var number_parse_int_default = /* @__PURE__ */ __webpack_require__.n(number_parse_int);
        var Panel = /* @__PURE__ */ function() {
          function Panel2(menuElement, _ref) {
            var name2 = _ref.name;
            _classCallCheck(this, Panel2);
            this.name = name2;
            this.items = [];
            this.panelElement = this._makePanelElement();
            this.listElement = this._makeListElement();
            this.panelElement.appendChild(this.listElement);
            menuElement.appendChild(this.panelElement);
          }
          _createClass(Panel2, [{
            key: "_makePanelElement",
            value: function _makePanelElement() {
              var panel = document.createElement("div");
              panel.className = "tie-panel-".concat(this.name);
              return panel;
            }
          }, {
            key: "_makeListElement",
            value: function _makeListElement() {
              var list = document.createElement("ol");
              list.className = "".concat(this.name, "-list");
              return list;
            }
          }, {
            key: "makeListItemElement",
            value: function makeListItemElement(html) {
              var listItem = document.createElement("li");
              listItem.innerHTML = html;
              listItem.className = "".concat(this.name, "-item");
              listItem.setAttribute("data-index", this.items.length);
              return listItem;
            }
          }, {
            key: "pushListItemElement",
            value: function pushListItemElement(item) {
              this.listElement.appendChild(item);
              this.listElement.scrollTop += item.offsetHeight;
              this.items.push(item);
            }
          }, {
            key: "deleteListItemElement",
            value: function deleteListItemElement(start, end) {
              var items = this.items;
              for (var i = start; i < end; i += 1) {
                this.listElement.removeChild(items[i]);
              }
              splice_default()(items).call(items, start, end - start + 1);
            }
          }, {
            key: "getListLength",
            value: function getListLength() {
              return this.items.length;
            }
          }, {
            key: "addClass",
            value: function addClass2(index2, className) {
              if (this.items[index2]) {
                this.items[index2].classList.add(className);
              }
            }
          }, {
            key: "removeClass",
            value: function removeClass2(index2, className) {
              if (this.items[index2]) {
                this.items[index2].classList.remove(className);
              }
            }
          }, {
            key: "toggleClass",
            value: function toggleClass2(index2, className) {
              if (this.items[index2]) {
                this.items[index2].classList.toggle(className);
              }
            }
          }]);
          return Panel2;
        }();
        var panelMenu = Panel;
        var submenu_history = function(_ref) {
          var _context2, _context22, _context3;
          var locale2 = _ref.locale, makeSvgIcon = _ref.makeSvgIcon, name2 = _ref.name, detail = _ref.detail;
          return concat_default()(_context2 = concat_default()(_context22 = concat_default()(_context3 = '\n    <div class="tui-image-editor-history-item history">\n        <div class="history-item-icon">\n            '.concat(makeSvgIcon(["normal", "active"], "history-".concat(name2.toLowerCase()), true), "\n        </div>\n        <span>\n            ")).call(_context3, locale2.localize(name2), "\n            ")).call(_context22, detail ? "(".concat(locale2.localize(detail), ")") : "", '\n        </span>\n        <div class="history-item-checkbox">\n            ')).call(_context2, makeSvgIcon(["normal"], "history-check", true), "\n        </div>\n    </div>\n");
        };
        function history_createSuper(Derived) {
          var hasNativeReflectConstruct = history_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function history_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var historyClassName = "history-item";
        var selectedClassName = "selected-item";
        var disabledClassName = "disabled-item";
        var History = /* @__PURE__ */ function(_Panel) {
          _inherits(History2, _Panel);
          var _super = history_createSuper(History2);
          function History2(menuElement, _ref) {
            var _this;
            var locale2 = _ref.locale, makeSvgIcon = _ref.makeSvgIcon;
            _classCallCheck(this, History2);
            _this = _super.call(this, menuElement, {
              name: "history"
            });
            menuElement.classList.add("enabled");
            _this.locale = locale2;
            _this.makeSvgIcon = makeSvgIcon;
            _this._eventHandler = {};
            _this._historyIndex = _this.getListLength();
            return _this;
          }
          _createClass(History2, [{
            key: "add",
            value: function add2(_ref2) {
              var name2 = _ref2.name, detail = _ref2.detail;
              if (this._hasDisabledItem()) {
                this.deleteListItemElement(this._historyIndex + 1, this.getListLength());
              }
              var html = submenu_history({
                locale: this.locale,
                makeSvgIcon: this.makeSvgIcon,
                name: name2,
                detail
              });
              var item = this.makeListItemElement(html);
              this.pushListItemElement(item);
              this._historyIndex = this.getListLength() - 1;
              this._selectItem(this._historyIndex);
            }
          }, {
            key: "init",
            value: function init2() {
              this.deleteListItemElement(1, this.getListLength());
              this._historyIndex = 0;
              this._selectItem(this._historyIndex);
            }
          }, {
            key: "clear",
            value: function clear() {
              this.deleteListItemElement(0, this.getListLength());
              this._historyIndex = -1;
            }
          }, {
            key: "prev",
            value: function prev() {
              this._historyIndex -= 1;
              this._selectItem(this._historyIndex);
            }
          }, {
            key: "next",
            value: function next() {
              this._historyIndex += 1;
              this._selectItem(this._historyIndex);
            }
          }, {
            key: "_hasDisabledItem",
            value: function _hasDisabledItem() {
              return this.getListLength() - 1 > this._historyIndex;
            }
          }, {
            key: "_addHistoryEventListener",
            value: function _addHistoryEventListener() {
              var _this2 = this;
              this._eventHandler.history = function(event) {
                return _this2._clickHistoryItem(event);
              };
              this.listElement.addEventListener("click", this._eventHandler.history);
            }
          }, {
            key: "_removeHistoryEventListener",
            value: function _removeHistoryEventListener() {
              this.listElement.removeEventListener("click", this._eventHandler.history);
            }
          }, {
            key: "_clickHistoryItem",
            value: function _clickHistoryItem(event) {
              var target = event.target;
              var item = target.closest(".".concat(historyClassName));
              if (!item) {
                return;
              }
              var index2 = number_parse_int_default()(item.getAttribute("data-index"), 10);
              if (index2 !== this._historyIndex) {
                var count = Math.abs(index2 - this._historyIndex);
                if (index2 < this._historyIndex) {
                  this._actions.undo(count);
                } else {
                  this._actions.redo(count);
                }
              }
            }
          }, {
            key: "_selectItem",
            value: function _selectItem(index2) {
              for (var i = 0; i < this.getListLength(); i += 1) {
                this.removeClass(i, selectedClassName);
                this.removeClass(i, disabledClassName);
                if (i > index2) {
                  this.addClass(i, disabledClassName);
                }
              }
              this.addClass(index2, selectedClassName);
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              this.removeEvent();
              assignmentForDestroy(this);
            }
          }, {
            key: "addEvent",
            value: function addEvent2(actions2) {
              this._actions = actions2;
              this._addHistoryEventListener();
            }
          }, {
            key: "removeEvent",
            value: function removeEvent2() {
              this._removeHistoryEventListener();
            }
          }]);
          return History2;
        }(panelMenu);
        var ui_history = History;
        var Locale = /* @__PURE__ */ function() {
          function Locale2(locale2) {
            _classCallCheck(this, Locale2);
            this._locale = locale2;
          }
          _createClass(Locale2, [{
            key: "localize",
            value: function localize(message) {
              return this._locale[message] || message;
            }
          }]);
          return Locale2;
        }();
        var locale = Locale;
        var SUB_UI_COMPONENT = {
          Shape: ui_shape,
          Crop: ui_crop,
          Resize: ui_resize,
          Flip: ui_flip,
          Rotate: ui_rotate,
          Text: ui_text,
          Mask: ui_mask,
          Icon: ui_icon,
          Draw: ui_draw,
          Filter: ui_filter
        };
        var BI_EXPRESSION_MINSIZE_WHEN_TOP_POSITION = "1300";
        var HISTORY_MENU = "history";
        var HISTORY_PANEL_CLASS_NAME = "tie-panel-history";
        var CLASS_NAME_ON = "on";
        var ZOOM_BUTTON_TYPE = {
          ZOOM_IN: "zoomIn",
          HAND: "hand"
        };
        var Ui = /* @__PURE__ */ function() {
          function Ui2(element, options, actions2) {
            _classCallCheck(this, Ui2);
            this.options = this._initializeOption(options);
            this._actions = actions2;
            this.submenu = false;
            this.imageSize = {};
            this.uiSize = {};
            this._locale = new locale(this.options.locale);
            this.theme = new theme(this.options.theme);
            this.eventHandler = {};
            this._submenuChangeTransection = false;
            this._selectedElement = null;
            this._mainElement = null;
            this._editorElementWrap = null;
            this._editorElement = null;
            this._menuBarElement = null;
            this._subMenuElement = null;
            this._makeUiElement(element);
            this._setUiSize();
            this._initMenuEvent = false;
            this._makeSubMenu();
            this._attachHistoryEvent();
            this._attachZoomEvent();
          }
          _createClass(Ui2, [{
            key: "destroy",
            value: function destroy2() {
              this._removeUiEvent();
              this._destroyAllMenu();
              this._selectedElement.innerHTML = "";
              assignmentForDestroy(this);
            }
          }, {
            key: "setUiDefaultSelectionStyle",
            value: function setUiDefaultSelectionStyle(option2) {
              return extend_default()({
                applyCropSelectionStyle: true,
                applyGroupSelectionStyle: true,
                selectionStyle: {
                  cornerStyle: "circle",
                  cornerSize: 16,
                  cornerColor: "#fff",
                  cornerStrokeColor: "#fff",
                  transparentCorners: false,
                  lineWidth: 2,
                  borderColor: "#fff"
                }
              }, option2);
            }
          }, {
            key: "resizeEditor",
            value: function resizeEditor() {
              var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, uiSize = _ref.uiSize, _ref$imageSize = _ref.imageSize, imageSize = _ref$imageSize === void 0 ? this.imageSize : _ref$imageSize;
              if (imageSize !== this.imageSize) {
                this.imageSize = imageSize;
              }
              if (uiSize) {
                this._setUiSize(uiSize);
              }
              var _this$_getCanvasMaxDi = this._getCanvasMaxDimension(), width = _this$_getCanvasMaxDi.width, height = _this$_getCanvasMaxDi.height;
              var editorElementStyle = this._editorElement.style;
              var menuBarPosition = this.options.menuBarPosition;
              editorElementStyle.height = "".concat(height, "px");
              editorElementStyle.width = "".concat(width, "px");
              this._setEditorPosition(menuBarPosition);
              this._editorElementWrap.style.bottom = "0px";
              this._editorElementWrap.style.top = "0px";
              this._editorElementWrap.style.left = "0px";
              this._editorElementWrap.style.width = "100%";
              var selectElementClassList = this._selectedElement.classList;
              if (menuBarPosition === "top" && this._selectedElement.offsetWidth < BI_EXPRESSION_MINSIZE_WHEN_TOP_POSITION) {
                selectElementClassList.add("tui-image-editor-top-optimization");
              } else {
                selectElementClassList.remove("tui-image-editor-top-optimization");
              }
            }
          }, {
            key: "toggleZoomButtonStatus",
            value: function toggleZoomButtonStatus(type) {
              var targetClassList = this._buttonElements[type].classList;
              targetClassList.toggle(CLASS_NAME_ON);
              if (type === ZOOM_BUTTON_TYPE.ZOOM_IN) {
                this._buttonElements[ZOOM_BUTTON_TYPE.HAND].classList.remove(CLASS_NAME_ON);
              } else {
                this._buttonElements[ZOOM_BUTTON_TYPE.ZOOM_IN].classList.remove(CLASS_NAME_ON);
              }
            }
          }, {
            key: "offZoomInButtonStatus",
            value: function offZoomInButtonStatus() {
              var zoomInClassList = this._buttonElements[ZOOM_BUTTON_TYPE.ZOOM_IN].classList;
              zoomInClassList.remove(CLASS_NAME_ON);
            }
          }, {
            key: "changeHandButtonStatus",
            value: function changeHandButtonStatus(enabled) {
              var handClassList = this._buttonElements[ZOOM_BUTTON_TYPE.HAND].classList;
              handClassList[enabled ? "add" : "remove"](CLASS_NAME_ON);
            }
          }, {
            key: "changeHelpButtonEnabled",
            value: function changeHelpButtonEnabled(buttonType, enableStatus) {
              var buttonClassList = this._buttonElements[buttonType].classList;
              buttonClassList[enableStatus ? "add" : "remove"]("enabled");
            }
          }, {
            key: "_initializeOption",
            value: function _initializeOption(options) {
              return extend_default()({
                loadImage: {
                  path: "",
                  name: ""
                },
                locale: {},
                menuIconPath: "",
                menu: ["resize", "crop", "flip", "rotate", "draw", "shape", "icon", "text", "mask", "filter"],
                initMenu: "",
                uiSize: {
                  width: "100%",
                  height: "100%"
                },
                menuBarPosition: "bottom"
              }, options);
            }
          }, {
            key: "_setUiSize",
            value: function _setUiSize() {
              var uiSize = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.options.uiSize;
              var elementDimension = this._selectedElement.style;
              elementDimension.width = uiSize.width;
              elementDimension.height = uiSize.height;
            }
          }, {
            key: "_makeSubMenu",
            value: function _makeSubMenu() {
              var _this = this;
              forEach_default()(this.options.menu, function(menuName) {
                var _context2;
                var SubComponentClass = SUB_UI_COMPONENT[menuName.replace(/^[a-z]/, function($0) {
                  return $0.toUpperCase();
                })];
                _this._makeMenuElement(menuName);
                _this._buttonElements[menuName] = _this._menuBarElement.querySelector(".tie-btn-".concat(menuName));
                _this[menuName] = new SubComponentClass(_this._subMenuElement, {
                  locale: _this._locale,
                  makeSvgIcon: bind_default()(_context2 = _this.theme.makeMenSvgIconSet).call(_context2, _this.theme),
                  menuBarPosition: _this.options.menuBarPosition,
                  usageStatistics: _this.options.usageStatistics
                });
              });
            }
          }, {
            key: "_attachHistoryEvent",
            value: function _attachHistoryEvent() {
              var _context2, _context3, _context4;
              this.on(eventNames.EXECUTE_COMMAND, bind_default()(_context2 = this._addHistory).call(_context2, this));
              this.on(eventNames.AFTER_UNDO, bind_default()(_context3 = this._selectPrevHistory).call(_context3, this));
              this.on(eventNames.AFTER_REDO, bind_default()(_context4 = this._selectNextHistory).call(_context4, this));
            }
          }, {
            key: "_attachZoomEvent",
            value: function _attachZoomEvent() {
              var _this2 = this;
              this.on(eventNames.HAND_STARTED, function() {
                _this2.offZoomInButtonStatus();
                _this2.changeHandButtonStatus(true);
              });
              this.on(eventNames.HAND_STOPPED, function() {
                return _this2.changeHandButtonStatus(false);
              });
            }
          }, {
            key: "_makeUiElement",
            value: function _makeUiElement(element) {
              var _context5;
              var selectedElement;
              if (element.nodeType) {
                selectedElement = element;
              } else {
                selectedElement = document.querySelector(element);
              }
              var selector = getSelector(selectedElement);
              selectedElement.classList.add("tui-image-editor-container");
              selectedElement.innerHTML = controls({
                locale: this._locale,
                biImage: this.theme.getStyle("common.bi"),
                loadButtonStyle: this.theme.getStyle("loadButton"),
                downloadButtonStyle: this.theme.getStyle("downloadButton"),
                menuBarPosition: this.options.menuBarPosition
              }) + mainContainer({
                locale: this._locale,
                biImage: this.theme.getStyle("common.bi"),
                commonStyle: this.theme.getStyle("common"),
                headerStyle: this.theme.getStyle("header"),
                loadButtonStyle: this.theme.getStyle("loadButton"),
                downloadButtonStyle: this.theme.getStyle("downloadButton"),
                submenuStyle: this.theme.getStyle("submenu")
              });
              this._selectedElement = selectedElement;
              this._selectedElement.classList.add(this.options.menuBarPosition);
              this._mainElement = selector(".tui-image-editor-main");
              this._editorElementWrap = selector(".tui-image-editor-wrap");
              this._editorElement = selector(".tui-image-editor");
              this._helpMenuBarElement = selector(".tui-image-editor-help-menu");
              this._menuBarElement = selector(".tui-image-editor-menu");
              this._subMenuElement = selector(".tui-image-editor-submenu");
              this._buttonElements = {
                download: this._selectedElement.querySelectorAll(".tui-image-editor-download-btn"),
                load: this._selectedElement.querySelectorAll(".tui-image-editor-load-btn")
              };
              this._addHelpMenus();
              this._historyMenu = new ui_history(this._buttonElements[HISTORY_MENU], {
                locale: this._locale,
                makeSvgIcon: bind_default()(_context5 = this.theme.makeMenSvgIconSet).call(_context5, this.theme)
              });
              this._activateZoomMenus();
            }
          }, {
            key: "_activateZoomMenus",
            value: function _activateZoomMenus() {
              var _this3 = this;
              forEach_default()(ZOOM_HELP_MENUS, function(menu) {
                _this3.changeHelpButtonEnabled(menu, true);
              });
            }
          }, {
            key: "_makeHelpMenuWithPartition",
            value: function _makeHelpMenuWithPartition() {
              var _context6;
              return concat_default()(_context6 = []).call(_context6, _toConsumableArray(ZOOM_HELP_MENUS), [""], _toConsumableArray(COMMAND_HELP_MENUS), [""], _toConsumableArray(DELETE_HELP_MENUS));
            }
          }, {
            key: "_addHelpMenus",
            value: function _addHelpMenus() {
              var _this4 = this;
              var helpMenuWithPartition = this._makeHelpMenuWithPartition();
              forEach_default()(helpMenuWithPartition, function(menuName) {
                if (!menuName) {
                  _this4._makeMenuPartitionElement();
                } else {
                  _this4._makeMenuElement(menuName, ["normal", "disabled", "hover"], "help");
                  _this4._buttonElements[menuName] = _this4._helpMenuBarElement.querySelector(".tie-btn-".concat(menuName));
                }
              });
            }
          }, {
            key: "_makeMenuPartitionElement",
            value: function _makeMenuPartitionElement() {
              var partitionElement = document.createElement("li");
              var partitionInnerElement = document.createElement("div");
              partitionElement.className = cls("item");
              partitionInnerElement.className = cls("icpartition");
              partitionElement.appendChild(partitionInnerElement);
              this._helpMenuBarElement.appendChild(partitionElement);
            }
          }, {
            key: "_makeMenuElement",
            value: function _makeMenuElement(menuName) {
              var _context7, _context8;
              var useIconTypes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ["normal", "active", "hover"];
              var menuType = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "normal";
              var btnElement = document.createElement("li");
              var menuItemHtml = this.theme.makeMenSvgIconSet(useIconTypes, menuName);
              this._addTooltipAttribute(btnElement, menuName);
              btnElement.className = concat_default()(_context7 = concat_default()(_context8 = "tie-btn-".concat(menuName, " ")).call(_context8, cls("item"), " ")).call(_context7, menuType);
              btnElement.innerHTML = menuItemHtml;
              if (menuType === "normal") {
                this._menuBarElement.appendChild(btnElement);
              } else {
                this._helpMenuBarElement.appendChild(btnElement);
              }
            }
          }, {
            key: "_addHelpActionEvent",
            value: function _addHelpActionEvent() {
              var _this5 = this;
              forEach_default()(HELP_MENUS, function(helpName) {
                _this5.eventHandler[helpName] = function(event) {
                  return _this5._actions.main[helpName](event);
                };
                _this5._buttonElements[helpName].addEventListener("click", _this5.eventHandler[helpName]);
              });
            }
          }, {
            key: "_removeHelpActionEvent",
            value: function _removeHelpActionEvent() {
              var _this6 = this;
              forEach_default()(HELP_MENUS, function(helpName) {
                _this6._buttonElements[helpName].removeEventListener("click", _this6.eventHandler[helpName]);
              });
            }
          }, {
            key: "_addHistory",
            value: function _addHistory(command2) {
              if (!isSilentCommand(command2)) {
                var historyTitle = typeof command2 === "string" ? {
                  name: command2
                } : getHistoryTitle(command2);
                this._historyMenu.add(historyTitle);
              }
            }
          }, {
            key: "initHistory",
            value: function initHistory() {
              this._historyMenu.init();
            }
          }, {
            key: "clearHistory",
            value: function clearHistory() {
              this._historyMenu.clear();
            }
          }, {
            key: "_selectPrevHistory",
            value: function _selectPrevHistory() {
              this._historyMenu.prev();
            }
          }, {
            key: "_selectNextHistory",
            value: function _selectNextHistory() {
              this._historyMenu.next();
            }
          }, {
            key: "toggleHistoryMenu",
            value: function toggleHistoryMenu(event) {
              var target = event.target;
              var item = target.closest(".".concat(HISTORY_PANEL_CLASS_NAME));
              if (item) {
                return;
              }
              var historyButtonClassList = this._buttonElements[HISTORY_MENU].classList;
              historyButtonClassList.toggle("opened");
            }
          }, {
            key: "_addTooltipAttribute",
            value: function _addTooltipAttribute(element, tooltipName) {
              element.setAttribute("tooltip-content", this._locale.localize(tooltipName.replace(/^[a-z]/g, function($0) {
                return $0.toUpperCase();
              })));
            }
          }, {
            key: "_addDownloadEvent",
            value: function _addDownloadEvent() {
              var _this7 = this;
              this.eventHandler.download = function() {
                return _this7._actions.main.download();
              };
              forEach_default()(this._buttonElements.download, function(element) {
                element.addEventListener("click", _this7.eventHandler.download);
              });
            }
          }, {
            key: "_removeDownloadEvent",
            value: function _removeDownloadEvent() {
              var _this8 = this;
              forEach_default()(this._buttonElements.download, function(element) {
                element.removeEventListener("click", _this8.eventHandler.download);
              });
            }
          }, {
            key: "_addLoadEvent",
            value: function _addLoadEvent() {
              var _this9 = this;
              this.eventHandler.loadImage = function(event) {
                return _this9._actions.main.load(event.target.files[0]);
              };
              forEach_default()(this._buttonElements.load, function(element) {
                element.addEventListener("change", _this9.eventHandler.loadImage);
              });
            }
          }, {
            key: "_removeLoadEvent",
            value: function _removeLoadEvent() {
              var _this10 = this;
              forEach_default()(this._buttonElements.load, function(element) {
                element.removeEventListener("change", _this10.eventHandler.loadImage);
              });
            }
          }, {
            key: "_addMainMenuEvent",
            value: function _addMainMenuEvent(menuName) {
              var _this11 = this;
              this.eventHandler[menuName] = function() {
                return _this11.changeMenu(menuName);
              };
              this._buttonElements[menuName].addEventListener("click", this.eventHandler[menuName]);
            }
          }, {
            key: "_addSubMenuEvent",
            value: function _addSubMenuEvent(menuName) {
              var _this12 = this;
              this[menuName].addEvent(this._actions[menuName]);
              this[menuName].on(eventNames.INPUT_BOX_EDITING_STARTED, function() {
                return _this12.fire(eventNames.INPUT_BOX_EDITING_STARTED);
              });
              this[menuName].on(eventNames.INPUT_BOX_EDITING_STOPPED, function() {
                return _this12.fire(eventNames.INPUT_BOX_EDITING_STOPPED);
              });
            }
          }, {
            key: "_addMenuEvent",
            value: function _addMenuEvent() {
              var _this13 = this;
              forEach_default()(this.options.menu, function(menuName) {
                _this13._addMainMenuEvent(menuName);
                _this13._addSubMenuEvent(menuName);
              });
            }
          }, {
            key: "_removeMainMenuEvent",
            value: function _removeMainMenuEvent() {
              var _this14 = this;
              forEach_default()(this.options.menu, function(menuName) {
                _this14._buttonElements[menuName].removeEventListener("click", _this14.eventHandler[menuName]);
                _this14[menuName].off(eventNames.INPUT_BOX_EDITING_STARTED);
                _this14[menuName].off(eventNames.INPUT_BOX_EDITING_STOPPED);
              });
            }
          }, {
            key: "getEditorArea",
            value: function getEditorArea() {
              return this._editorElement;
            }
          }, {
            key: "activeMenuEvent",
            value: function activeMenuEvent() {
              if (this._initMenuEvent) {
                return;
              }
              this._addHelpActionEvent();
              this._addDownloadEvent();
              this._addMenuEvent();
              this._initMenu();
              this._historyMenu.addEvent(this._actions.history);
              this._initMenuEvent = true;
            }
          }, {
            key: "_removeUiEvent",
            value: function _removeUiEvent() {
              this._removeHelpActionEvent();
              this._removeDownloadEvent();
              this._removeLoadEvent();
              this._removeMainMenuEvent();
              this._historyMenu.removeEvent();
            }
          }, {
            key: "_destroyAllMenu",
            value: function _destroyAllMenu() {
              var _this15 = this;
              forEach_default()(this.options.menu, function(menuName) {
                _this15[menuName].destroy();
              });
              this._historyMenu.destroy();
            }
          }, {
            key: "initCanvas",
            value: function initCanvas() {
              var _this16 = this;
              var loadImageInfo = this._getLoadImage();
              if (loadImageInfo.path) {
                this._actions.main.initLoadImage(loadImageInfo.path, loadImageInfo.name).then(function() {
                  _this16.activeMenuEvent();
                });
              }
              this._addLoadEvent();
              var gridVisual = document.createElement("div");
              gridVisual.className = cls("grid-visual");
              var grid = '<table>\n           <tr><td class="dot left-top"></td><td></td><td class="dot right-top"></td></tr>\n           <tr><td></td><td></td><td></td></tr>\n           <tr><td class="dot left-bottom"></td><td></td><td class="dot right-bottom"></td></tr>\n         </table>';
              gridVisual.innerHTML = grid;
              this._editorContainerElement = this._editorElement.querySelector(".tui-image-editor-canvas-container");
              this._editorContainerElement.appendChild(gridVisual);
            }
          }, {
            key: "_getLoadImage",
            value: function _getLoadImage() {
              return this.options.loadImage;
            }
          }, {
            key: "changeMenu",
            value: function changeMenu(menuName) {
              var toggle = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
              var discardSelection = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
              if (!this._submenuChangeTransection) {
                this._submenuChangeTransection = true;
                this._changeMenu(menuName, toggle, discardSelection);
                this._submenuChangeTransection = false;
              }
            }
          }, {
            key: "_changeMenu",
            value: function _changeMenu(menuName, toggle, discardSelection) {
              if (this.submenu) {
                this._buttonElements[this.submenu].classList.remove("active");
                this._mainElement.classList.remove("tui-image-editor-menu-".concat(this.submenu));
                if (discardSelection) {
                  this._actions.main.discardSelection();
                }
                this._actions.main.changeSelectableAll(true);
                this[this.submenu].changeStandbyMode();
              }
              if (this.submenu === menuName && toggle) {
                this.submenu = null;
              } else {
                this._buttonElements[menuName].classList.add("active");
                this._mainElement.classList.add("tui-image-editor-menu-".concat(menuName));
                this.submenu = menuName;
                this[this.submenu].changeStartMode();
              }
              this.resizeEditor();
            }
          }, {
            key: "_initMenu",
            value: function _initMenu() {
              if (this.options.initMenu) {
                var evt = document.createEvent("MouseEvents");
                evt.initEvent("click", true, false);
                this._buttonElements[this.options.initMenu].dispatchEvent(evt);
              }
              if (this.icon) {
                this.icon.registerDefaultIcon();
              }
            }
          }, {
            key: "_getCanvasMaxDimension",
            value: function _getCanvasMaxDimension() {
              var _this$_editorContaine = this._editorContainerElement.style, maxWidth = _this$_editorContaine.maxWidth, maxHeight = _this$_editorContaine.maxHeight;
              var width = parse_float_default()(maxWidth);
              var height = parse_float_default()(maxHeight);
              return {
                width,
                height
              };
            }
          }, {
            key: "_setEditorPosition",
            value: function _setEditorPosition(menuBarPosition) {
              var _this$_getCanvasMaxDi2 = this._getCanvasMaxDimension(), width = _this$_getCanvasMaxDi2.width, height = _this$_getCanvasMaxDi2.height;
              var editorElementStyle = this._editorElement.style;
              var top = 0;
              var left = 0;
              if (this.submenu) {
                if (menuBarPosition === "bottom") {
                  if (height > this._editorElementWrap.scrollHeight - 150) {
                    top = (height - this._editorElementWrap.scrollHeight) / 2;
                  } else {
                    top = 150 / 2 * -1;
                  }
                } else if (menuBarPosition === "top") {
                  if (height > this._editorElementWrap.offsetHeight - 150) {
                    top = 150 / 2 - (height - (this._editorElementWrap.offsetHeight - 150)) / 2;
                  } else {
                    top = 150 / 2;
                  }
                } else if (menuBarPosition === "left") {
                  if (width > this._editorElementWrap.offsetWidth - 248) {
                    left = 248 / 2 - (width - (this._editorElementWrap.offsetWidth - 248)) / 2;
                  } else {
                    left = 248 / 2;
                  }
                } else if (menuBarPosition === "right") {
                  if (width > this._editorElementWrap.scrollWidth - 248) {
                    left = (width - this._editorElementWrap.scrollWidth) / 2;
                  } else {
                    left = 248 / 2 * -1;
                  }
                }
              }
              editorElementStyle.top = "".concat(top, "px");
              editorElementStyle.left = "".concat(left, "px");
            }
          }]);
          return Ui2;
        }();
        customEvents_default().mixin(Ui);
        var ui = Ui;
        var instance_filter = __webpack_require__(381);
        var filter_default = /* @__PURE__ */ __webpack_require__.n(instance_filter);
        var ImageTracer = /* @__PURE__ */ function() {
          function ImageTracer2() {
            _classCallCheck(this, ImageTracer2);
            this.versionnumber = "1.2.4";
            this.optionpresets = {
              default: {
                corsenabled: false,
                ltres: 1,
                qtres: 1,
                pathomit: 8,
                rightangleenhance: true,
                colorsampling: 2,
                numberofcolors: 16,
                mincolorratio: 0,
                colorquantcycles: 3,
                layering: 0,
                strokewidth: 1,
                linefilter: false,
                scale: 1,
                roundcoords: 1,
                viewbox: false,
                desc: false,
                lcpr: 0,
                qcpr: 0,
                blurradius: 0,
                blurdelta: 20
              },
              posterized1: {
                colorsampling: 0,
                numberofcolors: 2
              },
              posterized2: {
                numberofcolors: 4,
                blurradius: 5
              },
              curvy: {
                ltres: 0.01,
                linefilter: true,
                rightangleenhance: false
              },
              sharp: {
                qtres: 0.01,
                linefilter: false
              },
              detailed: {
                pathomit: 0,
                roundcoords: 2,
                ltres: 0.5,
                qtres: 0.5,
                numberofcolors: 64
              },
              smoothed: {
                blurradius: 5,
                blurdelta: 64
              },
              grayscale: {
                colorsampling: 0,
                colorquantcycles: 1,
                numberofcolors: 7
              },
              fixedpalette: {
                colorsampling: 0,
                colorquantcycles: 1,
                numberofcolors: 27
              },
              randomsampling1: {
                colorsampling: 1,
                numberofcolors: 8
              },
              randomsampling2: {
                colorsampling: 1,
                numberofcolors: 64
              },
              artistic1: {
                colorsampling: 0,
                colorquantcycles: 1,
                pathomit: 0,
                blurradius: 5,
                blurdelta: 64,
                ltres: 0.01,
                linefilter: true,
                numberofcolors: 16,
                strokewidth: 2
              },
              artistic2: {
                qtres: 0.01,
                colorsampling: 0,
                colorquantcycles: 1,
                numberofcolors: 4,
                strokewidth: 0
              },
              artistic3: {
                qtres: 10,
                ltres: 10,
                numberofcolors: 8
              },
              artistic4: {
                qtres: 10,
                ltres: 10,
                numberofcolors: 64,
                blurradius: 5,
                blurdelta: 256,
                strokewidth: 2
              },
              posterized3: {
                ltres: 1,
                qtres: 1,
                pathomit: 20,
                rightangleenhance: true,
                colorsampling: 0,
                numberofcolors: 3,
                mincolorratio: 0,
                colorquantcycles: 3,
                blurradius: 3,
                blurdelta: 20,
                strokewidth: 0,
                linefilter: false,
                roundcoords: 1,
                pal: [{
                  r: 0,
                  g: 0,
                  b: 100,
                  a: 255
                }, {
                  r: 255,
                  g: 255,
                  b: 255,
                  a: 255
                }]
              }
            };
            this.pathscan_combined_lookup = [[[-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1]], [[0, 1, 0, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [0, 2, -1, 0]], [[-1, -1, -1, -1], [-1, -1, -1, -1], [0, 1, 0, -1], [0, 0, 1, 0]], [[0, 0, 1, 0], [-1, -1, -1, -1], [0, 2, -1, 0], [-1, -1, -1, -1]], [[-1, -1, -1, -1], [0, 0, 1, 0], [0, 3, 0, 1], [-1, -1, -1, -1]], [[13, 3, 0, 1], [13, 2, -1, 0], [7, 1, 0, -1], [7, 0, 1, 0]], [[-1, -1, -1, -1], [0, 1, 0, -1], [-1, -1, -1, -1], [0, 3, 0, 1]], [[0, 3, 0, 1], [0, 2, -1, 0], [-1, -1, -1, -1], [-1, -1, -1, -1]], [[0, 3, 0, 1], [0, 2, -1, 0], [-1, -1, -1, -1], [-1, -1, -1, -1]], [[-1, -1, -1, -1], [0, 1, 0, -1], [-1, -1, -1, -1], [0, 3, 0, 1]], [[11, 1, 0, -1], [14, 0, 1, 0], [14, 3, 0, 1], [11, 2, -1, 0]], [[-1, -1, -1, -1], [0, 0, 1, 0], [0, 3, 0, 1], [-1, -1, -1, -1]], [[0, 0, 1, 0], [-1, -1, -1, -1], [0, 2, -1, 0], [-1, -1, -1, -1]], [[-1, -1, -1, -1], [-1, -1, -1, -1], [0, 1, 0, -1], [0, 0, 1, 0]], [[0, 1, 0, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [0, 2, -1, 0]], [[-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1], [-1, -1, -1, -1]]];
            this.gks = [[0.27901, 0.44198, 0.27901], [0.135336, 0.228569, 0.272192, 0.228569, 0.135336], [0.086776, 0.136394, 0.178908, 0.195843, 0.178908, 0.136394, 0.086776], [0.063327, 0.093095, 0.122589, 0.144599, 0.152781, 0.144599, 0.122589, 0.093095, 0.063327], [0.049692, 0.069304, 0.089767, 0.107988, 0.120651, 0.125194, 0.120651, 0.107988, 0.089767, 0.069304, 0.049692]];
            this.specpalette = [{
              r: 0,
              g: 0,
              b: 0,
              a: 255
            }, {
              r: 128,
              g: 128,
              b: 128,
              a: 255
            }, {
              r: 0,
              g: 0,
              b: 128,
              a: 255
            }, {
              r: 64,
              g: 64,
              b: 128,
              a: 255
            }, {
              r: 192,
              g: 192,
              b: 192,
              a: 255
            }, {
              r: 255,
              g: 255,
              b: 255,
              a: 255
            }, {
              r: 128,
              g: 128,
              b: 192,
              a: 255
            }, {
              r: 0,
              g: 0,
              b: 192,
              a: 255
            }, {
              r: 128,
              g: 0,
              b: 0,
              a: 255
            }, {
              r: 128,
              g: 64,
              b: 64,
              a: 255
            }, {
              r: 128,
              g: 0,
              b: 128,
              a: 255
            }, {
              r: 168,
              g: 168,
              b: 168,
              a: 255
            }, {
              r: 192,
              g: 128,
              b: 128,
              a: 255
            }, {
              r: 192,
              g: 0,
              b: 0,
              a: 255
            }, {
              r: 255,
              g: 255,
              b: 255,
              a: 255
            }, {
              r: 0,
              g: 128,
              b: 0,
              a: 255
            }];
          }
          _createClass(ImageTracer2, [{
            key: "imageToSVG",
            value: function imageToSVG(url2, callback, options) {
              var _this = this;
              options = this.checkoptions(options);
              this.loadImage(url2, function(canvas) {
                callback(_this.imagedataToSVG(_this.getImgdata(canvas), options));
              }, options);
            }
          }, {
            key: "imagedataToSVG",
            value: function imagedataToSVG(imgd, options) {
              options = this.checkoptions(options);
              var td = this.imagedataToTracedata(imgd, options);
              return this.getsvgstring(td, options);
            }
          }, {
            key: "imageToTracedata",
            value: function imageToTracedata(url2, callback, options) {
              var _this2 = this;
              options = this.checkoptions(options);
              this.loadImage(url2, function(canvas) {
                callback(_this2.imagedataToTracedata(_this2.getImgdata(canvas), options));
              }, options);
            }
          }, {
            key: "imagedataToTracedata",
            value: function imagedataToTracedata(imgd, options) {
              options = this.checkoptions(options);
              var ii = this.colorquantization(imgd, options);
              var tracedata;
              if (options.layering === 0) {
                tracedata = {
                  layers: [],
                  palette: ii.palette,
                  width: ii.array[0].length - 2,
                  height: ii.array.length - 2
                };
                for (var colornum = 0; colornum < ii.palette.length; colornum += 1) {
                  var tracedlayer = this.batchtracepaths(this.internodes(this.pathscan(this.layeringstep(ii, colornum), options.pathomit), options), options.ltres, options.qtres);
                  tracedata.layers.push(tracedlayer);
                }
              } else {
                var ls = this.layering(ii);
                if (options.layercontainerid) {
                  this.drawLayers(ls, this.specpalette, options.scale, options.layercontainerid);
                }
                var bps = this.batchpathscan(ls, options.pathomit);
                var bis = this.batchinternodes(bps, options);
                tracedata = {
                  layers: this.batchtracelayers(bis, options.ltres, options.qtres),
                  palette: ii.palette,
                  width: imgd.width,
                  height: imgd.height
                };
              }
              return tracedata;
            }
          }, {
            key: "checkoptions",
            value: function checkoptions(options) {
              options = options || {};
              if (typeof options === "string") {
                options = options.toLowerCase();
                if (this.optionpresets[options]) {
                  options = this.optionpresets[options];
                } else {
                  options = {};
                }
              }
              var ok = keys_default()(this.optionpresets["default"]);
              for (var k = 0; k < ok.length; k += 1) {
                if (!options.hasOwnProperty(ok[k])) {
                  options[ok[k]] = this.optionpresets["default"][ok[k]];
                }
              }
              return options;
            }
          }, {
            key: "colorquantization",
            value: function colorquantization(imgd, options) {
              var arr2 = [];
              var idx = 0;
              var cd;
              var cdl;
              var ci;
              var paletteacc = [];
              var pixelnum = imgd.width * imgd.height;
              var i;
              var j2;
              var k;
              var cnt;
              var palette;
              for (j2 = 0; j2 < imgd.height + 2; j2 += 1) {
                arr2[j2] = [];
                for (i = 0; i < imgd.width + 2; i += 1) {
                  arr2[j2][i] = -1;
                }
              }
              if (options.pal) {
                palette = options.pal;
              } else if (options.colorsampling === 0) {
                palette = this.generatepalette(options.numberofcolors);
              } else if (options.colorsampling === 1) {
                palette = this.samplepalette(options.numberofcolors, imgd);
              } else {
                palette = this.samplepalette2(options.numberofcolors, imgd);
              }
              if (options.blurradius > 0) {
                imgd = this.blur(imgd, options.blurradius, options.blurdelta);
              }
              for (cnt = 0; cnt < options.colorquantcycles; cnt += 1) {
                if (cnt > 0) {
                  for (k = 0; k < palette.length; k += 1) {
                    if (paletteacc[k].n > 0) {
                      palette[k] = {
                        r: Math.floor(paletteacc[k].r / paletteacc[k].n),
                        g: Math.floor(paletteacc[k].g / paletteacc[k].n),
                        b: Math.floor(paletteacc[k].b / paletteacc[k].n),
                        a: Math.floor(paletteacc[k].a / paletteacc[k].n)
                      };
                    }
                    if (paletteacc[k].n / pixelnum < options.mincolorratio && cnt < options.colorquantcycles - 1) {
                      palette[k] = {
                        r: Math.floor(Math.random() * 255),
                        g: Math.floor(Math.random() * 255),
                        b: Math.floor(Math.random() * 255),
                        a: Math.floor(Math.random() * 255)
                      };
                    }
                  }
                }
                for (i = 0; i < palette.length; i += 1) {
                  paletteacc[i] = {
                    r: 0,
                    g: 0,
                    b: 0,
                    a: 0,
                    n: 0
                  };
                }
                for (j2 = 0; j2 < imgd.height; j2 += 1) {
                  for (i = 0; i < imgd.width; i += 1) {
                    idx = (j2 * imgd.width + i) * 4;
                    ci = 0;
                    cdl = 1024;
                    for (k = 0; k < palette.length; k += 1) {
                      cd = Math.abs(palette[k].r - imgd.data[idx]) + Math.abs(palette[k].g - imgd.data[idx + 1]) + Math.abs(palette[k].b - imgd.data[idx + 2]) + Math.abs(palette[k].a - imgd.data[idx + 3]);
                      if (cd < cdl) {
                        cdl = cd;
                        ci = k;
                      }
                    }
                    paletteacc[ci].r += imgd.data[idx];
                    paletteacc[ci].g += imgd.data[idx + 1];
                    paletteacc[ci].b += imgd.data[idx + 2];
                    paletteacc[ci].a += imgd.data[idx + 3];
                    paletteacc[ci].n += 1;
                    arr2[j2 + 1][i + 1] = ci;
                  }
                }
              }
              return {
                array: arr2,
                palette
              };
            }
          }, {
            key: "samplepalette",
            value: function samplepalette(numberofcolors, imgd) {
              var idx;
              var palette = [];
              for (var i = 0; i < numberofcolors; i += 1) {
                idx = Math.floor(Math.random() * imgd.data.length / 4) * 4;
                palette.push({
                  r: imgd.data[idx],
                  g: imgd.data[idx + 1],
                  b: imgd.data[idx + 2],
                  a: imgd.data[idx + 3]
                });
              }
              return palette;
            }
          }, {
            key: "samplepalette2",
            value: function samplepalette2(numberofcolors, imgd) {
              var idx;
              var palette = [];
              var ni = Math.ceil(Math.sqrt(numberofcolors));
              var nj = Math.ceil(numberofcolors / ni);
              var vx = imgd.width / (ni + 1);
              var vy = imgd.height / (nj + 1);
              for (var j2 = 0; j2 < nj; j2 += 1) {
                for (var i = 0; i < ni; i += 1) {
                  if (palette.length === numberofcolors) {
                    break;
                  } else {
                    idx = Math.floor((j2 + 1) * vy * imgd.width + (i + 1) * vx) * 4;
                    palette.push({
                      r: imgd.data[idx],
                      g: imgd.data[idx + 1],
                      b: imgd.data[idx + 2],
                      a: imgd.data[idx + 3]
                    });
                  }
                }
              }
              return palette;
            }
          }, {
            key: "generatepalette",
            value: function generatepalette(numberofcolors) {
              var palette = [];
              var rcnt;
              var gcnt;
              var bcnt;
              if (numberofcolors < 8) {
                var graystep = Math.floor(255 / (numberofcolors - 1));
                for (var i = 0; i < numberofcolors; i += 1) {
                  palette.push({
                    r: i * graystep,
                    g: i * graystep,
                    b: i * graystep,
                    a: 255
                  });
                }
              } else {
                var colorqnum = Math.floor(Math.pow(numberofcolors, 1 / 3));
                var colorstep = Math.floor(255 / (colorqnum - 1));
                var rndnum = numberofcolors - colorqnum * colorqnum * colorqnum;
                for (rcnt = 0; rcnt < colorqnum; rcnt += 1) {
                  for (gcnt = 0; gcnt < colorqnum; gcnt += 1) {
                    for (bcnt = 0; bcnt < colorqnum; bcnt += 1) {
                      palette.push({
                        r: rcnt * colorstep,
                        g: gcnt * colorstep,
                        b: bcnt * colorstep,
                        a: 255
                      });
                    }
                  }
                }
                for (rcnt = 0; rcnt < rndnum; rcnt += 1) {
                  palette.push({
                    r: Math.floor(Math.random() * 255),
                    g: Math.floor(Math.random() * 255),
                    b: Math.floor(Math.random() * 255),
                    a: Math.floor(Math.random() * 255)
                  });
                }
              }
              return palette;
            }
          }, {
            key: "layering",
            value: function layering(ii) {
              var layers = [];
              var val = 0;
              var ah = ii.array.length;
              var aw = ii.array[0].length;
              var n1;
              var n2;
              var n3;
              var n4;
              var n5;
              var n6;
              var n7;
              var n8;
              var i;
              var j2;
              var k;
              for (k = 0; k < ii.palette.length; k += 1) {
                layers[k] = [];
                for (j2 = 0; j2 < ah; j2 += 1) {
                  layers[k][j2] = [];
                  for (i = 0; i < aw; i += 1) {
                    layers[k][j2][i] = 0;
                  }
                }
              }
              for (j2 = 1; j2 < ah - 1; j2 += 1) {
                for (i = 1; i < aw - 1; i += 1) {
                  val = ii.array[j2][i];
                  n1 = ii.array[j2 - 1][i - 1] === val ? 1 : 0;
                  n2 = ii.array[j2 - 1][i] === val ? 1 : 0;
                  n3 = ii.array[j2 - 1][i + 1] === val ? 1 : 0;
                  n4 = ii.array[j2][i - 1] === val ? 1 : 0;
                  n5 = ii.array[j2][i + 1] === val ? 1 : 0;
                  n6 = ii.array[j2 + 1][i - 1] === val ? 1 : 0;
                  n7 = ii.array[j2 + 1][i] === val ? 1 : 0;
                  n8 = ii.array[j2 + 1][i + 1] === val ? 1 : 0;
                  layers[val][j2 + 1][i + 1] = 1 + n5 * 2 + n8 * 4 + n7 * 8;
                  if (!n4) {
                    layers[val][j2 + 1][i] = 0 + 2 + n7 * 4 + n6 * 8;
                  }
                  if (!n2) {
                    layers[val][j2][i + 1] = 0 + n3 * 2 + n5 * 4 + 8;
                  }
                  if (!n1) {
                    layers[val][j2][i] = 0 + n2 * 2 + 4 + n4 * 8;
                  }
                }
              }
              return layers;
            }
          }, {
            key: "layeringstep",
            value: function layeringstep(ii, cnum) {
              var layer = [];
              var ah = ii.array.length;
              var aw = ii.array[0].length;
              var i;
              var j2;
              for (j2 = 0; j2 < ah; j2 += 1) {
                layer[j2] = [];
                for (i = 0; i < aw; i += 1) {
                  layer[j2][i] = 0;
                }
              }
              for (j2 = 1; j2 < ah; j2 += 1) {
                for (i = 1; i < aw; i += 1) {
                  layer[j2][i] = (ii.array[j2 - 1][i - 1] === cnum ? 1 : 0) + (ii.array[j2 - 1][i] === cnum ? 2 : 0) + (ii.array[j2][i - 1] === cnum ? 8 : 0) + (ii.array[j2][i] === cnum ? 4 : 0);
                }
              }
              return layer;
            }
          }, {
            key: "pathscan",
            value: function pathscan(arr2, pathomit) {
              var paths = [];
              var pacnt = 0;
              var pcnt = 0;
              var px = 0;
              var py = 0;
              var w = arr2[0].length;
              var h2 = arr2.length;
              var dir = 0;
              var pathfinished = true;
              var holepath = false;
              var lookuprow;
              for (var j2 = 0; j2 < h2; j2 += 1) {
                for (var i = 0; i < w; i += 1) {
                  if (arr2[j2][i] === 4 || arr2[j2][i] === 11) {
                    px = i;
                    py = j2;
                    paths[pacnt] = {};
                    paths[pacnt].points = [];
                    paths[pacnt].boundingbox = [px, py, px, py];
                    paths[pacnt].holechildren = [];
                    pathfinished = false;
                    pcnt = 0;
                    holepath = arr2[j2][i] === 11;
                    dir = 1;
                    while (!pathfinished) {
                      paths[pacnt].points[pcnt] = {};
                      paths[pacnt].points[pcnt].x = px - 1;
                      paths[pacnt].points[pcnt].y = py - 1;
                      paths[pacnt].points[pcnt].t = arr2[py][px];
                      if (px - 1 < paths[pacnt].boundingbox[0]) {
                        paths[pacnt].boundingbox[0] = px - 1;
                      }
                      if (px - 1 > paths[pacnt].boundingbox[2]) {
                        paths[pacnt].boundingbox[2] = px - 1;
                      }
                      if (py - 1 < paths[pacnt].boundingbox[1]) {
                        paths[pacnt].boundingbox[1] = py - 1;
                      }
                      if (py - 1 > paths[pacnt].boundingbox[3]) {
                        paths[pacnt].boundingbox[3] = py - 1;
                      }
                      lookuprow = this.pathscan_combined_lookup[arr2[py][px]][dir];
                      arr2[py][px] = lookuprow[0];
                      dir = lookuprow[1];
                      px += lookuprow[2];
                      py += lookuprow[3];
                      if (px - 1 === paths[pacnt].points[0].x && py - 1 === paths[pacnt].points[0].y) {
                        pathfinished = true;
                        if (paths[pacnt].points.length < pathomit) {
                          paths.pop();
                        } else {
                          paths[pacnt].isholepath = !!holepath;
                          if (holepath) {
                            var parentidx = 0, parentbbox = [-1, -1, w + 1, h2 + 1];
                            for (var parentcnt = 0; parentcnt < pacnt; parentcnt++) {
                              if (!paths[parentcnt].isholepath && this.boundingboxincludes(paths[parentcnt].boundingbox, paths[pacnt].boundingbox) && this.boundingboxincludes(parentbbox, paths[parentcnt].boundingbox)) {
                                parentidx = parentcnt;
                                parentbbox = paths[parentcnt].boundingbox;
                              }
                            }
                            paths[parentidx].holechildren.push(pacnt);
                          }
                          pacnt += 1;
                        }
                      }
                      pcnt += 1;
                    }
                  }
                }
              }
              return paths;
            }
          }, {
            key: "boundingboxincludes",
            value: function boundingboxincludes(parentbbox, childbbox) {
              return parentbbox[0] < childbbox[0] && parentbbox[1] < childbbox[1] && parentbbox[2] > childbbox[2] && parentbbox[3] > childbbox[3];
            }
          }, {
            key: "batchpathscan",
            value: function batchpathscan(layers, pathomit) {
              var bpaths = [];
              for (var k in layers) {
                if (!layers.hasOwnProperty(k)) {
                  continue;
                }
                bpaths[k] = this.pathscan(layers[k], pathomit);
              }
              return bpaths;
            }
          }, {
            key: "internodes",
            value: function internodes(paths, options) {
              var ins = [];
              var palen = 0;
              var nextidx = 0;
              var nextidx2 = 0;
              var previdx = 0;
              var previdx2 = 0;
              var pacnt;
              var pcnt;
              for (pacnt = 0; pacnt < paths.length; pacnt += 1) {
                ins[pacnt] = {};
                ins[pacnt].points = [];
                ins[pacnt].boundingbox = paths[pacnt].boundingbox;
                ins[pacnt].holechildren = paths[pacnt].holechildren;
                ins[pacnt].isholepath = paths[pacnt].isholepath;
                palen = paths[pacnt].points.length;
                for (pcnt = 0; pcnt < palen; pcnt += 1) {
                  nextidx = (pcnt + 1) % palen;
                  nextidx2 = (pcnt + 2) % palen;
                  previdx = (pcnt - 1 + palen) % palen;
                  previdx2 = (pcnt - 2 + palen) % palen;
                  if (options.rightangleenhance && this.testrightangle(paths[pacnt], previdx2, previdx, pcnt, nextidx, nextidx2)) {
                    if (ins[pacnt].points.length > 0) {
                      ins[pacnt].points[ins[pacnt].points.length - 1].linesegment = this.getdirection(ins[pacnt].points[ins[pacnt].points.length - 1].x, ins[pacnt].points[ins[pacnt].points.length - 1].y, paths[pacnt].points[pcnt].x, paths[pacnt].points[pcnt].y);
                    }
                    ins[pacnt].points.push({
                      x: paths[pacnt].points[pcnt].x,
                      y: paths[pacnt].points[pcnt].y,
                      linesegment: this.getdirection(paths[pacnt].points[pcnt].x, paths[pacnt].points[pcnt].y, (paths[pacnt].points[pcnt].x + paths[pacnt].points[nextidx].x) / 2, (paths[pacnt].points[pcnt].y + paths[pacnt].points[nextidx].y) / 2)
                    });
                  }
                  ins[pacnt].points.push({
                    x: (paths[pacnt].points[pcnt].x + paths[pacnt].points[nextidx].x) / 2,
                    y: (paths[pacnt].points[pcnt].y + paths[pacnt].points[nextidx].y) / 2,
                    linesegment: this.getdirection((paths[pacnt].points[pcnt].x + paths[pacnt].points[nextidx].x) / 2, (paths[pacnt].points[pcnt].y + paths[pacnt].points[nextidx].y) / 2, (paths[pacnt].points[nextidx].x + paths[pacnt].points[nextidx2].x) / 2, (paths[pacnt].points[nextidx].y + paths[pacnt].points[nextidx2].y) / 2)
                  });
                }
              }
              return ins;
            }
          }, {
            key: "testrightangle",
            value: function testrightangle(path, idx1, idx2, idx3, idx4, idx5) {
              return path.points[idx3].x === path.points[idx1].x && path.points[idx3].x === path.points[idx2].x && path.points[idx3].y === path.points[idx4].y && path.points[idx3].y === path.points[idx5].y || path.points[idx3].y === path.points[idx1].y && path.points[idx3].y === path.points[idx2].y && path.points[idx3].x === path.points[idx4].x && path.points[idx3].x === path.points[idx5].x;
            }
          }, {
            key: "getdirection",
            value: function getdirection(x1, y1, x2, y2) {
              var val = 8;
              if (x1 < x2) {
                if (y1 < y2) {
                  val = 1;
                } else if (y1 > y2) {
                  val = 7;
                } else {
                  val = 0;
                }
              } else if (x1 > x2) {
                if (y1 < y2) {
                  val = 3;
                } else if (y1 > y2) {
                  val = 5;
                } else {
                  val = 4;
                }
              } else if (y1 < y2) {
                val = 2;
              } else if (y1 > y2) {
                val = 6;
              } else {
                val = 8;
              }
              return val;
            }
          }, {
            key: "batchinternodes",
            value: function batchinternodes(bpaths, options) {
              var binternodes = [];
              for (var k in bpaths) {
                if (!bpaths.hasOwnProperty(k)) {
                  continue;
                }
                binternodes[k] = this.internodes(bpaths[k], options);
              }
              return binternodes;
            }
          }, {
            key: "tracepath",
            value: function tracepath(path, ltres, qtres) {
              var pcnt = 0;
              var segtype1;
              var segtype2;
              var seqend;
              var smp = {};
              smp.segments = [];
              smp.boundingbox = path.boundingbox;
              smp.holechildren = path.holechildren;
              smp.isholepath = path.isholepath;
              while (pcnt < path.points.length) {
                var _context2;
                segtype1 = path.points[pcnt].linesegment;
                segtype2 = -1;
                seqend = pcnt + 1;
                while ((path.points[seqend].linesegment === segtype1 || path.points[seqend].linesegment === segtype2 || segtype2 === -1) && seqend < path.points.length - 1) {
                  if (path.points[seqend].linesegment !== segtype1 && segtype2 === -1) {
                    segtype2 = path.points[seqend].linesegment;
                  }
                  seqend += 1;
                }
                if (seqend === path.points.length - 1) {
                  seqend = 0;
                }
                smp.segments = concat_default()(_context2 = smp.segments).call(_context2, this.fitseq(path, ltres, qtres, pcnt, seqend));
                if (seqend > 0) {
                  pcnt = seqend;
                } else {
                  pcnt = path.points.length;
                }
              }
              return smp;
            }
          }, {
            key: "fitseq",
            value: function fitseq(path, ltres, qtres, seqstart, seqend) {
              var _context2;
              if (seqend > path.points.length || seqend < 0) {
                return [];
              }
              var errorpoint = seqstart, errorval = 0, curvepass = true, px, py, dist2;
              var tl = seqend - seqstart;
              if (tl < 0) {
                tl += path.points.length;
              }
              var vx = (path.points[seqend].x - path.points[seqstart].x) / tl, vy = (path.points[seqend].y - path.points[seqstart].y) / tl;
              var pcnt = (seqstart + 1) % path.points.length, pl;
              while (pcnt != seqend) {
                pl = pcnt - seqstart;
                if (pl < 0) {
                  pl += path.points.length;
                }
                px = path.points[seqstart].x + vx * pl;
                py = path.points[seqstart].y + vy * pl;
                dist2 = (path.points[pcnt].x - px) * (path.points[pcnt].x - px) + (path.points[pcnt].y - py) * (path.points[pcnt].y - py);
                if (dist2 > ltres) {
                  curvepass = false;
                }
                if (dist2 > errorval) {
                  errorpoint = pcnt;
                  errorval = dist2;
                }
                pcnt = (pcnt + 1) % path.points.length;
              }
              if (curvepass) {
                return [{
                  type: "L",
                  x1: path.points[seqstart].x,
                  y1: path.points[seqstart].y,
                  x2: path.points[seqend].x,
                  y2: path.points[seqend].y
                }];
              }
              var fitpoint = errorpoint;
              curvepass = true;
              errorval = 0;
              var t = (fitpoint - seqstart) / tl, t1 = (1 - t) * (1 - t), t2 = 2 * (1 - t) * t, t3 = t * t;
              var cpx = (t1 * path.points[seqstart].x + t3 * path.points[seqend].x - path.points[fitpoint].x) / -t2, cpy = (t1 * path.points[seqstart].y + t3 * path.points[seqend].y - path.points[fitpoint].y) / -t2;
              pcnt = seqstart + 1;
              while (pcnt != seqend) {
                t = (pcnt - seqstart) / tl;
                t1 = (1 - t) * (1 - t);
                t2 = 2 * (1 - t) * t;
                t3 = t * t;
                px = t1 * path.points[seqstart].x + t2 * cpx + t3 * path.points[seqend].x;
                py = t1 * path.points[seqstart].y + t2 * cpy + t3 * path.points[seqend].y;
                dist2 = (path.points[pcnt].x - px) * (path.points[pcnt].x - px) + (path.points[pcnt].y - py) * (path.points[pcnt].y - py);
                if (dist2 > qtres) {
                  curvepass = false;
                }
                if (dist2 > errorval) {
                  errorpoint = pcnt;
                  errorval = dist2;
                }
                pcnt = (pcnt + 1) % path.points.length;
              }
              if (curvepass) {
                return [{
                  type: "Q",
                  x1: path.points[seqstart].x,
                  y1: path.points[seqstart].y,
                  x2: cpx,
                  y2: cpy,
                  x3: path.points[seqend].x,
                  y3: path.points[seqend].y
                }];
              }
              var splitpoint = fitpoint;
              return concat_default()(_context2 = this.fitseq(path, ltres, qtres, seqstart, splitpoint)).call(_context2, this.fitseq(path, ltres, qtres, splitpoint, seqend));
            }
          }, {
            key: "batchtracepaths",
            value: function batchtracepaths(internodepaths, ltres, qtres) {
              var btracedpaths = [];
              for (var k in internodepaths) {
                if (!internodepaths.hasOwnProperty(k)) {
                  continue;
                }
                btracedpaths.push(this.tracepath(internodepaths[k], ltres, qtres));
              }
              return btracedpaths;
            }
          }, {
            key: "batchtracelayers",
            value: function batchtracelayers(binternodes, ltres, qtres) {
              var btbis = [];
              for (var k in binternodes) {
                if (!binternodes.hasOwnProperty(k)) {
                  continue;
                }
                btbis[k] = this.batchtracepaths(binternodes[k], ltres, qtres);
              }
              return btbis;
            }
          }, {
            key: "roundtodec",
            value: function roundtodec(val, places) {
              return Number(val.toFixed(places));
            }
          }, {
            key: "svgpathstring",
            value: function svgpathstring(tracedata, lnum, pathnum, options) {
              var _context3, _context4;
              var layer = tracedata.layers[lnum], smp = layer[pathnum], str = "", pcnt;
              if (options.linefilter && smp.segments.length < 3) {
                return str;
              }
              str = concat_default()(_context3 = "<path ".concat(options.desc ? concat_default()(_context4 = 'desc="l '.concat(lnum, " p ")).call(_context4, pathnum, '" ') : "")).call(_context3, this.tosvgcolorstr(tracedata.palette[lnum], options), 'd="');
              if (options.roundcoords === -1) {
                var _context5;
                str += concat_default()(_context5 = "M ".concat(smp.segments[0].x1 * options.scale, " ")).call(_context5, smp.segments[0].y1 * options.scale, " ");
                for (pcnt = 0; pcnt < smp.segments.length; pcnt++) {
                  var _context6, _context7;
                  str += concat_default()(_context6 = concat_default()(_context7 = "".concat(smp.segments[pcnt].type, " ")).call(_context7, smp.segments[pcnt].x2 * options.scale, " ")).call(_context6, smp.segments[pcnt].y2 * options.scale, " ");
                  if (smp.segments[pcnt].hasOwnProperty("x3")) {
                    var _context8;
                    str += concat_default()(_context8 = "".concat(smp.segments[pcnt].x3 * options.scale, " ")).call(_context8, smp.segments[pcnt].y3 * options.scale, " ");
                  }
                }
                str += "Z ";
              } else {
                var _context9;
                str += concat_default()(_context9 = "M ".concat(this.roundtodec(smp.segments[0].x1 * options.scale, options.roundcoords), " ")).call(_context9, this.roundtodec(smp.segments[0].y1 * options.scale, options.roundcoords), " ");
                for (pcnt = 0; pcnt < smp.segments.length; pcnt++) {
                  var _context10, _context11;
                  str += concat_default()(_context10 = concat_default()(_context11 = "".concat(smp.segments[pcnt].type, " ")).call(_context11, this.roundtodec(smp.segments[pcnt].x2 * options.scale, options.roundcoords), " ")).call(_context10, this.roundtodec(smp.segments[pcnt].y2 * options.scale, options.roundcoords), " ");
                  if (smp.segments[pcnt].hasOwnProperty("x3")) {
                    var _context12;
                    str += concat_default()(_context12 = "".concat(this.roundtodec(smp.segments[pcnt].x3 * options.scale, options.roundcoords), " ")).call(_context12, this.roundtodec(smp.segments[pcnt].y3 * options.scale, options.roundcoords), " ");
                  }
                }
                str += "Z ";
              }
              for (var hcnt = 0; hcnt < smp.holechildren.length; hcnt++) {
                var hsmp = layer[smp.holechildren[hcnt]];
                if (options.roundcoords === -1) {
                  if (hsmp.segments[hsmp.segments.length - 1].hasOwnProperty("x3")) {
                    var _context13;
                    str += concat_default()(_context13 = "M ".concat(hsmp.segments[hsmp.segments.length - 1].x3 * options.scale, " ")).call(_context13, hsmp.segments[hsmp.segments.length - 1].y3 * options.scale, " ");
                  } else {
                    var _context14;
                    str += concat_default()(_context14 = "M ".concat(hsmp.segments[hsmp.segments.length - 1].x2 * options.scale, " ")).call(_context14, hsmp.segments[hsmp.segments.length - 1].y2 * options.scale, " ");
                  }
                  for (pcnt = hsmp.segments.length - 1; pcnt >= 0; pcnt--) {
                    var _context16;
                    str += "".concat(hsmp.segments[pcnt].type, " ");
                    if (hsmp.segments[pcnt].hasOwnProperty("x3")) {
                      var _context15;
                      str += concat_default()(_context15 = "".concat(hsmp.segments[pcnt].x2 * options.scale, " ")).call(_context15, hsmp.segments[pcnt].y2 * options.scale, " ");
                    }
                    str += concat_default()(_context16 = "".concat(hsmp.segments[pcnt].x1 * options.scale, " ")).call(_context16, hsmp.segments[pcnt].y1 * options.scale, " ");
                  }
                } else {
                  if (hsmp.segments[hsmp.segments.length - 1].hasOwnProperty("x3")) {
                    var _context17;
                    str += concat_default()(_context17 = "M ".concat(this.roundtodec(hsmp.segments[hsmp.segments.length - 1].x3 * options.scale), " ")).call(_context17, this.roundtodec(hsmp.segments[hsmp.segments.length - 1].y3 * options.scale), " ");
                  } else {
                    var _context18;
                    str += concat_default()(_context18 = "M ".concat(this.roundtodec(hsmp.segments[hsmp.segments.length - 1].x2 * options.scale), " ")).call(_context18, this.roundtodec(hsmp.segments[hsmp.segments.length - 1].y2 * options.scale), " ");
                  }
                  for (pcnt = hsmp.segments.length - 1; pcnt >= 0; pcnt--) {
                    var _context20;
                    str += "".concat(hsmp.segments[pcnt].type, " ");
                    if (hsmp.segments[pcnt].hasOwnProperty("x3")) {
                      var _context19;
                      str += concat_default()(_context19 = "".concat(this.roundtodec(hsmp.segments[pcnt].x2 * options.scale), " ")).call(_context19, this.roundtodec(hsmp.segments[pcnt].y2 * options.scale), " ");
                    }
                    str += concat_default()(_context20 = "".concat(this.roundtodec(hsmp.segments[pcnt].x1 * options.scale), " ")).call(_context20, this.roundtodec(hsmp.segments[pcnt].y1 * options.scale), " ");
                  }
                }
                str += "Z ";
              }
              str += '" />';
              if (options.lcpr || options.qcpr) {
                for (pcnt = 0; pcnt < smp.segments.length; pcnt++) {
                  if (smp.segments[pcnt].hasOwnProperty("x3") && options.qcpr) {
                    var _context21, _context22, _context23, _context24, _context25, _context26, _context27, _context28, _context29, _context30, _context31, _context32, _context33, _context34;
                    str += concat_default()(_context21 = concat_default()(_context22 = concat_default()(_context23 = '<circle cx="'.concat(smp.segments[pcnt].x2 * options.scale, '" cy="')).call(_context23, smp.segments[pcnt].y2 * options.scale, '" r="')).call(_context22, options.qcpr, '" fill="cyan" stroke-width="')).call(_context21, options.qcpr * 0.2, '" stroke="black" />');
                    str += concat_default()(_context24 = concat_default()(_context25 = concat_default()(_context26 = '<circle cx="'.concat(smp.segments[pcnt].x3 * options.scale, '" cy="')).call(_context26, smp.segments[pcnt].y3 * options.scale, '" r="')).call(_context25, options.qcpr, '" fill="white" stroke-width="')).call(_context24, options.qcpr * 0.2, '" stroke="black" />');
                    str += concat_default()(_context27 = concat_default()(_context28 = concat_default()(_context29 = concat_default()(_context30 = '<line x1="'.concat(smp.segments[pcnt].x1 * options.scale, '" y1="')).call(_context30, smp.segments[pcnt].y1 * options.scale, '" x2="')).call(_context29, smp.segments[pcnt].x2 * options.scale, '" y2="')).call(_context28, smp.segments[pcnt].y2 * options.scale, '" stroke-width="')).call(_context27, options.qcpr * 0.2, '" stroke="cyan" />');
                    str += concat_default()(_context31 = concat_default()(_context32 = concat_default()(_context33 = concat_default()(_context34 = '<line x1="'.concat(smp.segments[pcnt].x2 * options.scale, '" y1="')).call(_context34, smp.segments[pcnt].y2 * options.scale, '" x2="')).call(_context33, smp.segments[pcnt].x3 * options.scale, '" y2="')).call(_context32, smp.segments[pcnt].y3 * options.scale, '" stroke-width="')).call(_context31, options.qcpr * 0.2, '" stroke="cyan" />');
                  }
                  if (!smp.segments[pcnt].hasOwnProperty("x3") && options.lcpr) {
                    var _context35, _context36, _context37;
                    str += concat_default()(_context35 = concat_default()(_context36 = concat_default()(_context37 = '<circle cx="'.concat(smp.segments[pcnt].x2 * options.scale, '" cy="')).call(_context37, smp.segments[pcnt].y2 * options.scale, '" r="')).call(_context36, options.lcpr, '" fill="white" stroke-width="')).call(_context35, options.lcpr * 0.2, '" stroke="black" />');
                  }
                }
                for (var hcnt = 0; hcnt < smp.holechildren.length; hcnt++) {
                  var hsmp = layer[smp.holechildren[hcnt]];
                  for (pcnt = 0; pcnt < hsmp.segments.length; pcnt++) {
                    if (hsmp.segments[pcnt].hasOwnProperty("x3") && options.qcpr) {
                      var _context38, _context39, _context40, _context41, _context42, _context43, _context44, _context45, _context46, _context47, _context48, _context49, _context50, _context51;
                      str += concat_default()(_context38 = concat_default()(_context39 = concat_default()(_context40 = '<circle cx="'.concat(hsmp.segments[pcnt].x2 * options.scale, '" cy="')).call(_context40, hsmp.segments[pcnt].y2 * options.scale, '" r="')).call(_context39, options.qcpr, '" fill="cyan" stroke-width="')).call(_context38, options.qcpr * 0.2, '" stroke="black" />');
                      str += concat_default()(_context41 = concat_default()(_context42 = concat_default()(_context43 = '<circle cx="'.concat(hsmp.segments[pcnt].x3 * options.scale, '" cy="')).call(_context43, hsmp.segments[pcnt].y3 * options.scale, '" r="')).call(_context42, options.qcpr, '" fill="white" stroke-width="')).call(_context41, options.qcpr * 0.2, '" stroke="black" />');
                      str += concat_default()(_context44 = concat_default()(_context45 = concat_default()(_context46 = concat_default()(_context47 = '<line x1="'.concat(hsmp.segments[pcnt].x1 * options.scale, '" y1="')).call(_context47, hsmp.segments[pcnt].y1 * options.scale, '" x2="')).call(_context46, hsmp.segments[pcnt].x2 * options.scale, '" y2="')).call(_context45, hsmp.segments[pcnt].y2 * options.scale, '" stroke-width="')).call(_context44, options.qcpr * 0.2, '" stroke="cyan" />');
                      str += concat_default()(_context48 = concat_default()(_context49 = concat_default()(_context50 = concat_default()(_context51 = '<line x1="'.concat(hsmp.segments[pcnt].x2 * options.scale, '" y1="')).call(_context51, hsmp.segments[pcnt].y2 * options.scale, '" x2="')).call(_context50, hsmp.segments[pcnt].x3 * options.scale, '" y2="')).call(_context49, hsmp.segments[pcnt].y3 * options.scale, '" stroke-width="')).call(_context48, options.qcpr * 0.2, '" stroke="cyan" />');
                    }
                    if (!hsmp.segments[pcnt].hasOwnProperty("x3") && options.lcpr) {
                      var _context52, _context53, _context54;
                      str += concat_default()(_context52 = concat_default()(_context53 = concat_default()(_context54 = '<circle cx="'.concat(hsmp.segments[pcnt].x2 * options.scale, '" cy="')).call(_context54, hsmp.segments[pcnt].y2 * options.scale, '" r="')).call(_context53, options.lcpr, '" fill="white" stroke-width="')).call(_context52, options.lcpr * 0.2, '" stroke="black" />');
                    }
                  }
                }
              }
              return str;
            }
          }, {
            key: "getsvgstring",
            value: function getsvgstring(tracedata, options) {
              var _context55, _context56, _context57;
              options = this.checkoptions(options);
              var w = tracedata.width * options.scale;
              var h2 = tracedata.height * options.scale;
              var svgstr = concat_default()(_context55 = "<svg ".concat(options.viewbox ? concat_default()(_context56 = 'viewBox="0 0 '.concat(w, " ")).call(_context56, h2, '" ') : concat_default()(_context57 = 'width="'.concat(w, '" height="')).call(_context57, h2, '" '), 'version="1.1" xmlns="http://www.w3.org/2000/svg" desc="Created with imagetracer.js version ')).call(_context55, this.versionnumber, '" >');
              for (var lcnt = 0; lcnt < tracedata.layers.length; lcnt += 1) {
                for (var pcnt = 0; pcnt < tracedata.layers[lcnt].length; pcnt += 1) {
                  if (!tracedata.layers[lcnt][pcnt].isholepath) {
                    svgstr += this.svgpathstring(tracedata, lcnt, pcnt, options);
                  }
                }
              }
              svgstr += "</svg>";
              return svgstr;
            }
          }, {
            key: "compareNumbers",
            value: function compareNumbers(a2, b) {
              return a2 - b;
            }
          }, {
            key: "torgbastr",
            value: function torgbastr(c) {
              var _context58, _context59, _context60;
              return concat_default()(_context58 = concat_default()(_context59 = concat_default()(_context60 = "rgba(".concat(c.r, ",")).call(_context60, c.g, ",")).call(_context59, c.b, ",")).call(_context58, c.a, ")");
            }
          }, {
            key: "tosvgcolorstr",
            value: function tosvgcolorstr(c, options) {
              var _context61, _context62, _context63, _context64, _context65, _context66, _context67;
              return concat_default()(_context61 = concat_default()(_context62 = concat_default()(_context63 = concat_default()(_context64 = concat_default()(_context65 = concat_default()(_context66 = concat_default()(_context67 = 'fill="rgb('.concat(c.r, ",")).call(_context67, c.g, ",")).call(_context66, c.b, ')" stroke="rgb(')).call(_context65, c.r, ",")).call(_context64, c.g, ",")).call(_context63, c.b, ')" stroke-width="')).call(_context62, options.strokewidth, '" opacity="')).call(_context61, c.a / 255, '" ');
            }
          }, {
            key: "appendSVGString",
            value: function appendSVGString(svgstr, parentid) {
              var div;
              if (parentid) {
                div = document.getElementById(parentid);
                if (!div) {
                  div = document.createElement("div");
                  div.id = parentid;
                  document.body.appendChild(div);
                }
              } else {
                div = document.createElement("div");
                document.body.appendChild(div);
              }
              div.innerHTML += svgstr;
            }
          }, {
            key: "blur",
            value: function blur(imgd, radius, delta) {
              var i, j2, k, d, idx, racc, gacc, bacc, aacc, wacc;
              var imgd2 = {
                width: imgd.width,
                height: imgd.height,
                data: []
              };
              radius = Math.floor(radius);
              if (radius < 1) {
                return imgd;
              }
              if (radius > 5) {
                radius = 5;
              }
              delta = Math.abs(delta);
              if (delta > 1024) {
                delta = 1024;
              }
              var thisgk = this.gks[radius - 1];
              for (j2 = 0; j2 < imgd.height; j2++) {
                for (i = 0; i < imgd.width; i++) {
                  racc = 0;
                  gacc = 0;
                  bacc = 0;
                  aacc = 0;
                  wacc = 0;
                  for (k = -radius; k < radius + 1; k++) {
                    if (i + k > 0 && i + k < imgd.width) {
                      idx = (j2 * imgd.width + i + k) * 4;
                      racc += imgd.data[idx] * thisgk[k + radius];
                      gacc += imgd.data[idx + 1] * thisgk[k + radius];
                      bacc += imgd.data[idx + 2] * thisgk[k + radius];
                      aacc += imgd.data[idx + 3] * thisgk[k + radius];
                      wacc += thisgk[k + radius];
                    }
                  }
                  idx = (j2 * imgd.width + i) * 4;
                  imgd2.data[idx] = Math.floor(racc / wacc);
                  imgd2.data[idx + 1] = Math.floor(gacc / wacc);
                  imgd2.data[idx + 2] = Math.floor(bacc / wacc);
                  imgd2.data[idx + 3] = Math.floor(aacc / wacc);
                }
              }
              var himgd = new Uint8ClampedArray(imgd2.data);
              for (j2 = 0; j2 < imgd.height; j2++) {
                for (i = 0; i < imgd.width; i++) {
                  racc = 0;
                  gacc = 0;
                  bacc = 0;
                  aacc = 0;
                  wacc = 0;
                  for (k = -radius; k < radius + 1; k++) {
                    if (j2 + k > 0 && j2 + k < imgd.height) {
                      idx = ((j2 + k) * imgd.width + i) * 4;
                      racc += himgd[idx] * thisgk[k + radius];
                      gacc += himgd[idx + 1] * thisgk[k + radius];
                      bacc += himgd[idx + 2] * thisgk[k + radius];
                      aacc += himgd[idx + 3] * thisgk[k + radius];
                      wacc += thisgk[k + radius];
                    }
                  }
                  idx = (j2 * imgd.width + i) * 4;
                  imgd2.data[idx] = Math.floor(racc / wacc);
                  imgd2.data[idx + 1] = Math.floor(gacc / wacc);
                  imgd2.data[idx + 2] = Math.floor(bacc / wacc);
                  imgd2.data[idx + 3] = Math.floor(aacc / wacc);
                }
              }
              for (j2 = 0; j2 < imgd.height; j2++) {
                for (i = 0; i < imgd.width; i++) {
                  idx = (j2 * imgd.width + i) * 4;
                  d = Math.abs(imgd2.data[idx] - imgd.data[idx]) + Math.abs(imgd2.data[idx + 1] - imgd.data[idx + 1]) + Math.abs(imgd2.data[idx + 2] - imgd.data[idx + 2]) + Math.abs(imgd2.data[idx + 3] - imgd.data[idx + 3]);
                  if (d > delta) {
                    imgd2.data[idx] = imgd.data[idx];
                    imgd2.data[idx + 1] = imgd.data[idx + 1];
                    imgd2.data[idx + 2] = imgd.data[idx + 2];
                    imgd2.data[idx + 3] = imgd.data[idx + 3];
                  }
                }
              }
              return imgd2;
            }
          }, {
            key: "loadImage",
            value: function loadImage(url2, callback, options) {
              var img = new Image();
              if (options && options.corsenabled) {
                img.crossOrigin = "Anonymous";
              }
              img.src = url2;
              img.onload = function() {
                var canvas = document.createElement("canvas");
                canvas.width = img.width;
                canvas.height = img.height;
                var context = canvas.getContext("2d");
                context.drawImage(img, 0, 0);
                callback(canvas);
              };
            }
          }, {
            key: "getImgdata",
            value: function getImgdata(canvas) {
              var context = canvas.getContext("2d");
              return context.getImageData(0, 0, canvas.width, canvas.height);
            }
          }, {
            key: "drawLayers",
            value: function drawLayers(layers, palette, scale, parentid) {
              scale = scale || 1;
              var w, h2, i, j2, k;
              var div;
              if (parentid) {
                div = document.getElementById(parentid);
                if (!div) {
                  div = document.createElement("div");
                  div.id = parentid;
                  document.body.appendChild(div);
                }
              } else {
                div = document.createElement("div");
                document.body.appendChild(div);
              }
              for (k in layers) {
                if (!layers.hasOwnProperty(k)) {
                  continue;
                }
                w = layers[k][0].length;
                h2 = layers[k].length;
                var canvas = document.createElement("canvas");
                canvas.width = w * scale;
                canvas.height = h2 * scale;
                var context = canvas.getContext("2d");
                for (j2 = 0; j2 < h2; j2 += 1) {
                  for (i = 0; i < w; i += 1) {
                    context.fillStyle = this.torgbastr(palette[layers[k][j2][i] % palette.length]);
                    context.fillRect(i * scale, j2 * scale, scale, scale);
                  }
                }
                div.appendChild(canvas);
              }
            }
          }], [{
            key: "tracerDefaultOption",
            value: function tracerDefaultOption() {
              return {
                pathomit: 100,
                ltres: 0.1,
                qtres: 1,
                scale: 1,
                strokewidth: 5,
                viewbox: false,
                linefilter: true,
                desc: false,
                rightangleenhance: false,
                pal: [{
                  r: 0,
                  g: 0,
                  b: 0,
                  a: 255
                }, {
                  r: 255,
                  g: 255,
                  b: 255,
                  a: 255
                }]
              };
            }
          }]);
          return ImageTracer2;
        }();
        var action = {
          getActions: function getActions() {
            return {
              main: this._mainAction(),
              shape: this._shapeAction(),
              crop: this._cropAction(),
              resize: this._resizeAction(),
              flip: this._flipAction(),
              rotate: this._rotateAction(),
              text: this._textAction(),
              mask: this._maskAction(),
              draw: this._drawAction(),
              icon: this._iconAction(),
              filter: this._filterAction(),
              history: this._historyAction()
            };
          },
          _mainAction: function _mainAction() {
            var _this = this;
            var exitCropOnAction = function exitCropOnAction2() {
              if (_this.ui.submenu === "crop") {
                _this.stopDrawingMode();
                _this.ui.changeMenu("crop");
              }
            };
            var setAngleRangeBarOnAction = function setAngleRangeBarOnAction2(angle2) {
              if (_this.ui.submenu === "rotate") {
                _this.ui.rotate.setRangeBarAngle("setAngle", angle2);
              }
            };
            var setFilterStateRangeBarOnAction = function setFilterStateRangeBarOnAction2(filterOptions) {
              if (_this.ui.submenu === "filter") {
                filter_default()(_this.ui).setFilterState(filterOptions);
              }
            };
            var onEndUndoRedo = function onEndUndoRedo2(result) {
              setAngleRangeBarOnAction(result);
              setFilterStateRangeBarOnAction(result);
              return result;
            };
            var toggleZoomMode = function toggleZoomMode2() {
              var zoomMode = _this._graphics.getZoomMode();
              _this.stopDrawingMode();
              if (zoomMode !== zoomModes.ZOOM) {
                _this.startDrawingMode(drawingModes.ZOOM);
                _this._graphics.startZoomInMode();
              } else {
                _this._graphics.endZoomInMode();
              }
            };
            var toggleHandMode = function toggleHandMode2() {
              var zoomMode = _this._graphics.getZoomMode();
              _this.stopDrawingMode();
              if (zoomMode !== zoomModes.HAND) {
                _this.startDrawingMode(drawingModes.ZOOM);
                _this._graphics.startHandMode();
              } else {
                _this._graphics.endHandMode();
              }
            };
            var initFilterState = function initFilterState2() {
              if (filter_default()(_this.ui)) {
                filter_default()(_this.ui).initFilterCheckBoxState();
              }
            };
            return extend_default()({
              initLoadImage: function initLoadImage(imagePath, imageName) {
                return _this.loadImageFromURL(imagePath, imageName).then(function(sizeValue) {
                  exitCropOnAction();
                  _this.ui.initializeImgUrl = imagePath;
                  _this.ui.resizeEditor({
                    imageSize: sizeValue
                  });
                  _this.clearUndoStack();
                  _this._invoker.fire(eventNames.EXECUTE_COMMAND, historyNames.LOAD_IMAGE);
                });
              },
              undo: function undo2() {
                if (!_this.isEmptyUndoStack()) {
                  exitCropOnAction();
                  _this.deactivateAll();
                  _this.undo().then(onEndUndoRedo);
                }
              },
              redo: function redo() {
                if (!_this.isEmptyRedoStack()) {
                  exitCropOnAction();
                  _this.deactivateAll();
                  _this.redo().then(onEndUndoRedo);
                }
              },
              reset: function reset() {
                exitCropOnAction();
                _this.loadImageFromURL(_this.ui.initializeImgUrl, "resetImage").then(function(sizeValue) {
                  exitCropOnAction();
                  initFilterState();
                  _this.ui.resizeEditor({
                    imageSize: sizeValue
                  });
                  _this.clearUndoStack();
                  _this._initHistory();
                });
              },
              delete: function _delete() {
                _this.ui.changeHelpButtonEnabled("delete", false);
                exitCropOnAction();
                _this.removeActiveObject();
                _this.activeObjectId = null;
              },
              deleteAll: function deleteAll() {
                exitCropOnAction();
                _this.clearObjects();
                _this.ui.changeHelpButtonEnabled("delete", false);
                _this.ui.changeHelpButtonEnabled("deleteAll", false);
              },
              load: function load(file) {
                if (!isSupportFileApi()) {
                  alert("This browser does not support file-api");
                }
                _this.ui.initializeImgUrl = url_default().createObjectURL(file);
                _this.loadImageFromFile(file).then(function(sizeValue) {
                  exitCropOnAction();
                  initFilterState();
                  _this.clearUndoStack();
                  _this.ui.activeMenuEvent();
                  _this.ui.resizeEditor({
                    imageSize: sizeValue
                  });
                  _this._clearHistory();
                  _this._invoker.fire(eventNames.EXECUTE_COMMAND, historyNames.LOAD_IMAGE);
                })["catch"](function(message) {
                  return promise_default().reject(message);
                });
              },
              download: function download2() {
                var dataURL = _this.toDataURL();
                var imageName = _this.getImageName();
                var blob, type, w;
                if (isSupportFileApi() && window.saveAs) {
                  blob = base64ToBlob(dataURL);
                  type = blob.type.split("/")[1];
                  if (imageName.split(".").pop() !== type) {
                    imageName += ".".concat(type);
                  }
                  saveAs(blob, imageName);
                } else {
                  w = window.open();
                  w.document.body.innerHTML = "<img src='".concat(dataURL, "'>");
                }
              },
              history: function history(event) {
                _this.ui.toggleHistoryMenu(event);
              },
              zoomIn: function zoomIn() {
                _this.ui.toggleZoomButtonStatus("zoomIn");
                _this.deactivateAll();
                toggleZoomMode();
              },
              zoomOut: function zoomOut() {
                _this._graphics.zoomOut();
              },
              hand: function hand() {
                _this.ui.offZoomInButtonStatus();
                _this.ui.toggleZoomButtonStatus("hand");
                _this.deactivateAll();
                toggleHandMode();
              }
            }, this._commonAction());
          },
          _iconAction: function _iconAction() {
            var _this2 = this;
            return extend_default()({
              changeColor: function changeColor(color2) {
                if (_this2.activeObjectId) {
                  _this2.changeIconColor(_this2.activeObjectId, color2);
                }
              },
              addIcon: function addIcon(iconType, iconColor) {
                _this2.startDrawingMode("ICON");
                _this2.setDrawingIcon(iconType, iconColor);
              },
              cancelAddIcon: function cancelAddIcon() {
                _this2.ui.icon.clearIconType();
                _this2.changeSelectableAll(true);
                _this2.changeCursor("default");
                _this2.stopDrawingMode();
              },
              registerDefaultIcons: function registerDefaultIcons(type, path) {
                var iconObj = {};
                iconObj[type] = path;
                _this2.registerIcons(iconObj);
              },
              registerCustomIcon: function registerCustomIcon(imgUrl, file) {
                var imagetracer = new ImageTracer();
                imagetracer.imageToSVG(imgUrl, function(svgstr) {
                  var _svgstr$match = svgstr.match(/path[^>]*d="([^"]*)"/), _svgstr$match2 = _slicedToArray(_svgstr$match, 2), svgPath = _svgstr$match2[1];
                  var iconObj = {};
                  iconObj[file.name] = svgPath;
                  _this2.registerIcons(iconObj);
                  _this2.addIcon(file.name, {
                    left: 100,
                    top: 100
                  });
                }, ImageTracer.tracerDefaultOption());
              }
            }, this._commonAction());
          },
          _drawAction: function _drawAction() {
            var _this3 = this;
            return extend_default()({
              setDrawMode: function setDrawMode(type, settings) {
                _this3.stopDrawingMode();
                if (type === "free") {
                  _this3.startDrawingMode("FREE_DRAWING", settings);
                } else {
                  _this3.startDrawingMode("LINE_DRAWING", settings);
                }
              },
              setColor: function setColor(color2) {
                _this3.setBrush({
                  color: color2
                });
              }
            }, this._commonAction());
          },
          _maskAction: function _maskAction() {
            var _this4 = this;
            return extend_default()({
              loadImageFromURL: function loadImageFromURL(imgUrl, file) {
                return _this4.loadImageFromURL(_this4.toDataURL(), "FilterImage").then(function() {
                  _this4.addImageObject(imgUrl).then(function() {
                    url_default().revokeObjectURL(file);
                  });
                  _this4._invoker.fire(eventNames.EXECUTE_COMMAND, historyNames.LOAD_MASK_IMAGE);
                });
              },
              applyFilter: function applyFilter() {
                _this4.applyFilter("mask", {
                  maskObjId: _this4.activeObjectId
                });
              }
            }, this._commonAction());
          },
          _textAction: function _textAction() {
            var _this5 = this;
            return extend_default()({
              changeTextStyle: function changeTextStyle(styleObj, isSilent) {
                if (_this5.activeObjectId) {
                  _this5.changeTextStyle(_this5.activeObjectId, styleObj, isSilent);
                }
              }
            }, this._commonAction());
          },
          _rotateAction: function _rotateAction() {
            var _this6 = this;
            return extend_default()({
              rotate: function rotate3(angle2, isSilent) {
                _this6.rotate(angle2, isSilent);
                _this6.ui.resizeEditor();
                _this6.ui.rotate.setRangeBarAngle("rotate", angle2);
              },
              setAngle: function setAngle(angle2, isSilent) {
                _this6.setAngle(angle2, isSilent);
                _this6.ui.resizeEditor();
                _this6.ui.rotate.setRangeBarAngle("setAngle", angle2);
              }
            }, this._commonAction());
          },
          _shapeAction: function _shapeAction() {
            var _this7 = this;
            return extend_default()({
              changeShape: function changeShape(changeShapeObject, isSilent) {
                if (_this7.activeObjectId) {
                  _this7.changeShape(_this7.activeObjectId, changeShapeObject, isSilent);
                }
              },
              setDrawingShape: function setDrawingShape(shapeType) {
                _this7.setDrawingShape(shapeType);
              }
            }, this._commonAction());
          },
          _cropAction: function _cropAction() {
            var _this8 = this;
            return extend_default()({
              crop: function crop2() {
                var cropRect = _this8.getCropzoneRect();
                if (cropRect && !isEmptyCropzone(cropRect)) {
                  _this8.crop(cropRect).then(function() {
                    _this8.stopDrawingMode();
                    _this8.ui.resizeEditor();
                    _this8.ui.changeMenu("crop");
                    _this8._invoker.fire(eventNames.EXECUTE_COMMAND, historyNames.CROP);
                  })["catch"](function(message) {
                    return promise_default().reject(message);
                  });
                }
              },
              cancel: function cancel() {
                _this8.stopDrawingMode();
                _this8.ui.changeMenu("crop");
              },
              preset: function preset(presetType) {
                switch (presetType) {
                  case "preset-square":
                    _this8.setCropzoneRect(1 / 1);
                    break;
                  case "preset-3-2":
                    _this8.setCropzoneRect(3 / 2);
                    break;
                  case "preset-4-3":
                    _this8.setCropzoneRect(4 / 3);
                    break;
                  case "preset-5-4":
                    _this8.setCropzoneRect(5 / 4);
                    break;
                  case "preset-7-5":
                    _this8.setCropzoneRect(7 / 5);
                    break;
                  case "preset-16-9":
                    _this8.setCropzoneRect(16 / 9);
                    break;
                  default:
                    _this8.setCropzoneRect();
                    _this8.ui.crop.changeApplyButtonStatus(false);
                    break;
                }
              }
            }, this._commonAction());
          },
          _resizeAction: function _resizeAction() {
            var _this9 = this;
            return extend_default()({
              getCurrentDimensions: function getCurrentDimensions() {
                return _this9._graphics.getCurrentDimensions();
              },
              preview: function preview(actor, value, lockState) {
                var currentDimensions = _this9._graphics.getCurrentDimensions();
                var calcAspectRatio = function calcAspectRatio2() {
                  return currentDimensions.width / currentDimensions.height;
                };
                var dimensions = {};
                switch (actor) {
                  case "width":
                    dimensions.width = value;
                    if (lockState) {
                      dimensions.height = value / calcAspectRatio();
                    } else {
                      dimensions.height = currentDimensions.height;
                    }
                    break;
                  case "height":
                    dimensions.height = value;
                    if (lockState) {
                      dimensions.width = value * calcAspectRatio();
                    } else {
                      dimensions.width = currentDimensions.width;
                    }
                    break;
                  default:
                    dimensions = currentDimensions;
                }
                _this9._graphics.resize(dimensions).then(function() {
                  _this9.ui.resizeEditor();
                });
                if (lockState) {
                  _this9.ui.resize.setWidthValue(dimensions.width);
                  _this9.ui.resize.setHeightValue(dimensions.height);
                }
              },
              lockAspectRatio: function lockAspectRatio(lockState, min2, max3) {
                var _this9$_graphics$getC = _this9._graphics.getCurrentDimensions(), width = _this9$_graphics$getC.width, height = _this9$_graphics$getC.height;
                var aspectRatio = width / height;
                if (lockState) {
                  if (width > height) {
                    var pMax = max3 / aspectRatio;
                    var pMin = min2 * aspectRatio;
                    _this9.ui.resize.setLimit({
                      minWidth: pMin > min2 ? pMin : min2,
                      minHeight: min2,
                      maxWidth: max3,
                      maxHeight: pMax < max3 ? pMax : max3
                    });
                  } else {
                    var _pMax = max3 * aspectRatio;
                    var _pMin = min2 / aspectRatio;
                    _this9.ui.resize.setLimit({
                      minWidth: min2,
                      minHeight: _pMin > min2 ? _pMin : min2,
                      maxWidth: _pMax < max3 ? _pMax : max3,
                      maxHeight: max3
                    });
                  }
                } else {
                  _this9.ui.resize.setLimit({
                    minWidth: min2,
                    minHeight: min2,
                    maxWidth: max3,
                    maxHeight: max3
                  });
                }
              },
              resize: function resize2() {
                var dimensions = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
                if (!dimensions) {
                  dimensions = _this9._graphics.getCurrentDimensions();
                }
                _this9.resize(dimensions).then(function() {
                  _this9._graphics.setOriginalDimensions(dimensions);
                  _this9.stopDrawingMode();
                  _this9.ui.resizeEditor();
                  _this9.ui.changeMenu("resize");
                })["catch"](function(message) {
                  return promise_default().reject(message);
                });
              },
              reset: function reset() {
                var standByMode = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
                var dimensions = _this9._graphics.getOriginalDimensions();
                _this9.ui.resize.setWidthValue(dimensions.width, true);
                _this9.ui.resize.setHeightValue(dimensions.height, true);
                _this9._graphics.resize(dimensions).then(function() {
                  if (!standByMode) {
                    _this9.stopDrawingMode();
                    _this9.ui.resizeEditor();
                    _this9.ui.changeMenu("resize");
                  }
                });
              }
            }, this._commonAction());
          },
          _flipAction: function _flipAction() {
            var _this10 = this;
            return extend_default()({
              flip: function flip2(flipType) {
                return _this10[flipType]();
              }
            }, this._commonAction());
          },
          _filterAction: function _filterAction() {
            var _this11 = this;
            return extend_default()({
              applyFilter: function applyFilter(applying, type, options, isSilent) {
                if (applying) {
                  _this11.applyFilter(type, options, isSilent);
                } else if (_this11.hasFilter(type)) {
                  _this11.removeFilter(type);
                }
              }
            }, this._commonAction());
          },
          setReAction: function setReAction() {
            var _this12 = this;
            this.on({
              undoStackChanged: function undoStackChanged(length) {
                if (length) {
                  _this12.ui.changeHelpButtonEnabled("undo", true);
                  _this12.ui.changeHelpButtonEnabled("reset", true);
                } else {
                  _this12.ui.changeHelpButtonEnabled("undo", false);
                  _this12.ui.changeHelpButtonEnabled("reset", false);
                }
                _this12.ui.resizeEditor();
              },
              redoStackChanged: function redoStackChanged(length) {
                if (length) {
                  _this12.ui.changeHelpButtonEnabled("redo", true);
                } else {
                  _this12.ui.changeHelpButtonEnabled("redo", false);
                }
                _this12.ui.resizeEditor();
              },
              objectActivated: function objectActivated(obj) {
                var _context2, _context22;
                _this12.activeObjectId = obj.id;
                _this12.ui.changeHelpButtonEnabled("delete", true);
                _this12.ui.changeHelpButtonEnabled("deleteAll", true);
                if (obj.type === "cropzone") {
                  _this12.ui.crop.changeApplyButtonStatus(true);
                } else if (index_of_default()(_context2 = ["rect", "circle", "triangle"]).call(_context2, obj.type) > -1) {
                  _this12.stopDrawingMode();
                  if (_this12.ui.submenu !== "shape") {
                    _this12.ui.changeMenu("shape", false, false);
                  }
                  _this12.ui.shape.setShapeStatus({
                    strokeColor: obj.stroke,
                    strokeWidth: obj.strokeWidth,
                    fillColor: fill_default()(obj)
                  });
                  _this12.ui.shape.setMaxStrokeValue(Math.min(obj.width, obj.height));
                } else if (obj.type === "path" || obj.type === "line") {
                  if (_this12.ui.submenu !== "draw") {
                    _this12.ui.changeMenu("draw", false, false);
                    _this12.ui.draw.changeStandbyMode();
                  }
                } else if (index_of_default()(_context22 = ["i-text", "text"]).call(_context22, obj.type) > -1) {
                  if (_this12.ui.submenu !== "text") {
                    _this12.ui.changeMenu("text", false, false);
                  }
                  _this12.ui.text.setTextStyleStateOnAction(obj);
                } else if (obj.type === "icon") {
                  _this12.stopDrawingMode();
                  if (_this12.ui.submenu !== "icon") {
                    _this12.ui.changeMenu("icon", false, false);
                  }
                  _this12.ui.icon.setIconPickerColor(fill_default()(obj));
                }
              },
              addText: function addText(pos) {
                var _this12$ui$text = _this12.ui.text, fill = _this12$ui$text.textColor, fontSize2 = _this12$ui$text.fontSize, fontStyle2 = _this12$ui$text.fontStyle, fontWeight2 = _this12$ui$text.fontWeight, underline = _this12$ui$text.underline;
                var fontFamily2 = "Noto Sans";
                _this12.addText("Double Click", {
                  position: pos.originPosition,
                  styles: {
                    fill,
                    fontSize: fontSize2,
                    fontFamily: fontFamily2,
                    fontStyle: fontStyle2,
                    fontWeight: fontWeight2,
                    underline
                  }
                }).then(function() {
                  _this12.changeCursor("default");
                });
              },
              addObjectAfter: function addObjectAfter(obj) {
                var _context3;
                if (obj.type === "icon") {
                  _this12.ui.icon.changeStandbyMode();
                } else if (index_of_default()(_context3 = ["rect", "circle", "triangle"]).call(_context3, obj.type) > -1) {
                  _this12.ui.shape.setMaxStrokeValue(Math.min(obj.width, obj.height));
                  _this12.ui.shape.changeStandbyMode();
                }
              },
              objectScaled: function objectScaled(obj) {
                var _context4, _context5;
                if (index_of_default()(_context4 = ["i-text", "text"]).call(_context4, obj.type) > -1) {
                  _this12.ui.text.fontSize = toInteger(obj.fontSize);
                } else if (index_of_default()(_context5 = ["rect", "circle", "triangle"]).call(_context5, obj.type) >= 0) {
                  var width = obj.width, height = obj.height;
                  var strokeValue = _this12.ui.shape.getStrokeValue();
                  if (width < strokeValue) {
                    _this12.ui.shape.setStrokeValue(width);
                  }
                  if (height < strokeValue) {
                    _this12.ui.shape.setStrokeValue(height);
                  }
                }
              },
              selectionCleared: function selectionCleared() {
                _this12.activeObjectId = null;
                if (_this12.ui.submenu === "text") {
                  _this12.changeCursor("text");
                } else if (!includes(["draw", "crop", "resize"], _this12.ui.submenu)) {
                  _this12.stopDrawingMode();
                }
              }
            });
          },
          _historyAction: function _historyAction() {
            var _this13 = this;
            return {
              undo: function undo2(count) {
                return _this13.undo(count);
              },
              redo: function redo(count) {
                return _this13.redo(count);
              }
            };
          },
          _commonAction: function _commonAction() {
            var _this14 = this, _context6, _context7, _context8, _context9;
            var TEXT2 = drawingModes.TEXT, CROPPER = drawingModes.CROPPER, SHAPE2 = drawingModes.SHAPE, ZOOM = drawingModes.ZOOM, RESIZE2 = drawingModes.RESIZE;
            return {
              modeChange: function modeChange(menu) {
                switch (menu) {
                  case drawingMenuNames.TEXT:
                    _this14._changeActivateMode(TEXT2);
                    break;
                  case drawingMenuNames.CROP:
                    _this14.startDrawingMode(CROPPER);
                    break;
                  case drawingMenuNames.SHAPE:
                    _this14._changeActivateMode(SHAPE2);
                    _this14.setDrawingShape(_this14.ui.shape.type, _this14.ui.shape.options);
                    break;
                  case drawingMenuNames.ZOOM:
                    _this14.startDrawingMode(ZOOM);
                    break;
                  case drawingMenuNames.RESIZE:
                    _this14.startDrawingMode(RESIZE2);
                    break;
                }
              },
              deactivateAll: bind_default()(_context6 = this.deactivateAll).call(_context6, this),
              changeSelectableAll: bind_default()(_context7 = this.changeSelectableAll).call(_context7, this),
              discardSelection: bind_default()(_context8 = this.discardSelection).call(_context8, this),
              stopDrawingMode: bind_default()(_context9 = this.stopDrawingMode).call(_context9, this)
            };
          },
          mixin: function mixin(ImageEditor3) {
            extend_default()(ImageEditor3.prototype, this);
          }
        };
        var isArray2 = __webpack_require__(602);
        var isArray_default = /* @__PURE__ */ __webpack_require__.n(isArray2);
        var forEachOwnProperties = __webpack_require__(5573);
        var forEachOwnProperties_default = /* @__PURE__ */ __webpack_require__.n(forEachOwnProperties);
        var Component2 = /* @__PURE__ */ function() {
          function Component3(name2, graphics2) {
            _classCallCheck(this, Component3);
            this.name = name2;
            this.graphics = graphics2;
          }
          _createClass(Component3, [{
            key: "fire",
            value: function fire() {
              var context = this.graphics;
              for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }
              return this.graphics.fire.apply(context, args);
            }
          }, {
            key: "setCanvasImage",
            value: function setCanvasImage(name2, oImage) {
              this.graphics.setCanvasImage(name2, oImage);
            }
          }, {
            key: "getCanvasElement",
            value: function getCanvasElement() {
              return this.graphics.getCanvasElement();
            }
          }, {
            key: "getCanvas",
            value: function getCanvas() {
              return this.graphics.getCanvas();
            }
          }, {
            key: "getCanvasImage",
            value: function getCanvasImage() {
              return this.graphics.getCanvasImage();
            }
          }, {
            key: "getImageName",
            value: function getImageName() {
              return this.graphics.getImageName();
            }
          }, {
            key: "getEditor",
            value: function getEditor() {
              return this.graphics.getEditor();
            }
          }, {
            key: "getName",
            value: function getName() {
              return this.name;
            }
          }, {
            key: "setImageProperties",
            value: function setImageProperties(setting, withRendering) {
              this.graphics.setImageProperties(setting, withRendering);
            }
          }, {
            key: "setCanvasCssDimension",
            value: function setCanvasCssDimension(dimension) {
              this.graphics.setCanvasCssDimension(dimension);
            }
          }, {
            key: "setCanvasBackstoreDimension",
            value: function setCanvasBackstoreDimension(dimension) {
              this.graphics.setCanvasBackstoreDimension(dimension);
            }
          }, {
            key: "adjustCanvasDimension",
            value: function adjustCanvasDimension() {
              this.graphics.adjustCanvasDimension();
            }
          }, {
            key: "adjustCanvasDimensionBase",
            value: function adjustCanvasDimensionBase() {
              this.graphics.adjustCanvasDimensionBase();
            }
          }]);
          return Component3;
        }();
        var component = Component2;
        function imageLoader_createSuper(Derived) {
          var hasNativeReflectConstruct = imageLoader_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function imageLoader_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var imageOption = {
          padding: 0,
          crossOrigin: "Anonymous"
        };
        var ImageLoader = /* @__PURE__ */ function(_Component) {
          _inherits(ImageLoader2, _Component);
          var _super = imageLoader_createSuper(ImageLoader2);
          function ImageLoader2(graphics2) {
            _classCallCheck(this, ImageLoader2);
            return _super.call(this, componentNames.IMAGE_LOADER, graphics2);
          }
          _createClass(ImageLoader2, [{
            key: "load",
            value: function load(imageName, img) {
              var _this = this;
              var promise;
              if (!imageName && !img) {
                var canvas = this.getCanvas();
                canvas.backgroundImage = null;
                canvas.renderAll();
                promise = new (promise_default())(function(resolve) {
                  _this.setCanvasImage("", null);
                  resolve();
                });
              } else {
                promise = this._setBackgroundImage(img).then(function(oImage) {
                  _this.setCanvasImage(imageName, oImage);
                  _this.adjustCanvasDimension();
                  return oImage;
                });
              }
              return promise;
            }
          }, {
            key: "_setBackgroundImage",
            value: function _setBackgroundImage(img) {
              var _this2 = this;
              if (!img) {
                return promise_default().reject(rejectMessages.loadImage);
              }
              return new (promise_default())(function(resolve, reject) {
                var canvas = _this2.getCanvas();
                canvas.setBackgroundImage(img, function() {
                  var oImage = canvas.backgroundImage;
                  if (oImage && oImage.getElement()) {
                    resolve(oImage);
                  } else {
                    reject(rejectMessages.loadingImageFailed);
                  }
                }, imageOption);
              });
            }
          }]);
          return ImageLoader2;
        }(component);
        var imageLoader = ImageLoader;
        var CORNER_TYPE_TOP_LEFT = "tl";
        var CORNER_TYPE_TOP_RIGHT = "tr";
        var CORNER_TYPE_MIDDLE_TOP = "mt";
        var CORNER_TYPE_MIDDLE_LEFT = "ml";
        var CORNER_TYPE_MIDDLE_RIGHT = "mr";
        var CORNER_TYPE_MIDDLE_BOTTOM = "mb";
        var CORNER_TYPE_BOTTOM_LEFT = "bl";
        var CORNER_TYPE_BOTTOM_RIGHT = "br";
        var CORNER_TYPE_LIST = [CORNER_TYPE_TOP_LEFT, CORNER_TYPE_TOP_RIGHT, CORNER_TYPE_MIDDLE_TOP, CORNER_TYPE_MIDDLE_LEFT, CORNER_TYPE_MIDDLE_RIGHT, CORNER_TYPE_MIDDLE_BOTTOM, CORNER_TYPE_BOTTOM_LEFT, CORNER_TYPE_BOTTOM_RIGHT];
        var NOOP_FUNCTION = function NOOP_FUNCTION2() {
        };
        function cornerTypeValid(selectedCorner) {
          return index_of_default()(CORNER_TYPE_LIST).call(CORNER_TYPE_LIST, selectedCorner) >= 0;
        }
        function getScaleBasis(diffX, diffY) {
          return diffX > diffY ? "width" : "height";
        }
        var Cropzone = fabric.fabric.util.createClass(
          fabric.fabric.Rect,
          {
            initialize: function initialize(canvas, options, extendsOptions) {
              options = extend_default()(options, extendsOptions);
              options.type = "cropzone";
              this.callSuper("initialize", options);
              this._addEventHandler();
              this.canvas = canvas;
              this.options = options;
            },
            canvasEventDelegation: function canvasEventDelegation(eventName) {
              var _context2;
              var delegationState = "unregistered";
              var isRegistered = this.canvasEventTrigger[eventName] !== NOOP_FUNCTION;
              if (isRegistered) {
                delegationState = "registered";
              } else if (index_of_default()(_context2 = [eventNames.OBJECT_MOVED, eventNames.OBJECT_SCALED]).call(_context2, eventName) < 0) {
                delegationState = "none";
              }
              return delegationState;
            },
            canvasEventRegister: function canvasEventRegister(eventName, eventTrigger) {
              this.canvasEventTrigger[eventName] = eventTrigger;
            },
            _addEventHandler: function _addEventHandler() {
              var _this$canvasEventTrig, _context2, _context3, _context4, _context5;
              this.canvasEventTrigger = (_this$canvasEventTrig = {}, _defineProperty2(_this$canvasEventTrig, eventNames.OBJECT_MOVED, NOOP_FUNCTION), _defineProperty2(_this$canvasEventTrig, eventNames.OBJECT_SCALED, NOOP_FUNCTION), _this$canvasEventTrig);
              this.on({
                moving: bind_default()(_context2 = this._onMoving).call(_context2, this),
                scaling: bind_default()(_context3 = this._onScaling).call(_context3, this)
              });
              fabric.fabric.util.addListener(document, "keydown", bind_default()(_context4 = this._onKeyDown).call(_context4, this));
              fabric.fabric.util.addListener(document, "keyup", bind_default()(_context5 = this._onKeyUp).call(_context5, this));
            },
            _renderCropzone: function _renderCropzone(ctx) {
              var cropzoneDashLineWidth = 7;
              var cropzoneDashLineOffset = 7;
              var originalFlipX = this.flipX ? -1 : 1;
              var originalFlipY = this.flipY ? -1 : 1;
              var originalScaleX = originalFlipX / this.scaleX;
              var originalScaleY = originalFlipY / this.scaleY;
              ctx.scale(originalScaleX, originalScaleY);
              this._fillOuterRect(ctx, "rgba(0, 0, 0, 0.5)");
              if (this.options.lineWidth) {
                this._fillInnerRect(ctx);
                this._strokeBorder(ctx, "rgb(255, 255, 255)", {
                  lineWidth: this.options.lineWidth
                });
              } else {
                this._strokeBorder(ctx, "rgb(0, 0, 0)", {
                  lineDashWidth: cropzoneDashLineWidth
                });
                this._strokeBorder(ctx, "rgb(255, 255, 255)", {
                  lineDashWidth: cropzoneDashLineWidth,
                  lineDashOffset: cropzoneDashLineOffset
                });
              }
              ctx.scale(1 / originalScaleX, 1 / originalScaleY);
            },
            _render: function _render(ctx) {
              this.callSuper("_render", ctx);
              this._renderCropzone(ctx);
            },
            _fillOuterRect: function _fillOuterRect(ctx, fillStyle) {
              var _this$_getCoordinates = this._getCoordinates(), x = _this$_getCoordinates.x, y = _this$_getCoordinates.y;
              ctx.save();
              ctx.fillStyle = fillStyle;
              ctx.beginPath();
              ctx.moveTo(x[0] - 1, y[0] - 1);
              ctx.lineTo(x[3] + 1, y[0] - 1);
              ctx.lineTo(x[3] + 1, y[3] + 1);
              ctx.lineTo(x[0] - 1, y[3] + 1);
              ctx.lineTo(x[0] - 1, y[0] - 1);
              ctx.closePath();
              ctx.moveTo(x[1], y[1]);
              ctx.lineTo(x[1], y[2]);
              ctx.lineTo(x[2], y[2]);
              ctx.lineTo(x[2], y[1]);
              ctx.lineTo(x[1], y[1]);
              ctx.closePath();
              fill_default()(ctx).call(ctx);
              ctx.restore();
            },
            _fillInnerRect: function _fillInnerRect(ctx) {
              var _this$_getCoordinates2 = this._getCoordinates(), outerX = _this$_getCoordinates2.x, outerY = _this$_getCoordinates2.y;
              var x = this._caculateInnerPosition(outerX, (outerX[2] - outerX[1]) / 3);
              var y = this._caculateInnerPosition(outerY, (outerY[2] - outerY[1]) / 3);
              ctx.save();
              ctx.strokeStyle = "rgba(255, 255, 255, 0.7)";
              ctx.lineWidth = this.options.lineWidth;
              ctx.beginPath();
              ctx.moveTo(x[0], y[1]);
              ctx.lineTo(x[3], y[1]);
              ctx.moveTo(x[0], y[2]);
              ctx.lineTo(x[3], y[2]);
              ctx.moveTo(x[1], y[0]);
              ctx.lineTo(x[1], y[3]);
              ctx.moveTo(x[2], y[0]);
              ctx.lineTo(x[2], y[3]);
              ctx.stroke();
              ctx.closePath();
              ctx.restore();
            },
            _caculateInnerPosition: function _caculateInnerPosition(outer, size) {
              var position2 = [];
              position2[0] = outer[1];
              position2[1] = outer[1] + size;
              position2[2] = outer[1] + size * 2;
              position2[3] = outer[2];
              return position2;
            },
            _getCoordinates: function _getCoordinates() {
              var _context6, _context7;
              var canvas = this.canvas, width = this.width, height = this.height, left = this.left, top = this.top;
              var halfWidth = width / 2;
              var halfHeight = height / 2;
              var canvasHeight = canvas.getHeight();
              var canvasWidth = canvas.getWidth();
              return {
                x: map_default()(_context6 = [
                  -(halfWidth + left),
                  -halfWidth,
                  halfWidth,
                  halfWidth + (canvasWidth - left - width)
                ]).call(_context6, Math.ceil),
                y: map_default()(_context7 = [
                  -(halfHeight + top),
                  -halfHeight,
                  halfHeight,
                  halfHeight + (canvasHeight - top - height)
                ]).call(_context7, Math.ceil)
              };
            },
            _strokeBorder: function _strokeBorder(ctx, strokeStyle, _ref) {
              var lineDashWidth = _ref.lineDashWidth, lineDashOffset = _ref.lineDashOffset, lineWidth = _ref.lineWidth;
              var halfWidth = this.width / 2;
              var halfHeight = this.height / 2;
              ctx.save();
              ctx.strokeStyle = strokeStyle;
              if (ctx.setLineDash) {
                ctx.setLineDash([lineDashWidth, lineDashWidth]);
              }
              if (lineDashOffset) {
                ctx.lineDashOffset = lineDashOffset;
              }
              if (lineWidth) {
                ctx.lineWidth = lineWidth;
              }
              ctx.beginPath();
              ctx.moveTo(-halfWidth, -halfHeight);
              ctx.lineTo(halfWidth, -halfHeight);
              ctx.lineTo(halfWidth, halfHeight);
              ctx.lineTo(-halfWidth, halfHeight);
              ctx.lineTo(-halfWidth, -halfHeight);
              ctx.stroke();
              ctx.restore();
            },
            _onMoving: function _onMoving() {
              var height = this.height, width = this.width, left = this.left, top = this.top;
              var maxLeft = this.canvas.getWidth() - width;
              var maxTop = this.canvas.getHeight() - height;
              this.left = clamp(left, 0, maxLeft);
              this.top = clamp(top, 0, maxTop);
              this.canvasEventTrigger[eventNames.OBJECT_MOVED](this);
            },
            _onScaling: function _onScaling(fEvent) {
              var selectedCorner = fEvent.transform.corner;
              var pointer = this.canvas.getPointer(fEvent.e);
              var settings = this._calcScalingSizeFromPointer(pointer, selectedCorner);
              this.scale(1).set(settings);
              this.canvasEventTrigger[eventNames.OBJECT_SCALED](this);
            },
            _calcScalingSizeFromPointer: function _calcScalingSizeFromPointer(pointer, selectedCorner) {
              var isCornerTypeValid = cornerTypeValid(selectedCorner);
              return isCornerTypeValid && this._resizeCropZone(pointer, selectedCorner);
            },
            adjustRatioCropzoneSize: function adjustRatioCropzoneSize(_ref2) {
              var width = _ref2.width, height = _ref2.height, leftMaker = _ref2.leftMaker, topMaker = _ref2.topMaker, maxWidth = _ref2.maxWidth, maxHeight = _ref2.maxHeight, scaleTo = _ref2.scaleTo;
              width = maxWidth ? clamp(width, 1, maxWidth) : width;
              height = maxHeight ? clamp(height, 1, maxHeight) : height;
              if (!this.presetRatio) {
                if (this._withShiftKey) {
                  if (width > height) {
                    height = width;
                  } else if (height > width) {
                    width = height;
                  }
                }
                return {
                  width,
                  height,
                  left: leftMaker(width),
                  top: topMaker(height)
                };
              }
              if (scaleTo === "width") {
                height = width / this.presetRatio;
              } else {
                width = height * this.presetRatio;
              }
              var maxScaleFactor = Math.min(maxWidth / width, maxHeight / height);
              if (maxScaleFactor <= 1) {
                var _context8;
                var _map = map_default()(_context8 = [width, height]).call(_context8, function(v) {
                  return v * maxScaleFactor;
                });
                var _map2 = _slicedToArray(_map, 2);
                width = _map2[0];
                height = _map2[1];
              }
              return {
                width,
                height,
                left: leftMaker(width),
                top: topMaker(height)
              };
            },
            _getCropzoneRectInfo: function _getCropzoneRectInfo() {
              var _this$canvas = this.canvas, canvasWidth = _this$canvas.width, canvasHeight = _this$canvas.height;
              var _this$getBoundingRect = this.getBoundingRect(false, true), rectTop = _this$getBoundingRect.top, rectLeft = _this$getBoundingRect.left, rectWidth = _this$getBoundingRect.width, rectHeight = _this$getBoundingRect.height;
              return {
                rectTop,
                rectLeft,
                rectWidth,
                rectHeight,
                rectRight: rectLeft + rectWidth,
                rectBottom: rectTop + rectHeight,
                canvasWidth,
                canvasHeight
              };
            },
            _resizeCropZone: function _resizeCropZone(_ref3, corner) {
              var x = _ref3.x, y = _ref3.y;
              var _this$_getCropzoneRec = this._getCropzoneRectInfo(), rectWidth = _this$_getCropzoneRec.rectWidth, rectHeight = _this$_getCropzoneRec.rectHeight, rectTop = _this$_getCropzoneRec.rectTop, rectLeft = _this$_getCropzoneRec.rectLeft, rectBottom = _this$_getCropzoneRec.rectBottom, rectRight = _this$_getCropzoneRec.rectRight, canvasWidth = _this$_getCropzoneRec.canvasWidth, canvasHeight = _this$_getCropzoneRec.canvasHeight;
              var resizeInfoMap = {
                tl: {
                  width: rectRight - x,
                  height: rectBottom - y,
                  leftMaker: function leftMaker(newWidth) {
                    return rectRight - newWidth;
                  },
                  topMaker: function topMaker(newHeight) {
                    return rectBottom - newHeight;
                  },
                  maxWidth: rectRight,
                  maxHeight: rectBottom,
                  scaleTo: getScaleBasis(rectLeft - x, rectTop - y)
                },
                tr: {
                  width: x - rectLeft,
                  height: rectBottom - y,
                  leftMaker: function leftMaker() {
                    return rectLeft;
                  },
                  topMaker: function topMaker(newHeight) {
                    return rectBottom - newHeight;
                  },
                  maxWidth: canvasWidth - rectLeft,
                  maxHeight: rectBottom,
                  scaleTo: getScaleBasis(x - rectRight, rectTop - y)
                },
                mt: {
                  width: rectWidth,
                  height: rectBottom - y,
                  leftMaker: function leftMaker() {
                    return rectLeft;
                  },
                  topMaker: function topMaker(newHeight) {
                    return rectBottom - newHeight;
                  },
                  maxWidth: canvasWidth - rectLeft,
                  maxHeight: rectBottom,
                  scaleTo: "height"
                },
                ml: {
                  width: rectRight - x,
                  height: rectHeight,
                  leftMaker: function leftMaker(newWidth) {
                    return rectRight - newWidth;
                  },
                  topMaker: function topMaker() {
                    return rectTop;
                  },
                  maxWidth: rectRight,
                  maxHeight: canvasHeight - rectTop,
                  scaleTo: "width"
                },
                mr: {
                  width: x - rectLeft,
                  height: rectHeight,
                  leftMaker: function leftMaker() {
                    return rectLeft;
                  },
                  topMaker: function topMaker() {
                    return rectTop;
                  },
                  maxWidth: canvasWidth - rectLeft,
                  maxHeight: canvasHeight - rectTop,
                  scaleTo: "width"
                },
                mb: {
                  width: rectWidth,
                  height: y - rectTop,
                  leftMaker: function leftMaker() {
                    return rectLeft;
                  },
                  topMaker: function topMaker() {
                    return rectTop;
                  },
                  maxWidth: canvasWidth - rectLeft,
                  maxHeight: canvasHeight - rectTop,
                  scaleTo: "height"
                },
                bl: {
                  width: rectRight - x,
                  height: y - rectTop,
                  leftMaker: function leftMaker(newWidth) {
                    return rectRight - newWidth;
                  },
                  topMaker: function topMaker() {
                    return rectTop;
                  },
                  maxWidth: rectRight,
                  maxHeight: canvasHeight - rectTop,
                  scaleTo: getScaleBasis(rectLeft - x, y - rectBottom)
                },
                br: {
                  width: x - rectLeft,
                  height: y - rectTop,
                  leftMaker: function leftMaker() {
                    return rectLeft;
                  },
                  topMaker: function topMaker() {
                    return rectTop;
                  },
                  maxWidth: canvasWidth - rectLeft,
                  maxHeight: canvasHeight - rectTop,
                  scaleTo: getScaleBasis(x - rectRight, y - rectBottom)
                }
              };
              return this.adjustRatioCropzoneSize(resizeInfoMap[corner]);
            },
            isValid: function isValid() {
              return this.left >= 0 && this.top >= 0 && this.width > 0 && this.height > 0;
            },
            _onKeyDown: function _onKeyDown(_ref4) {
              var keyCode = _ref4.keyCode;
              if (keyCode === keyCodes.SHIFT) {
                this._withShiftKey = true;
              }
            },
            _onKeyUp: function _onKeyUp(_ref5) {
              var keyCode = _ref5.keyCode;
              if (keyCode === keyCodes.SHIFT) {
                this._withShiftKey = false;
              }
            }
          }
        );
        var cropzone = Cropzone;
        function cropper_createSuper(Derived) {
          var hasNativeReflectConstruct = cropper_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function cropper_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var MOUSE_MOVE_THRESHOLD = 10;
        var DEFAULT_OPTION = {
          presetRatio: null,
          top: -10,
          left: -10,
          height: 1,
          width: 1
        };
        var Cropper = /* @__PURE__ */ function(_Component) {
          _inherits(Cropper2, _Component);
          var _super = cropper_createSuper(Cropper2);
          function Cropper2(graphics2) {
            var _context2, _context22, _context3, _context4, _context5;
            var _this;
            _classCallCheck(this, Cropper2);
            _this = _super.call(this, componentNames.CROPPER, graphics2);
            _this._cropzone = null;
            _this._startX = null;
            _this._startY = null;
            _this._withShiftKey = false;
            _this._listeners = {
              keydown: bind_default()(_context2 = _this._onKeyDown).call(_context2, _assertThisInitialized(_this)),
              keyup: bind_default()(_context22 = _this._onKeyUp).call(_context22, _assertThisInitialized(_this)),
              mousedown: bind_default()(_context3 = _this._onFabricMouseDown).call(_context3, _assertThisInitialized(_this)),
              mousemove: bind_default()(_context4 = _this._onFabricMouseMove).call(_context4, _assertThisInitialized(_this)),
              mouseup: bind_default()(_context5 = _this._onFabricMouseUp).call(_context5, _assertThisInitialized(_this))
            };
            return _this;
          }
          _createClass(Cropper2, [{
            key: "start",
            value: function start() {
              if (this._cropzone) {
                return;
              }
              var canvas = this.getCanvas();
              canvas.forEachObject(function(obj) {
                obj.evented = false;
              });
              this._cropzone = new cropzone(canvas, extend_default()({
                left: 0,
                top: 0,
                width: 0.5,
                height: 0.5,
                strokeWidth: 0,
                cornerSize: 10,
                cornerColor: "black",
                fill: "transparent"
              }, CROPZONE_DEFAULT_OPTIONS, this.graphics.cropSelectionStyle));
              canvas.discardActiveObject();
              canvas.add(this._cropzone);
              canvas.on("mouse:down", this._listeners.mousedown);
              canvas.selection = false;
              canvas.defaultCursor = "crosshair";
              fabric.fabric.util.addListener(document, "keydown", this._listeners.keydown);
              fabric.fabric.util.addListener(document, "keyup", this._listeners.keyup);
            }
          }, {
            key: "end",
            value: function end() {
              var canvas = this.getCanvas();
              var cropzone2 = this._cropzone;
              if (!cropzone2) {
                return;
              }
              canvas.remove(cropzone2);
              canvas.selection = true;
              canvas.defaultCursor = "default";
              canvas.off("mouse:down", this._listeners.mousedown);
              canvas.forEachObject(function(obj) {
                obj.evented = true;
              });
              this._cropzone = null;
              fabric.fabric.util.removeListener(document, "keydown", this._listeners.keydown);
              fabric.fabric.util.removeListener(document, "keyup", this._listeners.keyup);
            }
          }, {
            key: "changeVisibility",
            value: function changeVisibility(visible) {
              if (this._cropzone) {
                this._cropzone.set({
                  visible
                });
              }
            }
          }, {
            key: "_onFabricMouseDown",
            value: function _onFabricMouseDown(fEvent) {
              var canvas = this.getCanvas();
              if (fEvent.target) {
                return;
              }
              canvas.selection = false;
              var coord = canvas.getPointer(fEvent.e);
              this._startX = coord.x;
              this._startY = coord.y;
              canvas.on({
                "mouse:move": this._listeners.mousemove,
                "mouse:up": this._listeners.mouseup
              });
            }
          }, {
            key: "_onFabricMouseMove",
            value: function _onFabricMouseMove(fEvent) {
              var canvas = this.getCanvas();
              var pointer = canvas.getPointer(fEvent.e);
              var x = pointer.x, y = pointer.y;
              var cropzone2 = this._cropzone;
              if (Math.abs(x - this._startX) + Math.abs(y - this._startY) > MOUSE_MOVE_THRESHOLD) {
                canvas.remove(cropzone2);
                cropzone2.set(this._calcRectDimensionFromPoint(x, y, cropzone2.presetRatio));
                canvas.add(cropzone2);
                canvas.setActiveObject(cropzone2);
              }
            }
          }, {
            key: "_calcRectDimensionFromPoint",
            value: function _calcRectDimensionFromPoint(x, y) {
              var presetRatio = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
              var canvas = this.getCanvas();
              var canvasWidth = canvas.getWidth();
              var canvasHeight = canvas.getHeight();
              var startX = this._startX;
              var startY = this._startY;
              var left = clamp(x, 0, startX);
              var top = clamp(y, 0, startY);
              var width = clamp(x, startX, canvasWidth) - left;
              var height = clamp(y, startY, canvasHeight) - top;
              if (this._withShiftKey && !presetRatio) {
                if (width > height) {
                  height = width;
                } else if (height > width) {
                  width = height;
                }
                if (startX >= x) {
                  left = startX - width;
                }
                if (startY >= y) {
                  top = startY - height;
                }
              } else if (presetRatio) {
                height = width / presetRatio;
                if (startX >= x) {
                  left = clamp(startX - width, 0, canvasWidth);
                }
                if (startY >= y) {
                  top = clamp(startY - height, 0, canvasHeight);
                }
                if (top + height > canvasHeight) {
                  height = canvasHeight - top;
                  width = height * presetRatio;
                  if (startX >= x) {
                    left = clamp(startX - width, 0, canvasWidth);
                  }
                  if (startY >= y) {
                    top = clamp(startY - height, 0, canvasHeight);
                  }
                }
              }
              return {
                left,
                top,
                width,
                height
              };
            }
          }, {
            key: "_onFabricMouseUp",
            value: function _onFabricMouseUp() {
              var cropzone2 = this._cropzone;
              var listeners = this._listeners;
              var canvas = this.getCanvas();
              canvas.setActiveObject(cropzone2);
              canvas.off({
                "mouse:move": listeners.mousemove,
                "mouse:up": listeners.mouseup
              });
            }
          }, {
            key: "getCroppedImageData",
            value: function getCroppedImageData(cropRect) {
              var canvas = this.getCanvas();
              var containsCropzone = canvas.contains(this._cropzone);
              if (!cropRect) {
                return null;
              }
              if (containsCropzone) {
                canvas.remove(this._cropzone);
              }
              var imageData = {
                imageName: this.getImageName(),
                url: canvas.toDataURL(cropRect)
              };
              if (containsCropzone) {
                canvas.add(this._cropzone);
              }
              return imageData;
            }
          }, {
            key: "getCropzoneRect",
            value: function getCropzoneRect() {
              var cropzone2 = this._cropzone;
              if (!cropzone2.isValid()) {
                return null;
              }
              return {
                left: cropzone2.left,
                top: cropzone2.top,
                width: cropzone2.width,
                height: cropzone2.height
              };
            }
          }, {
            key: "setCropzoneRect",
            value: function setCropzoneRect(presetRatio) {
              var canvas = this.getCanvas();
              var cropzone2 = this._cropzone;
              canvas.discardActiveObject();
              canvas.selection = false;
              canvas.remove(cropzone2);
              cropzone2.set(presetRatio ? this._getPresetPropertiesForCropSize(presetRatio) : DEFAULT_OPTION);
              canvas.add(cropzone2);
              canvas.selection = true;
              if (presetRatio) {
                canvas.setActiveObject(cropzone2);
              }
            }
          }, {
            key: "_getPresetPropertiesForCropSize",
            value: function _getPresetPropertiesForCropSize(presetRatio) {
              var _context6, _context7;
              var canvas = this.getCanvas();
              var originalWidth = canvas.getWidth();
              var originalHeight = canvas.getHeight();
              var standardSize = originalWidth >= originalHeight ? originalWidth : originalHeight;
              var getScale = function getScale2(value, orignalValue) {
                return value > orignalValue ? orignalValue / value : 1;
              };
              var width = standardSize * presetRatio;
              var height = standardSize;
              var scaleWidth = getScale(width, originalWidth);
              var _map = map_default()(_context6 = [width, height]).call(_context6, function(sizeValue) {
                return sizeValue * scaleWidth;
              });
              var _map2 = _slicedToArray(_map, 2);
              width = _map2[0];
              height = _map2[1];
              var scaleHeight = getScale(height, originalHeight);
              var _map3 = map_default()(_context7 = [width, height]).call(_context7, function(sizeValue) {
                return fixFloatingPoint(sizeValue * scaleHeight);
              });
              var _map4 = _slicedToArray(_map3, 2);
              width = _map4[0];
              height = _map4[1];
              return {
                presetRatio,
                top: (originalHeight - height) / 2,
                left: (originalWidth - width) / 2,
                width,
                height
              };
            }
          }, {
            key: "_onKeyDown",
            value: function _onKeyDown(e2) {
              if (e2.keyCode === keyCodes.SHIFT) {
                this._withShiftKey = true;
              }
            }
          }, {
            key: "_onKeyUp",
            value: function _onKeyUp(e2) {
              if (e2.keyCode === keyCodes.SHIFT) {
                this._withShiftKey = false;
              }
            }
          }]);
          return Cropper2;
        }(component);
        var cropper = Cropper;
        function component_flip_createSuper(Derived) {
          var hasNativeReflectConstruct = component_flip_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function component_flip_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var flip_Flip = /* @__PURE__ */ function(_Component) {
          _inherits(Flip2, _Component);
          var _super = component_flip_createSuper(Flip2);
          function Flip2(graphics2) {
            _classCallCheck(this, Flip2);
            return _super.call(this, componentNames.FLIP, graphics2);
          }
          _createClass(Flip2, [{
            key: "getCurrentSetting",
            value: function getCurrentSetting() {
              var canvasImage = this.getCanvasImage();
              return {
                flipX: canvasImage.flipX,
                flipY: canvasImage.flipY
              };
            }
          }, {
            key: "set",
            value: function set(newSetting) {
              var setting = this.getCurrentSetting();
              var isChangingFlipX = setting.flipX !== newSetting.flipX;
              var isChangingFlipY = setting.flipY !== newSetting.flipY;
              if (!isChangingFlipX && !isChangingFlipY) {
                return promise_default().reject(rejectMessages.flip);
              }
              extend_default()(setting, newSetting);
              this.setImageProperties(setting, true);
              this._invertAngle(isChangingFlipX, isChangingFlipY);
              this._flipObjects(isChangingFlipX, isChangingFlipY);
              return promise_default().resolve({
                flipX: setting.flipX,
                flipY: setting.flipY,
                angle: this.getCanvasImage().angle
              });
            }
          }, {
            key: "_invertAngle",
            value: function _invertAngle(isChangingFlipX, isChangingFlipY) {
              var canvasImage = this.getCanvasImage();
              var angle2 = canvasImage.angle;
              if (isChangingFlipX) {
                angle2 *= -1;
              }
              if (isChangingFlipY) {
                angle2 *= -1;
              }
              canvasImage.rotate(parse_float_default()(angle2)).setCoords();
            }
          }, {
            key: "_flipObjects",
            value: function _flipObjects(isChangingFlipX, isChangingFlipY) {
              var canvas = this.getCanvas();
              if (isChangingFlipX) {
                canvas.forEachObject(function(obj) {
                  obj.set({
                    angle: parse_float_default()(obj.angle * -1),
                    flipX: !obj.flipX,
                    left: canvas.width - obj.left
                  }).setCoords();
                });
              }
              if (isChangingFlipY) {
                canvas.forEachObject(function(obj) {
                  obj.set({
                    angle: parse_float_default()(obj.angle * -1),
                    flipY: !obj.flipY,
                    top: canvas.height - obj.top
                  }).setCoords();
                });
              }
              canvas.renderAll();
            }
          }, {
            key: "reset",
            value: function reset() {
              return this.set({
                flipX: false,
                flipY: false
              });
            }
          }, {
            key: "flipX",
            value: function flipX() {
              var current = this.getCurrentSetting();
              return this.set({
                flipX: !current.flipX,
                flipY: current.flipY
              });
            }
          }, {
            key: "flipY",
            value: function flipY() {
              var current = this.getCurrentSetting();
              return this.set({
                flipX: current.flipX,
                flipY: !current.flipY
              });
            }
          }]);
          return Flip2;
        }(component);
        var component_flip = flip_Flip;
        function rotation_createSuper(Derived) {
          var hasNativeReflectConstruct = rotation_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function rotation_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var Rotation = /* @__PURE__ */ function(_Component) {
          _inherits(Rotation2, _Component);
          var _super = rotation_createSuper(Rotation2);
          function Rotation2(graphics2) {
            _classCallCheck(this, Rotation2);
            return _super.call(this, componentNames.ROTATION, graphics2);
          }
          _createClass(Rotation2, [{
            key: "getCurrentAngle",
            value: function getCurrentAngle() {
              return this.getCanvasImage().angle;
            }
          }, {
            key: "setAngle",
            value: function setAngle(angle2) {
              var oldAngle = this.getCurrentAngle() % 360;
              angle2 %= 360;
              var canvasImage = this.getCanvasImage();
              var oldImageCenter = canvasImage.getCenterPoint();
              canvasImage.set({
                angle: angle2
              }).setCoords();
              this.adjustCanvasDimension();
              var newImageCenter = canvasImage.getCenterPoint();
              this._rotateForEachObject(oldImageCenter, newImageCenter, angle2 - oldAngle);
              return promise_default().resolve(angle2);
            }
          }, {
            key: "_rotateForEachObject",
            value: function _rotateForEachObject(oldImageCenter, newImageCenter, angleDiff) {
              var canvas = this.getCanvas();
              var centerDiff = {
                x: oldImageCenter.x - newImageCenter.x,
                y: oldImageCenter.y - newImageCenter.y
              };
              canvas.forEachObject(function(obj) {
                var objCenter = obj.getCenterPoint();
                var radian = fabric.fabric.util.degreesToRadians(angleDiff);
                var newObjCenter = fabric.fabric.util.rotatePoint(objCenter, oldImageCenter, radian);
                obj.set({
                  left: newObjCenter.x - centerDiff.x,
                  top: newObjCenter.y - centerDiff.y,
                  angle: (obj.angle + angleDiff) % 360
                });
                obj.setCoords();
              });
              canvas.renderAll();
            }
          }, {
            key: "rotate",
            value: function rotate3(additionalAngle) {
              var current = this.getCurrentAngle();
              return this.setAngle(current + additionalAngle);
            }
          }]);
          return Rotation2;
        }(component);
        var rotation = Rotation;
        function freeDrawing_createSuper(Derived) {
          var hasNativeReflectConstruct = freeDrawing_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function freeDrawing_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var FreeDrawing = /* @__PURE__ */ function(_Component) {
          _inherits(FreeDrawing2, _Component);
          var _super = freeDrawing_createSuper(FreeDrawing2);
          function FreeDrawing2(graphics2) {
            var _this;
            _classCallCheck(this, FreeDrawing2);
            _this = _super.call(this, componentNames.FREE_DRAWING, graphics2);
            _this.width = 12;
            _this.oColor = new fabric.fabric.Color("rgba(0, 0, 0, 0.5)");
            return _this;
          }
          _createClass(FreeDrawing2, [{
            key: "start",
            value: function start(setting) {
              var canvas = this.getCanvas();
              canvas.isDrawingMode = true;
              this.setBrush(setting);
            }
          }, {
            key: "setBrush",
            value: function setBrush(setting) {
              var brush = this.getCanvas().freeDrawingBrush;
              setting = setting || {};
              this.width = setting.width || this.width;
              if (setting.color) {
                this.oColor = new fabric.fabric.Color(setting.color);
              }
              brush.width = this.width;
              brush.color = this.oColor.toRgba();
            }
          }, {
            key: "end",
            value: function end() {
              var canvas = this.getCanvas();
              canvas.isDrawingMode = false;
            }
          }]);
          return FreeDrawing2;
        }(component);
        var freeDrawing = FreeDrawing;
        var ARROW_ANGLE = 30;
        var CHEVRON_SIZE_RATIO = 2.7;
        var TRIANGLE_SIZE_RATIO = 1.7;
        var RADIAN_CONVERSION_VALUE = 180;
        var ArrowLine = fabric.fabric.util.createClass(
          fabric.fabric.Line,
          {
            type: "line",
            initialize: function initialize(points) {
              var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
              this.callSuper("initialize", points, options);
              this.arrowType = options.arrowType;
            },
            _render: function _render(ctx) {
              var _this$calcLinePoints = this.calcLinePoints(), fromX = _this$calcLinePoints.x1, fromY = _this$calcLinePoints.y1, toX = _this$calcLinePoints.x2, toY = _this$calcLinePoints.y2;
              var linePosition = {
                fromX,
                fromY,
                toX,
                toY
              };
              this.ctx = ctx;
              ctx.lineWidth = this.strokeWidth;
              this._renderBasicLinePath(linePosition);
              this._drawDecoratorPath(linePosition);
              this._renderStroke(ctx);
            },
            _renderBasicLinePath: function _renderBasicLinePath(_ref) {
              var fromX = _ref.fromX, fromY = _ref.fromY, toX = _ref.toX, toY = _ref.toY;
              this.ctx.beginPath();
              this.ctx.moveTo(fromX, fromY);
              this.ctx.lineTo(toX, toY);
            },
            _drawDecoratorPath: function _drawDecoratorPath(linePosition) {
              this._drawDecoratorPathType("head", linePosition);
              this._drawDecoratorPathType("tail", linePosition);
            },
            _drawDecoratorPathType: function _drawDecoratorPathType(type, linePosition) {
              switch (this.arrowType[type]) {
                case "triangle":
                  this._drawTrianglePath(type, linePosition);
                  break;
                case "chevron":
                  this._drawChevronPath(type, linePosition);
                  break;
              }
            },
            _drawTrianglePath: function _drawTrianglePath(type, linePosition) {
              var decorateSize = this.ctx.lineWidth * TRIANGLE_SIZE_RATIO;
              this._drawChevronPath(type, linePosition, decorateSize);
              this.ctx.closePath();
            },
            _drawChevronPath: function _drawChevronPath(type, _ref2, decorateSize) {
              var _this = this;
              var fromX = _ref2.fromX, fromY = _ref2.fromY, toX = _ref2.toX, toY = _ref2.toY;
              var ctx = this.ctx;
              if (!decorateSize) {
                decorateSize = this.ctx.lineWidth * CHEVRON_SIZE_RATIO;
              }
              var _ref3 = type === "head" ? [fromX, fromY] : [toX, toY], _ref4 = _slicedToArray(_ref3, 2), standardX = _ref4[0], standardY = _ref4[1];
              var _ref5 = type === "head" ? [toX, toY] : [fromX, fromY], _ref6 = _slicedToArray(_ref5, 2), compareX = _ref6[0], compareY = _ref6[1];
              var angle2 = Math.atan2(compareY - standardY, compareX - standardX) * RADIAN_CONVERSION_VALUE / Math.PI;
              var rotatedPosition = function rotatedPosition2(changeAngle) {
                return _this.getRotatePosition(decorateSize, changeAngle, {
                  x: standardX,
                  y: standardY
                });
              };
              ctx.moveTo.apply(ctx, _toConsumableArray(rotatedPosition(angle2 + ARROW_ANGLE)));
              ctx.lineTo(standardX, standardY);
              ctx.lineTo.apply(ctx, _toConsumableArray(rotatedPosition(angle2 - ARROW_ANGLE)));
            },
            getRotatePosition: function getRotatePosition(distance2, angle2, referencePosition) {
              var radian = angle2 * Math.PI / RADIAN_CONVERSION_VALUE;
              var x = referencePosition.x, y = referencePosition.y;
              return [distance2 * Math.cos(radian) + x, distance2 * Math.sin(radian) + y];
            }
          }
        );
        var arrowLine = ArrowLine;
        function line_createSuper(Derived) {
          var hasNativeReflectConstruct = line_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function line_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var Line = /* @__PURE__ */ function(_Component) {
          _inherits(Line2, _Component);
          var _super = line_createSuper(Line2);
          function Line2(graphics2) {
            var _context2, _context22, _context3;
            var _this;
            _classCallCheck(this, Line2);
            _this = _super.call(this, componentNames.LINE, graphics2);
            _this._width = 12;
            _this._oColor = new fabric.fabric.Color("rgba(0, 0, 0, 0.5)");
            _this._listeners = {
              mousedown: bind_default()(_context2 = _this._onFabricMouseDown).call(_context2, _assertThisInitialized(_this)),
              mousemove: bind_default()(_context22 = _this._onFabricMouseMove).call(_context22, _assertThisInitialized(_this)),
              mouseup: bind_default()(_context3 = _this._onFabricMouseUp).call(_context3, _assertThisInitialized(_this))
            };
            return _this;
          }
          _createClass(Line2, [{
            key: "setHeadOption",
            value: function setHeadOption(setting) {
              var _setting$arrowType = setting.arrowType, arrowType = _setting$arrowType === void 0 ? {
                head: null,
                tail: null
              } : _setting$arrowType;
              this._arrowType = arrowType;
            }
          }, {
            key: "start",
            value: function start() {
              var setting = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
              var canvas = this.getCanvas();
              canvas.defaultCursor = "crosshair";
              canvas.selection = false;
              this.setHeadOption(setting);
              this.setBrush(setting);
              canvas.forEachObject(function(obj) {
                obj.set({
                  evented: false
                });
              });
              canvas.on({
                "mouse:down": this._listeners.mousedown
              });
            }
          }, {
            key: "setBrush",
            value: function setBrush(setting) {
              var brush = this.getCanvas().freeDrawingBrush;
              setting = setting || {};
              this._width = setting.width || this._width;
              if (setting.color) {
                this._oColor = new fabric.fabric.Color(setting.color);
              }
              brush.width = this._width;
              brush.color = this._oColor.toRgba();
            }
          }, {
            key: "end",
            value: function end() {
              var canvas = this.getCanvas();
              canvas.defaultCursor = "default";
              canvas.selection = true;
              canvas.forEachObject(function(obj) {
                obj.set({
                  evented: true
                });
              });
              canvas.off("mouse:down", this._listeners.mousedown);
            }
          }, {
            key: "_onFabricMouseDown",
            value: function _onFabricMouseDown(fEvent) {
              var canvas = this.getCanvas();
              var _canvas$getPointer = canvas.getPointer(fEvent.e), x = _canvas$getPointer.x, y = _canvas$getPointer.y;
              var points = [x, y, x, y];
              this._line = new arrowLine(points, {
                stroke: this._oColor.toRgba(),
                strokeWidth: this._width,
                arrowType: this._arrowType,
                evented: false
              });
              this._line.set(fObjectOptions.SELECTION_STYLE);
              canvas.add(this._line);
              canvas.on({
                "mouse:move": this._listeners.mousemove,
                "mouse:up": this._listeners.mouseup
              });
              this.fire(eventNames.ADD_OBJECT, this._createLineEventObjectProperties());
            }
          }, {
            key: "_onFabricMouseMove",
            value: function _onFabricMouseMove(fEvent) {
              var canvas = this.getCanvas();
              var pointer = canvas.getPointer(fEvent.e);
              this._line.set({
                x2: pointer.x,
                y2: pointer.y
              });
              this._line.setCoords();
              canvas.renderAll();
            }
          }, {
            key: "_onFabricMouseUp",
            value: function _onFabricMouseUp() {
              var canvas = this.getCanvas();
              this.fire(eventNames.OBJECT_ADDED, this._createLineEventObjectProperties());
              this._line = null;
              canvas.off({
                "mouse:move": this._listeners.mousemove,
                "mouse:up": this._listeners.mouseup
              });
            }
          }, {
            key: "_createLineEventObjectProperties",
            value: function _createLineEventObjectProperties() {
              var params = this.graphics.createObjectProperties(this._line);
              var _this$_line = this._line, x1 = _this$_line.x1, x2 = _this$_line.x2, y1 = _this$_line.y1, y2 = _this$_line.y2;
              return extend_default()({}, params, {
                startPosition: {
                  x: x1,
                  y: y1
                },
                endPosition: {
                  x: x2,
                  y: y2
                }
              });
            }
          }]);
          return Line2;
        }(component);
        var line = Line;
        function component_text_createSuper(Derived) {
          var hasNativeReflectConstruct = component_text_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function component_text_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var defaultStyles = {
          fill: "#000000",
          left: 0,
          top: 0
        };
        var resetStyles = {
          fill: "#000000",
          fontStyle: "normal",
          fontWeight: "normal",
          textAlign: "tie-text-align-left",
          underline: false
        };
        var DBCLICK_TIME = 500;
        var text_Text = /* @__PURE__ */ function(_Component) {
          _inherits(Text2, _Component);
          var _super = component_text_createSuper(Text2);
          function Text2(graphics2) {
            var _context2, _context22, _context3, _context4, _context5;
            var _this;
            _classCallCheck(this, Text2);
            _this = _super.call(this, componentNames.TEXT, graphics2);
            _this._defaultStyles = defaultStyles;
            _this._isSelected = false;
            _this._selectedObj = {};
            _this._editingObj = {};
            _this._listeners = {
              mousedown: bind_default()(_context2 = _this._onFabricMouseDown).call(_context2, _assertThisInitialized(_this)),
              select: bind_default()(_context22 = _this._onFabricSelect).call(_context22, _assertThisInitialized(_this)),
              selectClear: bind_default()(_context3 = _this._onFabricSelectClear).call(_context3, _assertThisInitialized(_this)),
              scaling: bind_default()(_context4 = _this._onFabricScaling).call(_context4, _assertThisInitialized(_this)),
              textChanged: bind_default()(_context5 = _this._onFabricTextChanged).call(_context5, _assertThisInitialized(_this))
            };
            _this._textarea = null;
            _this._ratio = 1;
            _this._lastClickTime = new Date().getTime();
            _this._editingObjInfos = {};
            _this.isPrevEditing = false;
            return _this;
          }
          _createClass(Text2, [{
            key: "start",
            value: function start() {
              var _this2 = this;
              var canvas = this.getCanvas();
              canvas.selection = false;
              canvas.defaultCursor = "text";
              canvas.on({
                "mouse:down": this._listeners.mousedown,
                "selection:created": this._listeners.select,
                "selection:updated": this._listeners.select,
                "before:selection:cleared": this._listeners.selectClear,
                "object:scaling": this._listeners.scaling,
                "text:changed": this._listeners.textChanged
              });
              canvas.forEachObject(function(obj) {
                if (obj.type === "i-text") {
                  _this2.adjustOriginPosition(obj, "start");
                }
              });
              this.setCanvasRatio();
            }
          }, {
            key: "end",
            value: function end() {
              var _this3 = this;
              var canvas = this.getCanvas();
              canvas.selection = true;
              canvas.defaultCursor = "default";
              canvas.forEachObject(function(obj) {
                if (obj.type === "i-text") {
                  if (obj.text === "") {
                    canvas.remove(obj);
                  } else {
                    _this3.adjustOriginPosition(obj, "end");
                  }
                }
              });
              canvas.off({
                "mouse:down": this._listeners.mousedown,
                "selection:created": this._listeners.select,
                "selection:updated": this._listeners.select,
                "before:selection:cleared": this._listeners.selectClear,
                "object:selected": this._listeners.select,
                "object:scaling": this._listeners.scaling,
                "text:changed": this._listeners.textChanged
              });
            }
          }, {
            key: "adjustOriginPosition",
            value: function adjustOriginPosition(text, editStatus) {
              var originX = "center", originY = "center";
              if (editStatus === "start") {
                originX = "left";
                originY = "top";
              }
              var _text$getPointByOrigi = text.getPointByOrigin(originX, originY), left = _text$getPointByOrigi.x, top = _text$getPointByOrigi.y;
              text.set({
                left,
                top,
                originX,
                originY
              });
              text.setCoords();
            }
          }, {
            key: "add",
            value: function add2(text, options) {
              var _this4 = this;
              return new (promise_default())(function(resolve) {
                var _context6;
                var canvas = _this4.getCanvas();
                var newText = null;
                var selectionStyle = fObjectOptions.SELECTION_STYLE;
                var styles = _this4._defaultStyles;
                _this4._setInitPos(options.position);
                if (options.styles) {
                  styles = extend_default()(styles, options.styles);
                }
                if (!isExisty_default()(options.autofocus)) {
                  options.autofocus = true;
                }
                newText = new fabric.fabric.IText(text, styles);
                selectionStyle = extend_default()({}, selectionStyle, {
                  originX: "left",
                  originY: "top"
                });
                newText.set(selectionStyle);
                newText.on({
                  mouseup: bind_default()(_context6 = _this4._onFabricMouseUp).call(_context6, _this4)
                });
                canvas.add(newText);
                if (options.autofocus) {
                  newText.enterEditing();
                  newText.selectAll();
                }
                if (!canvas.getActiveObject()) {
                  canvas.setActiveObject(newText);
                }
                _this4.isPrevEditing = true;
                resolve(_this4.graphics.createObjectProperties(newText));
              });
            }
          }, {
            key: "change",
            value: function change(activeObj, text) {
              var _this5 = this;
              return new (promise_default())(function(resolve) {
                activeObj.set("text", text);
                _this5.getCanvas().renderAll();
                resolve();
              });
            }
          }, {
            key: "setStyle",
            value: function setStyle(activeObj, styleObj) {
              var _this6 = this;
              return new (promise_default())(function(resolve) {
                forEach_default()(styleObj, function(val, key) {
                  if (activeObj[key] === val && key !== "fontSize") {
                    styleObj[key] = resetStyles[key] || "";
                  }
                }, _this6);
                if ("textDecoration" in styleObj) {
                  extend_default()(styleObj, _this6._getTextDecorationAdaptObject(styleObj.textDecoration));
                }
                activeObj.set(styleObj);
                _this6.getCanvas().renderAll();
                resolve();
              });
            }
          }, {
            key: "getText",
            value: function getText(activeObj) {
              return activeObj.text;
            }
          }, {
            key: "setSelectedInfo",
            value: function setSelectedInfo(obj, state) {
              this._selectedObj = obj;
              this._isSelected = state;
            }
          }, {
            key: "isSelected",
            value: function isSelected() {
              return this._isSelected;
            }
          }, {
            key: "getSelectedObj",
            value: function getSelectedObj() {
              return this._selectedObj;
            }
          }, {
            key: "setCanvasRatio",
            value: function setCanvasRatio() {
              var canvasElement = this.getCanvasElement();
              var cssWidth = parse_int_default()(canvasElement.style.maxWidth, 10);
              var originWidth = canvasElement.width;
              this._ratio = originWidth / cssWidth;
            }
          }, {
            key: "getCanvasRatio",
            value: function getCanvasRatio() {
              return this._ratio;
            }
          }, {
            key: "_getTextDecorationAdaptObject",
            value: function _getTextDecorationAdaptObject(textDecoration) {
              return {
                underline: textDecoration === "underline",
                linethrough: textDecoration === "line-through",
                overline: textDecoration === "overline"
              };
            }
          }, {
            key: "_setInitPos",
            value: function _setInitPos(position2) {
              position2 = position2 || this.getCanvasImage().getCenterPoint();
              this._defaultStyles.left = position2.x;
              this._defaultStyles.top = position2.y;
            }
          }, {
            key: "_onInput",
            value: function _onInput() {
              var ratio = this.getCanvasRatio();
              var obj = this._editingObj;
              var textareaStyle = this._textarea.style;
              textareaStyle.width = "".concat(Math.ceil(obj.width / ratio), "px");
              textareaStyle.height = "".concat(Math.ceil(obj.height / ratio), "px");
            }
          }, {
            key: "_onKeyDown",
            value: function _onKeyDown() {
              var _this7 = this;
              var ratio = this.getCanvasRatio();
              var obj = this._editingObj;
              var textareaStyle = this._textarea.style;
              set_timeout_default()(function() {
                obj.text(_this7._textarea.value);
                textareaStyle.width = "".concat(Math.ceil(obj.width / ratio), "px");
                textareaStyle.height = "".concat(Math.ceil(obj.height / ratio), "px");
              }, 0);
            }
          }, {
            key: "_onBlur",
            value: function _onBlur() {
              var ratio = this.getCanvasRatio();
              var editingObj = this._editingObj;
              var editingObjInfos = this._editingObjInfos;
              var textContent = this._textarea.value;
              var transWidth = editingObj.width / ratio - editingObjInfos.width / ratio;
              var transHeight = editingObj.height / ratio - editingObjInfos.height / ratio;
              if (ratio === 1) {
                transWidth /= 2;
                transHeight /= 2;
              }
              this._textarea.style.display = "none";
              editingObj.set({
                left: editingObjInfos.left + transWidth,
                top: editingObjInfos.top + transHeight
              });
              if (textContent.length) {
                this.getCanvas().add(editingObj);
                var params = {
                  id: stamp(editingObj),
                  type: editingObj.type,
                  text: textContent
                };
                this.fire(eventNames.TEXT_CHANGED, params);
              }
            }
          }, {
            key: "_onScroll",
            value: function _onScroll() {
              this._textarea.scrollLeft = 0;
              this._textarea.scrollTop = 0;
            }
          }, {
            key: "_onFabricScaling",
            value: function _onFabricScaling(fEvent) {
              var obj = fEvent.target;
              obj.fontSize = obj.fontSize * obj.scaleY;
              obj.scaleX = 1;
              obj.scaleY = 1;
            }
          }, {
            key: "_onFabricTextChanged",
            value: function _onFabricTextChanged(props2) {
              this.fire(eventNames.TEXT_CHANGED, props2.target);
            }
          }, {
            key: "_onFabricSelectClear",
            value: function _onFabricSelectClear(fEvent) {
              var obj = this.getSelectedObj();
              this.isPrevEditing = true;
              this.setSelectedInfo(fEvent.target, false);
              if (obj) {
                if (obj.text === "") {
                  this.getCanvas().remove(obj);
                }
              }
            }
          }, {
            key: "_onFabricSelect",
            value: function _onFabricSelect(fEvent) {
              this.isPrevEditing = true;
              this.setSelectedInfo(fEvent.target, true);
            }
          }, {
            key: "_onFabricMouseDown",
            value: function _onFabricMouseDown(fEvent) {
              var obj = fEvent.target;
              if (obj && !obj.isType("text")) {
                return;
              }
              if (this.isPrevEditing) {
                this.isPrevEditing = false;
                return;
              }
              this._fireAddText(fEvent);
            }
          }, {
            key: "_fireAddText",
            value: function _fireAddText(fEvent) {
              var obj = fEvent.target;
              var e2 = fEvent.e || {};
              var originPointer = this.getCanvas().getPointer(e2);
              if (!obj) {
                this.fire(eventNames.ADD_TEXT, {
                  originPosition: {
                    x: originPointer.x,
                    y: originPointer.y
                  },
                  clientPosition: {
                    x: e2.clientX || 0,
                    y: e2.clientY || 0
                  }
                });
              }
            }
          }, {
            key: "_onFabricMouseUp",
            value: function _onFabricMouseUp(fEvent) {
              var target = fEvent.target;
              var newClickTime = new Date().getTime();
              if (this._isDoubleClick(newClickTime) && !target.isEditing) {
                target.enterEditing();
              }
              if (target.isEditing) {
                this.fire(eventNames.TEXT_EDITING);
              }
              this._lastClickTime = newClickTime;
            }
          }, {
            key: "_isDoubleClick",
            value: function _isDoubleClick(newClickTime) {
              return newClickTime - this._lastClickTime < DBCLICK_TIME;
            }
          }]);
          return Text2;
        }(component);
        var component_text = text_Text;
        function component_icon_createSuper(Derived) {
          var hasNativeReflectConstruct = component_icon_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function component_icon_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var pathMap = {
          arrow: "M 0 90 H 105 V 120 L 160 60 L 105 0 V 30 H 0 Z",
          cancel: "M 0 30 L 30 60 L 0 90 L 30 120 L 60 90 L 90 120 L 120 90 L 90 60 L 120 30 L 90 0 L 60 30 L 30 0 Z"
        };
        var icon_Icon = /* @__PURE__ */ function(_Component) {
          _inherits(Icon2, _Component);
          var _super = component_icon_createSuper(Icon2);
          function Icon2(graphics2) {
            var _context2, _context22, _context3;
            var _this;
            _classCallCheck(this, Icon2);
            _this = _super.call(this, componentNames.ICON, graphics2);
            _this._oColor = "#000000";
            _this._pathMap = pathMap;
            _this._type = null;
            _this._iconColor = null;
            _this._handlers = {
              mousedown: bind_default()(_context2 = _this._onFabricMouseDown).call(_context2, _assertThisInitialized(_this)),
              mousemove: bind_default()(_context22 = _this._onFabricMouseMove).call(_context22, _assertThisInitialized(_this)),
              mouseup: bind_default()(_context3 = _this._onFabricMouseUp).call(_context3, _assertThisInitialized(_this))
            };
            return _this;
          }
          _createClass(Icon2, [{
            key: "setStates",
            value: function setStates(type, iconColor) {
              this._type = type;
              this._iconColor = iconColor;
            }
          }, {
            key: "start",
            value: function start() {
              var canvas = this.getCanvas();
              canvas.selection = false;
              canvas.on("mouse:down", this._handlers.mousedown);
            }
          }, {
            key: "end",
            value: function end() {
              var canvas = this.getCanvas();
              canvas.selection = true;
              canvas.off({
                "mouse:down": this._handlers.mousedown
              });
            }
          }, {
            key: "add",
            value: function add2(type, options) {
              var _this2 = this;
              return new (promise_default())(function(resolve, reject) {
                var canvas = _this2.getCanvas();
                var path = _this2._pathMap[type];
                var selectionStyle = fObjectOptions.SELECTION_STYLE;
                var icon2 = path ? _this2._createIcon(path) : null;
                _this2._icon = icon2;
                if (!icon2) {
                  reject(rejectMessages.invalidParameters);
                }
                icon2.set(extend_default()({
                  type: "icon",
                  fill: _this2._oColor
                }, selectionStyle, options, _this2.graphics.controlStyle));
                canvas.add(icon2).setActiveObject(icon2);
                resolve(_this2.graphics.createObjectProperties(icon2));
              });
            }
          }, {
            key: "registerPaths",
            value: function registerPaths(pathInfos) {
              var _this3 = this;
              forEach_default()(pathInfos, function(path, type) {
                _this3._pathMap[type] = path;
              }, this);
            }
          }, {
            key: "setColor",
            value: function setColor(color2, obj) {
              this._oColor = color2;
              if (obj && obj.get("type") === "icon") {
                obj.set({
                  fill: this._oColor
                });
                this.getCanvas().renderAll();
              }
            }
          }, {
            key: "getColor",
            value: function getColor(obj) {
              return fill_default()(obj);
            }
          }, {
            key: "_createIcon",
            value: function _createIcon(path) {
              return new fabric.fabric.Path(path);
            }
          }, {
            key: "_onFabricMouseDown",
            value: function _onFabricMouseDown(fEvent) {
              var _this4 = this;
              var canvas = this.getCanvas();
              this._startPoint = canvas.getPointer(fEvent.e);
              var _this$_startPoint = this._startPoint, left = _this$_startPoint.x, top = _this$_startPoint.y;
              this.add(this._type, {
                left,
                top,
                fill: this._iconColor
              }).then(function() {
                _this4.fire(eventNames.ADD_OBJECT, _this4.graphics.createObjectProperties(_this4._icon));
                canvas.on("mouse:move", _this4._handlers.mousemove);
                canvas.on("mouse:up", _this4._handlers.mouseup);
              });
            }
          }, {
            key: "_onFabricMouseMove",
            value: function _onFabricMouseMove(fEvent) {
              var canvas = this.getCanvas();
              if (!this._icon) {
                return;
              }
              var moveOriginPointer = canvas.getPointer(fEvent.e);
              var scaleX = (moveOriginPointer.x - this._startPoint.x) / this._icon.width;
              var scaleY = (moveOriginPointer.y - this._startPoint.y) / this._icon.height;
              this._icon.set({
                scaleX: Math.abs(scaleX * 2),
                scaleY: Math.abs(scaleY * 2)
              });
              this._icon.setCoords();
              canvas.renderAll();
            }
          }, {
            key: "_onFabricMouseUp",
            value: function _onFabricMouseUp() {
              var canvas = this.getCanvas();
              this.fire(eventNames.OBJECT_ADDED, this.graphics.createObjectProperties(this._icon));
              this._icon = null;
              canvas.off("mouse:down", this._handlers.mousedown);
              canvas.off("mouse:move", this._handlers.mousemove);
              canvas.off("mouse:up", this._handlers.mouseup);
            }
          }]);
          return Icon2;
        }(component);
        var component_icon = icon_Icon;
        var mask_Mask = fabric.fabric.util.createClass(
          fabric.fabric.Image.filters.BlendImage,
          {
            applyTo: function applyTo(pipelineState) {
              if (!this.mask) {
                return;
              }
              var canvas = pipelineState.canvasEl;
              var width = canvas.width, height = canvas.height;
              var maskCanvasEl = this._createCanvasOfMask(width, height);
              var ctx = canvas.getContext("2d");
              var maskCtx = maskCanvasEl.getContext("2d");
              var imageData = ctx.getImageData(0, 0, width, height);
              this._drawMask(maskCtx, canvas, ctx);
              this._mapData(maskCtx, imageData, width, height);
              pipelineState.imageData = imageData;
            },
            _createCanvasOfMask: function _createCanvasOfMask(width, height) {
              var maskCanvasEl = fabric.fabric.util.createCanvasElement();
              maskCanvasEl.width = width;
              maskCanvasEl.height = height;
              return maskCanvasEl;
            },
            _drawMask: function _drawMask(maskCtx) {
              var mask2 = this.mask;
              var maskImg = mask2.getElement();
              var angle2 = mask2.angle, left = mask2.left, scaleX = mask2.scaleX, scaleY = mask2.scaleY, top = mask2.top;
              maskCtx.save();
              maskCtx.translate(left, top);
              maskCtx.rotate(angle2 * Math.PI / 180);
              maskCtx.scale(scaleX, scaleY);
              maskCtx.drawImage(maskImg, -maskImg.width / 2, -maskImg.height / 2);
              maskCtx.restore();
            },
            _mapData: function _mapData(maskCtx, imageData, width, height) {
              var data = imageData.data, imgHeight = imageData.height, imgWidth = imageData.width;
              var sourceData = data;
              var len = imgWidth * imgHeight * 4;
              var maskData = maskCtx.getImageData(0, 0, width, height).data;
              for (var i = 0; i < len; i += 4) {
                sourceData[i + 3] = maskData[i];
              }
            }
          }
        );
        var extension_mask = mask_Mask;
        var Sharpen = fabric.fabric.util.createClass(
          fabric.fabric.Image.filters.Convolute,
          {
            type: "Sharpen",
            initialize: function initialize() {
              this.matrix = [0, -1, 0, -1, 5, -1, 0, -1, 0];
            }
          }
        );
        var sharpen = Sharpen;
        var Emboss = fabric.fabric.util.createClass(
          fabric.fabric.Image.filters.Convolute,
          {
            type: "Emboss",
            initialize: function initialize() {
              this.matrix = [1, 1, 1, 1, 0.7, -1, -1, -1, -1];
            }
          }
        );
        var emboss = Emboss;
        var ColorFilter = fabric.fabric.util.createClass(
          fabric.fabric.Image.filters.BaseFilter,
          {
            type: "ColorFilter",
            initialize: function initialize(options) {
              if (!options) {
                options = {};
              }
              this.color = options.color || "#FFFFFF";
              this.threshold = options.threshold || 45;
              this.x = options.x || null;
              this.y = options.y || null;
            },
            applyTo: function applyTo(canvas) {
              var canvasEl = canvas.canvasEl;
              var context = canvasEl.getContext("2d");
              var imageData = context.getImageData(0, 0, canvasEl.width, canvasEl.height);
              var data = imageData.data;
              var threshold = this.threshold;
              var filterColor = fabric.fabric.Color.sourceFromHex(this.color);
              var i, len;
              if (this.x && this.y) {
                filterColor = this._getColor(imageData, this.x, this.y);
              }
              for (i = 0, len = data.length; i < len; i += 4) {
                if (this._isOutsideThreshold(data[i], filterColor[0], threshold) || this._isOutsideThreshold(data[i + 1], filterColor[1], threshold) || this._isOutsideThreshold(data[i + 2], filterColor[2], threshold)) {
                  continue;
                }
                data[i] = data[i + 1] = data[i + 2] = data[i + 3] = 0;
              }
              context.putImageData(imageData, 0, 0);
            },
            _isOutsideThreshold: function _isOutsideThreshold(color1, color2, threshold) {
              var diff2 = color1 - color2;
              return Math.abs(diff2) > threshold;
            },
            _getColor: function _getColor(imageData, x, y) {
              var color2 = [0, 0, 0, 0];
              var data = imageData.data, width = imageData.width;
              var bytes = 4;
              var position2 = (width * y + x) * bytes;
              color2[0] = data[position2];
              color2[1] = data[position2 + 1];
              color2[2] = data[position2 + 2];
              color2[3] = data[position2 + 3];
              return color2;
            }
          }
        );
        var colorFilter = ColorFilter;
        function component_filter_createSuper(Derived) {
          var hasNativeReflectConstruct = component_filter_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function component_filter_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var filters = fabric.fabric.Image.filters;
        filters.Mask = extension_mask;
        filters.Sharpen = sharpen;
        filters.Emboss = emboss;
        filters.ColorFilter = colorFilter;
        var filter_Filter = /* @__PURE__ */ function(_Component) {
          _inherits(Filter2, _Component);
          var _super = component_filter_createSuper(Filter2);
          function Filter2(graphics2) {
            _classCallCheck(this, Filter2);
            return _super.call(this, componentNames.FILTER, graphics2);
          }
          _createClass(Filter2, [{
            key: "add",
            value: function add2(type, options) {
              var _this = this;
              return new (promise_default())(function(resolve, reject) {
                var sourceImg = _this._getSourceImage();
                var canvas = _this.getCanvas();
                var imgFilter = _this._getFilter(sourceImg, type);
                if (!imgFilter) {
                  imgFilter = _this._createFilter(sourceImg, type, options);
                }
                if (!imgFilter) {
                  reject(rejectMessages.invalidParameters);
                }
                _this._changeFilterValues(imgFilter, options);
                _this._apply(sourceImg, function() {
                  canvas.renderAll();
                  resolve({
                    type,
                    action: "add",
                    options
                  });
                });
              });
            }
          }, {
            key: "remove",
            value: function remove(type) {
              var _this2 = this;
              return new (promise_default())(function(resolve, reject) {
                var sourceImg = _this2._getSourceImage();
                var canvas = _this2.getCanvas();
                var options = _this2.getOptions(type);
                if (!sourceImg.filters.length) {
                  reject(rejectMessages.unsupportedOperation);
                }
                _this2._removeFilter(sourceImg, type);
                _this2._apply(sourceImg, function() {
                  canvas.renderAll();
                  resolve({
                    type,
                    action: "remove",
                    options
                  });
                });
              });
            }
          }, {
            key: "hasFilter",
            value: function hasFilter(type) {
              return !!this._getFilter(this._getSourceImage(), type);
            }
          }, {
            key: "getOptions",
            value: function getOptions(type) {
              var sourceImg = this._getSourceImage();
              var imgFilter = this._getFilter(sourceImg, type);
              if (!imgFilter) {
                return null;
              }
              return extend_default()({}, imgFilter.options);
            }
          }, {
            key: "_changeFilterValues",
            value: function _changeFilterValues(imgFilter, options) {
              forEach_default()(options, function(value, key) {
                if (!isUndefined_default()(imgFilter[key])) {
                  imgFilter[key] = value;
                }
              });
              forEach_default()(imgFilter.options, function(value, key) {
                if (!isUndefined_default()(options[key])) {
                  imgFilter.options[key] = options[key];
                }
              });
            }
          }, {
            key: "_apply",
            value: function _apply(sourceImg, callback) {
              sourceImg.filters.push();
              var result = sourceImg.applyFilters();
              if (result) {
                callback();
              }
            }
          }, {
            key: "_getSourceImage",
            value: function _getSourceImage() {
              return this.getCanvasImage();
            }
          }, {
            key: "_createFilter",
            value: function _createFilter(sourceImg, type, options) {
              var filterObj;
              var fabricType = this._getFabricFilterType(type);
              var ImageFilter = fabric.fabric.Image.filters[fabricType];
              if (ImageFilter) {
                filterObj = new ImageFilter(options);
                filterObj.options = options;
                sourceImg.filters.push(filterObj);
              }
              return filterObj;
            }
          }, {
            key: "_getFilter",
            value: function _getFilter(sourceImg, type) {
              var imgFilter = null;
              if (sourceImg) {
                var fabricType = this._getFabricFilterType(type);
                var length = sourceImg.filters.length;
                var item, i;
                for (i = 0; i < length; i += 1) {
                  item = sourceImg.filters[i];
                  if (item.type === fabricType) {
                    imgFilter = item;
                    break;
                  }
                }
              }
              return imgFilter;
            }
          }, {
            key: "_removeFilter",
            value: function _removeFilter(sourceImg, type) {
              var _context2;
              var fabricType = this._getFabricFilterType(type);
              sourceImg.filters = filter_default()(_context2 = sourceImg.filters).call(_context2, function(value) {
                return value.type !== fabricType;
              });
            }
          }, {
            key: "_getFabricFilterType",
            value: function _getFabricFilterType(type) {
              return type.charAt(0).toUpperCase() + slice_default()(type).call(type, 1);
            }
          }]);
          return Filter2;
        }(component);
        var component_filter = filter_Filter;
        var shapeResizeHelper = __webpack_require__(1801);
        var shapeResizeHelper_default = /* @__PURE__ */ __webpack_require__.n(shapeResizeHelper);
        var FILTER_OPTION_MAP = {
          pixelate: "blocksize",
          blur: "blur"
        };
        var POSITION_DIMENSION_MAP = {
          x: "width",
          y: "height"
        };
        var FILTER_NAME_VALUE_MAP = flipObject(FILTER_OPTION_MAP);
        var cachedCanvasImageElement = null;
        function getFillImageFromShape(shapeObj) {
          var _getCustomProperty = getCustomProperty(shapeObj, "patternSourceCanvas"), patternSourceCanvas = _getCustomProperty.patternSourceCanvas;
          var _patternSourceCanvas$ = patternSourceCanvas.getObjects(), _patternSourceCanvas$2 = _slicedToArray(_patternSourceCanvas$, 1), fillImage = _patternSourceCanvas$2[0];
          return fillImage;
        }
        function rePositionFilterTypeFillImage(shapeObj) {
          var angle2 = shapeObj.angle, flipX = shapeObj.flipX, flipY = shapeObj.flipY;
          var fillImage = getFillImageFromShape(shapeObj);
          var rotatedShapeCornerDimension = getRotatedDimension(shapeObj);
          var right = rotatedShapeCornerDimension.right, bottom = rotatedShapeCornerDimension.bottom;
          var width = rotatedShapeCornerDimension.width, height = rotatedShapeCornerDimension.height;
          var diffLeft = (width - shapeObj.width) / 2;
          var diffTop = (height - shapeObj.height) / 2;
          var cropX = shapeObj.left - shapeObj.width / 2 - diffLeft;
          var cropY = shapeObj.top - shapeObj.height / 2 - diffTop;
          var left = width / 2 - diffLeft;
          var top = height / 2 - diffTop;
          var fillImageMaxSize = Math.max(width, height) + Math.max(diffLeft, diffTop);
          var _calculateFillImageDi = calculateFillImageDimensionOutsideCanvas({
            shapeObj,
            left,
            top,
            width,
            height,
            cropX,
            cropY,
            flipX,
            flipY,
            right,
            bottom
          });
          var _calculateFillImageDi2 = _slicedToArray(_calculateFillImageDi, 4);
          left = _calculateFillImageDi2[0];
          top = _calculateFillImageDi2[1];
          width = _calculateFillImageDi2[2];
          height = _calculateFillImageDi2[3];
          fillImage.set({
            angle: flipX === flipY ? -angle2 : angle2,
            left,
            top,
            width,
            height,
            cropX,
            cropY,
            flipX,
            flipY
          });
          setCustomProperty(fillImage, {
            fillImageMaxSize
          });
        }
        function makeFilterOptionFromFabricImage(imageObject) {
          var _context2;
          return map_default()(_context2 = imageObject.filters).call(_context2, function(filter2) {
            var _Object$keys = keys_default()(filter2), _Object$keys2 = _slicedToArray(_Object$keys, 1), key = _Object$keys2[0];
            return _defineProperty2({}, FILTER_NAME_VALUE_MAP[key], filter2[key]);
          });
        }
        function calculateFillImageDimensionOutsideCanvas(_ref2) {
          var shapeObj = _ref2.shapeObj, left = _ref2.left, top = _ref2.top, width = _ref2.width, height = _ref2.height, cropX = _ref2.cropX, cropY = _ref2.cropY, flipX = _ref2.flipX, flipY = _ref2.flipY, right = _ref2.right, bottom = _ref2.bottom;
          var overflowAreaPositionFixer = function overflowAreaPositionFixer2(type, outDistance, imageLeft, imageTop) {
            return calculateDistanceOverflowPart({
              type,
              outDistance,
              shapeObj,
              flipX,
              flipY,
              left: imageLeft,
              top: imageTop
            });
          };
          var originalWidth = width, originalHeight = height;
          var _calculateDimensionLe = calculateDimensionLeftTopEdge(overflowAreaPositionFixer, {
            left,
            top,
            width,
            height,
            cropX,
            cropY
          });
          var _calculateDimensionLe2 = _slicedToArray(_calculateDimensionLe, 4);
          left = _calculateDimensionLe2[0];
          top = _calculateDimensionLe2[1];
          width = _calculateDimensionLe2[2];
          height = _calculateDimensionLe2[3];
          var _calculateDimensionRi = calculateDimensionRightBottomEdge(overflowAreaPositionFixer, {
            left,
            top,
            insideCanvasRealImageWidth: width,
            insideCanvasRealImageHeight: height,
            right,
            bottom,
            cropX,
            cropY,
            originalWidth,
            originalHeight
          });
          var _calculateDimensionRi2 = _slicedToArray(_calculateDimensionRi, 4);
          left = _calculateDimensionRi2[0];
          top = _calculateDimensionRi2[1];
          width = _calculateDimensionRi2[2];
          height = _calculateDimensionRi2[3];
          return [left, top, width, height];
        }
        function calculateDimensionRightBottomEdge(overflowAreaPositionFixer, _ref3) {
          var left = _ref3.left, top = _ref3.top, insideCanvasRealImageWidth = _ref3.insideCanvasRealImageWidth, insideCanvasRealImageHeight = _ref3.insideCanvasRealImageHeight, right = _ref3.right, bottom = _ref3.bottom, cropX = _ref3.cropX, cropY = _ref3.cropY, originalWidth = _ref3.originalWidth, originalHeight = _ref3.originalHeight;
          var width = insideCanvasRealImageWidth, height = insideCanvasRealImageHeight;
          var _cachedCanvasImageEle = cachedCanvasImageElement, canvasWidth = _cachedCanvasImageEle.width, canvasHeight = _cachedCanvasImageEle.height;
          if (right > canvasWidth && cropX > 0) {
            width = originalWidth - Math.abs(right - canvasWidth);
          }
          if (bottom > canvasHeight && cropY > 0) {
            height = originalHeight - Math.abs(bottom - canvasHeight);
          }
          var diff2 = {
            x: (insideCanvasRealImageWidth - width) / 2,
            y: (insideCanvasRealImageHeight - height) / 2
          };
          forEach_default()(["x", "y"], function(type) {
            var cropDistance2 = diff2[type];
            if (cropDistance2 > 0) {
              var _overflowAreaPosition = overflowAreaPositionFixer(type, cropDistance2, left, top);
              var _overflowAreaPosition2 = _slicedToArray(_overflowAreaPosition, 2);
              left = _overflowAreaPosition2[0];
              top = _overflowAreaPosition2[1];
            }
          });
          return [left, top, width, height];
        }
        function calculateDimensionLeftTopEdge(overflowAreaPositionFixer, _ref4) {
          var left = _ref4.left, top = _ref4.top, width = _ref4.width, height = _ref4.height, cropX = _ref4.cropX, cropY = _ref4.cropY;
          var dimension = {
            width,
            height
          };
          forEach_default()(["x", "y"], function(type) {
            var cropDistance = type === "x" ? cropX : cropY;
            var compareSize = dimension[POSITION_DIMENSION_MAP[type]];
            var standardSize = cachedCanvasImageElement[POSITION_DIMENSION_MAP[type]];
            if (compareSize > standardSize) {
              var outDistance = (compareSize - standardSize) / 2;
              dimension[POSITION_DIMENSION_MAP[type]] = standardSize;
              var _overflowAreaPosition3 = overflowAreaPositionFixer(type, outDistance, left, top);
              var _overflowAreaPosition4 = _slicedToArray(_overflowAreaPosition3, 2);
              left = _overflowAreaPosition4[0];
              top = _overflowAreaPosition4[1];
            }
            if (cropDistance < 0) {
              var _overflowAreaPosition5 = overflowAreaPositionFixer(type, cropDistance, left, top);
              var _overflowAreaPosition6 = _slicedToArray(_overflowAreaPosition5, 2);
              left = _overflowAreaPosition6[0];
              top = _overflowAreaPosition6[1];
            }
          });
          return [left, top, dimension.width, dimension.height];
        }
        function makeFillPatternForFilter(canvasImage, filterOption, patternSourceCanvas) {
          var copiedCanvasElement = getCachedCanvasImageElement(canvasImage);
          var fillImage = makeFillImage(copiedCanvasElement, canvasImage.angle, filterOption);
          patternSourceCanvas.add(fillImage);
          var fabricProperty = {
            fill: new fabric.fabric.Pattern({
              source: patternSourceCanvas.getElement(),
              repeat: "no-repeat"
            })
          };
          setCustomProperty(fabricProperty, {
            patternSourceCanvas
          });
          return fabricProperty;
        }
        function resetFillPatternCanvas(patternSourceCanvas) {
          var _patternSourceCanvas$3 = patternSourceCanvas.getObjects(), _patternSourceCanvas$4 = _slicedToArray(_patternSourceCanvas$3, 1), innerImage = _patternSourceCanvas$4[0];
          var _getCustomProperty2 = getCustomProperty(innerImage, "fillImageMaxSize"), fillImageMaxSize = _getCustomProperty2.fillImageMaxSize;
          fillImageMaxSize = Math.max(1, fillImageMaxSize);
          patternSourceCanvas.setDimensions({
            width: fillImageMaxSize,
            height: fillImageMaxSize
          });
          patternSourceCanvas.renderAll();
        }
        function reMakePatternImageSource(shapeObj, canvasImage) {
          var _getCustomProperty3 = getCustomProperty(shapeObj, "patternSourceCanvas"), patternSourceCanvas = _getCustomProperty3.patternSourceCanvas;
          var _patternSourceCanvas$5 = patternSourceCanvas.getObjects(), _patternSourceCanvas$6 = _slicedToArray(_patternSourceCanvas$5, 1), fillImage = _patternSourceCanvas$6[0];
          var filterOption = makeFilterOptionFromFabricImage(fillImage);
          patternSourceCanvas.remove(fillImage);
          var copiedCanvasElement = getCachedCanvasImageElement(canvasImage, true);
          var newFillImage = makeFillImage(copiedCanvasElement, canvasImage.angle, filterOption);
          patternSourceCanvas.add(newFillImage);
        }
        function getCachedCanvasImageElement(canvasImage) {
          var reset = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
          if (!cachedCanvasImageElement || reset) {
            cachedCanvasImageElement = canvasImage.toCanvasElement();
          }
          return cachedCanvasImageElement;
        }
        function calculateDistanceOverflowPart(_ref5) {
          var type = _ref5.type, shapeObj = _ref5.shapeObj, outDistance = _ref5.outDistance, left = _ref5.left, top = _ref5.top, flipX = _ref5.flipX, flipY = _ref5.flipY;
          var shapePointNavigation = getShapeEdgePoint(shapeObj);
          var shapeNeighborPointNavigation = [[1, 2], [0, 3], [0, 3], [1, 2]];
          var linePointsOutsideCanvas = calculateLinePointsOutsideCanvas(type, shapePointNavigation, shapeNeighborPointNavigation);
          var reatAngles = calculateLineAngleOfOutsideCanvas(type, shapePointNavigation, linePointsOutsideCanvas);
          var startPointIndex = linePointsOutsideCanvas.startPointIndex;
          var diffPosition = getReversePositionForFlip({
            outDistance,
            startPointIndex,
            flipX,
            flipY,
            reatAngles
          });
          return [left + diffPosition.left, top + diffPosition.top];
        }
        function getReversePositionForFlip(_ref6) {
          var outDistance = _ref6.outDistance, startPointIndex = _ref6.startPointIndex, flipX = _ref6.flipX, flipY = _ref6.flipY, reatAngles = _ref6.reatAngles;
          var rotationChangePoint1 = outDistance * Math.cos(reatAngles[0] * Math.PI / 180);
          var rotationChangePoint2 = outDistance * Math.cos(reatAngles[1] * Math.PI / 180);
          var isForward = startPointIndex === 2 || startPointIndex === 3;
          var diffPosition = {
            top: isForward ? rotationChangePoint1 : rotationChangePoint2,
            left: isForward ? rotationChangePoint2 : rotationChangePoint1
          };
          if (isReverseLeftPositionForFlip(startPointIndex, flipX, flipY)) {
            diffPosition.left = diffPosition.left * -1;
          }
          if (isReverseTopPositionForFlip(startPointIndex, flipX, flipY)) {
            diffPosition.top = diffPosition.top * -1;
          }
          return diffPosition;
        }
        function calculateLinePointsOutsideCanvas(type, shapePointNavigation, shapeNeighborPointNavigation) {
          var minimumPoint = 0;
          var minimumPointIndex = 0;
          forEach_default()(shapePointNavigation, function(point, index2) {
            if (point[type] < minimumPoint) {
              minimumPoint = point[type];
              minimumPointIndex = index2;
            }
          });
          var _shapeNeighborPointNa = _slicedToArray(shapeNeighborPointNavigation[minimumPointIndex], 2), endPointIndex1 = _shapeNeighborPointNa[0], endPointIndex2 = _shapeNeighborPointNa[1];
          return {
            startPointIndex: minimumPointIndex,
            endPointIndex1,
            endPointIndex2
          };
        }
        function calculateLineAngleOfOutsideCanvas(type, shapePointNavigation, linePointsOfOneVertexIndex) {
          var _context2;
          var startPointIndex = linePointsOfOneVertexIndex.startPointIndex, endPointIndex1 = linePointsOfOneVertexIndex.endPointIndex1, endPointIndex2 = linePointsOfOneVertexIndex.endPointIndex2;
          var horizontalVerticalAngle = type === "x" ? 180 : 270;
          return map_default()(_context2 = [endPointIndex1, endPointIndex2]).call(_context2, function(pointIndex) {
            var startPoint2 = shapePointNavigation[startPointIndex];
            var endPoint = shapePointNavigation[pointIndex];
            var diffY = startPoint2.y - endPoint.y;
            var diffX = startPoint2.x - endPoint.x;
            return Math.atan2(diffY, diffX) * 180 / Math.PI - horizontalVerticalAngle;
          });
        }
        function isReverseLeftPositionForFlip(startPointIndex, flipX, flipY) {
          return (!flipX && flipY || !flipX && !flipY) && startPointIndex === 0 || (flipX && flipY || flipX && !flipY) && startPointIndex === 1 || (!flipX && !flipY || !flipX && flipY) && startPointIndex === 2 || (flipX && !flipY || flipX && flipY) && startPointIndex === 3;
        }
        function isReverseTopPositionForFlip(startPointIndex, flipX, flipY) {
          return (flipX && !flipY || !flipX && !flipY) && startPointIndex === 0 || (!flipX && !flipY || flipX && !flipY) && startPointIndex === 1 || (flipX && flipY || !flipX && flipY) && startPointIndex === 2 || (!flipX && flipY || flipX && flipY) && startPointIndex === 3;
        }
        function getShapeEdgePoint(shapeObj) {
          return [shapeObj.getPointByOrigin("left", "top"), shapeObj.getPointByOrigin("right", "top"), shapeObj.getPointByOrigin("left", "bottom"), shapeObj.getPointByOrigin("right", "bottom")];
        }
        function getRotatedDimension(shapeObj) {
          var _getShapeEdgePoint = getShapeEdgePoint(shapeObj), _getShapeEdgePoint2 = _slicedToArray(_getShapeEdgePoint, 4), _getShapeEdgePoint2$ = _getShapeEdgePoint2[0], ax = _getShapeEdgePoint2$.x, ay = _getShapeEdgePoint2$.y, _getShapeEdgePoint2$2 = _getShapeEdgePoint2[1], bx = _getShapeEdgePoint2$2.x, by = _getShapeEdgePoint2$2.y, _getShapeEdgePoint2$3 = _getShapeEdgePoint2[2], cx = _getShapeEdgePoint2$3.x, cy = _getShapeEdgePoint2$3.y, _getShapeEdgePoint2$4 = _getShapeEdgePoint2[3], dx = _getShapeEdgePoint2$4.x, dy = _getShapeEdgePoint2$4.y;
          var left = Math.min(ax, bx, cx, dx);
          var top = Math.min(ay, by, cy, dy);
          var right = Math.max(ax, bx, cx, dx);
          var bottom = Math.max(ay, by, cy, dy);
          return {
            left,
            top,
            right,
            bottom,
            width: right - left,
            height: bottom - top
          };
        }
        function makeFillImage(copiedCanvasElement, currentCanvasImageAngle, filterOption) {
          var _context3;
          var fillImage = new fabric.fabric.Image(copiedCanvasElement);
          forEach_default()(extend_default().apply(void 0, concat_default()(_context3 = [{}]).call(_context3, _toConsumableArray(filterOption))), function(value, key) {
            var fabricFilterClassName = capitalizeString(key);
            var filter2 = new fabric.fabric.Image.filters[fabricFilterClassName](_defineProperty2({}, FILTER_OPTION_MAP[key], value));
            fillImage.filters.push(filter2);
          });
          fillImage.applyFilters();
          setCustomProperty(fillImage, {
            originalAngle: currentCanvasImageAngle,
            fillImageMaxSize: Math.max(fillImage.width, fillImage.height)
          });
          shapeResizeHelper_default().adjustOriginToCenter(fillImage);
          return fillImage;
        }
        function shape_createSuper(Derived) {
          var hasNativeReflectConstruct = shape_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function shape_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var SHAPE_INIT_OPTIONS = extend_default()({
          strokeWidth: 1,
          stroke: "#000000",
          fill: "#ffffff",
          width: 1,
          height: 1,
          rx: 0,
          ry: 0
        }, SHAPE_DEFAULT_OPTIONS);
        var DEFAULT_TYPE = "rect";
        var DEFAULT_WIDTH = 20;
        var DEFAULT_HEIGHT = 20;
        function makeFabricFillOption(options, canvasImage, createStaticCanvas) {
          var fillOption = fill_default()(options);
          var fillType = getFillTypeFromOption(fill_default()(options));
          var fill = fillOption;
          if (fillOption.color) {
            fill = fillOption.color;
          }
          var extOption = null;
          if (fillType === "filter") {
            var newStaticCanvas = createStaticCanvas();
            extOption = makeFillPatternForFilter(canvasImage, filter_default()(fillOption), newStaticCanvas);
          } else {
            extOption = {
              fill
            };
          }
          return extend_default()({}, options, extOption);
        }
        var shape_Shape = /* @__PURE__ */ function(_Component) {
          _inherits(Shape2, _Component);
          var _super = shape_createSuper(Shape2);
          function Shape2(graphics2) {
            var _context2, _context22, _context3, _context4, _context5;
            var _this;
            _classCallCheck(this, Shape2);
            _this = _super.call(this, componentNames.SHAPE, graphics2);
            _this._shapeObj = null;
            _this._type = DEFAULT_TYPE;
            _this._options = extend_default()({}, SHAPE_INIT_OPTIONS);
            _this._isSelected = false;
            _this._startPoint = {};
            _this._withShiftKey = false;
            _this._handlers = {
              mousedown: bind_default()(_context2 = _this._onFabricMouseDown).call(_context2, _assertThisInitialized(_this)),
              mousemove: bind_default()(_context22 = _this._onFabricMouseMove).call(_context22, _assertThisInitialized(_this)),
              mouseup: bind_default()(_context3 = _this._onFabricMouseUp).call(_context3, _assertThisInitialized(_this)),
              keydown: bind_default()(_context4 = _this._onKeyDown).call(_context4, _assertThisInitialized(_this)),
              keyup: bind_default()(_context5 = _this._onKeyUp).call(_context5, _assertThisInitialized(_this))
            };
            return _this;
          }
          _createClass(Shape2, [{
            key: "start",
            value: function start() {
              var canvas = this.getCanvas();
              this._isSelected = false;
              canvas.defaultCursor = "crosshair";
              canvas.selection = false;
              canvas.uniformScaling = true;
              canvas.on({
                "mouse:down": this._handlers.mousedown
              });
              fabric.fabric.util.addListener(document, "keydown", this._handlers.keydown);
              fabric.fabric.util.addListener(document, "keyup", this._handlers.keyup);
            }
          }, {
            key: "end",
            value: function end() {
              var canvas = this.getCanvas();
              this._isSelected = false;
              canvas.defaultCursor = "default";
              canvas.selection = true;
              canvas.uniformScaling = false;
              canvas.off({
                "mouse:down": this._handlers.mousedown
              });
              fabric.fabric.util.removeListener(document, "keydown", this._handlers.keydown);
              fabric.fabric.util.removeListener(document, "keyup", this._handlers.keyup);
            }
          }, {
            key: "setStates",
            value: function setStates(type, options) {
              this._type = type;
              if (options) {
                this._options = extend_default()(this._options, options);
              }
            }
          }, {
            key: "add",
            value: function add2(type, options) {
              var _this2 = this;
              return new (promise_default())(function(resolve) {
                var canvas = _this2.getCanvas();
                var extendOption = _this2._extendOptions(options);
                var shapeObj = _this2._createInstance(type, extendOption);
                var objectProperties = _this2.graphics.createObjectProperties(shapeObj);
                _this2._bindEventOnShape(shapeObj);
                canvas.add(shapeObj).setActiveObject(shapeObj);
                _this2._resetPositionFillFilter(shapeObj);
                resolve(objectProperties);
              });
            }
          }, {
            key: "change",
            value: function change(shapeObj, options) {
              var _this3 = this;
              return new (promise_default())(function(resolve, reject) {
                if (!isShape(shapeObj)) {
                  reject(rejectMessages.unsupportedType);
                }
                var hasFillOption = getFillTypeFromOption(fill_default()(options)) === "filter";
                var _this3$graphics = _this3.graphics, canvasImage = _this3$graphics.canvasImage, createStaticCanvas = _this3$graphics.createStaticCanvas;
                shapeObj.set(hasFillOption ? makeFabricFillOption(options, canvasImage, createStaticCanvas) : options);
                if (hasFillOption) {
                  _this3._resetPositionFillFilter(shapeObj);
                }
                _this3.getCanvas().renderAll();
                resolve();
              });
            }
          }, {
            key: "makeFillPropertyForUserEvent",
            value: function makeFillPropertyForUserEvent(shapeObj) {
              var fillType = getFillTypeFromObject(shapeObj);
              var fillProp = {};
              if (fillType === SHAPE_FILL_TYPE.FILTER) {
                var fillImage = getFillImageFromShape(shapeObj);
                var filterOption = makeFilterOptionFromFabricImage(fillImage);
                fillProp.type = fillType;
                fillProp.filter = filterOption;
              } else {
                fillProp.type = SHAPE_FILL_TYPE.COLOR;
                fillProp.color = fill_default()(shapeObj) || "transparent";
              }
              return fillProp;
            }
          }, {
            key: "processForCopiedObject",
            value: function processForCopiedObject(shapeObj, originalShapeObj) {
              this._bindEventOnShape(shapeObj);
              if (getFillTypeFromObject(shapeObj) === "filter") {
                var fillImage = getFillImageFromShape(originalShapeObj);
                var filterOption = makeFilterOptionFromFabricImage(fillImage);
                var newStaticCanvas = this.graphics.createStaticCanvas();
                shapeObj.set(makeFillPatternForFilter(this.graphics.canvasImage, filterOption, newStaticCanvas));
                this._resetPositionFillFilter(shapeObj);
              }
            }
          }, {
            key: "_createInstance",
            value: function _createInstance(type, options) {
              var instance;
              switch (type) {
                case "rect":
                  instance = new fabric.fabric.Rect(options);
                  break;
                case "circle":
                  instance = new fabric.fabric.Ellipse(extend_default()({
                    type: "circle"
                  }, options));
                  break;
                case "triangle":
                  instance = new fabric.fabric.Triangle(options);
                  break;
                default:
                  instance = {};
              }
              return instance;
            }
          }, {
            key: "_extendOptions",
            value: function _extendOptions(options) {
              var selectionStyles = fObjectOptions.SELECTION_STYLE;
              var _this$graphics = this.graphics, canvasImage = _this$graphics.canvasImage, createStaticCanvas = _this$graphics.createStaticCanvas;
              options = extend_default()({}, SHAPE_INIT_OPTIONS, this._options, selectionStyles, options);
              return makeFabricFillOption(options, canvasImage, createStaticCanvas);
            }
          }, {
            key: "_bindEventOnShape",
            value: function _bindEventOnShape(shapeObj) {
              var self2 = this;
              var canvas = this.getCanvas();
              shapeObj.on({
                added: function added() {
                  self2._shapeObj = this;
                  shapeResizeHelper_default().setOrigins(self2._shapeObj);
                },
                selected: function selected() {
                  self2._isSelected = true;
                  self2._shapeObj = this;
                  canvas.uniformScaling = true;
                  canvas.defaultCursor = "default";
                  shapeResizeHelper_default().setOrigins(self2._shapeObj);
                },
                deselected: function deselected() {
                  self2._isSelected = false;
                  self2._shapeObj = null;
                  canvas.defaultCursor = "crosshair";
                  canvas.uniformScaling = false;
                },
                modified: function modified() {
                  var currentObj = self2._shapeObj;
                  shapeResizeHelper_default().adjustOriginToCenter(currentObj);
                  shapeResizeHelper_default().setOrigins(currentObj);
                },
                modifiedInGroup: function modifiedInGroup(activeSelection) {
                  self2._fillFilterRePositionInGroupSelection(shapeObj, activeSelection);
                },
                moving: function moving() {
                  self2._resetPositionFillFilter(this);
                },
                rotating: function rotating() {
                  self2._resetPositionFillFilter(this);
                },
                scaling: function scaling(fEvent) {
                  var pointer = canvas.getPointer(fEvent.e);
                  var currentObj = self2._shapeObj;
                  canvas.setCursor("crosshair");
                  shapeResizeHelper_default().resize(currentObj, pointer, true);
                  self2._resetPositionFillFilter(this);
                }
              });
            }
          }, {
            key: "_onFabricMouseDown",
            value: function _onFabricMouseDown(fEvent) {
              if (!fEvent.target) {
                this._isSelected = false;
                this._shapeObj = false;
              }
              if (!this._isSelected && !this._shapeObj) {
                var canvas = this.getCanvas();
                this._startPoint = canvas.getPointer(fEvent.e);
                canvas.on({
                  "mouse:move": this._handlers.mousemove,
                  "mouse:up": this._handlers.mouseup
                });
              }
            }
          }, {
            key: "_onFabricMouseMove",
            value: function _onFabricMouseMove(fEvent) {
              var _this4 = this;
              var canvas = this.getCanvas();
              var pointer = canvas.getPointer(fEvent.e);
              var startPointX = this._startPoint.x;
              var startPointY = this._startPoint.y;
              var width = startPointX - pointer.x;
              var height = startPointY - pointer.y;
              var shape2 = this._shapeObj;
              if (!shape2) {
                this.add(this._type, {
                  left: startPointX,
                  top: startPointY,
                  width,
                  height
                }).then(function(objectProps) {
                  _this4.fire(eventNames.ADD_OBJECT, objectProps);
                });
              } else {
                this._shapeObj.set({
                  isRegular: this._withShiftKey
                });
                shapeResizeHelper_default().resize(shape2, pointer);
                canvas.renderAll();
                this._resetPositionFillFilter(shape2);
              }
            }
          }, {
            key: "_onFabricMouseUp",
            value: function _onFabricMouseUp() {
              var _this5 = this;
              var canvas = this.getCanvas();
              var startPointX = this._startPoint.x;
              var startPointY = this._startPoint.y;
              var shape2 = this._shapeObj;
              if (!shape2) {
                this.add(this._type, {
                  left: startPointX,
                  top: startPointY,
                  width: DEFAULT_WIDTH,
                  height: DEFAULT_HEIGHT
                }).then(function(objectProps) {
                  _this5.fire(eventNames.ADD_OBJECT, objectProps);
                });
              } else if (shape2) {
                shapeResizeHelper_default().adjustOriginToCenter(shape2);
                this.fire(eventNames.OBJECT_ADDED, this.graphics.createObjectProperties(shape2));
              }
              canvas.off({
                "mouse:move": this._handlers.mousemove,
                "mouse:up": this._handlers.mouseup
              });
            }
          }, {
            key: "_onKeyDown",
            value: function _onKeyDown(e2) {
              if (e2.keyCode === keyCodes.SHIFT) {
                this._withShiftKey = true;
                if (this._shapeObj) {
                  this._shapeObj.isRegular = true;
                }
              }
            }
          }, {
            key: "_onKeyUp",
            value: function _onKeyUp(e2) {
              if (e2.keyCode === keyCodes.SHIFT) {
                this._withShiftKey = false;
                if (this._shapeObj) {
                  this._shapeObj.isRegular = false;
                }
              }
            }
          }, {
            key: "_resetPositionFillFilter",
            value: function _resetPositionFillFilter(shapeObj) {
              if (getFillTypeFromObject(shapeObj) !== "filter") {
                return;
              }
              var _getCustomProperty = getCustomProperty(shapeObj, "patternSourceCanvas"), patternSourceCanvas = _getCustomProperty.patternSourceCanvas;
              var fillImage = getFillImageFromShape(shapeObj);
              var _getCustomProperty2 = getCustomProperty(fillImage, "originalAngle"), originalAngle = _getCustomProperty2.originalAngle;
              if (this.graphics.canvasImage.angle !== originalAngle) {
                reMakePatternImageSource(shapeObj, this.graphics.canvasImage);
              }
              var originX = shapeObj.originX, originY = shapeObj.originY;
              shapeResizeHelper_default().adjustOriginToCenter(shapeObj);
              shapeObj.width *= shapeObj.scaleX;
              shapeObj.height *= shapeObj.scaleY;
              shapeObj.rx *= shapeObj.scaleX;
              shapeObj.ry *= shapeObj.scaleY;
              shapeObj.scaleX = 1;
              shapeObj.scaleY = 1;
              rePositionFilterTypeFillImage(shapeObj);
              changeOrigin(shapeObj, {
                originX,
                originY
              });
              resetFillPatternCanvas(patternSourceCanvas);
            }
          }, {
            key: "_fillFilterRePositionInGroupSelection",
            value: function _fillFilterRePositionInGroupSelection(shapeObj, activeSelection) {
              if (activeSelection.scaleX !== 1 || activeSelection.scaleY !== 1) {
                activeSelection.addWithUpdate();
              }
              var angle2 = shapeObj.angle, left = shapeObj.left, top = shapeObj.top;
              fabric.fabric.util.addTransformToObject(shapeObj, activeSelection.calcTransformMatrix());
              this._resetPositionFillFilter(shapeObj);
              shapeObj.set({
                angle: angle2,
                left,
                top
              });
            }
          }]);
          return Shape2;
        }(component);
        function zoom_createSuper(Derived) {
          var hasNativeReflectConstruct = zoom_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function zoom_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var zoom_MOUSE_MOVE_THRESHOLD = 10;
        var DEFAULT_SCROLL_OPTION = {
          left: 0,
          top: 0,
          width: 0,
          height: 0,
          stroke: "#000000",
          strokeWidth: 0,
          fill: "#000000",
          opacity: 0.4,
          evented: false,
          selectable: false,
          hoverCursor: "auto"
        };
        var DEFAULT_VERTICAL_SCROLL_RATIO = {
          SIZE: 45e-4,
          MARGIN: 3e-3,
          BORDER_RADIUS: 3e-3
        };
        var DEFAULT_HORIZONTAL_SCROLL_RATIO = {
          SIZE: 66e-4,
          MARGIN: 44e-4,
          BORDER_RADIUS: 3e-3
        };
        var DEFAULT_ZOOM_LEVEL = 1;
        var ZOOM_CHANGED = eventNames.ZOOM_CHANGED, ADD_TEXT = eventNames.ADD_TEXT, TEXT_EDITING = eventNames.TEXT_EDITING, OBJECT_MODIFIED = eventNames.OBJECT_MODIFIED, KEY_DOWN = eventNames.KEY_DOWN, KEY_UP = eventNames.KEY_UP, HAND_STARTED = eventNames.HAND_STARTED, HAND_STOPPED = eventNames.HAND_STOPPED;
        var Zoom = /* @__PURE__ */ function(_Component) {
          _inherits(Zoom2, _Component);
          var _super = zoom_createSuper(Zoom2);
          function Zoom2(graphics2) {
            var _context2, _context22, _context3, _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12;
            var _this;
            _classCallCheck(this, Zoom2);
            _this = _super.call(this, componentNames.ZOOM, graphics2);
            _this.zoomArea = null;
            _this._startPoint = null;
            _this._centerPoints = [];
            _this.zoomLevel = DEFAULT_ZOOM_LEVEL;
            _this.zoomMode = zoomModes.DEFAULT;
            _this._listeners = {
              startZoom: bind_default()(_context2 = _this._onMouseDownWithZoomMode).call(_context2, _assertThisInitialized(_this)),
              moveZoom: bind_default()(_context22 = _this._onMouseMoveWithZoomMode).call(_context22, _assertThisInitialized(_this)),
              stopZoom: bind_default()(_context3 = _this._onMouseUpWithZoomMode).call(_context3, _assertThisInitialized(_this)),
              startHand: bind_default()(_context4 = _this._onMouseDownWithHandMode).call(_context4, _assertThisInitialized(_this)),
              moveHand: bind_default()(_context5 = _this._onMouseMoveWithHandMode).call(_context5, _assertThisInitialized(_this)),
              stopHand: bind_default()(_context6 = _this._onMouseUpWithHandMode).call(_context6, _assertThisInitialized(_this)),
              zoomChanged: bind_default()(_context7 = _this._changeScrollState).call(_context7, _assertThisInitialized(_this)),
              keydown: bind_default()(_context8 = _this._startHandModeWithSpaceBar).call(_context8, _assertThisInitialized(_this)),
              keyup: bind_default()(_context9 = _this._endHandModeWithSpaceBar).call(_context9, _assertThisInitialized(_this))
            };
            var canvas = _this.getCanvas();
            _this.aspectRatio = canvas.width / canvas.height;
            _this._verticalScroll = new fabric.fabric.Rect(DEFAULT_SCROLL_OPTION);
            _this._horizontalScroll = new fabric.fabric.Rect(DEFAULT_SCROLL_OPTION);
            canvas.on(ZOOM_CHANGED, _this._listeners.zoomChanged);
            _this.graphics.on(ADD_TEXT, bind_default()(_context10 = _this._startTextEditingHandler).call(_context10, _assertThisInitialized(_this)));
            _this.graphics.on(TEXT_EDITING, bind_default()(_context11 = _this._startTextEditingHandler).call(_context11, _assertThisInitialized(_this)));
            _this.graphics.on(OBJECT_MODIFIED, bind_default()(_context12 = _this._stopTextEditingHandler).call(_context12, _assertThisInitialized(_this)));
            return _this;
          }
          _createClass(Zoom2, [{
            key: "attachKeyboardZoomEvents",
            value: function attachKeyboardZoomEvents() {
              fabric.fabric.util.addListener(document, KEY_DOWN, this._listeners.keydown);
              fabric.fabric.util.addListener(document, KEY_UP, this._listeners.keyup);
            }
          }, {
            key: "detachKeyboardZoomEvents",
            value: function detachKeyboardZoomEvents() {
              fabric.fabric.util.removeListener(document, KEY_DOWN, this._listeners.keydown);
              fabric.fabric.util.removeListener(document, KEY_UP, this._listeners.keyup);
            }
          }, {
            key: "_startTextEditingHandler",
            value: function _startTextEditingHandler() {
              this.isTextEditing = true;
            }
          }, {
            key: "_stopTextEditingHandler",
            value: function _stopTextEditingHandler() {
              this.isTextEditing = false;
            }
          }, {
            key: "_startHandModeWithSpaceBar",
            value: function _startHandModeWithSpaceBar(e2) {
              if (this.withSpace || this.isTextEditing) {
                return;
              }
              if (e2.keyCode === keyCodes.SPACE) {
                this.withSpace = true;
                this.startHandMode();
              }
            }
          }, {
            key: "_endHandModeWithSpaceBar",
            value: function _endHandModeWithSpaceBar(e2) {
              if (e2.keyCode === keyCodes.SPACE) {
                this.withSpace = false;
                this.endHandMode();
              }
            }
          }, {
            key: "startZoomInMode",
            value: function startZoomInMode() {
              if (this.zoomArea) {
                return;
              }
              this.endHandMode();
              this.zoomMode = zoomModes.ZOOM;
              var canvas = this.getCanvas();
              this._changeObjectsEventedState(false);
              this.zoomArea = new fabric.fabric.Rect({
                left: 0,
                top: 0,
                width: 0.5,
                height: 0.5,
                stroke: "black",
                strokeWidth: 1,
                fill: "transparent",
                hoverCursor: "zoom-in"
              });
              canvas.discardActiveObject();
              canvas.add(this.zoomArea);
              canvas.on("mouse:down", this._listeners.startZoom);
              canvas.selection = false;
              canvas.defaultCursor = "zoom-in";
            }
          }, {
            key: "endZoomInMode",
            value: function endZoomInMode() {
              this.zoomMode = zoomModes.DEFAULT;
              var canvas = this.getCanvas();
              var _this$_listeners = this._listeners, startZoom = _this$_listeners.startZoom, moveZoom = _this$_listeners.moveZoom, stopZoom = _this$_listeners.stopZoom;
              canvas.selection = true;
              canvas.defaultCursor = "auto";
              canvas.off({
                "mouse:down": startZoom,
                "mouse:move": moveZoom,
                "mouse:up": stopZoom
              });
              this._changeObjectsEventedState(true);
              canvas.remove(this.zoomArea);
              this.zoomArea = null;
            }
          }, {
            key: "start",
            value: function start() {
              this.zoomArea = null;
              this._startPoint = null;
              this._startHandPoint = null;
            }
          }, {
            key: "end",
            value: function end() {
              this.endZoomInMode();
              this.endHandMode();
            }
          }, {
            key: "startHandMode",
            value: function startHandMode() {
              this.endZoomInMode();
              this.zoomMode = zoomModes.HAND;
              var canvas = this.getCanvas();
              this._changeObjectsEventedState(false);
              canvas.discardActiveObject();
              canvas.off("mouse:down", this._listeners.startHand);
              canvas.on("mouse:down", this._listeners.startHand);
              canvas.selection = false;
              canvas.defaultCursor = "grab";
              canvas.fire(HAND_STARTED);
            }
          }, {
            key: "endHandMode",
            value: function endHandMode() {
              this.zoomMode = zoomModes.DEFAULT;
              var canvas = this.getCanvas();
              this._changeObjectsEventedState(true);
              canvas.off("mouse:down", this._listeners.startHand);
              canvas.selection = true;
              canvas.defaultCursor = "auto";
              this._startHandPoint = null;
              canvas.fire(HAND_STOPPED);
            }
          }, {
            key: "_onMouseDownWithZoomMode",
            value: function _onMouseDownWithZoomMode(_ref) {
              var target = _ref.target, e2 = _ref.e;
              if (target) {
                return;
              }
              var canvas = this.getCanvas();
              canvas.selection = false;
              this._startPoint = canvas.getPointer(e2);
              this.zoomArea.set({
                width: 0,
                height: 0
              });
              var _this$_listeners2 = this._listeners, moveZoom = _this$_listeners2.moveZoom, stopZoom = _this$_listeners2.stopZoom;
              canvas.on({
                "mouse:move": moveZoom,
                "mouse:up": stopZoom
              });
            }
          }, {
            key: "_onMouseMoveWithZoomMode",
            value: function _onMouseMoveWithZoomMode(_ref2) {
              var e2 = _ref2.e;
              var canvas = this.getCanvas();
              var pointer = canvas.getPointer(e2);
              var x = pointer.x, y = pointer.y;
              var zoomArea = this.zoomArea, _startPoint = this._startPoint;
              var deltaX = Math.abs(x - _startPoint.x);
              var deltaY = Math.abs(y - _startPoint.y);
              if (deltaX + deltaY > zoom_MOUSE_MOVE_THRESHOLD) {
                canvas.remove(zoomArea);
                zoomArea.set(this._calcRectDimensionFromPoint(x, y));
                canvas.add(zoomArea);
              }
            }
          }, {
            key: "_calcRectDimensionFromPoint",
            value: function _calcRectDimensionFromPoint(x, y) {
              var canvas = this.getCanvas();
              var canvasWidth = canvas.getWidth();
              var canvasHeight = canvas.getHeight();
              var _this$_startPoint = this._startPoint, startX = _this$_startPoint.x, startY = _this$_startPoint.y;
              var min2 = Math.min;
              var left = min2(startX, x);
              var top = min2(startY, y);
              var width = clamp(x, startX, canvasWidth) - left;
              var height = clamp(y, startY, canvasHeight) - top;
              return {
                left,
                top,
                width,
                height
              };
            }
          }, {
            key: "_onMouseUpWithZoomMode",
            value: function _onMouseUpWithZoomMode() {
              var zoomLevel = this.zoomLevel;
              var zoomArea = this.zoomArea;
              var _this$_listeners3 = this._listeners, moveZoom = _this$_listeners3.moveZoom, stopZoom = _this$_listeners3.stopZoom;
              var canvas = this.getCanvas();
              var center = this._getCenterPoint();
              var x = center.x, y = center.y;
              if (!this._isMaxZoomLevel()) {
                this._centerPoints.push({
                  x,
                  y,
                  prevZoomLevel: zoomLevel,
                  zoomLevel: zoomLevel + 1
                });
                zoomLevel += 1;
                canvas.zoomToPoint({
                  x,
                  y
                }, zoomLevel);
                this._fireZoomChanged(canvas, zoomLevel);
                this.zoomLevel = zoomLevel;
              }
              canvas.off({
                "mouse:move": moveZoom,
                "mouse:up": stopZoom
              });
              canvas.remove(zoomArea);
              this._startPoint = null;
            }
          }, {
            key: "_getCenterPoint",
            value: function _getCenterPoint() {
              var _this$zoomArea = this.zoomArea, left = _this$zoomArea.left, top = _this$zoomArea.top, width = _this$zoomArea.width, height = _this$zoomArea.height;
              var _this$_startPoint2 = this._startPoint, x = _this$_startPoint2.x, y = _this$_startPoint2.y;
              var aspectRatio = this.aspectRatio;
              if (width < zoom_MOUSE_MOVE_THRESHOLD && height < zoom_MOUSE_MOVE_THRESHOLD) {
                return {
                  x,
                  y
                };
              }
              return width > height ? {
                x: left + aspectRatio * height / 2,
                y: top + height / 2
              } : {
                x: left + width / 2,
                y: top + width / aspectRatio / 2
              };
            }
          }, {
            key: "zoom",
            value: function zoom2(_ref3) {
              var x = _ref3.x, y = _ref3.y;
              var zoomLevel = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.zoomLevel;
              var canvas = this.getCanvas();
              var centerPoints = this._centerPoints;
              for (var i = centerPoints.length - 1; i >= 0; i -= 1) {
                if (centerPoints[i].zoomLevel < zoomLevel) {
                  break;
                }
                var _centerPoints$pop = centerPoints.pop(), prevX = _centerPoints$pop.x, prevY = _centerPoints$pop.y, prevZoomLevel = _centerPoints$pop.prevZoomLevel;
                canvas.zoomToPoint({
                  x: prevX,
                  y: prevY
                }, prevZoomLevel);
                this.zoomLevel = prevZoomLevel;
              }
              canvas.zoomToPoint({
                x,
                y
              }, zoomLevel);
              if (!this._isDefaultZoomLevel(zoomLevel)) {
                this._centerPoints.push({
                  x,
                  y,
                  zoomLevel,
                  prevZoomLevel: this.zoomLevel
                });
              }
              this.zoomLevel = zoomLevel;
              this._fireZoomChanged(canvas, zoomLevel);
            }
          }, {
            key: "zoomOut",
            value: function zoomOut() {
              var centerPoints = this._centerPoints;
              if (!centerPoints.length) {
                return;
              }
              var canvas = this.getCanvas();
              var point = centerPoints.pop();
              var x = point.x, y = point.y, prevZoomLevel = point.prevZoomLevel;
              if (this._isDefaultZoomLevel(prevZoomLevel)) {
                canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
              } else {
                canvas.zoomToPoint({
                  x,
                  y
                }, prevZoomLevel);
              }
              this.zoomLevel = prevZoomLevel;
              this._fireZoomChanged(canvas, this.zoomLevel);
            }
          }, {
            key: "resetZoom",
            value: function resetZoom() {
              var canvas = this.getCanvas();
              canvas.setViewportTransform([1, 0, 0, 1, 0, 0]);
              this.zoomLevel = DEFAULT_ZOOM_LEVEL;
              this._centerPoints = [];
              this._fireZoomChanged(canvas, this.zoomLevel);
            }
          }, {
            key: "_isMaxZoomLevel",
            value: function _isMaxZoomLevel() {
              return this.zoomLevel >= 5;
            }
          }, {
            key: "_movePointOfZoom",
            value: function _movePointOfZoom(_ref4) {
              var deltaX = _ref4.x, deltaY = _ref4.y;
              var centerPoints = this._centerPoints;
              if (!centerPoints.length) {
                return;
              }
              var canvas = this.getCanvas();
              var zoomLevel = this.zoomLevel;
              var point = centerPoints.pop();
              var originX = point.x, originY = point.y, prevZoomLevel = point.prevZoomLevel;
              var x = originX - deltaX;
              var y = originY - deltaY;
              canvas.zoomToPoint({
                x: originX,
                y: originY
              }, prevZoomLevel);
              canvas.zoomToPoint({
                x,
                y
              }, zoomLevel);
              centerPoints.push({
                x,
                y,
                prevZoomLevel,
                zoomLevel
              });
              this._fireZoomChanged(canvas, zoomLevel);
            }
          }, {
            key: "_onMouseDownWithHandMode",
            value: function _onMouseDownWithHandMode(_ref5) {
              var target = _ref5.target, e2 = _ref5.e;
              if (target) {
                return;
              }
              var canvas = this.getCanvas();
              if (this.zoomLevel <= DEFAULT_ZOOM_LEVEL) {
                return;
              }
              canvas.selection = false;
              this._startHandPoint = canvas.getPointer(e2);
              var _this$_listeners4 = this._listeners, moveHand = _this$_listeners4.moveHand, stopHand = _this$_listeners4.stopHand;
              canvas.on({
                "mouse:move": moveHand,
                "mouse:up": stopHand
              });
            }
          }, {
            key: "_onMouseMoveWithHandMode",
            value: function _onMouseMoveWithHandMode(_ref6) {
              var e2 = _ref6.e;
              var canvas = this.getCanvas();
              var _canvas$getPointer = canvas.getPointer(e2), x = _canvas$getPointer.x, y = _canvas$getPointer.y;
              var deltaX = x - this._startHandPoint.x;
              var deltaY = y - this._startHandPoint.y;
              this._movePointOfZoom({
                x: deltaX,
                y: deltaY
              });
            }
          }, {
            key: "_onMouseUpWithHandMode",
            value: function _onMouseUpWithHandMode() {
              var canvas = this.getCanvas();
              var _this$_listeners5 = this._listeners, moveHand = _this$_listeners5.moveHand, stopHand = _this$_listeners5.stopHand;
              canvas.off({
                "mouse:move": moveHand,
                "mouse:up": stopHand
              });
              this._startHandPoint = null;
            }
          }, {
            key: "_changeScrollState",
            value: function _changeScrollState(_ref7) {
              var viewport = _ref7.viewport, zoomLevel = _ref7.zoomLevel;
              var canvas = this.getCanvas();
              canvas.remove(this._verticalScroll);
              canvas.remove(this._horizontalScroll);
              if (this._isDefaultZoomLevel(zoomLevel)) {
                return;
              }
              var canvasWidth = canvas.width;
              var canvasHeight = canvas.height;
              var tl = viewport.tl, tr = viewport.tr, bl = viewport.bl;
              var viewportWidth = tr.x - tl.x;
              var viewportHeight = bl.y - tl.y;
              var horizontalScrollWidth = viewportWidth * viewportWidth / canvasWidth;
              var horizontalScrollHeight = viewportHeight * DEFAULT_HORIZONTAL_SCROLL_RATIO.SIZE;
              var horizontalScrollLeft = clamp(tl.x + tl.x / canvasWidth * viewportWidth, tl.x, tr.x - horizontalScrollWidth);
              var horizontalScrollMargin = viewportHeight * DEFAULT_HORIZONTAL_SCROLL_RATIO.MARGIN;
              var horizontalScrollBorderRadius = viewportHeight * DEFAULT_HORIZONTAL_SCROLL_RATIO.BORDER_RADIUS;
              this._horizontalScroll.set({
                left: horizontalScrollLeft,
                top: bl.y - horizontalScrollHeight - horizontalScrollMargin,
                width: horizontalScrollWidth,
                height: horizontalScrollHeight,
                rx: horizontalScrollBorderRadius,
                ry: horizontalScrollBorderRadius
              });
              var verticalScrollWidth = viewportWidth * DEFAULT_VERTICAL_SCROLL_RATIO.SIZE;
              var verticalScrollHeight = viewportHeight * viewportHeight / canvasHeight;
              var verticalScrollTop = clamp(tl.y + tl.y / canvasHeight * viewportHeight, tr.y, bl.y - verticalScrollHeight);
              var verticalScrollMargin = viewportWidth * DEFAULT_VERTICAL_SCROLL_RATIO.MARGIN;
              var verticalScrollBorderRadius = viewportWidth * DEFAULT_VERTICAL_SCROLL_RATIO.BORDER_RADIUS;
              this._verticalScroll.set({
                left: tr.x - verticalScrollWidth - verticalScrollMargin,
                top: verticalScrollTop,
                width: verticalScrollWidth,
                height: verticalScrollHeight,
                rx: verticalScrollBorderRadius,
                ry: verticalScrollBorderRadius
              });
              this._addScrollBar();
            }
          }, {
            key: "_changeObjectsEventedState",
            value: function _changeObjectsEventedState() {
              var evented = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
              var canvas = this.getCanvas();
              canvas.forEachObject(function(obj) {
                obj.evented = evented;
              });
            }
          }, {
            key: "_addScrollBar",
            value: function _addScrollBar() {
              var _this2 = this;
              var canvas = this.getCanvas();
              canvas.add(this._horizontalScroll);
              canvas.add(this._verticalScroll);
              if (this.scrollBarTid) {
                clearTimeout(this.scrollBarTid);
              }
              this.scrollBarTid = set_timeout_default()(function() {
                canvas.remove(_this2._horizontalScroll);
                canvas.remove(_this2._verticalScroll);
              }, 3e3);
            }
          }, {
            key: "_isDefaultZoomLevel",
            value: function _isDefaultZoomLevel(zoomLevel) {
              return zoomLevel === DEFAULT_ZOOM_LEVEL;
            }
          }, {
            key: "_fireZoomChanged",
            value: function _fireZoomChanged(canvas, zoomLevel) {
              canvas.fire(ZOOM_CHANGED, {
                viewport: canvas.calcViewportBoundaries(),
                zoomLevel
              });
            }
          }, {
            key: "mode",
            get: function get() {
              return this.zoomMode;
            }
          }]);
          return Zoom2;
        }(component);
        var zoom = Zoom;
        var drawingMode_createMessage = errorMessage.create;
        var drawingMode_errorTypes = errorMessage.types;
        var DrawingMode = /* @__PURE__ */ function() {
          function DrawingMode2(name2) {
            _classCallCheck(this, DrawingMode2);
            this.name = name2;
          }
          _createClass(DrawingMode2, [{
            key: "getName",
            value: function getName() {
              return this.name;
            }
          }, {
            key: "start",
            value: function start() {
              throw new Error(drawingMode_createMessage(drawingMode_errorTypes.UN_IMPLEMENTATION, "start"));
            }
          }, {
            key: "end",
            value: function end() {
              throw new Error(drawingMode_createMessage(drawingMode_errorTypes.UN_IMPLEMENTATION, "stop"));
            }
          }]);
          return DrawingMode2;
        }();
        var drawingMode = DrawingMode;
        function drawingMode_cropper_createSuper(Derived) {
          var hasNativeReflectConstruct = drawingMode_cropper_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function drawingMode_cropper_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var CropperDrawingMode = /* @__PURE__ */ function(_DrawingMode) {
          _inherits(CropperDrawingMode2, _DrawingMode);
          var _super = drawingMode_cropper_createSuper(CropperDrawingMode2);
          function CropperDrawingMode2() {
            _classCallCheck(this, CropperDrawingMode2);
            return _super.call(this, drawingModes.CROPPER);
          }
          _createClass(CropperDrawingMode2, [{
            key: "start",
            value: function start(graphics2) {
              var cropper2 = graphics2.getComponent(componentNames.CROPPER);
              cropper2.start();
            }
          }, {
            key: "end",
            value: function end(graphics2) {
              var cropper2 = graphics2.getComponent(componentNames.CROPPER);
              cropper2.end();
            }
          }]);
          return CropperDrawingMode2;
        }(drawingMode);
        var drawingMode_cropper = CropperDrawingMode;
        function drawingMode_freeDrawing_createSuper(Derived) {
          var hasNativeReflectConstruct = drawingMode_freeDrawing_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function drawingMode_freeDrawing_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var FreeDrawingMode = /* @__PURE__ */ function(_DrawingMode) {
          _inherits(FreeDrawingMode2, _DrawingMode);
          var _super = drawingMode_freeDrawing_createSuper(FreeDrawingMode2);
          function FreeDrawingMode2() {
            _classCallCheck(this, FreeDrawingMode2);
            return _super.call(this, drawingModes.FREE_DRAWING);
          }
          _createClass(FreeDrawingMode2, [{
            key: "start",
            value: function start(graphics2, options) {
              var freeDrawing2 = graphics2.getComponent(componentNames.FREE_DRAWING);
              freeDrawing2.start(options);
            }
          }, {
            key: "end",
            value: function end(graphics2) {
              var freeDrawing2 = graphics2.getComponent(componentNames.FREE_DRAWING);
              freeDrawing2.end();
            }
          }]);
          return FreeDrawingMode2;
        }(drawingMode);
        var drawingMode_freeDrawing = FreeDrawingMode;
        function lineDrawing_createSuper(Derived) {
          var hasNativeReflectConstruct = lineDrawing_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function lineDrawing_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var LineDrawingMode = /* @__PURE__ */ function(_DrawingMode) {
          _inherits(LineDrawingMode2, _DrawingMode);
          var _super = lineDrawing_createSuper(LineDrawingMode2);
          function LineDrawingMode2() {
            _classCallCheck(this, LineDrawingMode2);
            return _super.call(this, drawingModes.LINE_DRAWING);
          }
          _createClass(LineDrawingMode2, [{
            key: "start",
            value: function start(graphics2, options) {
              var lineDrawing2 = graphics2.getComponent(componentNames.LINE);
              lineDrawing2.start(options);
            }
          }, {
            key: "end",
            value: function end(graphics2) {
              var lineDrawing2 = graphics2.getComponent(componentNames.LINE);
              lineDrawing2.end();
            }
          }]);
          return LineDrawingMode2;
        }(drawingMode);
        var lineDrawing = LineDrawingMode;
        function drawingMode_shape_createSuper(Derived) {
          var hasNativeReflectConstruct = drawingMode_shape_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function drawingMode_shape_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var ShapeDrawingMode = /* @__PURE__ */ function(_DrawingMode) {
          _inherits(ShapeDrawingMode2, _DrawingMode);
          var _super = drawingMode_shape_createSuper(ShapeDrawingMode2);
          function ShapeDrawingMode2() {
            _classCallCheck(this, ShapeDrawingMode2);
            return _super.call(this, drawingModes.SHAPE);
          }
          _createClass(ShapeDrawingMode2, [{
            key: "start",
            value: function start(graphics2) {
              var shape2 = graphics2.getComponent(componentNames.SHAPE);
              shape2.start();
            }
          }, {
            key: "end",
            value: function end(graphics2) {
              var shape2 = graphics2.getComponent(componentNames.SHAPE);
              shape2.end();
            }
          }]);
          return ShapeDrawingMode2;
        }(drawingMode);
        var drawingMode_shape = ShapeDrawingMode;
        function drawingMode_text_createSuper(Derived) {
          var hasNativeReflectConstruct = drawingMode_text_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function drawingMode_text_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var TextDrawingMode = /* @__PURE__ */ function(_DrawingMode) {
          _inherits(TextDrawingMode2, _DrawingMode);
          var _super = drawingMode_text_createSuper(TextDrawingMode2);
          function TextDrawingMode2() {
            _classCallCheck(this, TextDrawingMode2);
            return _super.call(this, drawingModes.TEXT);
          }
          _createClass(TextDrawingMode2, [{
            key: "start",
            value: function start(graphics2) {
              var text = graphics2.getComponent(componentNames.TEXT);
              text.start();
            }
          }, {
            key: "end",
            value: function end(graphics2) {
              var text = graphics2.getComponent(componentNames.TEXT);
              text.end();
            }
          }]);
          return TextDrawingMode2;
        }(drawingMode);
        var drawingMode_text = TextDrawingMode;
        function drawingMode_icon_createSuper(Derived) {
          var hasNativeReflectConstruct = drawingMode_icon_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function drawingMode_icon_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var IconDrawingMode = /* @__PURE__ */ function(_DrawingMode) {
          _inherits(IconDrawingMode2, _DrawingMode);
          var _super = drawingMode_icon_createSuper(IconDrawingMode2);
          function IconDrawingMode2() {
            _classCallCheck(this, IconDrawingMode2);
            return _super.call(this, drawingModes.ICON);
          }
          _createClass(IconDrawingMode2, [{
            key: "start",
            value: function start(graphics2) {
              var icon2 = graphics2.getComponent(componentNames.ICON);
              icon2.start();
            }
          }, {
            key: "end",
            value: function end(graphics2) {
              var icon2 = graphics2.getComponent(componentNames.ICON);
              icon2.end();
            }
          }]);
          return IconDrawingMode2;
        }(drawingMode);
        var drawingMode_icon = IconDrawingMode;
        function drawingMode_zoom_createSuper(Derived) {
          var hasNativeReflectConstruct = drawingMode_zoom_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function drawingMode_zoom_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var ZoomDrawingMode = /* @__PURE__ */ function(_DrawingMode) {
          _inherits(ZoomDrawingMode2, _DrawingMode);
          var _super = drawingMode_zoom_createSuper(ZoomDrawingMode2);
          function ZoomDrawingMode2() {
            _classCallCheck(this, ZoomDrawingMode2);
            return _super.call(this, drawingModes.ZOOM);
          }
          _createClass(ZoomDrawingMode2, [{
            key: "start",
            value: function start(graphics2) {
              var zoom2 = graphics2.getComponent(componentNames.ZOOM);
              zoom2.start();
            }
          }, {
            key: "end",
            value: function end(graphics2) {
              var zoom2 = graphics2.getComponent(componentNames.ZOOM);
              zoom2.end();
            }
          }]);
          return ZoomDrawingMode2;
        }(drawingMode);
        var drawingMode_zoom = ZoomDrawingMode;
        var cachedUndoDataForChangeDimension = null;
        function setCachedUndoDataForDimension(undoData) {
          cachedUndoDataForChangeDimension = undoData;
        }
        function getCachedUndoDataForDimension() {
          return cachedUndoDataForChangeDimension;
        }
        function makeSelectionUndoData(obj, undoDatumMaker) {
          var undoData;
          if (obj.type === "activeSelection") {
            var _context2;
            undoData = map_default()(_context2 = obj.getObjects()).call(_context2, function(item) {
              var angle2 = item.angle, left = item.left, top = item.top, scaleX = item.scaleX, scaleY = item.scaleY, width = item.width, height = item.height;
              fabric.fabric.util.addTransformToObject(item, obj.calcTransformMatrix());
              var result = undoDatumMaker(item);
              item.set({
                angle: angle2,
                left,
                top,
                width,
                height,
                scaleX,
                scaleY
              });
              return result;
            });
          } else {
            undoData = [undoDatumMaker(obj)];
          }
          return undoData;
        }
        function makeSelectionUndoDatum(id, obj, isSelection) {
          return isSelection ? {
            id,
            width: obj.width,
            height: obj.height,
            top: obj.top,
            left: obj.left,
            angle: obj.angle,
            scaleX: obj.scaleX,
            scaleY: obj.scaleY
          } : extend_default()({
            id
          }, obj);
        }
        function component_resize_createSuper(Derived) {
          var hasNativeReflectConstruct = component_resize_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function component_resize_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var resize_Resize = /* @__PURE__ */ function(_Component) {
          _inherits(Resize2, _Component);
          var _super = component_resize_createSuper(Resize2);
          function Resize2(graphics2) {
            var _this;
            _classCallCheck(this, Resize2);
            _this = _super.call(this, componentNames.RESIZE, graphics2);
            _this._dimensions = null;
            _this._originalDimensions = null;
            return _this;
          }
          _createClass(Resize2, [{
            key: "getCurrentDimensions",
            value: function getCurrentDimensions() {
              var canvasImage = this.getCanvasImage();
              if (!this._dimensions && canvasImage) {
                var width = canvasImage.width, height = canvasImage.height;
                this._dimensions = {
                  width,
                  height
                };
              }
              return this._dimensions;
            }
          }, {
            key: "getOriginalDimensions",
            value: function getOriginalDimensions() {
              return this._originalDimensions;
            }
          }, {
            key: "setOriginalDimensions",
            value: function setOriginalDimensions(dimensions) {
              this._originalDimensions = dimensions;
            }
          }, {
            key: "resize",
            value: function resize2(dimensions) {
              var canvasImage = this.getCanvasImage();
              var width = canvasImage.width, height = canvasImage.height, scaleX = canvasImage.scaleX, scaleY = canvasImage.scaleY;
              var dimensionsWidth = dimensions.width, dimensionsHeight = dimensions.height;
              var scaleValues = {
                scaleX: dimensionsWidth ? dimensionsWidth / width : scaleX,
                scaleY: dimensionsHeight ? dimensionsHeight / height : scaleY
              };
              if (scaleX !== scaleValues.scaleX || scaleY !== scaleValues.scaleY) {
                canvasImage.set(scaleValues).setCoords();
                this._dimensions = {
                  width: canvasImage.width * canvasImage.scaleX,
                  height: canvasImage.height * canvasImage.scaleY
                };
              }
              this.adjustCanvasDimensionBase();
              return promise_default().resolve();
            }
          }, {
            key: "start",
            value: function start() {
              var dimensions = this.getCurrentDimensions();
              this.setOriginalDimensions(dimensions);
            }
          }, {
            key: "end",
            value: function end() {
            }
          }]);
          return Resize2;
        }(component);
        var component_resize = resize_Resize;
        function drawingMode_resize_createSuper(Derived) {
          var hasNativeReflectConstruct = drawingMode_resize_isNativeReflectConstruct();
          return function _createSuperInternal() {
            var Super = _getPrototypeOf(Derived), result;
            if (hasNativeReflectConstruct) {
              var NewTarget = _getPrototypeOf(this).constructor;
              result = construct_default()(Super, arguments, NewTarget);
            } else {
              result = Super.apply(this, arguments);
            }
            return _possibleConstructorReturn(this, result);
          };
        }
        function drawingMode_resize_isNativeReflectConstruct() {
          if (typeof Reflect === "undefined" || !construct_default())
            return false;
          if (construct_default().sham)
            return false;
          if (typeof Proxy === "function")
            return true;
          try {
            Boolean.prototype.valueOf.call(construct_default()(Boolean, [], function() {
            }));
            return true;
          } catch (e2) {
            return false;
          }
        }
        var ResizeDrawingMode = /* @__PURE__ */ function(_DrawingMode) {
          _inherits(ResizeDrawingMode2, _DrawingMode);
          var _super = drawingMode_resize_createSuper(ResizeDrawingMode2);
          function ResizeDrawingMode2() {
            _classCallCheck(this, ResizeDrawingMode2);
            return _super.call(this, drawingModes.RESIZE);
          }
          _createClass(ResizeDrawingMode2, [{
            key: "start",
            value: function start(graphics2) {
              var resize2 = graphics2.getComponent(componentNames.RESIZE);
              resize2.start();
            }
          }, {
            key: "end",
            value: function end(graphics2) {
              var resize2 = graphics2.getComponent(componentNames.RESIZE);
              resize2.end();
            }
          }]);
          return ResizeDrawingMode2;
        }(drawingMode);
        var drawingMode_resize = ResizeDrawingMode;
        var DEFAULT_CSS_MAX_WIDTH = 1e3;
        var DEFAULT_CSS_MAX_HEIGHT = 800;
        var EXTRA_PX_FOR_PASTE = 10;
        var cssOnly = {
          cssOnly: true
        };
        var backstoreOnly = {
          backstoreOnly: true
        };
        var Graphics = /* @__PURE__ */ function() {
          function Graphics2(element) {
            var _context2, _context22, _context3, _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11;
            var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, cssMaxWidth = _ref.cssMaxWidth, cssMaxHeight = _ref.cssMaxHeight;
            _classCallCheck(this, Graphics2);
            this.canvasImage = null;
            this.cssMaxWidth = cssMaxWidth || DEFAULT_CSS_MAX_WIDTH;
            this.cssMaxHeight = cssMaxHeight || DEFAULT_CSS_MAX_HEIGHT;
            this.cropSelectionStyle = {};
            this.targetObjectForCopyPaste = null;
            this.imageName = "";
            this._objects = {};
            this._canvas = null;
            this._drawingMode = drawingModes.NORMAL;
            this._drawingModeMap = {};
            this._componentMap = {};
            this._handler = {
              onMouseDown: bind_default()(_context2 = this._onMouseDown).call(_context2, this),
              onObjectAdded: bind_default()(_context22 = this._onObjectAdded).call(_context22, this),
              onObjectRemoved: bind_default()(_context3 = this._onObjectRemoved).call(_context3, this),
              onObjectMoved: bind_default()(_context4 = this._onObjectMoved).call(_context4, this),
              onObjectScaled: bind_default()(_context5 = this._onObjectScaled).call(_context5, this),
              onObjectModified: bind_default()(_context6 = this._onObjectModified).call(_context6, this),
              onObjectRotated: bind_default()(_context7 = this._onObjectRotated).call(_context7, this),
              onObjectSelected: bind_default()(_context8 = this._onObjectSelected).call(_context8, this),
              onPathCreated: bind_default()(_context9 = this._onPathCreated).call(_context9, this),
              onSelectionCleared: bind_default()(_context10 = this._onSelectionCleared).call(_context10, this),
              onSelectionCreated: bind_default()(_context11 = this._onSelectionCreated).call(_context11, this)
            };
            this._setObjectCachingToFalse();
            this._setCanvasElement(element);
            this._createDrawingModeInstances();
            this._createComponents();
            this._attachCanvasEvents();
            this._attachZoomEvents();
          }
          _createClass(Graphics2, [{
            key: "destroy",
            value: function destroy2() {
              var wrapperEl = this._canvas.wrapperEl;
              this._canvas.clear();
              wrapperEl.parentNode.removeChild(wrapperEl);
              this._detachZoomEvents();
            }
          }, {
            key: "_attachZoomEvents",
            value: function _attachZoomEvents() {
              var zoom2 = this.getComponent(componentNames.ZOOM);
              zoom2.attachKeyboardZoomEvents();
            }
          }, {
            key: "_detachZoomEvents",
            value: function _detachZoomEvents() {
              var zoom2 = this.getComponent(componentNames.ZOOM);
              zoom2.detachKeyboardZoomEvents();
            }
          }, {
            key: "deactivateAll",
            value: function deactivateAll() {
              this._canvas.discardActiveObject();
              return this;
            }
          }, {
            key: "renderAll",
            value: function renderAll() {
              this._canvas.renderAll();
              return this;
            }
          }, {
            key: "add",
            value: function add2(objects) {
              var _this$_canvas;
              var theArgs = [];
              if (isArray_default()(objects)) {
                theArgs = objects;
              } else {
                theArgs.push(objects);
              }
              (_this$_canvas = this._canvas).add.apply(_this$_canvas, _toConsumableArray(theArgs));
            }
          }, {
            key: "contains",
            value: function contains2(target) {
              return this._canvas.contains(target);
            }
          }, {
            key: "getObjects",
            value: function getObjects() {
              var _context12;
              return slice_default()(_context12 = this._canvas.getObjects()).call(_context12);
            }
          }, {
            key: "getObject",
            value: function getObject(id) {
              return this._objects[id];
            }
          }, {
            key: "remove",
            value: function remove(target) {
              this._canvas.remove(target);
            }
          }, {
            key: "removeAll",
            value: function removeAll(includesBackground) {
              var _context13;
              var canvas = this._canvas;
              var objects = slice_default()(_context13 = canvas.getObjects()).call(_context13);
              canvas.remove.apply(canvas, _toConsumableArray(this._canvas.getObjects()));
              if (includesBackground) {
                canvas.clear();
              }
              return objects;
            }
          }, {
            key: "removeObjectById",
            value: function removeObjectById(id) {
              var objects = [];
              var canvas = this._canvas;
              var target = this.getObject(id);
              var isValidGroup = target && target.isType("group") && !target.isEmpty();
              if (isValidGroup) {
                canvas.discardActiveObject();
                target.forEachObject(function(obj) {
                  objects.push(obj);
                  canvas.remove(obj);
                });
              } else if (canvas.contains(target)) {
                objects.push(target);
                canvas.remove(target);
              }
              return objects;
            }
          }, {
            key: "getObjectId",
            value: function getObjectId(object) {
              var key = null;
              for (key in this._objects) {
                if (this._objects.hasOwnProperty(key)) {
                  if (object === this._objects[key]) {
                    return key;
                  }
                }
              }
              return null;
            }
          }, {
            key: "getActiveObject",
            value: function getActiveObject() {
              return this._canvas._activeObject;
            }
          }, {
            key: "getActiveObjectIdForRemove",
            value: function getActiveObjectIdForRemove() {
              var activeObject = this.getActiveObject();
              var type = activeObject.type, left = activeObject.left, top = activeObject.top;
              var isSelection = type === "activeSelection";
              if (isSelection) {
                var group = new fabric.fabric.Group(_toConsumableArray(activeObject.getObjects()), {
                  left,
                  top
                });
                return this._addFabricObject(group);
              }
              return this.getObjectId(activeObject);
            }
          }, {
            key: "isReadyRemoveObject",
            value: function isReadyRemoveObject() {
              var activeObject = this.getActiveObject();
              return activeObject && !activeObject.isEditing;
            }
          }, {
            key: "getActiveObjects",
            value: function getActiveObjects() {
              var activeObject = this._canvas._activeObject;
              return activeObject && activeObject.type === "activeSelection" ? activeObject : null;
            }
          }, {
            key: "getActiveSelectionFromObjects",
            value: function getActiveSelectionFromObjects(objects) {
              var canvas = this.getCanvas();
              return new fabric.fabric.ActiveSelection(objects, {
                canvas
              });
            }
          }, {
            key: "setActiveObject",
            value: function setActiveObject(target) {
              this._canvas.setActiveObject(target);
            }
          }, {
            key: "setCropSelectionStyle",
            value: function setCropSelectionStyle(style2) {
              this.cropSelectionStyle = style2;
            }
          }, {
            key: "getComponent",
            value: function getComponent(name2) {
              return this._componentMap[name2];
            }
          }, {
            key: "getDrawingMode",
            value: function getDrawingMode() {
              return this._drawingMode;
            }
          }, {
            key: "startDrawingMode",
            value: function startDrawingMode(mode, option2) {
              if (this._isSameDrawingMode(mode)) {
                return true;
              }
              this.stopDrawingMode();
              var drawingModeInstance = this._getDrawingModeInstance(mode);
              if (drawingModeInstance && drawingModeInstance.start) {
                drawingModeInstance.start(this, option2);
                this._drawingMode = mode;
              }
              return !!drawingModeInstance;
            }
          }, {
            key: "stopDrawingMode",
            value: function stopDrawingMode() {
              if (this._isSameDrawingMode(drawingModes.NORMAL)) {
                return;
              }
              var drawingModeInstance = this._getDrawingModeInstance(this.getDrawingMode());
              if (drawingModeInstance && drawingModeInstance.end) {
                drawingModeInstance.end(this);
              }
              this._drawingMode = drawingModes.NORMAL;
            }
          }, {
            key: "zoom",
            value: function zoom2(_ref2, zoomLevel) {
              var x = _ref2.x, y = _ref2.y;
              var zoom3 = this.getComponent(componentNames.ZOOM);
              zoom3.zoom({
                x,
                y
              }, zoomLevel);
            }
          }, {
            key: "getZoomMode",
            value: function getZoomMode() {
              var zoom2 = this.getComponent(componentNames.ZOOM);
              return zoom2.mode;
            }
          }, {
            key: "startZoomInMode",
            value: function startZoomInMode() {
              var zoom2 = this.getComponent(componentNames.ZOOM);
              zoom2.startZoomInMode();
            }
          }, {
            key: "endZoomInMode",
            value: function endZoomInMode() {
              var zoom2 = this.getComponent(componentNames.ZOOM);
              zoom2.endZoomInMode();
            }
          }, {
            key: "zoomOut",
            value: function zoomOut() {
              var zoom2 = this.getComponent(componentNames.ZOOM);
              zoom2.zoomOut();
            }
          }, {
            key: "startHandMode",
            value: function startHandMode() {
              var zoom2 = this.getComponent(componentNames.ZOOM);
              zoom2.startHandMode();
            }
          }, {
            key: "endHandMode",
            value: function endHandMode() {
              var zoom2 = this.getComponent(componentNames.ZOOM);
              zoom2.endHandMode();
            }
          }, {
            key: "resetZoom",
            value: function resetZoom() {
              var zoom2 = this.getComponent(componentNames.ZOOM);
              zoom2.resetZoom();
            }
          }, {
            key: "toDataURL",
            value: function toDataURL(options) {
              var cropper2 = this.getComponent(componentNames.CROPPER);
              cropper2.changeVisibility(false);
              var dataUrl = this._canvas && this._canvas.toDataURL(options);
              cropper2.changeVisibility(true);
              return dataUrl;
            }
          }, {
            key: "setCanvasImage",
            value: function setCanvasImage(name2, canvasImage) {
              if (canvasImage) {
                stamp(canvasImage);
              }
              this.imageName = name2;
              this.canvasImage = canvasImage;
            }
          }, {
            key: "setCssMaxDimension",
            value: function setCssMaxDimension(maxDimension) {
              this.cssMaxWidth = maxDimension.width || this.cssMaxWidth;
              this.cssMaxHeight = maxDimension.height || this.cssMaxHeight;
            }
          }, {
            key: "adjustCanvasDimension",
            value: function adjustCanvasDimension() {
              this.adjustCanvasDimensionBase(this.canvasImage.scale(1));
            }
          }, {
            key: "adjustCanvasDimensionBase",
            value: function adjustCanvasDimensionBase() {
              var canvasImage = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : null;
              if (!canvasImage) {
                canvasImage = this.canvasImage;
              }
              var _canvasImage$getBound = canvasImage.getBoundingRect(), width = _canvasImage$getBound.width, height = _canvasImage$getBound.height;
              var maxDimension = this._calcMaxDimension(width, height);
              this.setCanvasCssDimension({
                width: "100%",
                height: "100%",
                "max-width": "".concat(maxDimension.width, "px"),
                "max-height": "".concat(maxDimension.height, "px")
              });
              this.setCanvasBackstoreDimension({
                width,
                height
              });
              this._canvas.centerObject(canvasImage);
            }
          }, {
            key: "setCanvasCssDimension",
            value: function setCanvasCssDimension(dimension) {
              this._canvas.setDimensions(dimension, cssOnly);
            }
          }, {
            key: "setCanvasBackstoreDimension",
            value: function setCanvasBackstoreDimension(dimension) {
              this._canvas.setDimensions(dimension, backstoreOnly);
            }
          }, {
            key: "setImageProperties",
            value: function setImageProperties(setting, withRendering) {
              var canvasImage = this.canvasImage;
              if (!canvasImage) {
                return;
              }
              canvasImage.set(setting).setCoords();
              if (withRendering) {
                this._canvas.renderAll();
              }
            }
          }, {
            key: "getCanvasElement",
            value: function getCanvasElement() {
              return this._canvas.getElement();
            }
          }, {
            key: "getCanvas",
            value: function getCanvas() {
              return this._canvas;
            }
          }, {
            key: "getCanvasImage",
            value: function getCanvasImage() {
              return this.canvasImage;
            }
          }, {
            key: "getImageName",
            value: function getImageName() {
              return this.imageName;
            }
          }, {
            key: "addImageObject",
            value: function addImageObject(imgUrl) {
              var _context14, _this = this;
              var callback = bind_default()(_context14 = this._callbackAfterLoadingImageObject).call(_context14, this);
              return new (promise_default())(function(resolve) {
                fabric.fabric.Image.fromURL(imgUrl, function(image2) {
                  callback(image2);
                  resolve(_this.createObjectProperties(image2));
                }, {
                  crossOrigin: "Anonymous"
                });
              });
            }
          }, {
            key: "getCenter",
            value: function getCenter() {
              return this._canvas.getCenter();
            }
          }, {
            key: "getCropzoneRect",
            value: function getCropzoneRect() {
              return this.getComponent(componentNames.CROPPER).getCropzoneRect();
            }
          }, {
            key: "setCropzoneRect",
            value: function setCropzoneRect(mode) {
              this.getComponent(componentNames.CROPPER).setCropzoneRect(mode);
            }
          }, {
            key: "getCroppedImageData",
            value: function getCroppedImageData(cropRect) {
              return this.getComponent(componentNames.CROPPER).getCroppedImageData(cropRect);
            }
          }, {
            key: "setBrush",
            value: function setBrush(option2) {
              var drawingMode2 = this._drawingMode;
              var compName = componentNames.FREE_DRAWING;
              if (drawingMode2 === drawingModes.LINE_DRAWING) {
                compName = componentNames.LINE;
              }
              this.getComponent(compName).setBrush(option2);
            }
          }, {
            key: "setDrawingShape",
            value: function setDrawingShape(type, options) {
              this.getComponent(componentNames.SHAPE).setStates(type, options);
            }
          }, {
            key: "setIconStyle",
            value: function setIconStyle(type, iconColor) {
              this.getComponent(componentNames.ICON).setStates(type, iconColor);
            }
          }, {
            key: "registerPaths",
            value: function registerPaths(pathInfos) {
              this.getComponent(componentNames.ICON).registerPaths(pathInfos);
            }
          }, {
            key: "changeCursor",
            value: function changeCursor(cursorType) {
              var canvas = this.getCanvas();
              canvas.defaultCursor = cursorType;
              canvas.renderAll();
            }
          }, {
            key: "hasFilter",
            value: function hasFilter(type) {
              return this.getComponent(componentNames.FILTER).hasFilter(type);
            }
          }, {
            key: "setSelectionStyle",
            value: function setSelectionStyle(styles) {
              extend_default()(fObjectOptions.SELECTION_STYLE, styles);
            }
          }, {
            key: "setObjectProperties",
            value: function setObjectProperties(id, props2) {
              var object = this.getObject(id);
              var clone2 = extend_default()({}, props2);
              object.set(clone2);
              object.setCoords();
              this.getCanvas().renderAll();
              return clone2;
            }
          }, {
            key: "getObjectProperties",
            value: function getObjectProperties(id, keys3) {
              var object = this.getObject(id);
              var props2 = {};
              if (isString_default()(keys3)) {
                props2[keys3] = object[keys3];
              } else if (isArray_default()(keys3)) {
                forEachArray_default()(keys3, function(value) {
                  props2[value] = object[value];
                });
              } else {
                forEachOwnProperties_default()(keys3, function(value, key) {
                  props2[key] = object[key];
                });
              }
              return props2;
            }
          }, {
            key: "getObjectPosition",
            value: function getObjectPosition(id, originX, originY) {
              var targetObj = this.getObject(id);
              if (!targetObj) {
                return null;
              }
              return targetObj.getPointByOrigin(originX, originY);
            }
          }, {
            key: "setObjectPosition",
            value: function setObjectPosition(id, posInfo) {
              var targetObj = this.getObject(id);
              var x = posInfo.x, y = posInfo.y, originX = posInfo.originX, originY = posInfo.originY;
              if (!targetObj) {
                return false;
              }
              var targetOrigin = targetObj.getPointByOrigin(originX, originY);
              var centerOrigin = targetObj.getPointByOrigin("center", "center");
              var diffX = centerOrigin.x - targetOrigin.x;
              var diffY = centerOrigin.y - targetOrigin.y;
              targetObj.set({
                left: x + diffX,
                top: y + diffY
              });
              targetObj.setCoords();
              return true;
            }
          }, {
            key: "getCanvasSize",
            value: function getCanvasSize() {
              var image2 = this.getCanvasImage();
              return {
                width: image2 ? image2.width : 0,
                height: image2 ? image2.height : 0
              };
            }
          }, {
            key: "createStaticCanvas",
            value: function createStaticCanvas() {
              var staticCanvas = new fabric.fabric.StaticCanvas();
              staticCanvas.set({
                enableRetinaScaling: false
              });
              return staticCanvas;
            }
          }, {
            key: "_getDrawingModeInstance",
            value: function _getDrawingModeInstance(modeName) {
              return this._drawingModeMap[modeName];
            }
          }, {
            key: "_setObjectCachingToFalse",
            value: function _setObjectCachingToFalse() {
              fabric.fabric.Object.prototype.objectCaching = false;
            }
          }, {
            key: "_setCanvasElement",
            value: function _setCanvasElement(element) {
              var selectedElement;
              var canvasElement;
              if (element.nodeType) {
                selectedElement = element;
              } else {
                selectedElement = document.querySelector(element);
              }
              if (selectedElement.nodeName.toUpperCase() !== "CANVAS") {
                canvasElement = document.createElement("canvas");
                selectedElement.appendChild(canvasElement);
              }
              this._canvas = new fabric.fabric.Canvas(canvasElement, {
                containerClass: "tui-image-editor-canvas-container",
                enableRetinaScaling: false
              });
            }
          }, {
            key: "_createDrawingModeInstances",
            value: function _createDrawingModeInstances() {
              this._register(this._drawingModeMap, new drawingMode_cropper());
              this._register(this._drawingModeMap, new drawingMode_freeDrawing());
              this._register(this._drawingModeMap, new lineDrawing());
              this._register(this._drawingModeMap, new drawingMode_shape());
              this._register(this._drawingModeMap, new drawingMode_text());
              this._register(this._drawingModeMap, new drawingMode_icon());
              this._register(this._drawingModeMap, new drawingMode_zoom());
              this._register(this._drawingModeMap, new drawingMode_resize());
            }
          }, {
            key: "_createComponents",
            value: function _createComponents() {
              this._register(this._componentMap, new imageLoader(this));
              this._register(this._componentMap, new cropper(this));
              this._register(this._componentMap, new component_flip(this));
              this._register(this._componentMap, new rotation(this));
              this._register(this._componentMap, new freeDrawing(this));
              this._register(this._componentMap, new line(this));
              this._register(this._componentMap, new component_text(this));
              this._register(this._componentMap, new component_icon(this));
              this._register(this._componentMap, new component_filter(this));
              this._register(this._componentMap, new shape_Shape(this));
              this._register(this._componentMap, new zoom(this));
              this._register(this._componentMap, new component_resize(this));
            }
          }, {
            key: "_register",
            value: function _register(map2, module2) {
              map2[module2.getName()] = module2;
            }
          }, {
            key: "_isSameDrawingMode",
            value: function _isSameDrawingMode(mode) {
              return this.getDrawingMode() === mode;
            }
          }, {
            key: "_calcMaxDimension",
            value: function _calcMaxDimension(width, height) {
              var wScaleFactor = this.cssMaxWidth / width;
              var hScaleFactor = this.cssMaxHeight / height;
              var cssMaxWidth = Math.min(width, this.cssMaxWidth);
              var cssMaxHeight = Math.min(height, this.cssMaxHeight);
              if (wScaleFactor < 1 && wScaleFactor < hScaleFactor) {
                cssMaxWidth = width * wScaleFactor;
                cssMaxHeight = height * wScaleFactor;
              } else if (hScaleFactor < 1 && hScaleFactor < wScaleFactor) {
                cssMaxWidth = width * hScaleFactor;
                cssMaxHeight = height * hScaleFactor;
              }
              return {
                width: Math.floor(cssMaxWidth),
                height: Math.floor(cssMaxHeight)
              };
            }
          }, {
            key: "_callbackAfterLoadingImageObject",
            value: function _callbackAfterLoadingImageObject(obj) {
              var centerPos = this.getCanvasImage().getCenterPoint();
              obj.set(fObjectOptions.SELECTION_STYLE);
              obj.set({
                left: centerPos.x,
                top: centerPos.y,
                crossOrigin: "Anonymous"
              });
              this.getCanvas().add(obj).setActiveObject(obj);
            }
          }, {
            key: "_attachCanvasEvents",
            value: function _attachCanvasEvents() {
              var canvas = this._canvas;
              var handler = this._handler;
              canvas.on({
                "mouse:down": handler.onMouseDown,
                "object:added": handler.onObjectAdded,
                "object:removed": handler.onObjectRemoved,
                "object:moving": handler.onObjectMoved,
                "object:scaling": handler.onObjectScaled,
                "object:modified": handler.onObjectModified,
                "object:rotating": handler.onObjectRotated,
                "path:created": handler.onPathCreated,
                "selection:cleared": handler.onSelectionCleared,
                "selection:created": handler.onSelectionCreated,
                "selection:updated": handler.onObjectSelected
              });
            }
          }, {
            key: "_onMouseDown",
            value: function _onMouseDown(fEvent) {
              var _this2 = this;
              var event = fEvent.e, target = fEvent.target;
              var originPointer = this._canvas.getPointer(event);
              if (target) {
                var type = target.type;
                var undoData = makeSelectionUndoData(target, function(item) {
                  return makeSelectionUndoDatum(_this2.getObjectId(item), item, type === "activeSelection");
                });
                setCachedUndoDataForDimension(undoData);
              }
              this.fire(eventNames.MOUSE_DOWN, event, originPointer);
            }
          }, {
            key: "_onObjectAdded",
            value: function _onObjectAdded(fEvent) {
              var obj = fEvent.target;
              if (obj.isType("cropzone")) {
                return;
              }
              this._addFabricObject(obj);
            }
          }, {
            key: "_onObjectRemoved",
            value: function _onObjectRemoved(fEvent) {
              var obj = fEvent.target;
              this._removeFabricObject(stamp(obj));
            }
          }, {
            key: "_onObjectMoved",
            value: function _onObjectMoved(fEvent) {
              var _this3 = this;
              this._lazyFire(eventNames.OBJECT_MOVED, function(object) {
                return _this3.createObjectProperties(object);
              }, fEvent.target);
            }
          }, {
            key: "_onObjectScaled",
            value: function _onObjectScaled(fEvent) {
              var _this4 = this;
              this._lazyFire(eventNames.OBJECT_SCALED, function(object) {
                return _this4.createObjectProperties(object);
              }, fEvent.target);
            }
          }, {
            key: "_onObjectModified",
            value: function _onObjectModified(fEvent) {
              var target = fEvent.target;
              if (target.type === "activeSelection") {
                var items = target.getObjects();
                for_each_default()(items).call(items, function(item) {
                  return item.fire("modifiedInGroup", target);
                });
              }
              this.fire(eventNames.OBJECT_MODIFIED, target, this.getObjectId(target));
            }
          }, {
            key: "_onObjectRotated",
            value: function _onObjectRotated(fEvent) {
              var _this5 = this;
              this._lazyFire(eventNames.OBJECT_ROTATED, function(object) {
                return _this5.createObjectProperties(object);
              }, fEvent.target);
            }
          }, {
            key: "_lazyFire",
            value: function _lazyFire(eventName, paramsMaker, target) {
              var _this6 = this;
              var existEventDelegation = target && target.canvasEventDelegation;
              var delegationState = existEventDelegation ? target.canvasEventDelegation(eventName) : "none";
              if (delegationState === "unregistered") {
                target.canvasEventRegister(eventName, function(object) {
                  _this6.fire(eventName, paramsMaker(object));
                });
              }
              if (delegationState === "none") {
                this.fire(eventName, paramsMaker(target));
              }
            }
          }, {
            key: "_onObjectSelected",
            value: function _onObjectSelected(fEvent) {
              var target = fEvent.target;
              var params = this.createObjectProperties(target);
              this.fire(eventNames.OBJECT_ACTIVATED, params);
            }
          }, {
            key: "_onPathCreated",
            value: function _onPathCreated(obj) {
              var _obj$path$getCenterPo = obj.path.getCenterPoint(), left = _obj$path$getCenterPo.x, top = _obj$path$getCenterPo.y;
              obj.path.set(extend_default()({
                left,
                top
              }, fObjectOptions.SELECTION_STYLE));
              var params = this.createObjectProperties(obj.path);
              this.fire(eventNames.ADD_OBJECT, params);
            }
          }, {
            key: "_onSelectionCleared",
            value: function _onSelectionCleared() {
              this.fire(eventNames.SELECTION_CLEARED);
            }
          }, {
            key: "_onSelectionCreated",
            value: function _onSelectionCreated(fEvent) {
              var target = fEvent.target;
              var params = this.createObjectProperties(target);
              this.fire(eventNames.OBJECT_ACTIVATED, params);
              this.fire(eventNames.SELECTION_CREATED, fEvent.target);
            }
          }, {
            key: "discardSelection",
            value: function discardSelection() {
              this._canvas.discardActiveObject();
              this._canvas.renderAll();
            }
          }, {
            key: "changeSelectableAll",
            value: function changeSelectableAll(selectable) {
              this._canvas.forEachObject(function(obj) {
                obj.selectable = selectable;
                obj.hoverCursor = selectable ? "move" : "crosshair";
              });
            }
          }, {
            key: "createObjectProperties",
            value: function createObjectProperties(obj) {
              var predefinedKeys = ["left", "top", "width", "height", "fill", "stroke", "strokeWidth", "opacity", "angle"];
              var props2 = {
                id: stamp(obj),
                type: obj.type
              };
              extend_default()(props2, getProperties(obj, predefinedKeys));
              if (includes(["i-text", "text"], obj.type)) {
                extend_default()(props2, this._createTextProperties(obj, props2));
              } else if (includes(["rect", "triangle", "circle"], obj.type)) {
                var shapeComp = this.getComponent(componentNames.SHAPE);
                extend_default()(props2, {
                  fill: shapeComp.makeFillPropertyForUserEvent(obj)
                });
              }
              return props2;
            }
          }, {
            key: "_createTextProperties",
            value: function _createTextProperties(obj) {
              var predefinedKeys = ["text", "fontFamily", "fontSize", "fontStyle", "textAlign", "textDecoration", "fontWeight"];
              var props2 = {};
              extend_default()(props2, getProperties(obj, predefinedKeys));
              return props2;
            }
          }, {
            key: "_addFabricObject",
            value: function _addFabricObject(obj) {
              var id = stamp(obj);
              this._objects[id] = obj;
              return id;
            }
          }, {
            key: "_removeFabricObject",
            value: function _removeFabricObject(id) {
              delete this._objects[id];
            }
          }, {
            key: "resetTargetObjectForCopyPaste",
            value: function resetTargetObjectForCopyPaste() {
              var activeObject = this.getActiveObject();
              if (activeObject) {
                this.targetObjectForCopyPaste = activeObject;
              }
            }
          }, {
            key: "pasteObject",
            value: function pasteObject() {
              var _this7 = this;
              if (!this.targetObjectForCopyPaste) {
                return promise_default().resolve([]);
              }
              var targetObject = this.targetObjectForCopyPaste;
              var isGroupSelect = targetObject.type === "activeSelection";
              var targetObjects = isGroupSelect ? targetObject.getObjects() : [targetObject];
              var newTargetObject = null;
              this.discardSelection();
              return this._cloneObject(targetObjects).then(function(addedObjects) {
                if (addedObjects.length > 1) {
                  newTargetObject = _this7.getActiveSelectionFromObjects(addedObjects);
                } else {
                  var _addedObjects = _slicedToArray(addedObjects, 1);
                  newTargetObject = _addedObjects[0];
                }
                _this7.targetObjectForCopyPaste = newTargetObject;
                _this7.setActiveObject(newTargetObject);
              });
            }
          }, {
            key: "_cloneObject",
            value: function _cloneObject(targetObjects) {
              var _this8 = this;
              var addedObjects = map_default()(targetObjects).call(targetObjects, function(targetObject) {
                return _this8._cloneObjectItem(targetObject);
              });
              return promise_default().all(addedObjects);
            }
          }, {
            key: "_cloneObjectItem",
            value: function _cloneObjectItem(targetObject) {
              var _this9 = this;
              return this._copyFabricObjectForPaste(targetObject).then(function(clonedObject) {
                var objectProperties = _this9.createObjectProperties(clonedObject);
                _this9.add(clonedObject);
                _this9.fire(eventNames.ADD_OBJECT, objectProperties);
                return clonedObject;
              });
            }
          }, {
            key: "_copyFabricObjectForPaste",
            value: function _copyFabricObjectForPaste(targetObject) {
              var _this10 = this;
              var addExtraPx = function addExtraPx2(value, isReverse) {
                return isReverse ? value - EXTRA_PX_FOR_PASTE : value + EXTRA_PX_FOR_PASTE;
              };
              return this._copyFabricObject(targetObject).then(function(clonedObject) {
                var left = clonedObject.left, top = clonedObject.top, width = clonedObject.width, height = clonedObject.height;
                var _this10$getCanvasSize = _this10.getCanvasSize(), canvasWidth = _this10$getCanvasSize.width, canvasHeight = _this10$getCanvasSize.height;
                var rightEdge = left + width / 2;
                var bottomEdge = top + height / 2;
                clonedObject.set(extend_default()({
                  left: addExtraPx(left, rightEdge + EXTRA_PX_FOR_PASTE > canvasWidth),
                  top: addExtraPx(top, bottomEdge + EXTRA_PX_FOR_PASTE > canvasHeight)
                }, fObjectOptions.SELECTION_STYLE));
                return clonedObject;
              });
            }
          }, {
            key: "_copyFabricObject",
            value: function _copyFabricObject(targetObject) {
              var _this11 = this;
              return new (promise_default())(function(resolve) {
                targetObject.clone(function(cloned) {
                  var shapeComp = _this11.getComponent(componentNames.SHAPE);
                  if (isShape(cloned)) {
                    shapeComp.processForCopiedObject(cloned, targetObject);
                  }
                  resolve(cloned);
                });
              });
            }
          }, {
            key: "getCurrentDimensions",
            value: function getCurrentDimensions() {
              var resize2 = this.getComponent(componentNames.RESIZE);
              return resize2.getCurrentDimensions();
            }
          }, {
            key: "getOriginalDimensions",
            value: function getOriginalDimensions() {
              var resize2 = this.getComponent(componentNames.RESIZE);
              return resize2.getOriginalDimensions();
            }
          }, {
            key: "setOriginalDimensions",
            value: function setOriginalDimensions(dimensions) {
              var resize2 = this.getComponent(componentNames.RESIZE);
              resize2.setOriginalDimensions(dimensions);
            }
          }, {
            key: "resize",
            value: function resize2(dimensions) {
              var resize3 = this.getComponent(componentNames.RESIZE);
              return resize3.resize(dimensions);
            }
          }]);
          return Graphics2;
        }();
        customEvents_default().mixin(Graphics);
        var graphics = Graphics;
        var MOUSE_DOWN = eventNames.MOUSE_DOWN, OBJECT_MOVED = eventNames.OBJECT_MOVED, OBJECT_SCALED = eventNames.OBJECT_SCALED, OBJECT_ACTIVATED = eventNames.OBJECT_ACTIVATED, OBJECT_ROTATED = eventNames.OBJECT_ROTATED, OBJECT_ADDED = eventNames.OBJECT_ADDED, imageEditor_OBJECT_MODIFIED = eventNames.OBJECT_MODIFIED, imageEditor_ADD_TEXT = eventNames.ADD_TEXT, ADD_OBJECT = eventNames.ADD_OBJECT, imageEditor_TEXT_EDITING = eventNames.TEXT_EDITING, TEXT_CHANGED = eventNames.TEXT_CHANGED, ICON_CREATE_RESIZE = eventNames.ICON_CREATE_RESIZE, ICON_CREATE_END = eventNames.ICON_CREATE_END, SELECTION_CLEARED = eventNames.SELECTION_CLEARED, SELECTION_CREATED = eventNames.SELECTION_CREATED, ADD_OBJECT_AFTER = eventNames.ADD_OBJECT_AFTER;
        var ImageEditor2 = /* @__PURE__ */ function() {
          function ImageEditor3(wrapper, options) {
            var _context2, _context22, _context3, _context4, _context5, _context6, _context7, _context8, _context9, _context10, _context11, _context12, _context13, _context14, _context15, _context16;
            _classCallCheck(this, ImageEditor3);
            options = extend_default()({
              includeUI: false,
              usageStatistics: true
            }, options);
            this.mode = null;
            this.activeObjectId = null;
            if (options.includeUI) {
              var UIOption = options.includeUI;
              UIOption.usageStatistics = options.usageStatistics;
              this.ui = new ui(wrapper, UIOption, this.getActions());
              options = this.ui.setUiDefaultSelectionStyle(options);
            }
            this._invoker = new invoker();
            this._graphics = new graphics(this.ui ? this.ui.getEditorArea() : wrapper, {
              cssMaxWidth: options.cssMaxWidth,
              cssMaxHeight: options.cssMaxHeight
            });
            this._handlers = {
              keydown: bind_default()(_context2 = this._onKeyDown).call(_context2, this),
              mousedown: bind_default()(_context22 = this._onMouseDown).call(_context22, this),
              objectActivated: bind_default()(_context3 = this._onObjectActivated).call(_context3, this),
              objectMoved: bind_default()(_context4 = this._onObjectMoved).call(_context4, this),
              objectScaled: bind_default()(_context5 = this._onObjectScaled).call(_context5, this),
              objectRotated: bind_default()(_context6 = this._onObjectRotated).call(_context6, this),
              objectAdded: bind_default()(_context7 = this._onObjectAdded).call(_context7, this),
              objectModified: bind_default()(_context8 = this._onObjectModified).call(_context8, this),
              createdPath: this._onCreatedPath,
              addText: bind_default()(_context9 = this._onAddText).call(_context9, this),
              addObject: bind_default()(_context10 = this._onAddObject).call(_context10, this),
              textEditing: bind_default()(_context11 = this._onTextEditing).call(_context11, this),
              textChanged: bind_default()(_context12 = this._onTextChanged).call(_context12, this),
              iconCreateResize: bind_default()(_context13 = this._onIconCreateResize).call(_context13, this),
              iconCreateEnd: bind_default()(_context14 = this._onIconCreateEnd).call(_context14, this),
              selectionCleared: bind_default()(_context15 = this._selectionCleared).call(_context15, this),
              selectionCreated: bind_default()(_context16 = this._selectionCreated).call(_context16, this)
            };
            this._attachInvokerEvents();
            this._attachGraphicsEvents();
            this._attachDomEvents();
            this._setSelectionStyle(options.selectionStyle, {
              applyCropSelectionStyle: options.applyCropSelectionStyle,
              applyGroupSelectionStyle: options.applyGroupSelectionStyle
            });
            if (options.usageStatistics) {
              sendHostName();
            }
            if (this.ui) {
              this.ui.initCanvas();
              this.setReAction();
              this._attachColorPickerInputBoxEvents();
            }
            fabric.fabric.enableGLFiltering = false;
          }
          _createClass(ImageEditor3, [{
            key: "_attachColorPickerInputBoxEvents",
            value: function _attachColorPickerInputBoxEvents() {
              var _this = this;
              this.ui.on(eventNames.INPUT_BOX_EDITING_STARTED, function() {
                _this.isColorPickerInputBoxEditing = true;
              });
              this.ui.on(eventNames.INPUT_BOX_EDITING_STOPPED, function() {
                _this.isColorPickerInputBoxEditing = false;
              });
            }
          }, {
            key: "_detachColorPickerInputBoxEvents",
            value: function _detachColorPickerInputBoxEvents() {
              this.ui.off(eventNames.INPUT_BOX_EDITING_STARTED);
              this.ui.off(eventNames.INPUT_BOX_EDITING_STOPPED);
            }
          }, {
            key: "_setSelectionStyle",
            value: function _setSelectionStyle(selectionStyle, _ref) {
              var applyCropSelectionStyle = _ref.applyCropSelectionStyle, applyGroupSelectionStyle = _ref.applyGroupSelectionStyle;
              if (selectionStyle) {
                this._graphics.setSelectionStyle(selectionStyle);
              }
              if (applyCropSelectionStyle) {
                this._graphics.setCropSelectionStyle(selectionStyle);
              }
              if (applyGroupSelectionStyle) {
                this.on("selectionCreated", function(eventTarget) {
                  if (eventTarget.type === "activeSelection") {
                    eventTarget.set(selectionStyle);
                  }
                });
              }
            }
          }, {
            key: "_attachInvokerEvents",
            value: function _attachInvokerEvents() {
              var _context17, _context18, _this2 = this;
              var UNDO_STACK_CHANGED = eventNames.UNDO_STACK_CHANGED, REDO_STACK_CHANGED = eventNames.REDO_STACK_CHANGED, EXECUTE_COMMAND = eventNames.EXECUTE_COMMAND, AFTER_UNDO = eventNames.AFTER_UNDO, AFTER_REDO = eventNames.AFTER_REDO, HAND_STARTED2 = eventNames.HAND_STARTED, HAND_STOPPED2 = eventNames.HAND_STOPPED;
              this._invoker.on(UNDO_STACK_CHANGED, bind_default()(_context17 = this.fire).call(_context17, this, UNDO_STACK_CHANGED));
              this._invoker.on(REDO_STACK_CHANGED, bind_default()(_context18 = this.fire).call(_context18, this, REDO_STACK_CHANGED));
              if (this.ui) {
                var canvas = this._graphics.getCanvas();
                this._invoker.on(EXECUTE_COMMAND, function(command2) {
                  return _this2.ui.fire(EXECUTE_COMMAND, command2);
                });
                this._invoker.on(AFTER_UNDO, function(command2) {
                  return _this2.ui.fire(AFTER_UNDO, command2);
                });
                this._invoker.on(AFTER_REDO, function(command2) {
                  return _this2.ui.fire(AFTER_REDO, command2);
                });
                canvas.on(HAND_STARTED2, function() {
                  return _this2.ui.fire(HAND_STARTED2);
                });
                canvas.on(HAND_STOPPED2, function() {
                  return _this2.ui.fire(HAND_STOPPED2);
                });
              }
            }
          }, {
            key: "_attachGraphicsEvents",
            value: function _attachGraphicsEvents() {
              var _this$_graphics$on;
              this._graphics.on((_this$_graphics$on = {}, _defineProperty2(_this$_graphics$on, MOUSE_DOWN, this._handlers.mousedown), _defineProperty2(_this$_graphics$on, OBJECT_MOVED, this._handlers.objectMoved), _defineProperty2(_this$_graphics$on, OBJECT_SCALED, this._handlers.objectScaled), _defineProperty2(_this$_graphics$on, OBJECT_ROTATED, this._handlers.objectRotated), _defineProperty2(_this$_graphics$on, OBJECT_ACTIVATED, this._handlers.objectActivated), _defineProperty2(_this$_graphics$on, OBJECT_ADDED, this._handlers.objectAdded), _defineProperty2(_this$_graphics$on, imageEditor_OBJECT_MODIFIED, this._handlers.objectModified), _defineProperty2(_this$_graphics$on, imageEditor_ADD_TEXT, this._handlers.addText), _defineProperty2(_this$_graphics$on, ADD_OBJECT, this._handlers.addObject), _defineProperty2(_this$_graphics$on, imageEditor_TEXT_EDITING, this._handlers.textEditing), _defineProperty2(_this$_graphics$on, TEXT_CHANGED, this._handlers.textChanged), _defineProperty2(_this$_graphics$on, ICON_CREATE_RESIZE, this._handlers.iconCreateResize), _defineProperty2(_this$_graphics$on, ICON_CREATE_END, this._handlers.iconCreateEnd), _defineProperty2(_this$_graphics$on, SELECTION_CLEARED, this._handlers.selectionCleared), _defineProperty2(_this$_graphics$on, SELECTION_CREATED, this._handlers.selectionCreated), _this$_graphics$on));
            }
          }, {
            key: "_attachDomEvents",
            value: function _attachDomEvents() {
              document.addEventListener("keydown", this._handlers.keydown);
            }
          }, {
            key: "_detachDomEvents",
            value: function _detachDomEvents() {
              document.removeEventListener("keydown", this._handlers.keydown);
            }
          }, {
            key: "_onKeyDown",
            value: function _onKeyDown(e2) {
              var ctrlKey = e2.ctrlKey, keyCode = e2.keyCode, metaKey = e2.metaKey;
              var isModifierKey = ctrlKey || metaKey;
              if (isModifierKey) {
                if (keyCode === keyCodes.C) {
                  this._graphics.resetTargetObjectForCopyPaste();
                } else if (keyCode === keyCodes.V) {
                  this._graphics.pasteObject();
                  this.clearRedoStack();
                } else if (keyCode === keyCodes.Z) {
                  this.undo()["catch"](function() {
                  });
                } else if (keyCode === keyCodes.Y) {
                  this.redo()["catch"](function() {
                  });
                }
              }
              var isDeleteKey = keyCode === keyCodes.BACKSPACE || keyCode === keyCodes.DEL;
              var isRemoveReady = this._graphics.isReadyRemoveObject();
              if (!this.isColorPickerInputBoxEditing && isRemoveReady && isDeleteKey) {
                e2.preventDefault();
                this.removeActiveObject();
              }
            }
          }, {
            key: "removeActiveObject",
            value: function removeActiveObject() {
              var activeObjectId = this._graphics.getActiveObjectIdForRemove();
              this.removeObject(activeObjectId);
            }
          }, {
            key: "_onMouseDown",
            value: function _onMouseDown(event, originPointer) {
              this.fire(eventNames.MOUSE_DOWN, event, originPointer);
            }
          }, {
            key: "_pushAddObjectCommand",
            value: function _pushAddObjectCommand(obj) {
              var command2 = factory_command.create(commandNames.ADD_OBJECT, this._graphics, obj);
              this._invoker.pushUndoStack(command2);
            }
          }, {
            key: "_pushModifyObjectCommand",
            value: function _pushModifyObjectCommand(obj) {
              var _this3 = this;
              var type = obj.type;
              var props2 = makeSelectionUndoData(obj, function(item) {
                return makeSelectionUndoDatum(_this3._graphics.getObjectId(item), item, type === "activeSelection");
              });
              var command2 = factory_command.create(commandNames.CHANGE_SELECTION, this._graphics, props2);
              command2.execute(this._graphics, props2);
              this._invoker.pushUndoStack(command2);
            }
          }, {
            key: "_onObjectActivated",
            value: function _onObjectActivated(props2) {
              this.fire(eventNames.OBJECT_ACTIVATED, props2);
            }
          }, {
            key: "_onObjectMoved",
            value: function _onObjectMoved(props2) {
              this.fire(eventNames.OBJECT_MOVED, props2);
            }
          }, {
            key: "_onObjectScaled",
            value: function _onObjectScaled(props2) {
              this.fire(eventNames.OBJECT_SCALED, props2);
            }
          }, {
            key: "_onObjectRotated",
            value: function _onObjectRotated(props2) {
              this.fire(eventNames.OBJECT_ROTATED, props2);
            }
          }, {
            key: "getDrawingMode",
            value: function getDrawingMode() {
              return this._graphics.getDrawingMode();
            }
          }, {
            key: "clearObjects",
            value: function clearObjects() {
              return this.execute(commandNames.CLEAR_OBJECTS);
            }
          }, {
            key: "deactivateAll",
            value: function deactivateAll() {
              this._graphics.deactivateAll();
              this._graphics.renderAll();
            }
          }, {
            key: "discardSelection",
            value: function discardSelection() {
              this._graphics.discardSelection();
            }
          }, {
            key: "changeSelectableAll",
            value: function changeSelectableAll(selectable) {
              this._graphics.changeSelectableAll(selectable);
            }
          }, {
            key: "_initHistory",
            value: function _initHistory() {
              if (this.ui) {
                this.ui.initHistory();
              }
            }
          }, {
            key: "_clearHistory",
            value: function _clearHistory() {
              if (this.ui) {
                this.ui.clearHistory();
              }
            }
          }, {
            key: "execute",
            value: function execute(commandName) {
              var _context19, _this$_invoker, _context20;
              for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
                args[_key - 1] = arguments[_key];
              }
              var theArgs = concat_default()(_context19 = [this._graphics]).call(_context19, args);
              return (_this$_invoker = this._invoker).execute.apply(_this$_invoker, concat_default()(_context20 = [commandName]).call(_context20, _toConsumableArray(theArgs)));
            }
          }, {
            key: "executeSilent",
            value: function executeSilent(commandName) {
              var _context21, _this$_invoker2, _context22;
              for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
                args[_key2 - 1] = arguments[_key2];
              }
              var theArgs = concat_default()(_context21 = [this._graphics]).call(_context21, args);
              return (_this$_invoker2 = this._invoker).executeSilent.apply(_this$_invoker2, concat_default()(_context22 = [commandName]).call(_context22, _toConsumableArray(theArgs)));
            }
          }, {
            key: "undo",
            value: function undo2() {
              var _this4 = this;
              var iterationCount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
              var promise = promise_default().resolve();
              for (var i = 0; i < iterationCount; i += 1) {
                promise = promise.then(function() {
                  return _this4._invoker.undo();
                });
              }
              return promise;
            }
          }, {
            key: "redo",
            value: function redo() {
              var _this5 = this;
              var iterationCount = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 1;
              var promise = promise_default().resolve();
              for (var i = 0; i < iterationCount; i += 1) {
                promise = promise.then(function() {
                  return _this5._invoker.redo();
                });
              }
              return promise;
            }
          }, {
            key: "zoom",
            value: function zoom2(_ref2) {
              var x = _ref2.x, y = _ref2.y, zoomLevel = _ref2.zoomLevel;
              this._graphics.zoom({
                x,
                y
              }, zoomLevel);
            }
          }, {
            key: "resetZoom",
            value: function resetZoom() {
              this._graphics.resetZoom();
            }
          }, {
            key: "loadImageFromFile",
            value: function loadImageFromFile(imgFile, imageName) {
              if (!imgFile) {
                return promise_default().reject(rejectMessages.invalidParameters);
              }
              var imgUrl = url_default().createObjectURL(imgFile);
              imageName = imageName || imgFile.name;
              return this.loadImageFromURL(imgUrl, imageName).then(function(value) {
                url_default().revokeObjectURL(imgFile);
                return value;
              });
            }
          }, {
            key: "loadImageFromURL",
            value: function loadImageFromURL(url2, imageName) {
              if (!imageName || !url2) {
                return promise_default().reject(rejectMessages.invalidParameters);
              }
              return this.execute(commandNames.LOAD_IMAGE, imageName, url2);
            }
          }, {
            key: "addImageObject",
            value: function addImageObject(imgUrl) {
              if (!imgUrl) {
                return promise_default().reject(rejectMessages.invalidParameters);
              }
              return this.execute(commandNames.ADD_IMAGE_OBJECT, imgUrl);
            }
          }, {
            key: "startDrawingMode",
            value: function startDrawingMode(mode, option2) {
              return this._graphics.startDrawingMode(mode, option2);
            }
          }, {
            key: "stopDrawingMode",
            value: function stopDrawingMode() {
              this._graphics.stopDrawingMode();
            }
          }, {
            key: "crop",
            value: function crop2(rect) {
              var data = this._graphics.getCroppedImageData(rect);
              if (!data) {
                return promise_default().reject(rejectMessages.invalidParameters);
              }
              return this.loadImageFromURL(data.url, data.imageName);
            }
          }, {
            key: "getCropzoneRect",
            value: function getCropzoneRect() {
              return this._graphics.getCropzoneRect();
            }
          }, {
            key: "setCropzoneRect",
            value: function setCropzoneRect(mode) {
              this._graphics.setCropzoneRect(mode);
            }
          }, {
            key: "_flip",
            value: function _flip(type) {
              return this.execute(commandNames.FLIP_IMAGE, type);
            }
          }, {
            key: "flipX",
            value: function flipX() {
              return this._flip("flipX");
            }
          }, {
            key: "flipY",
            value: function flipY() {
              return this._flip("flipY");
            }
          }, {
            key: "resetFlip",
            value: function resetFlip() {
              return this._flip("reset");
            }
          }, {
            key: "_rotate",
            value: function _rotate(type, angle2, isSilent) {
              var result = null;
              if (isSilent) {
                result = this.executeSilent(commandNames.ROTATE_IMAGE, type, angle2);
              } else {
                result = this.execute(commandNames.ROTATE_IMAGE, type, angle2);
              }
              return result;
            }
          }, {
            key: "rotate",
            value: function rotate3(angle2, isSilent) {
              return this._rotate("rotate", angle2, isSilent);
            }
          }, {
            key: "setAngle",
            value: function setAngle(angle2, isSilent) {
              return this._rotate("setAngle", angle2, isSilent);
            }
          }, {
            key: "setBrush",
            value: function setBrush(option2) {
              this._graphics.setBrush(option2);
            }
          }, {
            key: "setDrawingShape",
            value: function setDrawingShape(type, options) {
              this._graphics.setDrawingShape(type, options);
            }
          }, {
            key: "setDrawingIcon",
            value: function setDrawingIcon(type, iconColor) {
              this._graphics.setIconStyle(type, iconColor);
            }
          }, {
            key: "addShape",
            value: function addShape(type, options) {
              options = options || {};
              this._setPositions(options);
              return this.execute(commandNames.ADD_SHAPE, type, options);
            }
          }, {
            key: "changeShape",
            value: function changeShape(id, options, isSilent) {
              var executeMethodName = isSilent ? "executeSilent" : "execute";
              return this[executeMethodName](commandNames.CHANGE_SHAPE, id, options);
            }
          }, {
            key: "addText",
            value: function addText(text, options) {
              text = text || "";
              options = options || {};
              return this.execute(commandNames.ADD_TEXT, text, options);
            }
          }, {
            key: "changeText",
            value: function changeText(id, text) {
              text = text || "";
              return this.execute(commandNames.CHANGE_TEXT, id, text);
            }
          }, {
            key: "changeTextStyle",
            value: function changeTextStyle(id, styleObj, isSilent) {
              var executeMethodName = isSilent ? "executeSilent" : "execute";
              return this[executeMethodName](commandNames.CHANGE_TEXT_STYLE, id, styleObj);
            }
          }, {
            key: "_changeActivateMode",
            value: function _changeActivateMode(type) {
              if (type !== "ICON" && this.getDrawingMode() !== type) {
                this.startDrawingMode(type);
              }
            }
          }, {
            key: "_onTextChanged",
            value: function _onTextChanged(target) {
              this.fire(eventNames.TEXT_CHANGED, target);
            }
          }, {
            key: "_onIconCreateResize",
            value: function _onIconCreateResize(originPointer) {
              this.fire(eventNames.ICON_CREATE_RESIZE, originPointer);
            }
          }, {
            key: "_onIconCreateEnd",
            value: function _onIconCreateEnd(originPointer) {
              this.fire(eventNames.ICON_CREATE_END, originPointer);
            }
          }, {
            key: "_onTextEditing",
            value: function _onTextEditing() {
              this.fire(eventNames.TEXT_EDITING);
            }
          }, {
            key: "_onAddText",
            value: function _onAddText(event) {
              this.fire(eventNames.ADD_TEXT, {
                originPosition: event.originPosition,
                clientPosition: event.clientPosition
              });
            }
          }, {
            key: "_onAddObject",
            value: function _onAddObject(objectProps) {
              var obj = this._graphics.getObject(objectProps.id);
              this._invoker.fire(eventNames.EXECUTE_COMMAND, getObjectType(obj.type));
              this._pushAddObjectCommand(obj);
            }
          }, {
            key: "_onObjectAdded",
            value: function _onObjectAdded(objectProps) {
              this.fire(OBJECT_ADDED, objectProps);
              this.fire(ADD_OBJECT_AFTER, objectProps);
            }
          }, {
            key: "_onObjectModified",
            value: function _onObjectModified(obj) {
              if (obj.type !== OBJ_TYPE.CROPZONE) {
                this._invoker.fire(eventNames.EXECUTE_COMMAND, getObjectType(obj.type));
                this._pushModifyObjectCommand(obj);
              }
            }
          }, {
            key: "_selectionCleared",
            value: function _selectionCleared() {
              this.fire(SELECTION_CLEARED);
            }
          }, {
            key: "_selectionCreated",
            value: function _selectionCreated(eventTarget) {
              this.fire(SELECTION_CREATED, eventTarget);
            }
          }, {
            key: "registerIcons",
            value: function registerIcons(infos) {
              this._graphics.registerPaths(infos);
            }
          }, {
            key: "changeCursor",
            value: function changeCursor(cursorType) {
              this._graphics.changeCursor(cursorType);
            }
          }, {
            key: "addIcon",
            value: function addIcon(type, options) {
              options = options || {};
              this._setPositions(options);
              return this.execute(commandNames.ADD_ICON, type, options);
            }
          }, {
            key: "changeIconColor",
            value: function changeIconColor(id, color2) {
              return this.execute(commandNames.CHANGE_ICON_COLOR, id, color2);
            }
          }, {
            key: "removeObject",
            value: function removeObject(id) {
              var _this$_graphics$getOb = this._graphics.getObject(id), type = _this$_graphics$getOb.type;
              return this.execute(commandNames.REMOVE_OBJECT, id, getObjectType(type));
            }
          }, {
            key: "hasFilter",
            value: function hasFilter(type) {
              return this._graphics.hasFilter(type);
            }
          }, {
            key: "removeFilter",
            value: function removeFilter(type) {
              return this.execute(commandNames.REMOVE_FILTER, type);
            }
          }, {
            key: "applyFilter",
            value: function applyFilter(type, options, isSilent) {
              var executeMethodName = isSilent ? "executeSilent" : "execute";
              return this[executeMethodName](commandNames.APPLY_FILTER, type, options);
            }
          }, {
            key: "toDataURL",
            value: function toDataURL(options) {
              return this._graphics.toDataURL(options);
            }
          }, {
            key: "getImageName",
            value: function getImageName() {
              return this._graphics.getImageName();
            }
          }, {
            key: "clearUndoStack",
            value: function clearUndoStack() {
              this._invoker.clearUndoStack();
            }
          }, {
            key: "clearRedoStack",
            value: function clearRedoStack() {
              this._invoker.clearRedoStack();
            }
          }, {
            key: "isEmptyUndoStack",
            value: function isEmptyUndoStack() {
              return this._invoker.isEmptyUndoStack();
            }
          }, {
            key: "isEmptyRedoStack",
            value: function isEmptyRedoStack() {
              return this._invoker.isEmptyRedoStack();
            }
          }, {
            key: "resizeCanvasDimension",
            value: function resizeCanvasDimension(dimension) {
              if (!dimension) {
                return promise_default().reject(rejectMessages.invalidParameters);
              }
              return this.execute(commandNames.RESIZE_CANVAS_DIMENSION, dimension);
            }
          }, {
            key: "destroy",
            value: function destroy2() {
              var _this6 = this;
              this.stopDrawingMode();
              this._detachDomEvents();
              this._graphics.destroy();
              this._graphics = null;
              if (this.ui) {
                this._detachColorPickerInputBoxEvents();
                this.ui.destroy();
              }
              forEach_default()(this, function(value, key) {
                _this6[key] = null;
              }, this);
            }
          }, {
            key: "_setPositions",
            value: function _setPositions(options) {
              var centerPosition = this._graphics.getCenter();
              if (isUndefined_default()(options.left)) {
                options.left = centerPosition.left;
              }
              if (isUndefined_default()(options.top)) {
                options.top = centerPosition.top;
              }
            }
          }, {
            key: "setObjectProperties",
            value: function setObjectProperties(id, keyValue) {
              return this.execute(commandNames.SET_OBJECT_PROPERTIES, id, keyValue);
            }
          }, {
            key: "setObjectPropertiesQuietly",
            value: function setObjectPropertiesQuietly(id, keyValue) {
              this._graphics.setObjectProperties(id, keyValue);
            }
          }, {
            key: "getObjectProperties",
            value: function getObjectProperties(id, keys3) {
              var object = this._graphics.getObject(id);
              if (!object) {
                return null;
              }
              return this._graphics.getObjectProperties(id, keys3);
            }
          }, {
            key: "getCanvasSize",
            value: function getCanvasSize() {
              return this._graphics.getCanvasSize();
            }
          }, {
            key: "getObjectPosition",
            value: function getObjectPosition(id, originX, originY) {
              return this._graphics.getObjectPosition(id, originX, originY);
            }
          }, {
            key: "setObjectPosition",
            value: function setObjectPosition(id, posInfo) {
              return this.execute(commandNames.SET_OBJECT_POSITION, id, posInfo);
            }
          }, {
            key: "resize",
            value: function resize2(dimensions) {
              return this.execute(commandNames.RESIZE_IMAGE, dimensions);
            }
          }]);
          return ImageEditor3;
        }();
        action.mixin(ImageEditor2);
        customEvents_default().mixin(ImageEditor2);
        var imageEditor = ImageEditor2;
        var ICON = componentNames.ICON;
        var addIcon_command = {
          name: commandNames.ADD_ICON,
          execute: function execute(graphics2, type, options) {
            var _this = this;
            var iconComp = graphics2.getComponent(ICON);
            return iconComp.add(type, options).then(function(objectProps) {
              _this.undoData.object = graphics2.getObject(objectProps.id);
              return objectProps;
            });
          },
          undo: function undo2(graphics2) {
            graphics2.remove(this.undoData.object);
            return promise_default().resolve();
          }
        };
        factory_command.register(addIcon_command);
        var addImageObject_command = {
          name: commandNames.ADD_IMAGE_OBJECT,
          execute: function execute(graphics2, imgUrl) {
            var _this = this;
            return graphics2.addImageObject(imgUrl).then(function(objectProps) {
              _this.undoData.object = graphics2.getObject(objectProps.id);
              return objectProps;
            });
          },
          undo: function undo2(graphics2) {
            graphics2.remove(this.undoData.object);
            return promise_default().resolve();
          }
        };
        factory_command.register(addImageObject_command);
        var addObject_command = {
          name: commandNames.ADD_OBJECT,
          execute: function execute(graphics2, object) {
            return new (promise_default())(function(resolve, reject) {
              if (!graphics2.contains(object)) {
                graphics2.add(object);
                resolve(object);
              } else {
                reject(rejectMessages.addedObject);
              }
            });
          },
          undo: function undo2(graphics2, object) {
            return new (promise_default())(function(resolve, reject) {
              if (graphics2.contains(object)) {
                graphics2.remove(object);
                resolve(object);
              } else {
                reject(rejectMessages.noObject);
              }
            });
          }
        };
        factory_command.register(addObject_command);
        var SHAPE = componentNames.SHAPE;
        var addShape_command = {
          name: commandNames.ADD_SHAPE,
          execute: function execute(graphics2, type, options) {
            var _this = this;
            var shapeComp = graphics2.getComponent(SHAPE);
            return shapeComp.add(type, options).then(function(objectProps) {
              var id = objectProps.id;
              _this.undoData.object = graphics2.getObject(id);
              return objectProps;
            });
          },
          undo: function undo2(graphics2) {
            graphics2.remove(this.undoData.object);
            return promise_default().resolve();
          }
        };
        factory_command.register(addShape_command);
        var TEXT = componentNames.TEXT;
        var addText_command = {
          name: commandNames.ADD_TEXT,
          execute: function execute(graphics2, text, options) {
            var _this = this;
            var textComp = graphics2.getComponent(TEXT);
            if (this.undoData.object) {
              var undoObject = this.undoData.object;
              return new (promise_default())(function(resolve, reject) {
                if (!graphics2.contains(undoObject)) {
                  graphics2.add(undoObject);
                  resolve(undoObject);
                } else {
                  reject(rejectMessages.redo);
                }
              });
            }
            return textComp.add(text, options).then(function(objectProps) {
              var id = objectProps.id;
              var textObject = graphics2.getObject(id);
              _this.undoData.object = textObject;
              setCachedUndoDataForDimension(makeSelectionUndoData(textObject, function() {
                return makeSelectionUndoDatum(id, textObject, false);
              }));
              return objectProps;
            });
          },
          undo: function undo2(graphics2) {
            graphics2.remove(this.undoData.object);
            return promise_default().resolve();
          }
        };
        factory_command.register(addText_command);
        var FILTER2 = componentNames.FILTER;
        var cachedUndoDataForSilent = null;
        function makeUndoData(type, prevfilterOption, options) {
          var undoData = {};
          if (type === "mask") {
            undoData.object = options.mask;
          }
          undoData.options = prevfilterOption;
          return undoData;
        }
        var applyFilter_command = {
          name: commandNames.APPLY_FILTER,
          execute: function execute(graphics2, type, options, isSilent) {
            var filterComp = graphics2.getComponent(FILTER2);
            if (type === "mask") {
              var maskObj = graphics2.getObject(options.maskObjId);
              if (!(maskObj && maskObj.isType("image"))) {
                return promise_default().reject(rejectMessages.invalidParameters);
              }
              extend_default()(options, {
                mask: maskObj
              });
              graphics2.remove(options.mask);
            }
            if (!this.isRedo) {
              var prevfilterOption = filterComp.getOptions(type);
              var undoData = makeUndoData(type, prevfilterOption, options);
              cachedUndoDataForSilent = this.setUndoData(undoData, cachedUndoDataForSilent, isSilent);
            }
            return filterComp.add(type, options);
          },
          undo: function undo2(graphics2, type) {
            var filterComp = graphics2.getComponent(FILTER2);
            if (type === "mask") {
              var mask2 = this.undoData.object;
              graphics2.add(mask2);
              graphics2.setActiveObject(mask2);
              return filterComp.remove(type);
            }
            if (this.undoData.options) {
              return filterComp.add(type, this.undoData.options);
            }
            return filterComp.remove(type);
          }
        };
        factory_command.register(applyFilter_command);
        var changeIconColor_ICON = componentNames.ICON;
        var changeIconColor_command = {
          name: commandNames.CHANGE_ICON_COLOR,
          execute: function execute(graphics2, id, color2) {
            var _this = this;
            return new (promise_default())(function(resolve, reject) {
              var iconComp = graphics2.getComponent(changeIconColor_ICON);
              var targetObj = graphics2.getObject(id);
              if (!targetObj) {
                reject(rejectMessages.noObject);
              }
              _this.undoData.object = targetObj;
              _this.undoData.color = iconComp.getColor(targetObj);
              iconComp.setColor(color2, targetObj);
              resolve();
            });
          },
          undo: function undo2(graphics2) {
            var iconComp = graphics2.getComponent(changeIconColor_ICON);
            var _this$undoData = this.undoData, icon2 = _this$undoData.object, color2 = _this$undoData.color;
            iconComp.setColor(color2, icon2);
            return promise_default().resolve();
          }
        };
        factory_command.register(changeIconColor_command);
        var changeShape_SHAPE = componentNames.SHAPE;
        var changeShape_cachedUndoDataForSilent = null;
        function changeShape_makeUndoData(options, targetObj) {
          var undoData = {
            object: targetObj,
            options: {}
          };
          forEachOwnProperties_default()(options, function(value, key) {
            undoData.options[key] = targetObj[key];
          });
          return undoData;
        }
        var changeShape_command = {
          name: commandNames.CHANGE_SHAPE,
          execute: function execute(graphics2, id, options, isSilent) {
            var shapeComp = graphics2.getComponent(changeShape_SHAPE);
            var targetObj = graphics2.getObject(id);
            if (!targetObj) {
              return promise_default().reject(rejectMessages.noObject);
            }
            if (!this.isRedo) {
              var undoData = changeShape_makeUndoData(options, targetObj);
              changeShape_cachedUndoDataForSilent = this.setUndoData(undoData, changeShape_cachedUndoDataForSilent, isSilent);
            }
            return shapeComp.change(targetObj, options);
          },
          undo: function undo2(graphics2) {
            var shapeComp = graphics2.getComponent(changeShape_SHAPE);
            var _this$undoData = this.undoData, shape2 = _this$undoData.object, options = _this$undoData.options;
            return shapeComp.change(shape2, options);
          }
        };
        factory_command.register(changeShape_command);
        var changeText_TEXT = componentNames.TEXT;
        var changeText_command = {
          name: commandNames.CHANGE_TEXT,
          execute: function execute(graphics2, id, text) {
            var textComp = graphics2.getComponent(changeText_TEXT);
            var targetObj = graphics2.getObject(id);
            if (!targetObj) {
              return promise_default().reject(rejectMessages.noObject);
            }
            this.undoData.object = targetObj;
            this.undoData.text = textComp.getText(targetObj);
            return textComp.change(targetObj, text);
          },
          undo: function undo2(graphics2) {
            var textComp = graphics2.getComponent(changeText_TEXT);
            var _this$undoData = this.undoData, textObj = _this$undoData.object, text = _this$undoData.text;
            return textComp.change(textObj, text);
          }
        };
        factory_command.register(changeText_command);
        var changeTextStyle_TEXT = componentNames.TEXT;
        var changeTextStyle_cachedUndoDataForSilent = null;
        function changeTextStyle_makeUndoData(styles, targetObj) {
          var undoData = {
            object: targetObj,
            styles: {}
          };
          forEachOwnProperties_default()(styles, function(value, key) {
            var undoValue = targetObj[key];
            undoData.styles[key] = undoValue;
          });
          return undoData;
        }
        var changeTextStyle_command = {
          name: commandNames.CHANGE_TEXT_STYLE,
          execute: function execute(graphics2, id, styles, isSilent) {
            var textComp = graphics2.getComponent(changeTextStyle_TEXT);
            var targetObj = graphics2.getObject(id);
            if (!targetObj) {
              return promise_default().reject(rejectMessages.noObject);
            }
            if (!this.isRedo) {
              var undoData = changeTextStyle_makeUndoData(styles, targetObj);
              changeTextStyle_cachedUndoDataForSilent = this.setUndoData(undoData, changeTextStyle_cachedUndoDataForSilent, isSilent);
            }
            return textComp.setStyle(targetObj, styles);
          },
          undo: function undo2(graphics2) {
            var textComp = graphics2.getComponent(changeTextStyle_TEXT);
            var _this$undoData = this.undoData, textObj = _this$undoData.object, styles = _this$undoData.styles;
            return textComp.setStyle(textObj, styles);
          }
        };
        factory_command.register(changeTextStyle_command);
        var clearObjects_command = {
          name: commandNames.CLEAR_OBJECTS,
          execute: function execute(graphics2) {
            var _this = this;
            return new (promise_default())(function(resolve) {
              _this.undoData.objects = graphics2.removeAll();
              resolve();
            });
          },
          undo: function undo2(graphics2) {
            graphics2.add(this.undoData.objects);
            return promise_default().resolve();
          }
        };
        factory_command.register(clearObjects_command);
        var FLIP = componentNames.FLIP;
        var flip_command = {
          name: commandNames.FLIP_IMAGE,
          execute: function execute(graphics2, type) {
            var flipComp = graphics2.getComponent(FLIP);
            this.undoData.setting = flipComp.getCurrentSetting();
            return flipComp[type]();
          },
          undo: function undo2(graphics2) {
            var flipComp = graphics2.getComponent(FLIP);
            return flipComp.set(this.undoData.setting);
          }
        };
        factory_command.register(flip_command);
        var IMAGE_LOADER = componentNames.IMAGE_LOADER;
        var loadImage_command = {
          name: commandNames.LOAD_IMAGE,
          execute: function execute(graphics2, imageName, imgUrl) {
            var _context2;
            var loader = graphics2.getComponent(IMAGE_LOADER);
            var prevImage = loader.getCanvasImage();
            var prevImageWidth = prevImage ? prevImage.width : 0;
            var prevImageHeight = prevImage ? prevImage.height : 0;
            var objects = filter_default()(_context2 = graphics2.removeAll(true)).call(_context2, function(objectItem) {
              return objectItem.type !== "cropzone";
            });
            for_each_default()(objects).call(objects, function(objectItem) {
              objectItem.evented = true;
            });
            this.undoData = {
              name: loader.getImageName(),
              image: prevImage,
              objects
            };
            return loader.load(imageName, imgUrl).then(function(newImage) {
              return {
                oldWidth: prevImageWidth,
                oldHeight: prevImageHeight,
                newWidth: newImage.width,
                newHeight: newImage.height
              };
            });
          },
          undo: function undo2(graphics2) {
            var loader = graphics2.getComponent(IMAGE_LOADER);
            var _this$undoData = this.undoData, objects = _this$undoData.objects, name2 = _this$undoData.name, image2 = _this$undoData.image;
            graphics2.removeAll(true);
            graphics2.add(objects);
            return loader.load(name2, image2);
          }
        };
        factory_command.register(loadImage_command);
        var removeFilter_FILTER = componentNames.FILTER;
        var removeFilter_command = {
          name: commandNames.REMOVE_FILTER,
          execute: function execute(graphics2, type) {
            var filterComp = graphics2.getComponent(removeFilter_FILTER);
            this.undoData.options = filterComp.getOptions(type);
            return filterComp.remove(type);
          },
          undo: function undo2(graphics2, type) {
            var filterComp = graphics2.getComponent(removeFilter_FILTER);
            var options = this.undoData.options;
            return filterComp.add(type, options);
          }
        };
        factory_command.register(removeFilter_command);
        var removeObject_command = {
          name: commandNames.REMOVE_OBJECT,
          execute: function execute(graphics2, id) {
            var _this = this;
            return new (promise_default())(function(resolve, reject) {
              _this.undoData.objects = graphics2.removeObjectById(id);
              if (_this.undoData.objects.length) {
                resolve();
              } else {
                reject(rejectMessages.noObject);
              }
            });
          },
          undo: function undo2(graphics2) {
            graphics2.add(this.undoData.objects);
            return promise_default().resolve();
          }
        };
        factory_command.register(removeObject_command);
        var resizeCanvasDimension_command = {
          name: commandNames.RESIZE_CANVAS_DIMENSION,
          execute: function execute(graphics2, dimension) {
            var _this = this;
            return new (promise_default())(function(resolve) {
              _this.undoData.size = {
                width: graphics2.cssMaxWidth,
                height: graphics2.cssMaxHeight
              };
              graphics2.setCssMaxDimension(dimension);
              graphics2.adjustCanvasDimension();
              resolve();
            });
          },
          undo: function undo2(graphics2) {
            graphics2.setCssMaxDimension(this.undoData.size);
            graphics2.adjustCanvasDimension();
            return promise_default().resolve();
          }
        };
        factory_command.register(resizeCanvasDimension_command);
        var ROTATION = componentNames.ROTATION;
        var rotate_cachedUndoDataForSilent = null;
        function rotate_makeUndoData(rotationComp) {
          return {
            angle: rotationComp.getCurrentAngle()
          };
        }
        var rotate_command = {
          name: commandNames.ROTATE_IMAGE,
          execute: function execute(graphics2, type, angle2, isSilent) {
            var rotationComp = graphics2.getComponent(ROTATION);
            if (!this.isRedo) {
              var undoData = rotate_makeUndoData(rotationComp);
              rotate_cachedUndoDataForSilent = this.setUndoData(undoData, rotate_cachedUndoDataForSilent, isSilent);
            }
            return rotationComp[type](angle2);
          },
          undo: function undo2(graphics2) {
            var rotationComp = graphics2.getComponent(ROTATION);
            var _this$args = _slicedToArray(this.args, 3), type = _this$args[1], angle2 = _this$args[2];
            if (type === "setAngle") {
              return rotationComp[type](this.undoData.angle);
            }
            return rotationComp.rotate(-angle2);
          }
        };
        factory_command.register(rotate_command);
        var setObjectProperties_command = {
          name: commandNames.SET_OBJECT_PROPERTIES,
          execute: function execute(graphics2, id, props2) {
            var _this = this;
            var targetObj = graphics2.getObject(id);
            if (!targetObj) {
              return promise_default().reject(rejectMessages.noObject);
            }
            this.undoData.props = {};
            forEachOwnProperties_default()(props2, function(value, key) {
              _this.undoData.props[key] = targetObj[key];
            });
            graphics2.setObjectProperties(id, props2);
            return promise_default().resolve();
          },
          undo: function undo2(graphics2, id) {
            var props2 = this.undoData.props;
            graphics2.setObjectProperties(id, props2);
            return promise_default().resolve();
          }
        };
        factory_command.register(setObjectProperties_command);
        var setObjectPosition_command = {
          name: commandNames.SET_OBJECT_POSITION,
          execute: function execute(graphics2, id, posInfo) {
            var targetObj = graphics2.getObject(id);
            if (!targetObj) {
              return promise_default().reject(rejectMessages.noObject);
            }
            this.undoData.objectId = id;
            this.undoData.props = graphics2.getObjectProperties(id, ["left", "top"]);
            graphics2.setObjectPosition(id, posInfo);
            graphics2.renderAll();
            return promise_default().resolve();
          },
          undo: function undo2(graphics2) {
            var _this$undoData = this.undoData, objectId = _this$undoData.objectId, props2 = _this$undoData.props;
            graphics2.setObjectProperties(objectId, props2);
            graphics2.renderAll();
            return promise_default().resolve();
          }
        };
        factory_command.register(setObjectPosition_command);
        var changeSelection_command = {
          name: commandNames.CHANGE_SELECTION,
          execute: function execute(graphics2, props2) {
            if (this.isRedo) {
              for_each_default()(props2).call(props2, function(prop) {
                graphics2.setObjectProperties(prop.id, prop);
              });
            } else {
              this.undoData = getCachedUndoDataForDimension();
            }
            return promise_default().resolve();
          },
          undo: function undo2(graphics2) {
            var _context2;
            for_each_default()(_context2 = this.undoData).call(_context2, function(datum) {
              graphics2.setObjectProperties(datum.id, datum);
            });
            return promise_default().resolve();
          }
        };
        factory_command.register(changeSelection_command);
        var RESIZE = componentNames.RESIZE;
        var resize_command = {
          name: commandNames.RESIZE_IMAGE,
          execute: function execute(graphics2, dimensions) {
            var resizeComp = graphics2.getComponent(RESIZE);
            var originalDimensions = resizeComp.getOriginalDimensions();
            if (!originalDimensions) {
              originalDimensions = resizeComp.getCurrentDimensions();
            }
            this.undoData.dimensions = originalDimensions;
            return resizeComp.resize(dimensions);
          },
          undo: function undo2(graphics2) {
            var resizeComp = graphics2.getComponent(RESIZE);
            return resizeComp.resize(this.undoData.dimensions);
          }
        };
        factory_command.register(resize_command);
        var src = imageEditor;
      }();
      __webpack_exports__ = __webpack_exports__["default"];
      return __webpack_exports__;
    }();
  });
})(tuiImageEditor);
var ImageEditor = /* @__PURE__ */ getDefaultExportFromCjs(tuiImageEditor.exports);
var locale_zh = {
  ZoomIn: "\u653E\u5927",
  ZoomOut: "\u7F29\u5C0F",
  Hand: "\u624B\u638C",
  History: "\u5386\u53F2",
  Resize: "\u8C03\u6574\u5BBD\u9AD8",
  Crop: "\u88C1\u526A",
  DeleteAll: "\u5168\u90E8\u5220\u9664",
  Delete: "\u5220\u9664",
  Undo: "\u64A4\u9500",
  Redo: "\u53CD\u64A4\u9500",
  Reset: "\u91CD\u7F6E",
  Flip: "\u955C\u50CF",
  Rotate: "\u65CB\u8F6C",
  Draw: "\u753B",
  Shape: "\u5F62\u72B6\u6807\u6CE8",
  Icon: "\u56FE\u6807\u6807\u6CE8",
  Text: "\u6587\u5B57\u6807\u6CE8",
  Mask: "\u906E\u7F69",
  Filter: "\u6EE4\u955C",
  Bold: "\u52A0\u7C97",
  Italic: "\u659C\u4F53",
  Underline: "\u4E0B\u5212\u7EBF",
  Left: "\u5DE6\u5BF9\u9F50",
  Center: "\u5C45\u4E2D",
  Right: "\u53F3\u5BF9\u9F50",
  Color: "\u989C\u8272",
  "Text size": "\u5B57\u4F53\u5927\u5C0F",
  Custom: "\u81EA\u5B9A\u4E49",
  Square: "\u6B63\u65B9\u5F62",
  Apply: "\u5E94\u7528",
  Cancel: "\u53D6\u6D88",
  "Flip X": "X \u8F74",
  "Flip Y": "Y \u8F74",
  Range: "\u533A\u95F4",
  Stroke: "\u63CF\u8FB9",
  Fill: "\u586B\u5145",
  Circle: "\u5706",
  Triangle: "\u4E09\u89D2",
  Rectangle: "\u77E9\u5F62",
  Free: "\u66F2\u7EBF",
  Straight: "\u76F4\u7EBF",
  Arrow: "\u7BAD\u5934",
  "Arrow-2": "\u7BAD\u59342",
  "Arrow-3": "\u7BAD\u59343",
  "Star-1": "\u661F\u661F1",
  "Star-2": "\u661F\u661F2",
  Polygon: "\u591A\u8FB9\u5F62",
  Location: "\u5B9A\u4F4D",
  Heart: "\u5FC3\u5F62",
  Bubble: "\u6C14\u6CE1",
  "Custom icon": "\u81EA\u5B9A\u4E49\u56FE\u6807",
  "Load Mask Image": "\u52A0\u8F7D\u8499\u5C42\u56FE\u7247",
  Grayscale: "\u7070\u5EA6",
  Blur: "\u6A21\u7CCA",
  Sharpen: "\u9510\u5316",
  Emboss: "\u6D6E\u96D5",
  "Remove White": "\u9664\u53BB\u767D\u8272",
  Distance: "\u8DDD\u79BB",
  Brightness: "\u4EAE\u5EA6",
  Noise: "\u566A\u97F3",
  "Color Filter": "\u5F69\u8272\u6EE4\u955C",
  Sepia: "\u68D5\u8272",
  Sepia2: "\u68D5\u82722",
  Invert: "\u8D1F\u7247",
  Pixelate: "\u50CF\u7D20\u5316",
  Threshold: "\u9608\u503C",
  Tint: "\u8272\u8C03",
  Multiply: "\u6B63\u7247\u53E0\u5E95",
  Blend: "\u6DF7\u5408\u8272",
  Width: "\u5BBD\u5EA6",
  Height: "\u9AD8\u5EA6",
  "Lock Aspect Ratio": "\u9501\u5B9A\u5BBD\u9AD8\u6BD4\u4F8B"
};
var EditImg_vue_vue_type_style_index_0_lang = "";
const _hoisted_1$a = /* @__PURE__ */ createElementVNode("div", { id: "tui-image-editor" }, null, -1);
const _sfc_main$c = defineComponent({
  __name: "EditImg",
  setup(__props) {
    const instance = ref$1(null);
    const visible = computed$1(() => erpStore.state.editImgVisible);
    const index2 = computed$1(() => erpStore.state.imgIndex);
    const imgs = computed$1(() => erpStore.state.imgs);
    const init2 = () => {
      const timer = setInterval(() => {
        const dom = document.querySelector("#tui-image-editor");
        if (dom) {
          clearInterval(timer);
          instance.value = new ImageEditor(dom, {
            includeUI: {
              loadImage: {
                path: imgs.value[index2.value],
                name: "image"
              },
              initMenu: "draw",
              menuBarPosition: "bottom",
              locale: locale_zh
            },
            cssMaxWidth: 1e3,
            cssMaxHeight: 600
          });
        }
      }, 50);
    };
    const onOk = () => {
      const t = instance.value.toDataURL();
      const _imgs = [...imgs.value];
      _imgs[index2.value] = t;
      erpStore.commit("setImg", _imgs);
      console.log(_imgs);
      erpStore.commit("setEditImgVisible", false);
    };
    watch(visible, (val) => {
      if (val) {
        init2();
      }
    });
    return (_ctx, _cache) => {
      const _component_el_button = resolveComponent("el-button");
      const _component_el_dialog = resolveComponent("el-dialog");
      return openBlock(), createBlock(_component_el_dialog, {
        modelValue: visible.value,
        "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => visible.value = $event),
        title: "\u7F16\u8F91\u56FE\u7247",
        top: "2vh",
        width: "90%",
        style: { "height": "90vh" }
      }, {
        default: withCtx(() => [
          createVNode(_component_el_button, {
            style: { "position": "absolute", "z-index": "99", "right": "43vw", "top": "135px" },
            type: "primary",
            onClick: onOk
          }, {
            default: withCtx(() => [
              createTextVNode("\u7ACB\u5373\u66F4\u6539")
            ]),
            _: 1
          }),
          _hoisted_1$a
        ]),
        _: 1
      }, 8, ["modelValue"]);
    };
  }
});
var SelectTemplate_vue_vue_type_style_index_0_scoped_true_lang = "";
const beforeUnload = function(e2) {
  const confirmationMessage = "\u7CFB\u7EDF\u4E0D\u4F1A\u81EA\u52A8\u4FDD\u5B58\u60A8\u672A\u4FEE\u6539\u7684\u5185\u5BB9";
  (e2 || window.event).returnValue = confirmationMessage;
  return confirmationMessage;
};
const _sfc_main$b = defineComponent({
  components: {
    RightClickMenu,
    Moveable,
    headerOptions,
    ProgressLoading,
    designBoard,
    zoomControl,
    lineGuides,
    imageCutout: index$3,
    widgetPanel,
    stylePanel,
    ElDialog,
    EditImg: _sfc_main$c
  },
  mixins: [shortcuts],
  emits: ["update:modelValue", "close"],
  setup(props2) {
    !_config.isDev && window.addEventListener("beforeunload", beforeUnload);
    const state = reactive$1({
      style: {
        left: "0px"
      },
      downloadPercent: 0,
      downloadText: "",
      isContinue: true,
      APP_NAME: _config.APP_NAME,
      showLineGuides: false,
      visible: false
    });
    onMounted(() => {
      setTimeout(() => {
        state.visible = true;
      }, 3e3);
    });
    function jump2home() {
      window.open("https://xp.palxp.cn/");
    }
    return {
      ...toRefs(state),
      jump2home
    };
  },
  computed: {
    ...mapGetters(["dActiveElement", "dHistoryParams", "dCopyElement", "dPage", "dZoom"]),
    undoable() {
      return !(this.dHistoryParams.index === -1 || this.dHistoryParams === 0 && this.dHistoryParams.length === this.dHistoryParams.maxLength);
    },
    redoable() {
      return !(this.dHistoryParams.index === this.dHistoryParams.length - 1);
    },
    templateVisible() {
      return this.$store.state.templateVisible;
    },
    templateId() {
      return this.$store.state.templateId;
    },
    noMenu() {
      return this.$store.state.templateMode === 1;
    },
    editImgVisible() {
      return this.$store.state.editImgVisible;
    },
    imgs() {
      return this.$store.state.imgs;
    },
    imgIndex() {
      return this.$store.state.imgIndex;
    }
  },
  watch: {
    templateVisible(n) {
      if (n) {
        this.initGroupJson(JSON.stringify(wGroup.setting));
        window.addEventListener("scroll", this.fixTopBarScroll);
        document.addEventListener("keydown", this.handleKeydowm, false);
        document.addEventListener("keyup", this.handleKeyup, false);
        this.loadData();
      } else {
        window.removeEventListener("scroll", this.fixTopBarScroll);
        document.removeEventListener("keydown", this.handleKeydowm, false);
        document.removeEventListener("keyup", this.handleKeyup, false);
        document.oncontextmenu = null;
      }
    },
    templateId(n) {
    }
  },
  mounted() {
  },
  methods: {
    ...mapActions(["selectWidget", "initGroupJson", "handleHistory"]),
    editImgDone: (base642) => {
      const _imgs = [...(void 0).imgs.value];
      const _index = (void 0).imgIndex.value;
      _imgs.value[_index] = base642;
      (void 0).$store.commit("setState", { key: "editImgVisible", value: false });
      (void 0).$store.commit("setState", { key: "imgs", value: _imgs });
    },
    handleClose() {
      this.$emit("close");
    },
    toggleMode(mode) {
      this.$store.commit("setState", { key: "templateMode", value: mode });
    },
    changeLineGuides() {
      this.showLineGuides = !this.showLineGuides;
    },
    downloadCancel() {
      this.downloadPercent = 0;
      this.isContinue = false;
    },
    async loadData() {
      setTimeout(() => {
        var _a2, _b, _c;
        (_c = (_b = (_a2 = this == null ? void 0 : this.$refs) == null ? void 0 : _a2.options) == null ? void 0 : _b.load) == null ? void 0 : _c.call(_b, null, null, null, async () => {
          this.$refs.zoomControl.screenChange();
          await this.$nextTick();
          this.selectWidget({
            uuid: "-1"
          });
        });
      }, 50);
    },
    zoomSub() {
      this.$refs.zoomControl.sub();
    },
    zoomAdd() {
      this.$refs.zoomControl.add();
    },
    save() {
      this.$refs.options.save();
    },
    fixTopBarScroll() {
      const scrollLeft = document.documentElement.scrollLeft || document.body.scrollLeft;
      this.style.left = `-${scrollLeft}px`;
    },
    clickListener(e2) {
      console.log("click listener", e2);
    },
    optionsChange({ downloadPercent, downloadText }) {
      this.downloadPercent = downloadPercent;
      this.downloadText = downloadText;
    }
  }
});
const _withScopeId$4 = (n) => (pushScopeId("data-v-379b29eb"), n = n(), popScopeId(), n);
const _hoisted_1$9 = { class: "text-left" };
const _hoisted_2$6 = {
  id: "page-design-index",
  ref: "pageDesignIndex",
  class: "page-design-bg-color"
};
const _hoisted_3$6 = { class: "top-nav-wrap" };
const _hoisted_4$5 = { class: "top-left" };
const _hoisted_5$4 = { class: "operation" };
const _hoisted_6$2 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createElementVNode("i", { class: "iconfont icon-undo" }, null, -1));
const _hoisted_7$1 = [
  _hoisted_6$2
];
const _hoisted_8$1 = /* @__PURE__ */ _withScopeId$4(() => /* @__PURE__ */ createElementVNode("i", { class: "iconfont icon-redo" }, null, -1));
const _hoisted_9$1 = [
  _hoisted_8$1
];
const _hoisted_10$1 = { class: "page-design-index-wrap" };
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_header_options = resolveComponent("header-options");
  const _component_widget_panel = resolveComponent("widget-panel");
  const _component_design_board = resolveComponent("design-board");
  const _component_style_panel = resolveComponent("style-panel");
  const _component_edit_img = resolveComponent("edit-img");
  const _component_image_cutout = resolveComponent("image-cutout");
  const _component_line_guides = resolveComponent("line-guides");
  const _component_zoom_control = resolveComponent("zoom-control");
  const _component_right_click_menu = resolveComponent("right-click-menu");
  const _component_Moveable = resolveComponent("Moveable");
  const _component_ProgressLoading = resolveComponent("ProgressLoading");
  const _component_el_dialog = resolveComponent("el-dialog");
  return openBlock(), createBlock(_component_el_dialog, {
    "model-value": _ctx.templateVisible,
    top: "5vh",
    width: "90%",
    style: { "height": "90vh" },
    onClose: _ctx.handleClose
  }, {
    header: withCtx(() => [
      createElementVNode("div", _hoisted_1$9, [
        createTextVNode(" \u7F16\u8F91" + toDisplayString(_ctx.noMenu ? "\u56FE\u7247" : "\u6A21\u677F") + " - \u3010", 1),
        createElementVNode("a", {
          class: "text-blue-500 cursor-pointer",
          onClick: _cache[0] || (_cache[0] = ($event) => _ctx.toggleMode(_ctx.noMenu ? 2 : 1))
        }, toDisplayString(_ctx.noMenu ? "\u8FDB\u5165" : "\u9000\u51FA") + "\u6A21\u677F\u7F16\u8F91", 1),
        createTextVNode("\u3011 ")
      ])
    ]),
    default: withCtx(() => [
      createElementVNode("div", _hoisted_2$6, [
        createVNode(_component_header_options, {
          ref: "options",
          modelValue: _ctx.isContinue,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = ($event) => _ctx.isContinue = $event),
          noMenu: _ctx.noMenu,
          onChange: _ctx.optionsChange
        }, null, 8, ["modelValue", "noMenu", "onChange"]),
        withDirectives(createElementVNode("div", {
          style: normalizeStyle(_ctx.style),
          class: "top-nav"
        }, [
          createElementVNode("div", _hoisted_3$6, [
            createElementVNode("div", _hoisted_4$5, [
              createElementVNode("div", {
                class: "name",
                onClick: _cache[2] || (_cache[2] = (...args) => _ctx.jump2home && _ctx.jump2home(...args))
              }, toDisplayString(_ctx.APP_NAME), 1),
              createElementVNode("div", _hoisted_5$4, [
                createElementVNode("div", {
                  class: normalizeClass(["operation-item", { disable: !_ctx.undoable }]),
                  onClick: _cache[3] || (_cache[3] = ($event) => _ctx.undoable ? _ctx.handleHistory("undo") : "")
                }, _hoisted_7$1, 2),
                createElementVNode("div", {
                  class: normalizeClass(["operation-item", { disable: !_ctx.redoable }]),
                  onClick: _cache[4] || (_cache[4] = ($event) => _ctx.redoable ? _ctx.handleHistory("redo") : "")
                }, _hoisted_9$1, 2)
              ])
            ])
          ])
        ], 4), [
          [vShow, false]
        ]),
        createElementVNode("div", _hoisted_10$1, [
          createVNode(_component_widget_panel, { noMenu: _ctx.noMenu }, null, 8, ["noMenu"]),
          createVNode(_component_design_board, {
            class: "page-design-wrap",
            pageDesignCanvasId: "page-design-canvas"
          }, {
            default: withCtx(() => [
              createElementVNode("div", {
                class: "shelter",
                style: normalizeStyle({ width: Math.floor(_ctx.dPage.width * _ctx.dZoom / 100) + "px", height: Math.floor(_ctx.dPage.height * _ctx.dZoom / 100) + "px" })
              }, null, 4),
              createElementVNode("div", {
                class: "shelter-bg transparent-bg",
                style: normalizeStyle({ width: Math.floor(_ctx.dPage.width * _ctx.dZoom / 100) + "px", height: Math.floor(_ctx.dPage.height * _ctx.dZoom / 100) + "px" })
              }, null, 4)
            ]),
            _: 1
          }),
          createVNode(_component_style_panel, { noMenu: _ctx.noMenu }, null, 8, ["noMenu"])
        ]),
        createVNode(_component_edit_img, {
          visible: _ctx.editImgVisible,
          onDone: _ctx.editImgDone
        }, null, 8, ["visible", "onDone"]),
        createVNode(_component_image_cutout),
        createVNode(_component_line_guides, { show: _ctx.showLineGuides }, null, 8, ["show"]),
        createVNode(_component_zoom_control, { ref: "zoomControl" }, null, 512),
        createVNode(_component_right_click_menu),
        createVNode(_component_Moveable),
        createVNode(_component_ProgressLoading, {
          percent: _ctx.downloadPercent,
          text: _ctx.downloadText,
          cancelText: "\u53D6\u6D88",
          onCancel: _ctx.downloadCancel,
          onDone: _cache[5] || (_cache[5] = ($event) => _ctx.downloadPercent = 0)
        }, null, 8, ["percent", "text", "onCancel"])
      ], 512)
    ]),
    _: 1
  }, 8, ["model-value", "onClose"]);
}
var SelectTemplate = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$8], ["__scopeId", "data-v-379b29eb"]]);
var Home_vue_vue_type_style_index_0_lang = "";
const _sfc_main$a = defineComponent({
  __name: "Home",
  props: ["companyId", "data", "config", "modelValue"],
  emits: "close",
  setup(__props, { emit: emits2 }) {
    const props2 = __props;
    const data = computed$1(() => props2.data);
    const isShow = computed$1(() => props2.modelValue);
    watch(
      () => data.value,
      (n) => {
        erpStore.commit("setImg", n);
      }
    );
    watch(
      () => isShow.value,
      (n) => {
        if (n) {
          erpStore.commit("setState", { key: "templateVisible", value: true });
          erpStore.commit("setState", { key: "templateMode", value: 1 });
          erpStore.commit("setState", { key: "templateDate", value: Date.now() });
        }
      }
    );
    const closeModal = () => {
      emits2("update:modelValue", false);
      erpStore.commit("setState", { key: "templateVisible", value: false });
    };
    onMounted(() => {
      if (props2.companyId) {
        localStorage.setItem("CompanyId", props2.companyId);
      }
      if (props2.config) {
        for (const key in props2.config) {
          if (Object.prototype.hasOwnProperty.call(props2.config, key)) {
            const val = props2.config[key];
            localStorage.setItem(key, val);
          }
        }
      }
    });
    return (_ctx, _cache) => {
      return openBlock(), createBlock(SelectTemplate, { onClose: closeModal });
    };
  }
});
const config = _config;
const isInArray = (arr2, value) => {
  if (arr2.indexOf && typeof arr2.indexOf === "function") {
    const index2 = arr2.indexOf(value);
    if (index2 >= 0) {
      return index2;
    }
  }
  return false;
};
const deleteSome = (obj, arr2) => {
  arr2.forEach((key) => {
    delete obj[key];
  });
  return obj;
};
const pickSome = (obj, arr2) => {
  const newObj = {};
  arr2.forEach((key) => {
    newObj[key] = obj[key];
  });
  return newObj;
};
const rndNum = (n, m) => {
  const random = Math.floor(Math.random() * (m - n + 1) + n);
  return random;
};
var utils$1 = {};
var utils$2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  config,
  isInArray,
  deleteSome,
  pickSome,
  rndNum,
  "default": utils$1
}, Symbol.toStringTag, { value: "Module" }));
var sizeControl_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$2 = "size-control";
const _sfc_main$9 = {
  name: NAME$2,
  data() {
    return {
      dirs: []
    };
  },
  computed: {
    ...mapGetters(["dActiveElement", "dWidgets"]),
    left() {
      return parseInt(this.dActiveElement.left);
    },
    top() {
      return parseInt(this.dActiveElement.top);
    },
    width() {
      return parseInt(this.dActiveElement.record.width);
    },
    height() {
      return parseInt(this.dActiveElement.record.height);
    }
  },
  watch: {},
  methods: {
    ...mapActions(["dResize", "initDResize", "dResize", "stopDResize"]),
    handlemousedown(e2, dirs) {
      e2.stopPropagation();
      this.dirs = dirs.split("-");
      this.initDResize({
        startX: e2.pageX,
        startY: e2.pageY,
        originX: this.dActiveElement.left,
        originY: this.dActiveElement.top,
        width: this.width,
        height: this.height
      });
      document.addEventListener("mousemove", this.handlemousemove, true);
      document.addEventListener("mouseup", this.handlemouseup, true);
    },
    handlemousemove(e2) {
      e2.stopPropagation();
      e2.preventDefault();
      this.dResize({
        x: e2.pageX,
        y: e2.pageY,
        dirs: this.dirs
      });
    },
    handlemouseup() {
      document.removeEventListener("mousemove", this.handlemousemove, true);
      document.removeEventListener("mouseup", this.handlemouseup, true);
      this.stopDResize();
    }
  }
};
const _hoisted_1$8 = {
  key: 0,
  id: "size-control"
};
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return _ctx.dActiveElement.record && _ctx.dActiveElement.uuid !== "-1" ? (openBlock(), createElementBlock("div", _hoisted_1$8, [
    _ctx.dActiveElement.record.dir === "all" ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: "square",
      style: normalizeStyle({
        left: $options.left + "px",
        top: $options.top + "px",
        cursor: "nw-resize"
      }),
      onMousedown: _cache[0] || (_cache[0] = ($event) => $options.handlemousedown($event, "left-top"))
    }, null, 36)) : createCommentVNode("", true),
    _ctx.dActiveElement.record.dir === "vertical" || _ctx.dActiveElement.record.dir === "all" ? (openBlock(), createElementBlock("div", {
      key: 1,
      class: "square",
      style: normalizeStyle({
        left: $options.left + $options.width / 2 + "px",
        top: $options.top + "px",
        cursor: "n-resize"
      }),
      onMousedown: _cache[1] || (_cache[1] = ($event) => $options.handlemousedown($event, "top"))
    }, null, 36)) : createCommentVNode("", true),
    _ctx.dActiveElement.record.dir === "all" ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: "square",
      style: normalizeStyle({
        left: $options.left + $options.width + "px",
        top: $options.top + "px",
        cursor: "ne-resize"
      }),
      onMousedown: _cache[2] || (_cache[2] = ($event) => $options.handlemousedown($event, "right-top"))
    }, null, 36)) : createCommentVNode("", true),
    _ctx.dActiveElement.record.dir === "horizontal" || _ctx.dActiveElement.record.dir === "all" ? (openBlock(), createElementBlock("div", {
      key: 3,
      class: "square",
      style: normalizeStyle({
        left: $options.left + "px",
        top: $options.top + $options.height / 2 + "px",
        cursor: "w-resize"
      }),
      onMousedown: _cache[3] || (_cache[3] = ($event) => $options.handlemousedown($event, "left"))
    }, null, 36)) : createCommentVNode("", true),
    _ctx.dActiveElement.record.dir === "horizontal" || _ctx.dActiveElement.record.dir === "all" ? (openBlock(), createElementBlock("div", {
      key: 4,
      class: "square",
      style: normalizeStyle({
        left: $options.left + $options.width + "px",
        top: $options.top + $options.height / 2 + "px",
        cursor: "e-resize"
      }),
      onMousedown: _cache[4] || (_cache[4] = ($event) => $options.handlemousedown($event, "right"))
    }, null, 36)) : createCommentVNode("", true),
    _ctx.dActiveElement.record.dir === "all" ? (openBlock(), createElementBlock("div", {
      key: 5,
      class: "square",
      style: normalizeStyle({
        left: $options.left + "px",
        top: $options.top + $options.height + "px",
        cursor: "sw-resize"
      }),
      onMousedown: _cache[5] || (_cache[5] = ($event) => $options.handlemousedown($event, "left-bottom"))
    }, null, 36)) : createCommentVNode("", true),
    _ctx.dActiveElement.record.dir === "vertical" || _ctx.dActiveElement.record.dir === "all" ? (openBlock(), createElementBlock("div", {
      key: 6,
      class: "square",
      style: normalizeStyle({
        left: $options.left + $options.width / 2 + "px",
        top: $options.top + $options.height + "px",
        cursor: "s-resize"
      }),
      onMousedown: _cache[6] || (_cache[6] = ($event) => $options.handlemousedown($event, "bottom"))
    }, null, 36)) : createCommentVNode("", true),
    _ctx.dActiveElement.record.dir === "all" ? (openBlock(), createElementBlock("div", {
      key: 7,
      class: "square",
      style: normalizeStyle({
        left: $options.left + $options.width + "px",
        top: $options.top + $options.height + "px",
        cursor: "se-resize"
      }),
      onMousedown: _cache[7] || (_cache[7] = ($event) => $options.handlemousedown($event, "right-bottom"))
    }, null, 36)) : createCommentVNode("", true)
  ])) : createCommentVNode("", true);
}
var sizeControl = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$7], ["__scopeId", "data-v-48f7cb62"]]);
var __glob_0_2 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": sizeControl
}, Symbol.toStringTag, { value: "Module" }));
var textInput_vue_vue_type_style_index_0_scoped_true_lang = "";
const NAME$1 = "text-input";
const _sfc_main$8 = {
  name: NAME$1,
  props: {
    label: {
      default: ""
    },
    modelValue: {
      default: ""
    },
    editable: {
      default: true
    }
  },
  emits: ["update:modelValue", "finish"],
  data() {
    return {
      inputBorder: false,
      tagText: ""
    };
  },
  computed: {},
  methods: {
    updateValue(value) {
      this.$emit("update:modelValue", value);
    },
    focusInput() {
      this.inputBorder = true;
      this.tagText = this.modelValue;
    },
    blurInput() {
      this.inputBorder = false;
      if (this.modelValue !== this.tagText) {
        this.$emit("finish", this.modelValue);
      }
    }
  }
};
const _hoisted_1$7 = { class: "text-input" };
const _hoisted_2$5 = {
  key: 0,
  class: "input-label"
};
const _hoisted_3$5 = ["value", "readonly"];
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", _hoisted_1$7, [
    $props.label ? (openBlock(), createElementBlock("p", _hoisted_2$5, toDisplayString($props.label), 1)) : createCommentVNode("", true),
    createElementVNode("div", {
      class: normalizeClass({ "input-wrap": true, active: $data.inputBorder })
    }, [
      createElementVNode("input", {
        class: normalizeClass({ "real-input": true, disable: !$props.editable }),
        type: "text",
        value: $props.modelValue,
        readonly: $props.editable ? false : "readonly",
        onInput: _cache[0] || (_cache[0] = ($event) => $options.updateValue($event.target.value)),
        onFocus: _cache[1] || (_cache[1] = (...args) => $options.focusInput && $options.focusInput(...args)),
        onBlur: _cache[2] || (_cache[2] = (...args) => $options.blurInput && $options.blurInput(...args))
      }, null, 42, _hoisted_3$5)
    ], 2)
  ]);
}
var textInput = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$6], ["__scopeId", "data-v-2ff701aa"]]);
var __glob_0_10 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": textInput
}, Symbol.toStringTag, { value: "Module" }));
var Tabs_vue_vue_type_style_index_0_scoped_true_lang = "";
const _hoisted_1$6 = { class: "my-tabs" };
const _hoisted_2$4 = { class: "my-tabs__header p-0.5 mb-3 rounded bg-gray-100 cursor-pointers" };
const _hoisted_3$4 = { class: "my-tabs__header-shell relative flex justify-between" };
const _hoisted_4$4 = ["onClick"];
const _hoisted_5$3 = { class: "my-tabs__content" };
const __default__$1 = {
  name: "Tabs"
};
const _sfc_main$7 = Object.assign(__default__$1, {
  props: {
    value: {
      type: String,
      required: true
    }
  },
  emits: ["update:value", "change"],
  setup(__props, { expose: __expose, emit: emit2 }) {
    const props2 = __props;
    watch(
      () => props2.value,
      () => {
        changeTab();
      }
    );
    const tabs = ref$1([]);
    const sliderStyle = reactive$1({ width: 0, left: 0 });
    let tabWidth = 0;
    onMounted(() => {
      tabWidth = 100 / tabs.value.length;
      sliderStyle.width = `${tabWidth}%`;
      changeTab();
    });
    let preActiveTabVM = null;
    async function changeTab(index2 = -1) {
      var _a2, _b, _c, _d;
      if (index2 < 0) {
        index2 = tabs.value.findIndex((vm) => vm.props.label === props2.value);
      }
      sliderStyle.left = `${tabWidth * index2}%`;
      try {
        await nextTick();
        (_b = (_a2 = preActiveTabVM == null ? void 0 : preActiveTabVM.exposed) == null ? void 0 : _a2.changeActive) == null ? void 0 : _b.call(_a2, false);
        preActiveTabVM = tabs.value[index2];
        (_d = (_c = preActiveTabVM.exposed) == null ? void 0 : _c.changeActive) == null ? void 0 : _d.call(_c, true);
      } catch (error) {
      }
    }
    function onClickTab(tab, index2) {
      emit2("update:value", tab.props.label);
      changeTab(index2);
    }
    __expose({ tabs });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$6, [
        createElementVNode("div", _hoisted_2$4, [
          createElementVNode("div", _hoisted_3$4, [
            (openBlock(true), createElementBlock(Fragment, null, renderList(tabs.value, (tab, index2) => {
              return openBlock(), createElementBlock("div", {
                key: tab.props.label,
                class: normalizeClass(["my-tab__title relative flex-auto py-1 text-center", { "my-active": tab.props.label === __props.value }]),
                onClick: ($event) => onClickTab(tab, index2)
              }, toDisplayString(tab.props.label), 11, _hoisted_4$4);
            }), 128)),
            createElementVNode("div", {
              class: "my-tab__slider",
              style: normalizeStyle(sliderStyle)
            }, null, 4)
          ])
        ]),
        createElementVNode("div", _hoisted_5$3, [
          renderSlot(_ctx.$slots, "default", {}, void 0, true)
        ])
      ]);
    };
  }
});
var Tabs = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["__scopeId", "data-v-5ec3cc7e"]]);
const __default__ = {
  name: "TabPanel"
};
const _sfc_main$6 = Object.assign(__default__, {
  props: {
    label: {
      type: String,
      required: true
    }
  },
  setup(__props, { expose: __expose }) {
    const vm = getCurrentInstance();
    vm.parent.exposed.tabs.value.push(vm);
    const active = ref$1(false);
    const rootStyle = computed$1(() => ({
      display: active.value ? "block" : "none"
    }));
    function changeActive(value) {
      active.value = value;
    }
    __expose({
      changeActive
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", {
        class: "tab-panel",
        style: normalizeStyle(rootStyle.value)
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 4);
    };
  }
});
var elBadge = "";
var elMessage = "";
var pageStyle_vue_vue_type_style_index_0_lang = "";
var pageStyle_vue_vue_type_style_index_1_scoped_true_lang = "";
const NAME = "page-style";
const _sfc_main$5 = {
  name: NAME,
  components: { numberInput, colorSelect, uploader, Tabs, TabPanel: _sfc_main$6 },
  props: ["noMenu"],
  data() {
    return {
      activeNames: ["1", "2", "3", "4"],
      innerElement: {},
      tag: false,
      ingoreKeys: ["backgroundColor", "name", "width", "height"],
      downP: 0,
      mode: "\u989C\u8272",
      modes: ["\u989C\u8272", "\u56FE\u7247"]
    };
  },
  computed: {
    ...mapGetters(["dActiveElement"]),
    imgs() {
      var _a2;
      return (_a2 = this.$store.state) == null ? void 0 : _a2.imgs;
    },
    imgIndex() {
      var _a2;
      return (_a2 = this.$store.state) == null ? void 0 : _a2.imgIndex;
    }
  },
  watch: {
    dActiveElement: {
      handler(newValue, oldValue) {
        this.change();
      },
      deep: true
    },
    innerElement: {
      handler(newValue, oldValue) {
        this.changeValue();
      },
      deep: true
    }
  },
  created() {
    this.change();
  },
  methods: {
    ...mapActions(["updatePageData"]),
    selectImg(img, index2) {
      this.finish("backgroundImage", img);
      this.$store.commit("setImgIndex", index2);
    },
    editImg(index2) {
      this.$store.commit("setImgIndex", index2);
      this.$store.commit("setEditImgVisible", true);
    },
    async removeBg(index2) {
      ElMessageBox.confirm("\u70B9\u51FB\u786E\u8BA4\u540E\u5C06\u8FDB\u884C\u667A\u80FD\u62A0\u56FE\uFF0C\u53EF\u80FD\u9700\u8981\u4E00\u6BB5\u65F6\u95F4\uFF0C\u662F\u5426\u7EE7\u7EED\uFF1F", "Warning", {
        confirmButtonText: "\u5F00\u59CB",
        cancelButtonText: "\u53D6\u6D88",
        type: "warning",
        beforeClose: async (action, instance, done) => {
          if (action === "confirm") {
            instance.confirmButtonLoading = true;
            instance.confirmButtonText = "Loading...";
            const _imgs = [...this.imgs];
            const img = _imgs[index2];
            if ((img == null ? void 0 : img.indexOf("http")) > -1) {
              const res = await api$1.ai.uploadByUrl(img);
              const resultImage = URL.createObjectURL(res);
              this.$store.commit("setImgIndex", index2);
              this.$store.commit("setImageCutoutVisible", true);
              this.$store.commit("setImageCutoutResult", resultImage);
              this.$store.commit("setImageCutoutRaw", img);
            }
            done();
            instance.confirmButtonLoading = false;
          } else {
            done();
          }
        }
      });
    },
    colorChange(e2) {
      if (e2.mode === "\u6E10\u53D8")
        ;
    },
    onChangeMode(value) {
      this.mode = value;
      if (value === "\u989C\u8272") {
        this._localTempBG = this.innerElement.backgroundImage;
        this.finish("backgroundImage", "");
      } else {
        this._localTempBG && this.finish("backgroundImage", this._localTempBG);
      }
    },
    change() {
      this.mode = this.modes[0];
      this.tag = true;
      this.innerElement = JSON.parse(JSON.stringify(this.dActiveElement));
      this.innerElement.backgroundImage && (this.mode = this.modes[1]);
    },
    changeValue() {
      if (this.tag) {
        this.tag = false;
        return;
      }
      for (let key in this.innerElement) {
        if (key !== "setting" && key !== "record" && this.innerElement[key] !== this.dActiveElement[key]) {
          if (this.ingoreKeys.indexOf(key) !== -1) {
            this.dActiveElement[key] = this.innerElement[key];
          } else {
            this.updatePageData({
              key,
              value: this.innerElement[key]
            });
          }
        }
      }
    },
    finish(key, value) {
      this.updatePageData({
        key,
        value,
        pushHistory: true
      });
    },
    async uploadImgDone(img) {
      await api$1.material.addMyPhoto(img);
      this.updatePageData({
        key: "backgroundTransform",
        value: {}
      });
      this.finish("backgroundImage", img.url);
    },
    async deleteBg() {
      this._localTempBG = null;
      this.updatePageData({
        key: "backgroundImage",
        value: "",
        pushHistory: true
      });
      await this.$nextTick();
      this.mode = this.modes[1];
    },
    async downloadBG() {
      await _dl.downloadImg(this.innerElement.backgroundImage, (p) => {
        this.downP = p < 99 ? p / 100 : 0;
      });
    }
  }
};
const _withScopeId$3 = (n) => (pushScopeId("data-v-069b7440"), n = n(), popScopeId(), n);
const _hoisted_1$5 = { id: "page-style" };
const _hoisted_2$3 = { class: "position-size" };
const _hoisted_3$3 = {
  key: 0,
  class: "flex flex-col justify-center items-center"
};
const _hoisted_4$3 = { class: "tool" };
const _hoisted_5$2 = ["onClick"];
const _hoisted_6$1 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("i", { class: "iconfont icon-edit" }, null, -1));
const _hoisted_7 = [
  _hoisted_6$1
];
const _hoisted_8 = ["onClick"];
const _hoisted_9 = /* @__PURE__ */ _withScopeId$3(() => /* @__PURE__ */ createElementVNode("i", { class: "iconfont icon-magic-wand" }, null, -1));
const _hoisted_10 = [
  _hoisted_9
];
const _hoisted_11 = {
  key: 0,
  class: "flex flex-col justify-center items-center"
};
const _hoisted_12 = {
  key: 1,
  class: "flex flex-col justify-center items-center"
};
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_number_input = resolveComponent("number-input");
  const _component_el_collapse_item = resolveComponent("el-collapse-item");
  const _component_el_image = resolveComponent("el-image");
  const _component_el_button = resolveComponent("el-button");
  const _component_uploader = resolveComponent("uploader");
  const _component_color_select = resolveComponent("color-select");
  const _component_el_collapse = resolveComponent("el-collapse");
  return openBlock(), createElementBlock("div", _hoisted_1$5, [
    createVNode(_component_el_collapse, {
      modelValue: $data.activeNames,
      "onUpdate:modelValue": _cache[7] || (_cache[7] = ($event) => $data.activeNames = $event)
    }, {
      default: withCtx(() => [
        createVNode(_component_el_collapse_item, {
          title: "\u753B\u5E03\u5C3A\u5BF8",
          name: "1"
        }, {
          default: withCtx(() => [
            createElementVNode("div", _hoisted_2$3, [
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.width,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => $data.innerElement.width = $event),
                label: "\u5BBD",
                maxValue: 5e3,
                onFinish: _cache[1] || (_cache[1] = (value) => $options.finish("width", value))
              }, null, 8, ["modelValue"]),
              createVNode(_component_number_input, {
                modelValue: $data.innerElement.height,
                "onUpdate:modelValue": _cache[2] || (_cache[2] = ($event) => $data.innerElement.height = $event),
                label: "\u9AD8",
                maxValue: 5e3,
                onFinish: _cache[3] || (_cache[3] = (value) => $options.finish("height", value))
              }, null, 8, ["modelValue"])
            ])
          ]),
          _: 1
        }),
        $props.noMenu ? (openBlock(), createBlock(_component_el_collapse_item, {
          key: 0,
          title: "\u4EA7\u54C1\u8BBE\u7F6E",
          name: "2"
        }, {
          default: withCtx(() => [
            $data.mode === "\u56FE\u7247" && $data.innerElement.backgroundImage ? (openBlock(), createElementBlock("div", _hoisted_3$3, [
              (openBlock(true), createElementBlock(Fragment, null, renderList($options.imgs, (item, index2) => {
                return openBlock(), createElementBlock("div", {
                  key: index2,
                  class: "relative -ml-[28px]"
                }, [
                  createElementVNode("div", _hoisted_4$3, [
                    createElementVNode("div", {
                      class: "tool-item",
                      onClick: ($event) => $options.editImg(index2)
                    }, _hoisted_7, 8, _hoisted_5$2),
                    createElementVNode("div", {
                      class: "tool-item",
                      onClick: ($event) => $options.removeBg(index2)
                    }, _hoisted_10, 8, _hoisted_8)
                  ]),
                  createVNode(_component_el_image, {
                    class: normalizeClass(["cursor-pointer border-[1px] border-solid border-[#3468C0] mb-2", { "border-[1px]": index2 !== $options.imgIndex, "border-[2px]": index2 === $options.imgIndex }]),
                    style: { "width": "200px", "height": "auto" },
                    src: item,
                    fit: "contain",
                    onClick: ($event) => $options.selectImg(item, index2)
                  }, null, 8, ["class", "src", "onClick"])
                ]);
              }), 128))
            ])) : createCommentVNode("", true),
            withDirectives(createVNode(_component_uploader, {
              style: { "width": "100%", "margin-top": "0.7rem" },
              onDone: $options.uploadImgDone
            }, {
              default: withCtx(() => [
                createVNode(_component_el_button, {
                  style: { "width": "100%" },
                  plain: ""
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString($data.innerElement.backgroundImage ? "\u66FF\u6362\u80CC\u666F" : "\u4E0A\u4F20\u80CC\u666F") + "\u56FE", 1)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            }, 8, ["onDone"]), [
              [vShow, $data.mode === "\u56FE\u7247" && !$data.innerElement.backgroundImage]
            ])
          ]),
          _: 1
        })) : (openBlock(), createBlock(_component_el_collapse_item, {
          key: 1,
          title: "\u80CC\u666F\u8BBE\u7F6E",
          name: "2"
        }, {
          default: withCtx(() => [
            $data.mode === "\u989C\u8272" && $data.innerElement.backgroundColor ? (openBlock(), createElementBlock("div", _hoisted_11, [
              withDirectives(createVNode(_component_color_select, {
                modelValue: $data.innerElement.backgroundColor,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = ($event) => $data.innerElement.backgroundColor = $event),
                modes: ["\u7EAF\u8272"],
                onChange: $options.colorChange,
                onFinish: _cache[5] || (_cache[5] = (value) => $options.finish("backgroundColor", value))
              }, null, 8, ["modelValue", "onChange"]), [
                [vShow, $data.mode === "\u989C\u8272"]
              ]),
              createVNode(_component_el_button, {
                style: { "width": "100%", "margin-top": "0.7rem" },
                size: "small",
                onClick: _cache[6] || (_cache[6] = ($event) => $options.finish("backgroundColor", ""))
              }, {
                default: withCtx(() => [
                  createTextVNode("\u5220\u9664\u989C\u8272")
                ]),
                _: 1
              })
            ])) : createCommentVNode("", true),
            $data.mode === "\u56FE\u7247" && $data.innerElement.backgroundImage ? (openBlock(), createElementBlock("div", _hoisted_12, [
              createVNode(_component_el_button, {
                style: { "width": "100%", "margin-top": "0.7rem" },
                size: "small",
                onClick: $options.deleteBg
              }, {
                default: withCtx(() => [
                  createTextVNode("\u5220\u9664")
                ]),
                _: 1
              }, 8, ["onClick"])
            ])) : createCommentVNode("", true)
          ]),
          _: 1
        }))
      ]),
      _: 1
    }, 8, ["modelValue"])
  ]);
}
var pageStyle = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$5], ["__scopeId", "data-v-069b7440"]]);
var __glob_0_13 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": pageStyle
}, Symbol.toStringTag, { value: "Module" }));
var elRadioButton = "";
var ContainerWrap_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$4 = defineComponent({
  components: { ElRadioGroup, ElRadioButton },
  props: ["modelValue", "degree"],
  emits: ["change"],
  setup(props2, context) {
    const state = reactive$1({
      effectSelect: "",
      visiable: false,
      type: "166",
      list: []
    });
    const select = (value = "") => {
      state.visiable = false;
      const setting = JSON.parse(JSON.stringify(wSvg.setting));
      setting.svgUrl = value;
      context.emit("change", setting);
    };
    onMounted(async () => {
      await nextTick();
      state.effectSelect = (props2 == null ? void 0 : props2.modelValue) || "";
      getList2();
    });
    async function getList2() {
      const res = await api$1.material.getList({
        first_id: 2,
        second_id: state.type
      });
      state.list = res.list.map(({ thumbUrl, imgUrl }) => {
        return { thumbUrl, imgUrl };
      });
    }
    watch(
      () => state.type,
      (value) => {
        getList2();
      }
    );
    return {
      ...toRefs(state),
      select
    };
  },
  methods: {}
});
const _withScopeId$2 = (n) => (pushScopeId("data-v-5eba818f"), n = n(), popScopeId(), n);
const _hoisted_1$4 = { class: "card-header" };
const _hoisted_2$2 = /* @__PURE__ */ _withScopeId$2(() => /* @__PURE__ */ createElementVNode("span", { class: "title" }, "\u56FE\u7247\u5BB9\u5668", -1));
const _hoisted_3$2 = { class: "box__header" };
const _hoisted_4$2 = { class: "select__box" };
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_radio_button = resolveComponent("el-radio-button");
  const _component_el_radio_group = resolveComponent("el-radio-group");
  const _component_el_image = resolveComponent("el-image");
  const _component_el_button = resolveComponent("el-button");
  const _component_el_popover = resolveComponent("el-popover");
  const _component_el_card = resolveComponent("el-card");
  return openBlock(), createBlock(_component_el_card, {
    class: "box-card",
    shadow: "hover",
    "body-style": { padding: _ctx.effectSelect ? "20px" : 0 }
  }, {
    header: withCtx(() => [
      createElementVNode("div", _hoisted_1$4, [
        _ctx.effectSelect ? (openBlock(), createBlock(resolveDynamicComponent(_ctx.effectSelect), {
          key: 0,
          class: "demo"
        })) : createCommentVNode("", true),
        withDirectives(createElementVNode("div", null, "\u65E0", 512), [
          [vShow, !_ctx.effectSelect]
        ]),
        _hoisted_2$2,
        createVNode(_component_el_popover, {
          visible: _ctx.visiable,
          placement: "bottom-end",
          width: 260,
          trigger: "click"
        }, {
          reference: withCtx(() => [
            createVNode(_component_el_button, {
              class: "button",
              link: "",
              onClick: _cache[2] || (_cache[2] = ($event) => _ctx.visiable = !_ctx.visiable)
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString(_ctx.visiable ? "\u53D6\u6D88" : "\u9009\u62E9"), 1)
              ]),
              _: 1
            })
          ]),
          default: withCtx(() => [
            createElementVNode("div", _hoisted_3$2, [
              createVNode(_component_el_radio_group, {
                modelValue: _ctx.type,
                "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.type = $event),
                size: "small"
              }, {
                default: withCtx(() => [
                  createVNode(_component_el_radio_button, { label: "160" }, {
                    default: withCtx(() => [
                      createTextVNode("\u5F62\u72B6")
                    ]),
                    _: 1
                  }),
                  createVNode(_component_el_radio_button, { label: "166" }, {
                    default: withCtx(() => [
                      createTextVNode("\u6846\u67B6")
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }, 8, ["modelValue"])
            ]),
            createElementVNode("div", _hoisted_4$2, [
              createElementVNode("div", {
                class: "select__box__select-item",
                onClick: _cache[1] || (_cache[1] = ($event) => _ctx.select(null))
              }, "\u65E0"),
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.list, (item, i) => {
                return openBlock(), createBlock(_component_el_image, {
                  key: i + "l",
                  class: "select__box__select-item",
                  src: item.thumbUrl,
                  fit: "contain",
                  onClick: ($event) => _ctx.select(item.imgUrl)
                }, null, 8, ["src", "onClick"]);
              }), 128))
            ])
          ]),
          _: 1
        }, 8, ["visible"])
      ])
    ]),
    _: 1
  }, 8, ["body-style"]);
}
var ContainerWrap = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$4], ["__scopeId", "data-v-5eba818f"]]);
var __glob_0_23 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": ContainerWrap
}, Symbol.toStringTag, { value: "Module" }));
var classHeader_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$3 = defineComponent({
  props: ["types", "isBack"],
  emits: ["select", "back"],
  setup(props2, { emit: emit2 }) {
    const select = (item) => {
      emit2("select", item);
    };
    const back = () => {
      emit2("back");
    };
    return { select, back };
  }
});
const _withScopeId$1 = (n) => (pushScopeId("data-v-70375d67"), n = n(), popScopeId(), n);
const _hoisted_1$3 = {
  key: 0,
  class: "content__wrap"
};
const _hoisted_2$1 = ["onClick"];
const _hoisted_3$1 = { style: { "flex": "1" } };
const _hoisted_4$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode("span", { class: "types__header-more" }, [
  /* @__PURE__ */ createTextVNode("\u5168\u90E8"),
  /* @__PURE__ */ createElementVNode("i", { class: "iconfont icon-right" })
], -1));
const _hoisted_5$1 = /* @__PURE__ */ _withScopeId$1(() => /* @__PURE__ */ createElementVNode("i", { class: "iconfont icon-right" }, null, -1));
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return !_ctx.isBack ? (openBlock(), createElementBlock("div", _hoisted_1$3, [
    (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.types, (t, ti) => {
      return openBlock(), createElementBlock("div", {
        key: ti + "t"
      }, [
        createElementVNode("div", {
          class: "types__header",
          onClick: ($event) => _ctx.select(t)
        }, [
          createElementVNode("span", _hoisted_3$1, toDisplayString(t.name), 1),
          _hoisted_4$1
        ], 8, _hoisted_2$1),
        renderSlot(_ctx.$slots, "default", { index: ti }, void 0, true)
      ]);
    }), 128))
  ])) : (openBlock(), createElementBlock("span", {
    key: 1,
    class: "types__header-back",
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.back && _ctx.back(...args))
  }, [
    _hoisted_5$1,
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ]));
}
var classHeader = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$3], ["__scopeId", "data-v-70375d67"]]);
var __glob_0_35 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": classHeader
}, Symbol.toStringTag, { value: "Module" }));
const _sfc_main$2 = defineComponent({
  props: {
    detail: {}
  },
  setup() {
    return {};
  }
});
const _hoisted_1$2 = { style: { "max-width": "140px" } };
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tooltip = resolveComponent("el-tooltip");
  return openBlock(), createBlock(_component_el_tooltip, {
    disabled: !_ctx.detail.author,
    offset: 1,
    effect: "light",
    placement: "bottom-start",
    "hide-after": 0,
    enterable: false,
    "raw-content": ""
  }, {
    content: withCtx(() => [
      createElementVNode("p", _hoisted_1$2, [
        createElementVNode("b", null, toDisplayString(_ctx.detail.description), 1)
      ]),
      createElementVNode("p", null, "@" + toDisplayString(_ctx.detail.author), 1)
    ]),
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8, ["disabled"]);
}
var imageTip = /* @__PURE__ */ _export_sfc(_sfc_main$2, [["render", _sfc_render$2]]);
var __glob_0_37 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": imageTip
}, Symbol.toStringTag, { value: "Module" }));
var photoList_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main$1 = defineComponent({
  props: {
    listData: {},
    edit: {},
    isDone: {},
    isShort: {
      default: false
    }
  },
  emits: ["load", "drag", "select"],
  setup(props2, context) {
    const state = reactive$1({
      loading: true,
      list: [],
      listRef: null
    });
    const dragHelper2 = new dragHelper$2();
    let isDrag2 = false;
    let startPoint2 = { x: 99999, y: 99999 };
    const mouseup = (e2) => {
      e2.preventDefault();
      setTimeout(() => {
        isDrag2 = false;
        startPoint2 = { x: 99999, y: 99999 };
      }, 10);
    };
    const mousemove = (e2) => {
      e2.preventDefault();
      if (e2.x - startPoint2.x > 2 || e2.y - startPoint2.y > 2) {
        isDrag2 = true;
      }
    };
    watch(
      () => props2.listData,
      async (newList, oldList) => {
        !oldList && (oldList = []);
        if (newList.length <= 0) {
          state.list.length = 0;
          return;
        }
        let list = newList.filter((v) => !newList.includes(v) || !oldList.includes(v));
        list = JSON.parse(JSON.stringify(list));
        const marginRight2 = 6;
        const limitWidth = await getFatherWidth() - marginRight2;
        const standardHeight = 280;
        const neatArr = [];
        function factory(cutArr) {
          return new Promise((resolve) => {
            const lineup = list.shift();
            if (!lineup) {
              resolve({ height: calculate2(cutArr), list: cutArr });
              return;
            }
            cutArr.push(lineup);
            const finalHeight = calculate2(cutArr);
            if (finalHeight > standardHeight) {
              resolve(factory(cutArr));
            } else {
              resolve({ height: finalHeight, list: cutArr });
            }
          });
        }
        function calculate2(cutArr) {
          let cumulate = 0;
          for (const iterator of cutArr) {
            const { width, height } = iterator;
            cumulate += width / height;
          }
          return (limitWidth - marginRight2 * (cutArr.length - 1)) / cumulate;
        }
        async function handleList() {
          if (list.length <= 0) {
            return;
          }
          const { list: newList2, height } = await factory([list.shift()]);
          neatArr.push(
            newList2.map((x, index2) => {
              x.listWidth = x.width / x.height * height;
              x.gap = index2 !== newList2.length - 1 ? marginRight2 : 0;
              return x;
            })
          );
          if (list.length > 0) {
            await handleList();
          }
        }
        await handleList();
        state.list = state.list.concat(neatArr.flat(1));
        state.loading = false;
      }
    );
    async function getFatherWidth() {
      await nextTick();
      const dom = state.listRef;
      const father = dom.parentElement || dom.parentNode;
      return father.offsetWidth;
    }
    function getRef() {
      return state.listRef;
    }
    const load = () => {
      state.loading = true;
      context.emit("load");
    };
    const select = (i) => {
      !isDrag2 && !state.list[i].isDelect && context.emit("select", i);
    };
    const dragStart2 = async (e2, i) => {
      e2.preventDefault();
      startPoint2 = { x: e2.x, y: e2.y };
      if (!state.list[i].isDelect) {
        const img = await setItem2Data(state.list[i]);
        dragHelper2.start(e2, img.canvasWidth);
        context.emit("drag", i);
      }
    };
    function delItem(i) {
      state.list[i].isDelect = true;
    }
    const scrollEvent = (e2) => {
      if (e2.target.scrollTop + e2.target.offsetHeight + 200 >= e2.target.scrollHeight) {
        load();
      }
    };
    const getInnerHeight = ({ height, listWidth, width }) => height * listWidth / width;
    return {
      load,
      dragStart: dragStart2,
      select,
      ...toRefs(state),
      delItem,
      scrollEvent,
      getRef,
      mouseup,
      mousemove,
      getInnerHeight
    };
  }
});
const _withScopeId = (n) => (pushScopeId("data-v-1c1c8e52"), n = n(), popScopeId(), n);
const _hoisted_1$1 = { class: "list" };
const _hoisted_2 = ["onMousedown", "onClick", "onDragstart"];
const _hoisted_3 = {
  key: 0,
  class: "list__mask"
};
const _hoisted_4 = {
  key: 0,
  class: "loading"
};
const _hoisted_5 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createElementVNode("i", { class: "el-icon-loading" }, null, -1));
const _hoisted_6 = {
  key: 1,
  class: "loading"
};
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_image = resolveComponent("el-image");
  const _component_edit_model = resolveComponent("edit-model");
  const _component_imageTip = resolveComponent("imageTip");
  return openBlock(), createElementBlock("ul", {
    ref: "listRef",
    class: "img-list-wrap",
    style: normalizeStyle({ paddingBottom: _ctx.isShort ? "15px" : "200px" }),
    onScroll: _cache[2] || (_cache[2] = ($event) => _ctx.scrollEvent($event))
  }, [
    createElementVNode("div", _hoisted_1$1, [
      (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.list, (item, i) => {
        return openBlock(), createElementBlock("div", {
          key: i + "i",
          style: normalizeStyle({ width: item.listWidth + "px", marginRight: item.gap + "px" }),
          class: "list__img",
          draggable: "false",
          onMousedown: ($event) => _ctx.dragStart($event, i),
          onMousemove: _cache[0] || (_cache[0] = (...args) => _ctx.mousemove && _ctx.mousemove(...args)),
          onMouseup: _cache[1] || (_cache[1] = (...args) => _ctx.mouseup && _ctx.mouseup(...args)),
          onClick: withModifiers(($event) => _ctx.select(i), ["stop"]),
          onDragstart: ($event) => _ctx.dragStart($event, i)
        }, [
          _ctx.edit ? (openBlock(), createBlock(_component_edit_model, {
            key: 0,
            options: _ctx.edit,
            data: { item, i }
          }, {
            default: withCtx(() => [
              item.isDelect ? (openBlock(), createElementBlock("div", _hoisted_3, "\u5DF2\u5220\u9664")) : createCommentVNode("", true),
              createVNode(_component_el_image, {
                class: "img transparent-bg",
                src: item.thumb || item.url,
                style: normalizeStyle({ height: _ctx.getInnerHeight(item) + "px" }),
                lazy: "",
                loading: "lazy"
              }, null, 8, ["src", "style"])
            ]),
            _: 2
          }, 1032, ["options", "data"])) : (openBlock(), createBlock(_component_imageTip, {
            key: 1,
            detail: item
          }, {
            default: withCtx(() => [
              createVNode(_component_el_image, {
                class: "img",
                src: item.thumb || item.url,
                style: normalizeStyle({ height: _ctx.getInnerHeight(item) + "px" }),
                lazy: "",
                loading: "lazy"
              }, {
                placeholder: withCtx(() => [
                  createElementVNode("div", {
                    style: normalizeStyle({ backgroundColor: item.color }),
                    class: "image-color"
                  }, null, 4)
                ]),
                _: 2
              }, 1032, ["src", "style"])
            ]),
            _: 2
          }, 1032, ["detail"]))
        ], 44, _hoisted_2);
      }), 128))
    ]),
    !_ctx.isDone ? withDirectives((openBlock(), createElementBlock("div", _hoisted_4, [
      _hoisted_5,
      createTextVNode(" \u62FC\u547D\u52A0\u8F7D\u4E2D")
    ], 512)), [
      [vShow, _ctx.loading]
    ]) : (openBlock(), createElementBlock("div", _hoisted_6, "\u5168\u90E8\u52A0\u8F7D\u5B8C\u6BD5"))
  ], 36);
}
var photoList = /* @__PURE__ */ _export_sfc(_sfc_main$1, [["render", _sfc_render$1], ["__scopeId", "data-v-1c1c8e52"]]);
var __glob_0_39 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": photoList
}, Symbol.toStringTag, { value: "Module" }));
var innerToolBar_vue_vue_type_style_index_0_scoped_true_lang = "";
const _sfc_main = {};
const _hoisted_1 = { class: "inner-tool-bar" };
function _sfc_render(_ctx, _cache) {
  return openBlock(), createElementBlock("div", _hoisted_1, [
    renderSlot(_ctx.$slots, "default", {}, void 0, true)
  ]);
}
var innerToolBar = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render], ["__scopeId", "data-v-5abbe7ff"]]);
var __glob_0_41 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  "default": innerToolBar
}, Symbol.toStringTag, { value: "Module" }));
function capitalizeFirstLetter(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
}
const exclude = ["settings", "layout"];
const regex = RegExp(".*^(?!.*?(" + exclude.join("|") + ")).*\\.vue$");
const requireComponent = { "./layout/designBoard.vue": __glob_0_0, "./layout/lineGuides.vue": __glob_0_1, "./layout/sizeControl.vue": __glob_0_2, "./layout/zoomControl.vue": __glob_0_3, "./panel/stylePanel.vue": __glob_0_4, "./panel/widgetPanel.vue": __glob_0_5, "./settings/colorSelect.vue": __glob_0_6, "./settings/iconItemSelect.vue": __glob_0_7, "./settings/numberInput.vue": __glob_0_8, "./settings/numberSlider.vue": __glob_0_9, "./settings/textInput.vue": __glob_0_10, "./settings/textInputArea.vue": __glob_0_11, "./settings/valueSelect.vue": __glob_0_12, "./widgets/pageStyle.vue": __glob_0_13, "./panel/components/layerList.vue": __glob_0_14, "./panel/wrap/BgImgListWrap.vue": __glob_0_15, "./panel/wrap/CompListWrap.vue": __glob_0_16, "./panel/wrap/GraphListWrap.vue": __glob_0_17, "./panel/wrap/PhotoListWrap.vue": __glob_0_18, "./panel/wrap/TempListWrap.vue": __glob_0_19, "./panel/wrap/TextListWrap.vue": __glob_0_20, "./panel/wrap/ToolsListWrap.vue": __glob_0_21, "./panel/wrap/UserWrap.vue": __glob_0_22, "./settings/EffectSelect/ContainerWrap.vue": __glob_0_23, "./settings/EffectSelect/TextWrap.vue": __glob_0_24, "./widgets/wGroup/wGroup.vue": __glob_0_25, "./widgets/wGroup/wGroupStyle.vue": __glob_0_26, "./widgets/wImage/wImage.vue": __glob_0_27, "./widgets/wImage/wImageStyle.vue": __glob_0_28, "./widgets/wQrcode/wQrcode.vue": __glob_0_29, "./widgets/wQrcode/wQrcodeStyle.vue": __glob_0_30, "./widgets/wSvg/wSvg.vue": __glob_0_31, "./widgets/wSvg/wSvgStyle.vue": __glob_0_32, "./widgets/wText/wText.vue": __glob_0_33, "./widgets/wText/wTextStyle.vue": __glob_0_34, "./panel/wrap/components/classHeader.vue": __glob_0_35, "./panel/wrap/components/editModel.vue": __glob_0_36, "./panel/wrap/components/imageTip.vue": __glob_0_37, "./panel/wrap/components/imgWaterFall.vue": __glob_0_38, "./panel/wrap/components/photoList.vue": __glob_0_39, "./panel/wrap/components/searchHeader.vue": __glob_0_40, "./widgets/wImage/components/innerToolBar.vue": __glob_0_41 };
function guide(Vue) {
  for (const fileName in requireComponent) {
    if (regex.test(fileName)) {
      const componentConfig = requireComponent[fileName];
      const componentName = capitalizeFirstLetter(fileName.replace(/^\..*\//, "").replace(/\.\w+$/, ""));
      Vue.component(componentName, componentConfig.default || componentConfig);
    }
  }
}
var modules = (Vue) => {
  guide(Vue);
};
var cssLoader = (url) => {
  const link_element = document.createElement("link");
  link_element.setAttribute("rel", "stylesheet");
  link_element.setAttribute("href", url);
  document.head.appendChild(link_element);
};
var utils = {
  install(myVue) {
    modules(myVue);
    cssLoader(_config.ICONFONT_EXTRA);
    cssLoader(_config.ICONFONT_URL);
    myVue.config.globalProperties.$ajax = services;
    myVue.config.globalProperties.$utils = utils$2;
  }
};
var normalize = "";
var global$1 = "";
var index = "";
const MyPlugin = {
  install(app) {
    const vue = app;
    vue.use(erpStore);
    vue.use(utils);
    vue.component("ErpPosterDesign", _sfc_main$a);
  }
};
export { MyPlugin as default };
//# sourceMappingURL=erp-poster-design.es.js.map
